{"version":3,"sources":["node_modules/browserify/node_modules/browser-pack/_prelude.js","awayjs-methodmaterials/lib/TriangleMaterialMode.ts","awayjs-methodmaterials/lib/TriangleMethodMaterial.ts","awayjs-methodmaterials/lib/data/MethodVO.ts","awayjs-methodmaterials/lib/methods/AmbientBasicMethod.ts","awayjs-methodmaterials/lib/methods/AmbientEnvMapMethod.ts","awayjs-methodmaterials/lib/methods/DiffuseBasicMethod.ts","awayjs-methodmaterials/lib/methods/DiffuseCelMethod.ts","awayjs-methodmaterials/lib/methods/DiffuseCompositeMethod.ts","awayjs-methodmaterials/lib/methods/DiffuseDepthMethod.ts","awayjs-methodmaterials/lib/methods/DiffuseGradientMethod.ts","awayjs-methodmaterials/lib/methods/DiffuseLightMapMethod.ts","awayjs-methodmaterials/lib/methods/DiffuseSubSurfaceMethod.ts","awayjs-methodmaterials/lib/methods/DiffuseWrapMethod.ts","awayjs-methodmaterials/lib/methods/EffectAlphaMaskMethod.ts","awayjs-methodmaterials/lib/methods/EffectColorMatrixMethod.ts","awayjs-methodmaterials/lib/methods/EffectColorTransformMethod.ts","awayjs-methodmaterials/lib/methods/EffectEnvMapMethod.ts","awayjs-methodmaterials/lib/methods/EffectFogMethod.ts","awayjs-methodmaterials/lib/methods/EffectFresnelEnvMapMethod.ts","awayjs-methodmaterials/lib/methods/EffectLightMapMethod.ts","awayjs-methodmaterials/lib/methods/EffectMethodBase.ts","awayjs-methodmaterials/lib/methods/EffectRefractionEnvMapMethod.ts","awayjs-methodmaterials/lib/methods/EffectRimLightMethod.ts","awayjs-methodmaterials/lib/methods/LightingMethodBase.ts","awayjs-methodmaterials/lib/methods/NormalBasicMethod.ts","awayjs-methodmaterials/lib/methods/NormalHeightMapMethod.ts","awayjs-methodmaterials/lib/methods/NormalSimpleWaterMethod.ts","awayjs-methodmaterials/lib/methods/ShadingMethodBase.ts","awayjs-methodmaterials/lib/methods/ShadowCascadeMethod.ts","awayjs-methodmaterials/lib/methods/ShadowDitheredMethod.ts","awayjs-methodmaterials/lib/methods/ShadowFilteredMethod.ts","awayjs-methodmaterials/lib/methods/ShadowHardMethod.ts","awayjs-methodmaterials/lib/methods/ShadowMapMethodBase.ts","awayjs-methodmaterials/lib/methods/ShadowMethodBase.ts","awayjs-methodmaterials/lib/methods/ShadowNearMethod.ts","awayjs-methodmaterials/lib/methods/ShadowSoftMethod.ts","awayjs-methodmaterials/lib/methods/SpecularAnisotropicMethod.ts","awayjs-methodmaterials/lib/methods/SpecularBasicMethod.ts","awayjs-methodmaterials/lib/methods/SpecularCelMethod.ts","awayjs-methodmaterials/lib/methods/SpecularCompositeMethod.ts","awayjs-methodmaterials/lib/methods/SpecularFresnelMethod.ts","awayjs-methodmaterials/lib/methods/SpecularPhongMethod.ts","awayjs-methodmaterials/lib/passes/MaterialPassMode.ts","awayjs-methodmaterials/lib/passes/SingleObjectDepthPass.ts","awayjs-methodmaterials/lib/passes/TriangleMethodPass.ts"],"names":[],"mappings":"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","file":"awayjs-methodmaterials.min.js","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})","class TriangleMaterialMode\n{\n\t/**\n\t *\n\t */\n\tpublic static SINGLE_PASS:string = \"singlePass\";\n\n\t/**\n\t *\n\t */\n\tpublic static MULTI_PASS:string = \"multiPass\";\n}\n\nexport = TriangleMaterialMode;","import ColorTransform\t\t\t\t= require(\"awayjs-core/lib/geom/ColorTransform\");\nimport Texture2DBase\t\t\t\t= require(\"awayjs-core/lib/textures/Texture2DBase\");\n\nimport BlendMode\t\t\t\t\t= require(\"awayjs-display/lib/base/BlendMode\");\nimport Camera\t\t\t\t\t\t= require(\"awayjs-display/lib/entities/Camera\");\nimport StaticLightPicker\t\t\t= require(\"awayjs-display/lib/materials/lightpickers/StaticLightPicker\");\n\nimport Stage\t\t\t\t\t\t= require(\"awayjs-stagegl/lib/base/Stage\");\nimport ContextGLCompareMode\t\t\t= require(\"awayjs-stagegl/lib/base/ContextGLCompareMode\");\n\nimport TriangleMaterialBase\t\t\t= require(\"awayjs-renderergl/lib/materials/TriangleMaterialBase\");\n\nimport TriangleMaterialMode\t\t\t= require(\"awayjs-methodmaterials/lib/TriangleMaterialMode\");\nimport AmbientBasicMethod\t\t\t= require(\"awayjs-methodmaterials/lib/methods/AmbientBasicMethod\");\nimport DiffuseBasicMethod\t\t\t= require(\"awayjs-methodmaterials/lib/methods/DiffuseBasicMethod\");\nimport EffectMethodBase\t\t\t\t= require(\"awayjs-methodmaterials/lib/methods/EffectMethodBase\");\nimport NormalBasicMethod\t\t\t= require(\"awayjs-methodmaterials/lib/methods/NormalBasicMethod\");\nimport ShadowMapMethodBase\t\t\t= require(\"awayjs-methodmaterials/lib/methods/ShadowMapMethodBase\");\nimport SpecularBasicMethod\t\t\t= require(\"awayjs-methodmaterials/lib/methods/SpecularBasicMethod\");\nimport MaterialPassMode\t\t\t\t= require(\"awayjs-methodmaterials/lib/passes/MaterialPassMode\");\nimport TriangleMethodPass\t\t\t= require(\"awayjs-methodmaterials/lib/passes/TriangleMethodPass\");\n\n/**\n * TriangleMethodMaterial forms an abstract base class for the default shaded materials provided by Stage,\n * using material methods to define their appearance.\n */\nclass TriangleMethodMaterial extends TriangleMaterialBase\n{\n\tprivate _alphaBlending:boolean = false;\n\tprivate _alpha:number = 1;\n\tprivate _colorTransform:ColorTransform;\n\tprivate _materialMode:string;\n\tprivate _casterLightPass:TriangleMethodPass;\n\tprivate _nonCasterLightPasses:Array<TriangleMethodPass>;\n\tprivate _screenPass:TriangleMethodPass;\n\n\tprivate _ambientMethod:AmbientBasicMethod = new AmbientBasicMethod();\n\tprivate _shadowMethod:ShadowMapMethodBase;\n\tprivate _diffuseMethod:DiffuseBasicMethod = new DiffuseBasicMethod();\n\tprivate _normalMethod:NormalBasicMethod = new NormalBasicMethod();\n\tprivate _specularMethod:SpecularBasicMethod = new SpecularBasicMethod();\n\n\n\tprivate _depthCompareMode:string = ContextGLCompareMode.LESS_EQUAL;\n\n\t/**\n\t * Creates a new TriangleMethodMaterial object.\n\t *\n\t * @param texture The texture used for the material's albedo color.\n\t * @param smooth Indicates whether the texture should be filtered when sampled. Defaults to true.\n\t * @param repeat Indicates whether the texture should be tiled when sampled. Defaults to false.\n\t * @param mipmap Indicates whether or not any used textures should use mipmapping. Defaults to false.\n\t */\n\tconstructor(texture?:Texture2DBase, smooth?:boolean, repeat?:boolean, mipmap?:boolean);\n\tconstructor(color?:number, alpha?:number);\n\tconstructor(textureColor:any = null, smoothAlpha:any = null, repeat:boolean = false, mipmap:boolean = false)\n\t{\n\t\tsuper();\n\n\t\tthis._materialMode = TriangleMaterialMode.SINGLE_PASS;\n\n\t\tif (textureColor instanceof Texture2DBase) {\n\t\t\tthis.texture = <Texture2DBase> textureColor;\n\n\t\t\tthis.smooth = (smoothAlpha == null)? true : false;\n\t\t\tthis.repeat = repeat;\n\t\t\tthis.mipmap = mipmap;\n\t\t} else {\n\t\t\tthis.color = (textureColor == null)? 0xFFFFFF : Number(textureColor);\n\t\t\tthis.alpha = (smoothAlpha == null)? 1 : Number(smoothAlpha);\n\t\t}\n\t}\n\n\n\tpublic get materialMode():string\n\t{\n\t\treturn this._materialMode;\n\t}\n\n\tpublic set materialMode(value:string)\n\t{\n\t\tif (this._materialMode == value)\n\t\t\treturn;\n\n\t\tthis._materialMode = value;\n\n\t\tthis._pInvalidateScreenPasses();\n\t}\n\n\t/**\n\t * The depth compare mode used to render the renderables using this material.\n\t *\n\t * @see away.stagegl.ContextGLCompareMode\n\t */\n\n\tpublic get depthCompareMode():string\n\t{\n\t\treturn this._depthCompareMode;\n\t}\n\n\tpublic set depthCompareMode(value:string)\n\t{\n\t\tif (this._depthCompareMode == value)\n\t\t\treturn;\n\n\t\tthis._depthCompareMode = value;\n\n\t\tthis._pInvalidateScreenPasses();\n\t}\n\n\t/**\n\t * The alpha of the surface.\n\t */\n\tpublic get alpha():number\n\t{\n\t\treturn this._alpha;\n\t}\n\n\tpublic set alpha(value:number)\n\t{\n\t\tif (value > 1)\n\t\t\tvalue = 1;\n\t\telse if (value < 0)\n\t\t\tvalue = 0;\n\n\t\tif (this._alpha == value)\n\t\t\treturn;\n\n\t\tthis._alpha = value;\n\n\t\tif (this._colorTransform == null)\n\t\t\tthis._colorTransform = new ColorTransform();\n\n\t\tthis._colorTransform.alphaMultiplier = value;\n\n\t\tthis._pInvalidatePasses();\n\t}\n\n\t/**\n\t * The ColorTransform object to transform the colour of the material with. Defaults to null.\n\t */\n\tpublic get colorTransform():ColorTransform\n\t{\n\t\treturn this._screenPass.colorTransform;\n\t}\n\n\tpublic set colorTransform(value:ColorTransform)\n\t{\n\t\tthis._screenPass.colorTransform = value;\n\t}\n\n\t/**\n\t * The texture object to use for the ambient colour.\n\t */\n\tpublic get diffuseTexture():Texture2DBase\n\t{\n\t\treturn this._diffuseMethod.texture;\n\t}\n\n\tpublic set diffuseTexture(value:Texture2DBase)\n\t{\n\t\tthis._diffuseMethod.texture = value;\n\t}\n\n\t/**\n\t * The method that provides the ambient lighting contribution. Defaults to AmbientBasicMethod.\n\t */\n\tpublic get ambientMethod():AmbientBasicMethod\n\t{\n\t\treturn this._ambientMethod;\n\t}\n\n\tpublic set ambientMethod(value:AmbientBasicMethod)\n\t{\n\t\tif (this._ambientMethod == value)\n\t\t\treturn;\n\n\t\tif (value && this._ambientMethod)\n\t\t\tvalue.copyFrom(this._ambientMethod);\n\n\t\tthis._ambientMethod = value;\n\n\t\tthis._pInvalidateScreenPasses();\n\t}\n\n\t/**\n\t * The method used to render shadows cast on this surface, or null if no shadows are to be rendered. Defaults to null.\n\t */\n\tpublic get shadowMethod():ShadowMapMethodBase\n\t{\n\t\treturn this._shadowMethod;\n\t}\n\n\tpublic set shadowMethod(value:ShadowMapMethodBase)\n\t{\n\t\tif (this._shadowMethod == value)\n\t\t\treturn;\n\n\t\tif (value && this._shadowMethod)\n\t\t\tvalue.copyFrom(this._shadowMethod);\n\n\t\tthis._shadowMethod = value;\n\n\t\tthis._pInvalidateScreenPasses();\n\t}\n\n\t/**\n\t * The method that provides the diffuse lighting contribution. Defaults to DiffuseBasicMethod.\n\t */\n\tpublic get diffuseMethod():DiffuseBasicMethod\n\t{\n\t\treturn this._diffuseMethod;\n\t}\n\n\tpublic set diffuseMethod(value:DiffuseBasicMethod)\n\t{\n\t\tif (this._diffuseMethod == value)\n\t\t\treturn;\n\n\t\tif (value && this._diffuseMethod)\n\t\t\tvalue.copyFrom(this._diffuseMethod);\n\n\t\tthis._diffuseMethod = value;\n\n\t\tthis._pInvalidateScreenPasses();\n\t}\n\n\t/**\n\t * The method that provides the specular lighting contribution. Defaults to SpecularBasicMethod.\n\t */\n\tpublic get specularMethod():SpecularBasicMethod\n\t{\n\t\treturn this._specularMethod;\n\t}\n\n\tpublic set specularMethod(value:SpecularBasicMethod)\n\t{\n\t\tif (this._specularMethod == value)\n\t\t\treturn;\n\n\t\tif (value && this._specularMethod)\n\t\t\tvalue.copyFrom(this._specularMethod);\n\n\t\tthis._specularMethod = value;\n\n\t\tthis._pInvalidateScreenPasses();\n\t}\n\n\t/**\n\t * The method used to generate the per-pixel normals. Defaults to NormalBasicMethod.\n\t */\n\tpublic get normalMethod():NormalBasicMethod\n\t{\n\t\treturn this._normalMethod;\n\t}\n\n\tpublic set normalMethod(value:NormalBasicMethod)\n\t{\n\t\tif (this._normalMethod == value)\n\t\t\treturn;\n\n\t\tif (value && this._normalMethod)\n\t\t\tvalue.copyFrom(this._normalMethod);\n\n\t\tthis._normalMethod = value;\n\n\t\tthis._pInvalidateScreenPasses();\n\t}\n\n\t/**\n\t * Appends an \"effect\" shading method to the shader. Effect methods are those that do not influence the lighting\n\t * but modulate the shaded colour, used for fog, outlines, etc. The method will be applied to the result of the\n\t * methods added prior.\n\t */\n\tpublic addEffectMethod(method:EffectMethodBase)\n\t{\n\t\tif (this._screenPass == null)\n\t\t\tthis._screenPass = new TriangleMethodPass();\n\n\t\tthis._screenPass.addEffectMethod(method);\n\n\t\tthis._pInvalidateScreenPasses();\n\t}\n\n\t/**\n\t * The number of \"effect\" methods added to the material.\n\t */\n\tpublic get numEffectMethods():number\n\t{\n\t\treturn this._screenPass? this._screenPass.numEffectMethods : 0;\n\t}\n\n\t/**\n\t * Queries whether a given effect method was added to the material.\n\t *\n\t * @param method The method to be queried.\n\t * @return true if the method was added to the material, false otherwise.\n\t */\n\tpublic hasEffectMethod(method:EffectMethodBase):boolean\n\t{\n\t\treturn this._screenPass? this._screenPass.hasEffectMethod(method) : false;\n\t}\n\n\t/**\n\t * Returns the method added at the given index.\n\t * @param index The index of the method to retrieve.\n\t * @return The method at the given index.\n\t */\n\tpublic getEffectMethodAt(index:number):EffectMethodBase\n\t{\n\t\tif (this._screenPass == null)\n\t\t\treturn null;\n\n\t\treturn this._screenPass.getEffectMethodAt(index);\n\t}\n\n\t/**\n\t * Adds an effect method at the specified index amongst the methods already added to the material. Effect\n\t * methods are those that do not influence the lighting but modulate the shaded colour, used for fog, outlines,\n\t * etc. The method will be applied to the result of the methods with a lower index.\n\t */\n\tpublic addEffectMethodAt(method:EffectMethodBase, index:number)\n\t{\n\t\tif (this._screenPass == null)\n\t\t\tthis._screenPass = new TriangleMethodPass();\n\n\t\tthis._screenPass.addEffectMethodAt(method, index);\n\n\t\tthis._pInvalidatePasses();\n\t}\n\n\t/**\n\t * Removes an effect method from the material.\n\t * @param method The method to be removed.\n\t */\n\tpublic removeEffectMethod(method:EffectMethodBase)\n\t{\n\t\tif (this._screenPass == null)\n\t\t\treturn;\n\n\t\tthis._screenPass.removeEffectMethod(method);\n\n\t\t// reconsider\n\t\tif (this._screenPass.numEffectMethods == 0)\n\t\t\tthis._pInvalidatePasses();\n\t}\n\n\t/**\n\t * The normal map to modulate the direction of the surface for each texel. The default normal method expects\n\t * tangent-space normal maps, but others could expect object-space maps.\n\t */\n\tpublic get normalMap():Texture2DBase\n\t{\n\t\treturn this._normalMethod.normalMap;\n\t}\n\n\tpublic set normalMap(value:Texture2DBase)\n\t{\n\t\tthis._normalMethod.normalMap = value;\n\t}\n\n\t/**\n\t * A specular map that defines the strength of specular reflections for each texel in the red channel,\n\t * and the gloss factor in the green channel. You can use SpecularBitmapTexture if you want to easily set\n\t * specular and gloss maps from grayscale images, but correctly authored images are preferred.\n\t */\n\tpublic get specularMap():Texture2DBase\n\t{\n\t\treturn this._specularMethod.texture;\n\t}\n\n\tpublic set specularMap(value:Texture2DBase)\n\t{\n\t\tthis._specularMethod.texture = value;\n\t}\n\n\t/**\n\t * The glossiness of the material (sharpness of the specular highlight).\n\t */\n\tpublic get gloss():number\n\t{\n\t\treturn this._specularMethod.gloss;\n\t}\n\n\tpublic set gloss(value:number)\n\t{\n\t\tthis._specularMethod.gloss = value;\n\t}\n\n\t/**\n\t * The strength of the ambient reflection.\n\t */\n\tpublic get ambient():number\n\t{\n\t\treturn this._ambientMethod.ambient;\n\t}\n\n\tpublic set ambient(value:number)\n\t{\n\t\tthis._ambientMethod.ambient = value;\n\t}\n\n\t/**\n\t * The overall strength of the specular reflection.\n\t */\n\tpublic get specular():number\n\t{\n\t\treturn this._specularMethod.specular;\n\t}\n\n\tpublic set specular(value:number)\n\t{\n\t\tthis._specularMethod.specular = value;\n\t}\n\n\t/**\n\t * The colour of the ambient reflection.\n\t */\n\tpublic get ambientColor():number\n\t{\n\t\treturn this._diffuseMethod.ambientColor;\n\t}\n\n\tpublic set ambientColor(value:number)\n\t{\n\t\tthis._diffuseMethod.ambientColor = value;\n\t}\n\n\t/**\n\t * The colour of the diffuse reflection.\n\t */\n\tpublic get diffuseColor():number\n\t{\n\t\treturn this._diffuseMethod.diffuseColor;\n\t}\n\n\tpublic set diffuseColor(value:number)\n\t{\n\t\tthis._diffuseMethod.diffuseColor = value;\n\t}\n\n\t/**\n\t * The colour of the specular reflection.\n\t */\n\tpublic get specularColor():number\n\t{\n\t\treturn this._specularMethod.specularColor;\n\t}\n\n\tpublic set specularColor(value:number)\n\t{\n\t\tthis._specularMethod.specularColor = value;\n\t}\n\n\t/**\n\t * Indicates whether or not the material has transparency. If binary transparency is sufficient, for\n\t * example when using textures of foliage, consider using alphaThreshold instead.\n\t */\n\n\tpublic get alphaBlending():boolean\n\t{\n\t\treturn this._alphaBlending;\n\t}\n\n\tpublic set alphaBlending(value:boolean)\n\t{\n\t\tif (this._alphaBlending == value)\n\t\t\treturn;\n\n\t\tthis._alphaBlending = value;\n\n\t\tthis._pInvalidatePasses();\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic _iUpdateMaterial()\n\t{\n\t\tif (this._pScreenPassesInvalid) {\n\t\t\t//Updates screen passes when they were found to be invalid.\n\t\t\tthis._pScreenPassesInvalid = false;\n\n\t\t\tthis.initPasses();\n\n\t\t\tthis.setBlendAndCompareModes();\n\n\t\t\tthis._pClearScreenPasses();\n\n\t\t\tif (this._materialMode == TriangleMaterialMode.MULTI_PASS) {\n\t\t\t\tif (this._casterLightPass)\n\t\t\t\t\tthis._pAddScreenPass(this._casterLightPass);\n\n\t\t\t\tif (this._nonCasterLightPasses)\n\t\t\t\t\tfor (var i:number = 0; i < this._nonCasterLightPasses.length; ++i)\n\t\t\t\t\t\tthis._pAddScreenPass(this._nonCasterLightPasses[i]);\n\t\t\t}\n\n\t\t\tif (this._screenPass)\n\t\t\t\tthis._pAddScreenPass(this._screenPass);\n\t\t}\n\t}\n\n\t/**\n\t * Initializes all the passes and their dependent passes.\n\t */\n\tprivate initPasses()\n\t{\n\t\t// let the effects pass handle everything if there are no lights, when there are effect methods applied\n\t\t// after shading, or when the material mode is single pass.\n\t\tif (this.numLights == 0 || this.numEffectMethods > 0 || this._materialMode == TriangleMaterialMode.SINGLE_PASS)\n\t\t\tthis.initEffectPass();\n\t\telse if (this._screenPass)\n\t\t\tthis.removeEffectPass();\n\n\t\t// only use a caster light pass if shadows need to be rendered\n\t\tif (this._shadowMethod && this._materialMode == TriangleMaterialMode.MULTI_PASS)\n\t\t\tthis.initCasterLightPass();\n\t\telse if (this._casterLightPass)\n\t\t\tthis.removeCasterLightPass();\n\n\t\t// only use non caster light passes if there are lights that don't cast\n\t\tif (this.numNonCasters > 0 && this._materialMode == TriangleMaterialMode.MULTI_PASS)\n\t\t\tthis.initNonCasterLightPasses();\n\t\telse if (this._nonCasterLightPasses)\n\t\t\tthis.removeNonCasterLightPasses();\n\t}\n\n\t/**\n\t * Sets up the various blending modes for all screen passes, based on whether or not there are previous passes.\n\t */\n\tprivate setBlendAndCompareModes()\n\t{\n\t\tvar forceSeparateMVP:boolean = Boolean(this._casterLightPass || this._screenPass);\n\n\t\t// caster light pass is always first if it exists, hence it uses normal blending\n\t\tif (this._casterLightPass) {\n\t\t\tthis._casterLightPass.forceSeparateMVP = forceSeparateMVP;\n\t\t\tthis._casterLightPass.setBlendMode(BlendMode.NORMAL);\n\t\t\tthis._casterLightPass.depthCompareMode = this._depthCompareMode;\n\t\t}\n\n\t\tif (this._nonCasterLightPasses) {\n\t\t\tvar firstAdditiveIndex:number = 0;\n\n\t\t\t// if there's no caster light pass, the first non caster light pass will be the first\n\t\t\t// and should use normal blending\n\t\t\tif (!this._casterLightPass) {\n\t\t\t\tthis._nonCasterLightPasses[0].forceSeparateMVP = forceSeparateMVP;\n\t\t\t\tthis._nonCasterLightPasses[0].setBlendMode(BlendMode.NORMAL);\n\t\t\t\tthis._nonCasterLightPasses[0].depthCompareMode = this._depthCompareMode;\n\t\t\t\tfirstAdditiveIndex = 1;\n\t\t\t}\n\n\t\t\t// all lighting passes following the first light pass should use additive blending\n\t\t\tfor (var i:number = firstAdditiveIndex; i < this._nonCasterLightPasses.length; ++i) {\n\t\t\t\tthis._nonCasterLightPasses[i].forceSeparateMVP = forceSeparateMVP;\n\t\t\t\tthis._nonCasterLightPasses[i].setBlendMode(BlendMode.ADD);\n\t\t\t\tthis._nonCasterLightPasses[i].depthCompareMode = ContextGLCompareMode.LESS_EQUAL;\n\t\t\t}\n\t\t}\n\n\t\tif (this._casterLightPass || this._nonCasterLightPasses) {\n\t\t\t//cannot be blended by blendmode property if multipass enabled\n\t\t\tthis._pRequiresBlending = false;\n\n\t\t\t// there are light passes, so this should be blended in\n\t\t\tif (this._screenPass) {\n\t\t\t\tthis._screenPass.passMode = MaterialPassMode.EFFECTS;\n\t\t\t\tthis._screenPass.depthCompareMode = ContextGLCompareMode.LESS_EQUAL;\n\t\t\t\tthis._screenPass.setBlendMode(BlendMode.LAYER);\n\t\t\t\tthis._screenPass.forceSeparateMVP = forceSeparateMVP;\n\t\t\t}\n\n\t\t} else if (this._screenPass) {\n\t\t\tthis._pRequiresBlending = (this._pBlendMode != BlendMode.NORMAL || this._alphaBlending || (this._colorTransform && this._colorTransform.alphaMultiplier < 1));\n\t\t\t// effects pass is the only pass, so it should just blend normally\n\t\t\tthis._screenPass.passMode = MaterialPassMode.SUPER_SHADER;\n\t\t\tthis._screenPass.depthCompareMode = this._depthCompareMode;\n\t\t\tthis._screenPass.preserveAlpha = this._pRequiresBlending;\n\t\t\tthis._screenPass.colorTransform = this._colorTransform;\n\t\t\tthis._screenPass.setBlendMode((this._pBlendMode == BlendMode.NORMAL && this._pRequiresBlending)? BlendMode.LAYER : this._pBlendMode);\n\t\t\tthis._screenPass.forceSeparateMVP = false;\n\t\t}\n\t}\n\n\tprivate initCasterLightPass()\n\t{\n\n\t\tif (this._casterLightPass == null)\n\t\t\tthis._casterLightPass = new TriangleMethodPass(MaterialPassMode.LIGHTING);\n\n\t\tthis._casterLightPass.lightPicker = new StaticLightPicker([this._shadowMethod.castingLight]);\n\t\tthis._casterLightPass.shadowMethod = this._shadowMethod;\n\t\tthis._casterLightPass.diffuseMethod = this._diffuseMethod;\n\t\tthis._casterLightPass.ambientMethod = this._ambientMethod;\n\t\tthis._casterLightPass.normalMethod = this._normalMethod;\n\t\tthis._casterLightPass.specularMethod = this._specularMethod;\n\t}\n\n\tprivate removeCasterLightPass()\n\t{\n\t\tthis._casterLightPass.dispose();\n\t\tthis._pRemoveScreenPass(this._casterLightPass);\n\t\tthis._casterLightPass = null;\n\t}\n\n\tprivate initNonCasterLightPasses()\n\t{\n\t\tthis.removeNonCasterLightPasses();\n\t\tvar pass:TriangleMethodPass;\n\t\tvar numDirLights:number = this._pLightPicker.numDirectionalLights;\n\t\tvar numPointLights:number = this._pLightPicker.numPointLights;\n\t\tvar numLightProbes:number = this._pLightPicker.numLightProbes;\n\t\tvar dirLightOffset:number = 0;\n\t\tvar pointLightOffset:number = 0;\n\t\tvar probeOffset:number = 0;\n\n\t\tif (!this._casterLightPass) {\n\t\t\tnumDirLights += this._pLightPicker.numCastingDirectionalLights;\n\t\t\tnumPointLights += this._pLightPicker.numCastingPointLights;\n\t\t}\n\n\t\tthis._nonCasterLightPasses = new Array<TriangleMethodPass>();\n\n\t\twhile (dirLightOffset < numDirLights || pointLightOffset < numPointLights || probeOffset < numLightProbes) {\n\t\t\tpass = new TriangleMethodPass(MaterialPassMode.LIGHTING);\n\t\t\tpass.includeCasters = this._shadowMethod == null;\n\t\t\tpass.directionalLightsOffset = dirLightOffset;\n\t\t\tpass.pointLightsOffset = pointLightOffset;\n\t\t\tpass.lightProbesOffset = probeOffset;\n\t\t\tpass.lightPicker = this._pLightPicker;\n\t\t\tpass.diffuseMethod = this._diffuseMethod;\n\t\t\tpass.ambientMethod = this._ambientMethod;\n\t\t\tpass.normalMethod = this._normalMethod;\n\t\t\tpass.specularMethod = this._specularMethod;\n\t\t\tthis._nonCasterLightPasses.push(pass);\n\n\t\t\tdirLightOffset += pass.iNumDirectionalLights;\n\t\t\tpointLightOffset += pass.iNumPointLights;\n\t\t\tprobeOffset += pass.iNumLightProbes;\n\t\t}\n\t}\n\n\tprivate removeNonCasterLightPasses()\n\t{\n\t\tif (!this._nonCasterLightPasses)\n\t\t\treturn;\n\n\t\tfor (var i:number = 0; i < this._nonCasterLightPasses.length; ++i)\n\t\t\tthis._pRemoveScreenPass(this._nonCasterLightPasses[i]);\n\n\t\tthis._nonCasterLightPasses = null;\n\t}\n\n\tprivate removeEffectPass()\n\t{\n\t\tif (this._screenPass.ambientMethod != this._ambientMethod)\n\t\t\tthis._screenPass.ambientMethod.dispose();\n\n\t\tif (this._screenPass.diffuseMethod != this._diffuseMethod)\n\t\t\tthis._screenPass.diffuseMethod.dispose();\n\n\t\tif (this._screenPass.specularMethod != this._specularMethod)\n\t\t\tthis._screenPass.specularMethod.dispose();\n\n\t\tif (this._screenPass.normalMethod != this._normalMethod)\n\t\t\tthis._screenPass.normalMethod.dispose();\n\n\t\tthis._pRemoveScreenPass(this._screenPass);\n\t\tthis._screenPass = null;\n\t}\n\n\tprivate initEffectPass()\n\t{\n\t\tif (this._screenPass == null)\n\t\t\tthis._screenPass = new TriangleMethodPass();\n\n\t\tif (this._materialMode == TriangleMaterialMode.SINGLE_PASS) {\n\t\t\tthis._screenPass.ambientMethod = this._ambientMethod;\n\t\t\tthis._screenPass.diffuseMethod = this._diffuseMethod;\n\t\t\tthis._screenPass.specularMethod = this._specularMethod;\n\t\t\tthis._screenPass.normalMethod = this._normalMethod;\n\t\t\tthis._screenPass.shadowMethod = this._shadowMethod;\n\t\t} else if (this._materialMode == TriangleMaterialMode.MULTI_PASS) {\n\t\t\tif (this.numLights == 0) {\n\t\t\t\tthis._screenPass.ambientMethod = this._ambientMethod;\n\t\t\t} else {\n\t\t\t\tthis._screenPass.ambientMethod = null;\n\t\t\t}\n\n\t\t\tthis._screenPass.preserveAlpha = false;\n\t\t\tthis._screenPass.normalMethod = this._normalMethod;\n\t\t}\n\t}\n\n\t/**\n\t * The maximum total number of lights provided by the light picker.\n\t */\n\tprivate get numLights():number\n\t{\n\t\treturn this._pLightPicker? this._pLightPicker.numLightProbes + this._pLightPicker.numDirectionalLights + this._pLightPicker.numPointLights + this._pLightPicker.numCastingDirectionalLights + this._pLightPicker.numCastingPointLights : 0;\n\t}\n\n\t/**\n\t * The amount of lights that don't cast shadows.\n\t */\n\tprivate get numNonCasters():number\n\t{\n\t\treturn this._pLightPicker? this._pLightPicker.numLightProbes + this._pLightPicker.numDirectionalLights + this._pLightPicker.numPointLights : 0;\n\t}\n}\n\nexport = TriangleMethodMaterial;","import ShadingMethodBase\t\t\t= require(\"awayjs-methodmaterials/lib/methods/ShadingMethodBase\");\n\n/**\n * MethodVO contains data for a given shader object for the use within a single material.\n * This allows shader methods to be shared across materials while their non-public state differs.\n */\nclass MethodVO\n{\n\tpublic useMethod:boolean = true;\n\n\tpublic method:ShadingMethodBase;\n\n\t// public register indices\n\tpublic texturesIndex:number;\n\tpublic secondaryTexturesIndex:number; // sometimes needed for composites\n\tpublic vertexConstantsIndex:number;\n\tpublic secondaryVertexConstantsIndex:number; // sometimes needed for composites\n\tpublic fragmentConstantsIndex:number;\n\tpublic secondaryFragmentConstantsIndex:number; // sometimes needed for composites\n\n\t// internal stuff for the material to know before assembling code\n\tpublic needsProjection:boolean;\n\tpublic needsView:boolean;\n\tpublic needsNormals:boolean;\n\tpublic needsTangents:boolean;\n\tpublic needsUV:boolean;\n\tpublic needsSecondaryUV:boolean;\n\tpublic needsGlobalVertexPos:boolean;\n\tpublic needsGlobalFragmentPos:boolean;\n\n\tpublic usesTexture:boolean;\n\n\t/**\n\t * Creates a new MethodVO object.\n\t */\n\tconstructor(method:ShadingMethodBase)\n\t{\n\t\tthis.method = method;\n\t}\n\n\t/**\n\t * Resets the values of the value object to their \"unused\" state.\n\t */\n\tpublic reset()\n\t{\n\t\tthis.method.iReset();\n\n\t\tthis.texturesIndex = -1;\n\t\tthis.vertexConstantsIndex = -1;\n\t\tthis.fragmentConstantsIndex = -1;\n\n\t\tthis.needsProjection = false;\n\t\tthis.needsView = false;\n\t\tthis.needsNormals = false;\n\t\tthis.needsTangents = false;\n\t\tthis.needsUV = false;\n\t\tthis.needsSecondaryUV = false;\n\t\tthis.needsGlobalVertexPos = false;\n\t\tthis.needsGlobalFragmentPos = false;\n\t}\n}\n\nexport = MethodVO;\n","import Texture2DBase\t\t\t\t= require(\"awayjs-core/lib/textures/Texture2DBase\");\n\nimport ContextGLMipFilter\t\t\t= require(\"awayjs-stagegl/lib/base/ContextGLMipFilter\");\nimport ContextGLTextureFilter\t\t= require(\"awayjs-stagegl/lib/base/ContextGLTextureFilter\");\nimport ContextGLWrapMode\t\t\t= require(\"awayjs-stagegl/lib/base/ContextGLWrapMode\");\nimport Stage\t\t\t\t\t\t= require(\"awayjs-stagegl/lib/base/Stage\");\n\nimport ShaderObjectBase\t\t\t\t= require(\"awayjs-renderergl/lib/compilation/ShaderObjectBase\");\nimport ShaderRegisterCache\t\t\t= require(\"awayjs-renderergl/lib/compilation/ShaderRegisterCache\");\nimport ShaderRegisterData\t\t\t= require(\"awayjs-renderergl/lib/compilation/ShaderRegisterData\");\nimport ShaderRegisterElement\t\t= require(\"awayjs-renderergl/lib/compilation/ShaderRegisterElement\");\nimport ShaderCompilerHelper\t\t\t= require(\"awayjs-renderergl/lib/utils/ShaderCompilerHelper\");\n\nimport MethodVO\t\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/data/MethodVO\");\nimport ShadingMethodBase\t\t\t= require(\"awayjs-methodmaterials/lib/methods/ShadingMethodBase\");\n\n/**\n * AmbientBasicMethod provides the default shading method for uniform ambient lighting.\n */\nclass AmbientBasicMethod extends ShadingMethodBase\n{\n\tprivate _color:number = 0xffffff;\n\tprivate _alpha:number = 1;\n\n\tprivate _colorR:number = 1;\n\tprivate _colorG:number = 1;\n\tprivate _colorB:number = 1;\n\n\tprivate _ambient:number = 1;\n\n\t/**\n\t * Creates a new AmbientBasicMethod object.\n\t */\n\tconstructor()\n\t{\n\t\tsuper();\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitVO(shaderObject:ShaderObjectBase, methodVO:MethodVO)\n\t{\n\t\tmethodVO.needsUV = Boolean(shaderObject.texture != null);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitConstants(shaderObject:ShaderObjectBase, methodVO:MethodVO)\n\t{\n\t\tif (!methodVO.needsUV) {\n\t\t\tthis._color = shaderObject.color;\n\t\t\tthis.updateColor();\n\t\t}\n\t}\n\n\t/**\n\t * The strength of the ambient reflection of the surface.\n\t */\n\tpublic get ambient():number\n\t{\n\t\treturn this._ambient;\n\t}\n\n\tpublic set ambient(value:number)\n\t{\n\t\tif (this._ambient == value)\n\t\t\treturn;\n\n\t\tthis._ambient = value;\n\n\t\tthis.updateColor();\n\t}\n\n\t/**\n\t * The alpha component of the surface.\n\t */\n\tpublic get alpha():number\n\t{\n\t\treturn this._alpha;\n\t}\n\n\tpublic set alpha(value:number)\n\t{\n\t\tif (this._alpha == value)\n\t\t\treturn;\n\n\t\tthis._alpha = value;\n\n\t\tthis.updateColor();\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic copyFrom(method:ShadingMethodBase)\n\t{\n\t\tvar m:any = method;\n\t\tvar b:AmbientBasicMethod = <AmbientBasicMethod> m;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentCode(shaderObject:ShaderObjectBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = \"\";\n\t\tvar ambientInputRegister:ShaderRegisterElement;\n\n\t\tif (methodVO.needsUV) {\n\t\t\tambientInputRegister = registerCache.getFreeTextureReg();\n\n\t\t\tmethodVO.texturesIndex = ambientInputRegister.index;\n\n\t\t\tcode += ShaderCompilerHelper.getTex2DSampleCode(targetReg, sharedRegisters, ambientInputRegister, shaderObject.texture, shaderObject.useSmoothTextures, shaderObject.repeatTextures, shaderObject.useMipmapping);\n\n\t\t\tif (shaderObject.alphaThreshold > 0) {\n\t\t\t\tvar cutOffReg:ShaderRegisterElement = registerCache.getFreeFragmentConstant();\n\t\t\t\tmethodVO.fragmentConstantsIndex = cutOffReg.index*4;\n\n\t\t\t\tcode += \"sub \" + targetReg + \".w, \" + targetReg + \".w, \" + cutOffReg + \".x\\n\" +\n\t\t\t\t\t\"kil \" + targetReg + \".w\\n\" +\n\t\t\t\t\t\"add \" + targetReg + \".w, \" + targetReg + \".w, \" + cutOffReg + \".x\\n\";\n\t\t\t}\n\n\t\t} else {\n\t\t\tambientInputRegister = registerCache.getFreeFragmentConstant();\n\t\t\tmethodVO.fragmentConstantsIndex = ambientInputRegister.index*4;\n\n\t\t\tcode += \"mov \" + targetReg + \", \" + ambientInputRegister + \"\\n\";\n\t\t}\n\n\t\treturn code;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iActivate(shaderObject:ShaderObjectBase, methodVO:MethodVO, stage:Stage)\n\t{\n\t\tif (methodVO.needsUV) {\n\t\t\tstage.context.setSamplerStateAt(methodVO.texturesIndex, shaderObject.repeatTextures? ContextGLWrapMode.REPEAT:ContextGLWrapMode.CLAMP, shaderObject.useSmoothTextures? ContextGLTextureFilter.LINEAR:ContextGLTextureFilter.NEAREST, shaderObject.useMipmapping? ContextGLMipFilter.MIPLINEAR:ContextGLMipFilter.MIPNONE);\n\t\t\tstage.activateTexture(methodVO.texturesIndex, shaderObject.texture);\n\n\t\t\tif (shaderObject.alphaThreshold > 0)\n\t\t\t\tshaderObject.fragmentConstantData[methodVO.fragmentConstantsIndex] = shaderObject.alphaThreshold;\n\t\t} else {\n\t\t\tvar index:number = methodVO.fragmentConstantsIndex;\n\t\t\tvar data:Array<number> = shaderObject.fragmentConstantData;\n\t\t\tdata[index] = this._colorR;\n\t\t\tdata[index + 1] = this._colorG;\n\t\t\tdata[index + 2] = this._colorB;\n\t\t\tdata[index + 3] = this._alpha;\n\t\t}\n\t}\n\n\t/**\n\t * Updates the ambient color data used by the render state.\n\t */\n\tprivate updateColor()\n\t{\n\t\tthis._colorR = ((this._color >> 16) & 0xff)/0xff*this._ambient;\n\t\tthis._colorG = ((this._color >> 8) & 0xff)/0xff*this._ambient;\n\t\tthis._colorB = (this._color & 0xff)/0xff*this._ambient;\n\t}\n}\n\nexport = AmbientBasicMethod;","import CubeTextureBase\t\t\t\t\t= require(\"awayjs-core/lib/textures/CubeTextureBase\");\n\nimport Stage\t\t\t\t\t\t\t= require(\"awayjs-stagegl/lib/base/Stage\");\n\nimport ShaderObjectBase\t\t\t\t\t= require(\"awayjs-renderergl/lib/compilation/ShaderObjectBase\");\nimport ShaderRegisterCache\t\t\t\t= require(\"awayjs-renderergl/lib/compilation/ShaderRegisterCache\");\nimport ShaderRegisterData\t\t\t\t= require(\"awayjs-renderergl/lib/compilation/ShaderRegisterData\");\nimport ShaderRegisterElement\t\t\t= require(\"awayjs-renderergl/lib/compilation/ShaderRegisterElement\");\nimport ShaderCompilerHelper\t\t\t\t= require(\"awayjs-renderergl/lib/utils/ShaderCompilerHelper\");\n\nimport MethodVO\t\t\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/data/MethodVO\");\nimport AmbientBasicMethod\t\t\t\t= require(\"awayjs-methodmaterials/lib/methods/AmbientBasicMethod\");\n\n/**\n * AmbientEnvMapMethod provides a diffuse shading method that uses a diffuse irradiance environment map to\n * approximate global lighting rather than lights.\n */\nclass AmbientEnvMapMethod extends AmbientBasicMethod\n{\n\tprivate _cubeTexture:CubeTextureBase;\n\t\n\t/**\n\t * Creates a new <code>AmbientEnvMapMethod</code> object.\n\t *\n\t * @param envMap The cube environment map to use for the ambient lighting.\n\t */\n\tconstructor(envMap:CubeTextureBase)\n\t{\n\t\tsuper();\n\t\tthis._cubeTexture = envMap;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitVO(shaderObject:ShaderObjectBase, methodVO:MethodVO)\n\t{\n\t\tsuper.iInitVO(shaderObject, methodVO);\n\n\t\tmethodVO.needsNormals = true;\n\t}\n\t\n\t/**\n\t * The cube environment map to use for the diffuse lighting.\n\t */\n\tpublic get envMap():CubeTextureBase\n\t{\n\t\treturn this._cubeTexture;\n\t}\n\t\n\tpublic set envMap(value:CubeTextureBase)\n\t{\n\t\tthis._cubeTexture = value;\n\t}\n\t\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iActivate(shaderObject:ShaderObjectBase, methodVO:MethodVO, stage:Stage)\n\t{\n\t\tsuper.iActivate(shaderObject, methodVO, stage);\n\n\t\tstage.activateCubeTexture(methodVO.texturesIndex, this._cubeTexture);\n\t}\n\t\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentCode(shaderObject:ShaderObjectBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, regCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = \"\";\n\t\tvar ambientInputRegister:ShaderRegisterElement;\n\t\tvar cubeMapReg:ShaderRegisterElement = regCache.getFreeTextureReg();\n\t\tmethodVO.texturesIndex = cubeMapReg.index;\n\t\t\n\t\tcode += ShaderCompilerHelper.getTexCubeSampleCode(targetReg, cubeMapReg, this._cubeTexture, shaderObject.useSmoothTextures, shaderObject.useMipmapping, sharedRegisters.normalFragment);\n\n\t\tambientInputRegister = regCache.getFreeFragmentConstant();\n\t\tmethodVO.fragmentConstantsIndex = ambientInputRegister.index;\n\t\t\n\t\tcode += \"add \" + targetReg + \".xyz, \" + targetReg + \".xyz, \" + ambientInputRegister + \".xyz\\n\";\n\t\t\n\t\treturn code;\n\t}\n}\n\nexport = AmbientEnvMapMethod;","import Texture2DBase\t\t\t\t= require(\"awayjs-core/lib/textures/Texture2DBase\");\n\nimport Camera\t\t\t\t\t\t= require(\"awayjs-display/lib/entities/Camera\");\n\nimport Stage\t\t\t\t\t\t= require(\"awayjs-stagegl/lib/base/Stage\");\nimport ContextGLMipFilter\t\t\t= require(\"awayjs-stagegl/lib/base/ContextGLMipFilter\");\nimport ContextGLTextureFilter\t\t= require(\"awayjs-stagegl/lib/base/ContextGLTextureFilter\");\nimport ContextGLWrapMode\t\t\t= require(\"awayjs-stagegl/lib/base/ContextGLWrapMode\");\n\nimport ShaderLightingObject\t\t\t= require(\"awayjs-renderergl/lib/compilation/ShaderLightingObject\");\nimport ShaderRegisterCache\t\t\t= require(\"awayjs-renderergl/lib/compilation/ShaderRegisterCache\");\nimport ShaderRegisterData\t\t\t= require(\"awayjs-renderergl/lib/compilation/ShaderRegisterData\");\nimport ShaderRegisterElement\t\t= require(\"awayjs-renderergl/lib/compilation/ShaderRegisterElement\");\nimport ShaderCompilerHelper\t\t\t= require(\"awayjs-renderergl/lib/utils/ShaderCompilerHelper\");\nimport RenderableBase\t\t\t\t= require(\"awayjs-renderergl/lib/pool/RenderableBase\");\n\nimport MethodVO\t\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/data/MethodVO\");\nimport ShadingMethodBase\t\t\t= require(\"awayjs-methodmaterials/lib/methods/ShadingMethodBase\");\nimport LightingMethodBase\t\t\t= require(\"awayjs-methodmaterials/lib/methods/LightingMethodBase\");\n\n/**\n * DiffuseBasicMethod provides the default shading method for Lambert (dot3) diffuse lighting.\n */\nclass DiffuseBasicMethod extends LightingMethodBase\n{\n\tprivate _multiply:boolean = true;\n\n\tpublic _pUseTexture:boolean;\n\tpublic _pTotalLightColorReg:ShaderRegisterElement;\n\tpublic _pDiffuseInputRegister:ShaderRegisterElement;\n\n\tprivate _texture:Texture2DBase;\n\tprivate _diffuseColor:number = 0xffffff;\n\tprivate _ambientColor:number = 0xffffff;\n\tprivate _diffuseR:number = 1;\n\tprivate _diffuseG:number = 1;\n\tprivate _diffuseB:number = 1;\n\tprivate _ambientR:number = 1;\n\tprivate _ambientG:number = 1;\n\tprivate _ambientB:number = 1;\n\n\tpublic _pIsFirstLight:boolean;\n\n\t/**\n\t * Creates a new DiffuseBasicMethod object.\n\t */\n\tconstructor()\n\t{\n\t\tsuper();\n\t}\n\n\tpublic iIsUsed(shaderObject:ShaderLightingObject):boolean\n\t{\n\t\tif (!shaderObject.numLights)\n\t\t\treturn false;\n\n\t\treturn true;\n\t}\n\n\t/**\n\t * Set internally if diffuse color component multiplies or replaces the ambient color\n\t */\n\tpublic get multiply():boolean\n\t{\n\t\treturn this._multiply;\n\t}\n\n\tpublic set multiply(value:boolean)\n\t{\n\t\tif (this._multiply == value)\n\t\t\treturn;\n\n\t\tthis._multiply = value;\n\n\t\tthis.iInvalidateShaderProgram();\n\t}\n\n\tpublic iInitVO(shaderObject:ShaderLightingObject, methodVO:MethodVO)\n\t{\n\t\tmethodVO.needsUV = this._pUseTexture;\n\t\tmethodVO.needsNormals = shaderObject.numLights > 0;\n\t}\n\n\t/**\n\t * Forces the creation of the texture.\n\t * @param stage The Stage used by the renderer\n\t */\n\tpublic generateMip(stage:Stage)\n\t{\n\t\tif (this._pUseTexture)\n\t\t\tstage.activateTexture(0, this._texture);\n\t}\n\n\t/**\n\t * The color of the diffuse reflection when not using a texture.\n\t */\n\tpublic get diffuseColor():number\n\t{\n\t\treturn this._diffuseColor;\n\t}\n\n\tpublic set diffuseColor(value:number)\n\t{\n\t\tif (this._diffuseColor == value)\n\t\t\treturn;\n\n\t\tthis._diffuseColor = value;\n\n\t\tthis.updateDiffuse();\n\t}\n\n\t/**\n\t * The color of the ambient reflection\n\t */\n\tpublic get ambientColor():number\n\t{\n\t\treturn this._ambientColor;\n\t}\n\n\tpublic set ambientColor(value:number)\n\t{\n\t\tif (this._ambientColor == value)\n\t\t\treturn;\n\n\t\tthis._ambientColor = value;\n\n\t\tthis.updateAmbient();\n\t}\n\n\n\t/**\n\t * The bitmapData to use to define the diffuse reflection color per texel.\n\t */\n\tpublic get texture():Texture2DBase\n\t{\n\t\treturn this._texture;\n\t}\n\n\tpublic set texture(value:Texture2DBase)\n\t{\n\t\tvar b:boolean = (value != null);\n\n\t\tif (b != this._pUseTexture || (value && this._texture && (value.hasMipmaps != this._texture.hasMipmaps || value.format != this._texture.format)))\n\t\t\tthis.iInvalidateShaderProgram();\n\n\t\tthis._pUseTexture = b;\n\t\tthis._texture = value;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic dispose()\n\t{\n\t\tthis._texture = null;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic copyFrom(method:ShadingMethodBase)\n\t{\n\t\tvar diff:DiffuseBasicMethod = <DiffuseBasicMethod> method;\n\n\t\tthis.texture = diff.texture;\n\t\tthis.multiply = diff.multiply;\n\t\tthis.diffuseColor = diff.diffuseColor;\n\t\tthis.ambientColor = diff.ambientColor;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iCleanCompilationData()\n\t{\n\t\tsuper.iCleanCompilationData();\n\n\t\tthis._pTotalLightColorReg = null;\n\t\tthis._pDiffuseInputRegister = null;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentPreLightingCode(shaderObject:ShaderLightingObject, methodVO:MethodVO, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = \"\";\n\n\t\tthis._pIsFirstLight = true;\n\n\t\tthis._pTotalLightColorReg = registerCache.getFreeFragmentVectorTemp();\n\t\tregisterCache.addFragmentTempUsages(this._pTotalLightColorReg, 1);\n\n\t\treturn code;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentCodePerLight(shaderObject:ShaderLightingObject, methodVO:MethodVO, lightDirReg:ShaderRegisterElement, lightColReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = \"\";\n\t\tvar t:ShaderRegisterElement;\n\n\t\t// write in temporary if not first light, so we can add to total diffuse colour\n\t\tif (this._pIsFirstLight) {\n\t\t\tt = this._pTotalLightColorReg;\n\t\t} else {\n\t\t\tt = registerCache.getFreeFragmentVectorTemp();\n\t\t\tregisterCache.addFragmentTempUsages(t, 1);\n\t\t}\n\n\t\tcode += \"dp3 \" + t + \".x, \" + lightDirReg + \", \" + sharedRegisters.normalFragment + \"\\n\" +\n\t\t\t\t\"max \" + t + \".w, \" + t + \".x, \" + sharedRegisters.commons + \".y\\n\";\n\n\t\tif (shaderObject.usesLightFallOff)\n\t\t\tcode += \"mul \" + t + \".w, \" + t + \".w, \" + lightDirReg + \".w\\n\";\n\n\t\tif (this._iModulateMethod != null)\n\t\t\tcode += this._iModulateMethod(shaderObject, methodVO, t, registerCache, sharedRegisters);\n\n\t\tcode += \"mul \" + t + \", \" + t + \".w, \" + lightColReg + \"\\n\";\n\n\t\tif (!this._pIsFirstLight) {\n\t\t\tcode += \"add \" + this._pTotalLightColorReg + \".xyz, \" + this._pTotalLightColorReg + \", \" + t + \"\\n\";\n\t\t\tregisterCache.removeFragmentTempUsage(t);\n\t\t}\n\n\t\tthis._pIsFirstLight = false;\n\n\t\treturn code;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentCodePerProbe(shaderObject:ShaderLightingObject, methodVO:MethodVO, cubeMapReg:ShaderRegisterElement, weightRegister:string, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = \"\";\n\t\tvar t:ShaderRegisterElement;\n\n\t\t// write in temporary if not first light, so we can add to total diffuse colour\n\t\tif (this._pIsFirstLight) {\n\t\t\tt = this._pTotalLightColorReg;\n\t\t} else {\n\t\t\tt = registerCache.getFreeFragmentVectorTemp();\n\t\t\tregisterCache.addFragmentTempUsages(t, 1);\n\t\t}\n\n\t\tcode += \"tex \" + t + \", \" + sharedRegisters.normalFragment + \", \" + cubeMapReg + \" <cube,linear,miplinear>\\n\" +\n\t\t\t\t\"mul \" + t + \".xyz, \" + t + \".xyz, \" + weightRegister + \"\\n\";\n\n\t\tif (this._iModulateMethod != null)\n\t\t\tcode += this._iModulateMethod(shaderObject, methodVO, t, registerCache, sharedRegisters);\n\n\t\tif (!this._pIsFirstLight) {\n\t\t\tcode += \"add \" + this._pTotalLightColorReg + \".xyz, \" + this._pTotalLightColorReg + \", \" + t + \"\\n\";\n\t\t\tregisterCache.removeFragmentTempUsage(t);\n\t\t}\n\n\t\tthis._pIsFirstLight = false;\n\n\t\treturn code;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentPostLightingCode(shaderObject:ShaderLightingObject, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = \"\";\n\n\t\tvar albedo:ShaderRegisterElement;\n\t\tvar cutOffReg:ShaderRegisterElement;\n\n\t\t// incorporate input from ambient\n\t\tif (sharedRegisters.shadowTarget)\n\t\t\tcode += this.pApplyShadow(shaderObject, methodVO, registerCache, sharedRegisters);\n\n\t\talbedo = registerCache.getFreeFragmentVectorTemp();\n\t\tregisterCache.addFragmentTempUsages(albedo, 1);\n\n\t\tvar ambientColorRegister:ShaderRegisterElement = registerCache.getFreeFragmentConstant();\n\t\tmethodVO.fragmentConstantsIndex = ambientColorRegister.index*4;\n\n\t\tif (this._pUseTexture) {\n\t\t\tthis._pDiffuseInputRegister = registerCache.getFreeTextureReg();\n\n\t\t\tmethodVO.texturesIndex = this._pDiffuseInputRegister.index;\n\n\t\t\tcode += ShaderCompilerHelper.getTex2DSampleCode(albedo, sharedRegisters, this._pDiffuseInputRegister, this._texture, shaderObject.useSmoothTextures, shaderObject.repeatTextures, shaderObject.useMipmapping);\n\n\t\t} else {\n\t\t\tthis._pDiffuseInputRegister = registerCache.getFreeFragmentConstant();\n\n\t\t\tcode += \"mov \" + albedo + \", \" + this._pDiffuseInputRegister + \"\\n\";\n\t\t}\n\n\t\tcode += \"sat \" + this._pTotalLightColorReg + \", \" + this._pTotalLightColorReg + \"\\n\" +\n\t\t\t\"mul \" + albedo + \".xyz, \" + albedo + \", \" + this._pTotalLightColorReg + \"\\n\";\n\n\t\tif (this._multiply) {\n\t\t\tcode += \"add \" + albedo + \".xyz, \" + albedo + \", \" + ambientColorRegister + \"\\n\" +\n\t\t\t\t\"mul \" + targetReg + \".xyz, \" + targetReg + \", \" + albedo + \"\\n\";\n\t\t} else {\n\t\t\tcode += \"mul \" + targetReg + \".xyz, \" + targetReg + \", \" + ambientColorRegister + \"\\n\" +\n\t\t\t\t\"mul \" + this._pTotalLightColorReg + \".xyz, \" + targetReg + \", \" + this._pTotalLightColorReg + \"\\n\" +\n\t\t\t\t\"sub \" + targetReg + \".xyz, \" + targetReg + \", \" + this._pTotalLightColorReg + \"\\n\" +\n\t\t\t\t\"add \" + targetReg + \".xyz, \" + targetReg + \", \" + albedo + \"\\n\";\n\t\t}\n\n\t\tregisterCache.removeFragmentTempUsage(this._pTotalLightColorReg);\n\t\tregisterCache.removeFragmentTempUsage(albedo);\n\n\t\treturn code;\n\t}\n\n\t/**\n\t * Generate the code that applies the calculated shadow to the diffuse light\n\t * @param methodVO The MethodVO object for which the compilation is currently happening.\n\t * @param regCache The register cache the compiler is currently using for the register management.\n\t */\n\tpublic pApplyShadow(shaderObject:ShaderLightingObject, methodVO:MethodVO, regCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\treturn \"mul \" + this._pTotalLightColorReg + \".xyz, \" + this._pTotalLightColorReg + \", \" + sharedRegisters.shadowTarget + \".w\\n\";\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iActivate(shaderObject:ShaderLightingObject, methodVO:MethodVO, stage:Stage)\n\t{\n\t\tif (this._pUseTexture) {\n\t\t\tstage.context.setSamplerStateAt(methodVO.texturesIndex, shaderObject.repeatTextures? ContextGLWrapMode.REPEAT:ContextGLWrapMode.CLAMP, shaderObject.useSmoothTextures? ContextGLTextureFilter.LINEAR : ContextGLTextureFilter.NEAREST, shaderObject.useMipmapping? ContextGLMipFilter.MIPLINEAR : ContextGLMipFilter.MIPNONE);\n\t\t\tstage.activateTexture(methodVO.texturesIndex, this._texture);\n\t\t} else {\n\t\t\tvar index:number = methodVO.fragmentConstantsIndex;\n\t\t\tvar data:Array<number> = shaderObject.fragmentConstantData;\n\t\t\tdata[index + 4] = this._diffuseR;\n\t\t\tdata[index + 5] = this._diffuseG;\n\t\t\tdata[index + 6] = this._diffuseB;\n\t\t\tdata[index + 7] = 1;\n\t\t}\n\t}\n\n\t/**\n\t * Updates the diffuse color data used by the render state.\n\t */\n\tprivate updateDiffuse()\n\t{\n\t\tthis._diffuseR = ((this._diffuseColor >> 16) & 0xff)/0xff;\n\t\tthis._diffuseG = ((this._diffuseColor >> 8) & 0xff)/0xff;\n\t\tthis._diffuseB = (this._diffuseColor & 0xff)/0xff;\n\t}\n\n\t/**\n\t * Updates the ambient color data used by the render state.\n\t */\n\tprivate updateAmbient()\n\t{\n\t\tthis._ambientR = ((this._ambientColor >> 16) & 0xff)/0xff;\n\t\tthis._ambientG = ((this._ambientColor >> 8) & 0xff)/0xff;\n\t\tthis._ambientB = (this._ambientColor & 0xff)/0xff;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iSetRenderState(shaderObject:ShaderLightingObject, methodVO:MethodVO, renderable:RenderableBase, stage:Stage, camera:Camera)\n\t{\n\t\t//TODO move this to Activate (ambientR/G/B currently calc'd in render state)\n\t\tif (shaderObject.numLights > 0) {\n\t\t\tvar index:number = methodVO.fragmentConstantsIndex;\n\t\t\tvar data:Array<number> = shaderObject.fragmentConstantData;\n\t\t\tdata[index] = shaderObject.ambientR*this._ambientR;\n\t\t\tdata[index + 1] = shaderObject.ambientG*this._ambientG;\n\t\t\tdata[index + 2] = shaderObject.ambientB*this._ambientB;\n\t\t\tdata[index + 3] = 1;\n\t\t}\n\t}\n}\n\nexport = DiffuseBasicMethod;","import Stage\t\t\t\t\t\t\t= require(\"awayjs-stagegl/lib/base/Stage\");\n\nimport ShaderLightingObject\t\t\t\t= require(\"awayjs-renderergl/lib/compilation/ShaderLightingObject\");\nimport ShaderObjectBase\t\t\t\t\t= require(\"awayjs-renderergl/lib/compilation/ShaderObjectBase\");\nimport ShaderRegisterCache\t\t\t\t= require(\"awayjs-renderergl/lib/compilation/ShaderRegisterCache\");\nimport ShaderRegisterData\t\t\t\t= require(\"awayjs-renderergl/lib/compilation/ShaderRegisterData\");\nimport ShaderRegisterElement\t\t\t= require(\"awayjs-renderergl/lib/compilation/ShaderRegisterElement\");\nimport ShaderCompilerHelper\t\t\t\t= require(\"awayjs-renderergl/lib/utils/ShaderCompilerHelper\");\n\nimport MethodVO\t\t\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/data/MethodVO\");\nimport DiffuseBasicMethod\t\t\t\t= require(\"awayjs-methodmaterials/lib/methods/DiffuseBasicMethod\");\nimport DiffuseCompositeMethod\t\t\t= require(\"awayjs-methodmaterials/lib/methods/DiffuseCompositeMethod\");\n\n/**\n * DiffuseCelMethod provides a shading method to add diffuse cel (cartoon) shading.\n */\nclass DiffuseCelMethod extends DiffuseCompositeMethod\n{\n\tprivate _levels:number /*uint*/;\n\tprivate _dataReg:ShaderRegisterElement;\n\tprivate _smoothness:number = .1;\n\n\t/**\n\t * Creates a new DiffuseCelMethod object.\n\t * @param levels The amount of shadow gradations.\n\t * @param baseMethod An optional diffuse method on which the cartoon shading is based. If omitted, DiffuseBasicMethod is used.\n\t */\n\tconstructor(levels:number /*uint*/ = 3, baseMethod:DiffuseBasicMethod = null)\n\t{\n\t\tsuper(null, baseMethod);\n\n\t\tthis.baseMethod._iModulateMethod = (shaderObject:ShaderObjectBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData) => this.clampDiffuse(shaderObject, methodVO, targetReg, registerCache, sharedRegisters);\n\n\t\tthis._levels = levels;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitConstants(shaderObject:ShaderLightingObject, methodVO:MethodVO)\n\t{\n\t\tvar data:Array<number> = shaderObject.fragmentConstantData;\n\t\tvar index:number /*int*/ = methodVO.secondaryFragmentConstantsIndex;\n\t\tsuper.iInitConstants(shaderObject, methodVO);\n\t\tdata[index + 1] = 1;\n\t\tdata[index + 2] = 0;\n\t}\n\n\t/**\n\t * The amount of shadow gradations.\n\t */\n\tpublic get levels():number /*uint*/\n\t{\n\t\treturn this._levels;\n\t}\n\n\tpublic set levels(value:number /*uint*/)\n\t{\n\t\tthis._levels = value;\n\t}\n\n\t/**\n\t * The smoothness of the edge between 2 shading levels.\n\t */\n\tpublic get smoothness():number\n\t{\n\t\treturn this._smoothness;\n\t}\n\n\tpublic set smoothness(value:number)\n\t{\n\t\tthis._smoothness = value;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iCleanCompilationData()\n\t{\n\t\tsuper.iCleanCompilationData();\n\t\tthis._dataReg = null;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentPreLightingCode(shaderObject:ShaderLightingObject, methodVO:MethodVO, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tthis._dataReg = registerCache.getFreeFragmentConstant();\n\t\tmethodVO.secondaryFragmentConstantsIndex = this._dataReg.index*4;\n\n\t\treturn super.iGetFragmentPreLightingCode(shaderObject, methodVO, registerCache, sharedRegisters);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iActivate(shaderObject:ShaderLightingObject, methodVO:MethodVO, stage:Stage)\n\t{\n\t\tsuper.iActivate(shaderObject, methodVO, stage);\n\t\tvar data:Array<number> = shaderObject.fragmentConstantData;\n\t\tvar index:number /*int*/ = methodVO.secondaryFragmentConstantsIndex;\n\t\tdata[index] = this._levels;\n\t\tdata[index + 3] = this._smoothness;\n\t}\n\n\t/**\n\t * Snaps the diffuse shading of the wrapped method to one of the levels.\n\t * @param vo The MethodVO used to compile the current shader.\n\t * @param t The register containing the diffuse strength in the \"w\" component.\n\t * @param regCache The register cache used for the shader compilation.\n\t * @param sharedRegisters The shared register data for this shader.\n\t * @return The AGAL fragment code for the method.\n\t */\n\tprivate clampDiffuse(shaderObject:ShaderObjectBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\treturn \"mul \" + targetReg + \".w, \" + targetReg + \".w, \" + this._dataReg + \".x\\n\" +\n\t\t\t\"frc \" + targetReg + \".z, \" + targetReg + \".w\\n\" +\n\t\t\t\"sub \" + targetReg + \".y, \" + targetReg + \".w, \" + targetReg + \".z\\n\" +\n\t\t\t\"mov \" + targetReg + \".x, \" + this._dataReg + \".x\\n\" +\n\t\t\t\"sub \" + targetReg + \".x, \" + targetReg + \".x, \" + this._dataReg + \".y\\n\" +\n\t\t\t\"rcp \" + targetReg + \".x,\" + targetReg + \".x\\n\" +\n\t\t\t\"mul \" + targetReg + \".w, \" + targetReg + \".y, \" + targetReg + \".x\\n\" +\n\n\t\t\t// previous clamped strength\n\t\t\t\"sub \" + targetReg + \".y, \" + targetReg + \".w, \" + targetReg + \".x\\n\" +\n\n\t\t\t// fract/epsilon (so 0 - epsilon will become 0 - 1)\n\t\t\t\"div \" + targetReg + \".z, \" + targetReg + \".z, \" + this._dataReg + \".w\\n\" +\n\t\t\t\"sat \" + targetReg + \".z, \" + targetReg + \".z\\n\" +\n\n\t\t\t\"mul \" + targetReg + \".w, \" + targetReg + \".w, \" + targetReg + \".z\\n\" +\n\t\t\t// 1-z\n\t\t\t\"sub \" + targetReg + \".z, \" + this._dataReg + \".y, \" + targetReg + \".z\\n\" +\n\t\t\t\"mul \" + targetReg + \".y, \" + targetReg + \".y, \" + targetReg + \".z\\n\" +\n\t\t\t\"add \" + targetReg + \".w, \" + targetReg + \".w, \" + targetReg + \".y\\n\" +\n\t\t\t\"sat \" + targetReg + \".w, \" + targetReg + \".w\\n\";\n\t}\n}\n\nexport = DiffuseCelMethod;","import Texture2DBase\t\t\t\t\t= require(\"awayjs-core/lib/textures/Texture2DBase\");\n\nimport Camera\t\t\t\t\t\t\t= require(\"awayjs-display/lib/entities/Camera\");\n\nimport Stage\t\t\t\t\t\t\t= require(\"awayjs-stagegl/lib/base/Stage\");\n\nimport ShaderLightingObject\t\t\t\t= require(\"awayjs-renderergl/lib/compilation/ShaderLightingObject\");\nimport ShaderObjectBase\t\t\t\t\t= require(\"awayjs-renderergl/lib/compilation/ShaderObjectBase\");\nimport ShaderRegisterCache\t\t\t\t= require(\"awayjs-renderergl/lib/compilation/ShaderRegisterCache\");\nimport ShaderRegisterData\t\t\t\t= require(\"awayjs-renderergl/lib/compilation/ShaderRegisterData\");\nimport ShaderRegisterElement\t\t\t= require(\"awayjs-renderergl/lib/compilation/ShaderRegisterElement\");\nimport ShadingMethodEvent\t\t\t\t= require(\"awayjs-renderergl/lib/events/ShadingMethodEvent\");\nimport RenderableBase\t\t\t\t\t= require(\"awayjs-renderergl/lib/pool/RenderableBase\");\n\nimport MethodVO\t\t\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/data/MethodVO\");\nimport DiffuseBasicMethod\t\t\t\t= require(\"awayjs-methodmaterials/lib/methods/DiffuseBasicMethod\");\n\n/**\n * DiffuseCompositeMethod provides a base class for diffuse methods that wrap a diffuse method to alter the\n * calculated diffuse reflection strength.\n */\nclass DiffuseCompositeMethod extends DiffuseBasicMethod\n{\n\tpublic pBaseMethod:DiffuseBasicMethod;\n\n\tprivate _onShaderInvalidatedDelegate:Function;\n\n\t/**\n\t * Creates a new <code>DiffuseCompositeMethod</code> object.\n\t *\n\t * @param modulateMethod The method which will add the code to alter the base method's strength. It needs to have the signature clampDiffuse(t:ShaderRegisterElement, regCache:ShaderRegisterCache):string, in which t.w will contain the diffuse strength.\n\t * @param baseMethod The base diffuse method on which this method's shading is based.\n\t */\n\tconstructor(modulateMethod:(shaderObject:ShaderObjectBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData) => string, baseMethod:DiffuseBasicMethod = null)\n\t{\n\t\tsuper();\n\n\t\tthis._onShaderInvalidatedDelegate = (event:ShadingMethodEvent) => this.onShaderInvalidated(event);\n\n\t\tthis.pBaseMethod = baseMethod || new DiffuseBasicMethod();\n\t\tthis.pBaseMethod._iModulateMethod = modulateMethod;\n\t\tthis.pBaseMethod.addEventListener(ShadingMethodEvent.SHADER_INVALIDATED, this._onShaderInvalidatedDelegate);\n\t}\n\n\t/**\n\t * The base diffuse method on which this method's shading is based.\n\t */\n\tpublic get baseMethod():DiffuseBasicMethod\n\t{\n\t\treturn this.pBaseMethod;\n\t}\n\n\tpublic set baseMethod(value:DiffuseBasicMethod)\n\t{\n\t\tif (this.pBaseMethod == value)\n\t\t\treturn;\n\n\t\tthis.pBaseMethod.removeEventListener(ShadingMethodEvent.SHADER_INVALIDATED, this._onShaderInvalidatedDelegate);\n\t\tthis.pBaseMethod = value;\n\t\tthis.pBaseMethod.addEventListener(ShadingMethodEvent.SHADER_INVALIDATED, this._onShaderInvalidatedDelegate);\n\t\tthis.iInvalidateShaderProgram();\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitVO(shaderObject:ShaderLightingObject, methodVO:MethodVO)\n\t{\n\t\tthis.pBaseMethod.iInitVO(shaderObject, methodVO);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitConstants(shaderObject:ShaderLightingObject, methodVO:MethodVO)\n\t{\n\t\tthis.pBaseMethod.iInitConstants(shaderObject, methodVO);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic dispose()\n\t{\n\t\tthis.pBaseMethod.removeEventListener(ShadingMethodEvent.SHADER_INVALIDATED, this._onShaderInvalidatedDelegate);\n\t\tthis.pBaseMethod.dispose();\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic get texture():Texture2DBase\n\t{\n\t\treturn this.pBaseMethod.texture;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic set texture(value:Texture2DBase)\n\t{\n\t\tthis.pBaseMethod.texture = value;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic get diffuseColor():number\n\t{\n\t\treturn this.pBaseMethod.diffuseColor;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic set diffuseColor(value:number)\n\t{\n\t\tthis.pBaseMethod.diffuseColor = value;\n\t}\n\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic get ambientColor():number\n\t{\n\t\treturn this.pBaseMethod.ambientColor;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic set ambientColor(value:number)\n\t{\n\t\tthis.pBaseMethod.ambientColor = value;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentPreLightingCode(shaderObject:ShaderLightingObject, methodVO:MethodVO, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\treturn this.pBaseMethod.iGetFragmentPreLightingCode(shaderObject, methodVO, registerCache, sharedRegisters);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentCodePerLight(shaderObject:ShaderLightingObject, methodVO:MethodVO, lightDirReg:ShaderRegisterElement, lightColReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = this.pBaseMethod.iGetFragmentCodePerLight(shaderObject, methodVO, lightDirReg, lightColReg, registerCache, sharedRegisters);\n\t\tthis._pTotalLightColorReg = this.pBaseMethod._pTotalLightColorReg;\n\t\treturn code;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentCodePerProbe(shaderObject:ShaderLightingObject, methodVO:MethodVO, cubeMapReg:ShaderRegisterElement, weightRegister:string, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = this.pBaseMethod.iGetFragmentCodePerProbe(shaderObject, methodVO, cubeMapReg, weightRegister, registerCache, sharedRegisters);\n\t\tthis._pTotalLightColorReg = this.pBaseMethod._pTotalLightColorReg;\n\t\treturn code;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iActivate(shaderObject:ShaderLightingObject, methodVO:MethodVO, stage:Stage)\n\t{\n\t\tthis.pBaseMethod.iActivate(shaderObject, methodVO, stage);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iSetRenderState(shaderObject:ShaderLightingObject, methodVO:MethodVO, renderable:RenderableBase, stage:Stage, camera:Camera)\n\t{\n\t\tthis.pBaseMethod.iSetRenderState(shaderObject, methodVO, renderable, stage, camera);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iDeactivate(shaderObject:ShaderLightingObject, methodVO:MethodVO, stage:Stage)\n\t{\n\t\tthis.pBaseMethod.iDeactivate(shaderObject, methodVO, stage);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetVertexCode(shaderObject:ShaderObjectBase, methodVO:MethodVO, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\treturn this.pBaseMethod.iGetVertexCode(shaderObject, methodVO, registerCache, sharedRegisters);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentPostLightingCode(shaderObject:ShaderLightingObject, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\treturn this.pBaseMethod.iGetFragmentPostLightingCode(shaderObject, methodVO, targetReg, registerCache, sharedRegisters);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iReset()\n\t{\n\t\tthis.pBaseMethod.iReset();\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iCleanCompilationData()\n\t{\n\t\tsuper.iCleanCompilationData();\n\t\tthis.pBaseMethod.iCleanCompilationData();\n\t}\n\n\t/**\n\t * Called when the base method's shader code is invalidated.\n\t */\n\tprivate onShaderInvalidated(event:ShadingMethodEvent)\n\t{\n\t\tthis.iInvalidateShaderProgram();\n\t}\n}\n\nexport = DiffuseCompositeMethod;","import ShaderLightingObject\t\t\t\t= require(\"awayjs-renderergl/lib/compilation/ShaderLightingObject\");\nimport ShaderObjectBase\t\t\t\t\t= require(\"awayjs-renderergl/lib/compilation/ShaderObjectBase\");\nimport ShaderRegisterCache\t\t\t\t= require(\"awayjs-renderergl/lib/compilation/ShaderRegisterCache\");\nimport ShaderRegisterData\t\t\t\t= require(\"awayjs-renderergl/lib/compilation/ShaderRegisterData\");\nimport ShaderRegisterElement\t\t\t= require(\"awayjs-renderergl/lib/compilation/ShaderRegisterElement\");\nimport ShaderCompilerHelper\t\t\t\t= require(\"awayjs-renderergl/lib/utils/ShaderCompilerHelper\");\n\nimport MethodVO\t\t\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/data/MethodVO\");\nimport DiffuseBasicMethod\t\t\t\t= require(\"awayjs-methodmaterials/lib/methods/DiffuseBasicMethod\");\n\n/**\n * DiffuseDepthMethod provides a debug method to visualise depth maps\n */\nclass DiffuseDepthMethod extends DiffuseBasicMethod\n{\n\t/**\n\t * Creates a new DiffuseBasicMethod object.\n\t */\n\tconstructor()\n\t{\n\t\tsuper();\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitConstants(shaderObject:ShaderObjectBase, methodVO:MethodVO)\n\t{\n\t\tvar data:Array<number> = shaderObject.fragmentConstantData;\n\t\tvar index:number /*int*/ = methodVO.fragmentConstantsIndex;\n\t\tdata[index] = 1.0;\n\t\tdata[index + 1] = 1/255.0;\n\t\tdata[index + 2] = 1/65025.0;\n\t\tdata[index + 3] = 1/16581375.0;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentPostLightingCode(shaderObject:ShaderLightingObject, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = \"\";\n\t\tvar temp:ShaderRegisterElement;\n\t\tvar decReg:ShaderRegisterElement;\n\n\t\tif (!this._pUseTexture)\n\t\t\tthrow new Error(\"DiffuseDepthMethod requires texture!\");\n\n\t\t// incorporate input from ambient\n\t\tif (shaderObject.numLights > 0) {\n\t\t\tif (sharedRegisters.shadowTarget)\n\t\t\t\tcode += \"mul \" + this._pTotalLightColorReg + \".xyz, \" + this._pTotalLightColorReg + \".xyz, \" + sharedRegisters.shadowTarget + \".w\\n\";\n\t\t\tcode += \"add \" + targetReg + \".xyz, \" + this._pTotalLightColorReg + \".xyz, \" + targetReg + \".xyz\\n\" +\n\t\t\t\t\"sat \" + targetReg + \".xyz, \" + targetReg + \".xyz\\n\";\n\t\t\tregisterCache.removeFragmentTempUsage(this._pTotalLightColorReg);\n\t\t}\n\n\t\ttemp = shaderObject.numLights > 0? registerCache.getFreeFragmentVectorTemp():targetReg;\n\n\t\tthis._pDiffuseInputRegister = registerCache.getFreeTextureReg();\n\t\tmethodVO.texturesIndex = this._pDiffuseInputRegister.index;\n\t\tdecReg = registerCache.getFreeFragmentConstant();\n\t\tmethodVO.fragmentConstantsIndex = decReg.index*4;\n\t\tcode += ShaderCompilerHelper.getTex2DSampleCode(temp, sharedRegisters, this._pDiffuseInputRegister, this.texture, shaderObject.useSmoothTextures, shaderObject.repeatTextures, shaderObject.useMipmapping) +\n\t\t\t\"dp4 \" + temp + \".x, \" + temp + \", \" + decReg + \"\\n\" +\n\t\t\t\"mov \" + temp + \".yz, \" + temp + \".xx\t\t\t\\n\" +\n\t\t\t\"mov \" + temp + \".w, \" + decReg + \".x\\n\" +\n\t\t\t\"sub \" + temp + \".xyz, \" + decReg + \".xxx, \" + temp + \".xyz\\n\";\n\n\t\tif (shaderObject.numLights == 0)\n\t\t\treturn code;\n\n\t\tcode += \"mul \" + targetReg + \".xyz, \" + temp + \".xyz, \" + targetReg + \".xyz\\n\" +\n\t\t\t\"mov \" + targetReg + \".w, \" + temp + \".w\\n\";\n\n\t\treturn code;\n\t}\n}\n\nexport = DiffuseDepthMethod;","import Texture2DBase\t\t\t\t\t= require(\"awayjs-core/lib/textures/Texture2DBase\");\n\nimport Stage\t\t\t\t\t\t\t= require(\"awayjs-stagegl/lib/base/Stage\");\n\nimport ShaderLightingObject\t\t\t\t= require(\"awayjs-renderergl/lib/compilation/ShaderLightingObject\");\nimport ShaderRegisterCache\t\t\t\t= require(\"awayjs-renderergl/lib/compilation/ShaderRegisterCache\");\nimport ShaderRegisterData\t\t\t\t= require(\"awayjs-renderergl/lib/compilation/ShaderRegisterData\");\nimport ShaderRegisterElement\t\t\t= require(\"awayjs-renderergl/lib/compilation/ShaderRegisterElement\");\nimport ShaderCompilerHelper\t\t\t\t= require(\"awayjs-renderergl/lib/utils/ShaderCompilerHelper\");\n\nimport MethodVO\t\t\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/data/MethodVO\");\nimport DiffuseBasicMethod\t\t\t\t= require(\"awayjs-methodmaterials/lib/methods/DiffuseBasicMethod\");\n\n/**\n * DiffuseGradientMethod is an alternative to DiffuseBasicMethod in which the shading can be modulated with a gradient\n * to introduce color-tinted shading as opposed to the single-channel diffuse strength. This can be used as a crude\n * approximation to subsurface scattering (for instance, the mid-range shading for skin can be tinted red to similate\n * scattered light within the skin attributing to the final colour)\n */\nclass DiffuseGradientMethod extends DiffuseBasicMethod\n{\n\tprivate _gradientTextureRegister:ShaderRegisterElement;\n\tprivate _gradient:Texture2DBase;\n\n\t/**\n\t * Creates a new DiffuseGradientMethod object.\n\t * @param gradient A texture that contains the light colour based on the angle. This can be used to change\n\t * the light colour due to subsurface scattering when the surface faces away from the light.\n\t */\n\tconstructor(gradient:Texture2DBase)\n\t{\n\t\tsuper();\n\n\t\tthis._gradient = gradient;\n\t}\n\n\t/**\n\t * A texture that contains the light colour based on the angle. This can be used to change the light colour\n\t * due to subsurface scattering when the surface faces away from the light.\n\t */\n\tpublic get gradient():Texture2DBase\n\t{\n\t\treturn this._gradient;\n\t}\n\n\tpublic set gradient(value:Texture2DBase)\n\t{\n\t\tif (value.hasMipmaps != this._gradient.hasMipmaps || value.format != this._gradient.format)\n\t\t\tthis.iInvalidateShaderProgram();\n\t\tthis._gradient = value;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iCleanCompilationData()\n\t{\n\t\tsuper.iCleanCompilationData();\n\t\tthis._gradientTextureRegister = null;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentPreLightingCode(shaderObject:ShaderLightingObject, methodVO:MethodVO, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = super.iGetFragmentPreLightingCode(shaderObject, methodVO, registerCache, sharedRegisters);\n\t\tthis._pIsFirstLight = true;\n\n\t\tif (shaderObject.numLights > 0) {\n\t\t\tthis._gradientTextureRegister = registerCache.getFreeTextureReg();\n\t\t\tmethodVO.secondaryTexturesIndex = this._gradientTextureRegister.index;\n\t\t}\n\t\treturn code;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentCodePerLight(shaderObject:ShaderLightingObject, methodVO:MethodVO, lightDirReg:ShaderRegisterElement, lightColReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = \"\";\n\t\tvar t:ShaderRegisterElement;\n\n\t\t// write in temporary if not first light, so we can add to total diffuse colour\n\t\tif (this._pIsFirstLight)\n\t\t\tt = this._pTotalLightColorReg;\n\t\telse {\n\t\t\tt = registerCache.getFreeFragmentVectorTemp();\n\t\t\tregisterCache.addFragmentTempUsages(t, 1);\n\t\t}\n\n\t\tcode += \"dp3 \" + t + \".w, \" + lightDirReg + \".xyz, \" + sharedRegisters.normalFragment + \".xyz\\n\" +\n\t\t\t\"mul \" + t + \".w, \" + t + \".w, \" + sharedRegisters.commons + \".x\\n\" +\n\t\t\t\"add \" + t + \".w, \" + t + \".w, \" + sharedRegisters.commons + \".x\\n\" +\n\t\t\t\"mul \" + t + \".xyz, \" + t + \".w, \" + lightDirReg + \".w\\n\";\n\n\t\tif (this._iModulateMethod != null)\n\t\t\tcode += this._iModulateMethod(shaderObject, methodVO, t, registerCache, sharedRegisters);\n\n\t\tcode += ShaderCompilerHelper.getTex2DSampleCode(t, sharedRegisters, this._gradientTextureRegister, this._gradient, shaderObject.useSmoothTextures, shaderObject.repeatTextures, shaderObject.useMipmapping, t, \"clamp\") +\n\t\t\t//\t\t\t\t\t\"mul \" + t + \".xyz, \" + t + \".xyz, \" + t + \".w\\n\" +\n\t\t\t\"mul \" + t + \".xyz, \" + t + \".xyz, \" + lightColReg + \".xyz\\n\";\n\n\t\tif (!this._pIsFirstLight) {\n\t\t\tcode += \"add \" + this._pTotalLightColorReg + \".xyz, \" + this._pTotalLightColorReg + \".xyz, \" + t + \".xyz\\n\";\n\t\t\tregisterCache.removeFragmentTempUsage(t);\n\t\t}\n\n\t\tthis._pIsFirstLight = false;\n\n\t\treturn code;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic pApplyShadow(shaderObject:ShaderLightingObject, methodVO:MethodVO, regCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar t:ShaderRegisterElement = regCache.getFreeFragmentVectorTemp();\n\n\t\treturn \"mov \" + t + \", \" + sharedRegisters.shadowTarget + \".wwww\\n\" +\n\t\t\tShaderCompilerHelper.getTex2DSampleCode(t, sharedRegisters, this._gradientTextureRegister, this._gradient, shaderObject.useSmoothTextures, shaderObject.repeatTextures, shaderObject.useMipmapping, t, \"clamp\") +\n\t\t\t\"mul \" + this._pTotalLightColorReg + \".xyz, \" + this._pTotalLightColorReg + \", \" + t + \"\\n\";\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iActivate(shaderObject:ShaderLightingObject, methodVO:MethodVO, stage:Stage)\n\t{\n\t\tsuper.iActivate(shaderObject, methodVO, stage);\n\n\t\tstage.activateTexture(methodVO.secondaryTexturesIndex, this._gradient);\n\t}\n}\n\nexport = DiffuseGradientMethod;","import Texture2DBase\t\t\t\t\t= require(\"awayjs-core/lib/textures/Texture2DBase\");\n\nimport Stage\t\t\t\t\t\t\t= require(\"awayjs-stagegl/lib/base/Stage\");\n\nimport ShaderLightingObject\t\t\t\t= require(\"awayjs-renderergl/lib/compilation/ShaderLightingObject\");\nimport ShaderRegisterCache\t\t\t\t= require(\"awayjs-renderergl/lib/compilation/ShaderRegisterCache\");\nimport ShaderRegisterData\t\t\t\t= require(\"awayjs-renderergl/lib/compilation/ShaderRegisterData\");\nimport ShaderRegisterElement\t\t\t= require(\"awayjs-renderergl/lib/compilation/ShaderRegisterElement\");\nimport ShaderCompilerHelper\t\t\t\t= require(\"awayjs-renderergl/lib/utils/ShaderCompilerHelper\");\n\nimport MethodVO\t\t\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/data/MethodVO\");\nimport DiffuseBasicMethod\t\t\t\t= require(\"awayjs-methodmaterials/lib/methods/DiffuseBasicMethod\");\nimport DiffuseCompositeMethod\t\t\t= require(\"awayjs-methodmaterials/lib/methods/DiffuseCompositeMethod\");\n\n/**\n * DiffuseLightMapMethod provides a diffuse shading method that uses a light map to modulate the calculated diffuse\n * lighting. It is different from EffectLightMapMethod in that the latter modulates the entire calculated pixel color, rather\n * than only the diffuse lighting value.\n */\nclass DiffuseLightMapMethod extends DiffuseCompositeMethod\n{\n\t/**\n\t * Indicates the light map should be multiplied with the calculated shading result.\n\t * This can be used to add pre-calculated shadows or occlusion.\n\t */\n\tpublic static MULTIPLY:string = \"multiply\";\n\n\t/**\n\t * Indicates the light map should be added into the calculated shading result.\n\t * This can be used to add pre-calculated lighting or global illumination.\n\t */\n\tpublic static ADD:string = \"add\";\n\n\tprivate _lightMapTexture:Texture2DBase;\n\tprivate _blendMode:string;\n\tprivate _useSecondaryUV:boolean;\n\n\t/**\n\t * Creates a new DiffuseLightMapMethod method.\n\t *\n\t * @param lightMap The texture containing the light map.\n\t * @param blendMode The blend mode with which the light map should be applied to the lighting result.\n\t * @param useSecondaryUV Indicates whether the secondary UV set should be used to map the light map.\n\t * @param baseMethod The diffuse method used to calculate the regular diffuse-based lighting.\n\t */\n\tconstructor(lightMap:Texture2DBase, blendMode:string = \"multiply\", useSecondaryUV:boolean = false, baseMethod:DiffuseBasicMethod = null)\n\t{\n\t\tsuper(null, baseMethod);\n\n\t\tthis._useSecondaryUV = useSecondaryUV;\n\t\tthis._lightMapTexture = lightMap;\n\t\tthis.blendMode = blendMode;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitVO(shaderObject:ShaderLightingObject, methodVO:MethodVO)\n\t{\n\t\tmethodVO.needsSecondaryUV = this._useSecondaryUV;\n\t\tmethodVO.needsUV = !this._useSecondaryUV;\n\t}\n\n\t/**\n\t * The blend mode with which the light map should be applied to the lighting result.\n\t *\n\t * @see DiffuseLightMapMethod.ADD\n\t * @see DiffuseLightMapMethod.MULTIPLY\n\t */\n\tpublic get blendMode():string\n\t{\n\t\treturn this._blendMode;\n\t}\n\n\tpublic set blendMode(value:string)\n\t{\n\t\tif (value != DiffuseLightMapMethod.ADD && value != DiffuseLightMapMethod.MULTIPLY)\n\t\t\tthrow new Error(\"Unknown blendmode!\");\n\n\t\tif (this._blendMode == value)\n\t\t\treturn;\n\n\t\tthis._blendMode = value;\n\n\t\tthis.iInvalidateShaderProgram();\n\t}\n\n\t/**\n\t * The texture containing the light map data.\n\t */\n\tpublic get lightMapTexture():Texture2DBase\n\t{\n\t\treturn this._lightMapTexture;\n\t}\n\n\tpublic set lightMapTexture(value:Texture2DBase)\n\t{\n\t\tthis._lightMapTexture = value;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iActivate(shaderObject:ShaderLightingObject, methodVO:MethodVO, stage:Stage)\n\t{\n\t\tstage.activateTexture(methodVO.secondaryTexturesIndex, this._lightMapTexture);\n\n\t\tsuper.iActivate(shaderObject, methodVO, stage);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentPostLightingCode(shaderObject:ShaderLightingObject, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string;\n\t\tvar lightMapReg:ShaderRegisterElement = registerCache.getFreeTextureReg();\n\t\tvar temp:ShaderRegisterElement = registerCache.getFreeFragmentVectorTemp();\n\t\tmethodVO.secondaryTexturesIndex = lightMapReg.index;\n\n\t\tcode = ShaderCompilerHelper.getTex2DSampleCode(temp, sharedRegisters, lightMapReg, this._lightMapTexture, shaderObject.useSmoothTextures, shaderObject.repeatTextures, shaderObject.useMipmapping, sharedRegisters.secondaryUVVarying);\n\n\t\tswitch (this._blendMode) {\n\t\t\tcase DiffuseLightMapMethod.MULTIPLY:\n\t\t\t\tcode += \"mul \" + this._pTotalLightColorReg + \", \" + this._pTotalLightColorReg + \", \" + temp + \"\\n\";\n\t\t\t\tbreak;\n\t\t\tcase DiffuseLightMapMethod.ADD:\n\t\t\t\tcode += \"add \" + this._pTotalLightColorReg + \", \" + this._pTotalLightColorReg + \", \" + temp + \"\\n\";\n\t\t\t\tbreak;\n\t\t}\n\n\t\tcode += super.iGetFragmentPostLightingCode(shaderObject, methodVO, targetReg, registerCache, sharedRegisters);\n\n\t\treturn code;\n\t}\n}\n\nexport = DiffuseLightMapMethod;","import Camera\t\t\t\t\t\t\t= require(\"awayjs-display/lib/entities/Camera\");\n\nimport Stage\t\t\t\t\t\t\t= require(\"awayjs-stagegl/lib/base/Stage\");\n\nimport ShaderLightingObject\t\t\t\t= require(\"awayjs-renderergl/lib/compilation/ShaderLightingObject\");\nimport ShaderObjectBase\t\t\t\t\t= require(\"awayjs-renderergl/lib/compilation/ShaderObjectBase\");\nimport ShaderRegisterCache\t\t\t\t= require(\"awayjs-renderergl/lib/compilation/ShaderRegisterCache\");\nimport ShaderRegisterData\t\t\t\t= require(\"awayjs-renderergl/lib/compilation/ShaderRegisterData\");\nimport ShaderRegisterElement\t\t\t= require(\"awayjs-renderergl/lib/compilation/ShaderRegisterElement\");\nimport MaterialPassGLBase\t\t\t\t= require(\"awayjs-renderergl/lib/passes/MaterialPassGLBase\");\nimport RenderableBase\t\t\t\t\t= require(\"awayjs-renderergl/lib/pool/RenderableBase\");\n\nimport MethodVO\t\t\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/data/MethodVO\");\nimport DiffuseBasicMethod\t\t\t\t= require(\"awayjs-methodmaterials/lib/methods/DiffuseBasicMethod\");\nimport DiffuseCompositeMethod\t\t\t= require(\"awayjs-methodmaterials/lib/methods/DiffuseCompositeMethod\");\nimport SingleObjectDepthPass\t\t\t= require(\"awayjs-methodmaterials/lib/passes/SingleObjectDepthPass\");\n\n/**\n * DiffuseSubSurfaceMethod provides a depth map-based diffuse shading method that mimics the scattering of\n * light inside translucent surfaces. It allows light to shine through an object and to soften the diffuse shading.\n * It can be used for candle wax, ice, skin, ...\n */\nclass DiffuseSubSurfaceMethod extends DiffuseCompositeMethod\n{\n\tprivate _depthPass:SingleObjectDepthPass;\n\tprivate _lightProjVarying:ShaderRegisterElement;\n\tprivate _propReg:ShaderRegisterElement;\n\tprivate _scattering:number;\n\tprivate _translucency:number = 1;\n\tprivate _lightColorReg:ShaderRegisterElement;\n\tprivate _scatterColor:number /*uint*/ = 0xffffff;\n\tprivate _colorReg:ShaderRegisterElement;\n\tprivate _decReg:ShaderRegisterElement;\n\tprivate _scatterR:number = 1.0;\n\tprivate _scatterG:number = 1.0;\n\tprivate _scatterB:number = 1.0;\n\tprivate _targetReg:ShaderRegisterElement;\n\t\n\t/**\n\t * Creates a new <code>DiffuseSubSurfaceMethod</code> object.\n\t *\n\t * @param depthMapSize The size of the depth map used.\n\t * @param depthMapOffset The amount by which the rendered object will be inflated, to prevent depth map rounding errors.\n\t * @param baseMethod The diffuse method used to calculate the regular diffuse-based lighting.\n\t */\n\tconstructor(depthMapSize:number /*int*/ = 512, depthMapOffset:number = 15, baseMethod:DiffuseBasicMethod = null)\n\t{\n\t\tsuper(null, baseMethod);\n\n\t\tthis.pBaseMethod._iModulateMethod = (shaderObject:ShaderObjectBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData) => this.scatterLight(shaderObject, methodVO, targetReg, registerCache, sharedRegisters);\n\n\t\t//this._passes = new Array<MaterialPassGLBase>();\n\t\tthis._depthPass = new SingleObjectDepthPass();\n\t\tthis._depthPass.textureSize = depthMapSize;\n\t\tthis._depthPass.polyOffset = depthMapOffset;\n\t\t//this._passes.push(this._depthPass);\n\t\tthis._scattering = 0.2;\n\t\tthis._translucency = 1;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitConstants(shaderObject:ShaderLightingObject, methodVO:MethodVO)\n\t{\n\t\tsuper.iInitConstants(shaderObject, methodVO);\n\n\t\tvar data:Array<number> = shaderObject.vertexConstantData;\n\t\tvar index:number /*int*/ = methodVO.secondaryVertexConstantsIndex;\n\t\tdata[index] = .5;\n\t\tdata[index + 1] = -.5;\n\t\tdata[index + 2] = 0;\n\t\tdata[index + 3] = 1;\n\t\t\n\t\tdata = shaderObject.fragmentConstantData;\n\t\tindex = methodVO.secondaryFragmentConstantsIndex;\n\t\tdata[index + 3] = 1.0;\n\t\tdata[index + 4] = 1.0;\n\t\tdata[index + 5] = 1/255;\n\t\tdata[index + 6] = 1/65025;\n\t\tdata[index + 7] = 1/16581375;\n\t\tdata[index + 10] = .5;\n\t\tdata[index + 11] = -.1;\n\t}\n\t\n\tpublic iCleanCompilationData()\n\t{\n\t\tsuper.iCleanCompilationData();\n\n\t\tthis._lightProjVarying = null;\n\t\tthis._propReg = null;\n\t\tthis._lightColorReg = null;\n\t\tthis._colorReg = null;\n\t\tthis._decReg = null;\n\t\tthis._targetReg = null;\n\t}\n\t\n\t/**\n\t * The amount by which the light scatters. It can be used to set the translucent surface's thickness. Use low\n\t * values for skin.\n\t */\n\tpublic get scattering():number\n\t{\n\t\treturn this._scattering;\n\t}\n\t\n\tpublic set scattering(value:number)\n\t{\n\t\tthis._scattering = value;\n\t}\n\t\n\t/**\n\t * The translucency of the object.\n\t */\n\tpublic get translucency():number\n\t{\n\t\treturn this._translucency;\n\t}\n\t\n\tpublic set translucency(value:number)\n\t{\n\t\tthis._translucency = value;\n\t}\n\t\n\t/**\n\t * The colour of the \"insides\" of the object, ie: the colour the light becomes after leaving the object.\n\t */\n\tpublic get scatterColor():number /*uint*/\n\t{\n\t\treturn this._scatterColor;\n\t}\n\t\n\tpublic set scatterColor(scatterColor:number /*uint*/)\n\t{\n\t\tthis._scatterColor = scatterColor;\n\t\tthis._scatterR = ((scatterColor >> 16) & 0xff)/0xff;\n\t\tthis._scatterG = ((scatterColor >> 8) & 0xff)/0xff;\n\t\tthis._scatterB = (scatterColor & 0xff)/0xff;\n\t}\n\t\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetVertexCode(shaderObject:ShaderObjectBase, methodVO:MethodVO, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = super.iGetVertexCode(shaderObject, methodVO, registerCache, sharedRegisters);\n\t\tvar lightProjection:ShaderRegisterElement;\n\t\tvar toTexRegister:ShaderRegisterElement;\n\t\tvar temp:ShaderRegisterElement = registerCache.getFreeVertexVectorTemp();\n\t\t\n\t\ttoTexRegister = registerCache.getFreeVertexConstant();\n\t\tmethodVO.secondaryVertexConstantsIndex = toTexRegister.index*4;\n\n\t\tthis._lightProjVarying = registerCache.getFreeVarying();\n\t\tlightProjection = registerCache.getFreeVertexConstant();\n\t\tregisterCache.getFreeVertexConstant();\n\t\tregisterCache.getFreeVertexConstant();\n\t\tregisterCache.getFreeVertexConstant();\n\t\t\n\t\tcode += \"m44 \" + temp + \", vt0, \" + lightProjection + \"\\n\" +\n\t\t\t\"div \" + temp + \".xyz, \" + temp + \".xyz, \" + temp + \".w\\n\" +\n\t\t\t\"mul \" + temp + \".xy, \" + temp + \".xy, \" + toTexRegister + \".xy\\n\" +\n\t\t\t\"add \" + temp + \".xy, \" + temp + \".xy, \" + toTexRegister + \".xx\\n\" +\n\t\t\t\"mov \" + this._lightProjVarying + \".xyz, \" + temp + \".xyz\\n\" +\n\t\t\t\"mov \" + this._lightProjVarying + \".w, va0.w\\n\";\n\t\t\n\t\treturn code;\n\t}\n\t\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentPreLightingCode(shaderObject:ShaderLightingObject, methodVO:MethodVO, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tthis._colorReg = registerCache.getFreeFragmentConstant();\n\t\tthis._decReg = registerCache.getFreeFragmentConstant();\n\t\tthis._propReg = registerCache.getFreeFragmentConstant();\n\t\tmethodVO.secondaryFragmentConstantsIndex = this._colorReg.index*4;\n\t\t\n\t\treturn super.iGetFragmentPreLightingCode(shaderObject, methodVO, registerCache, sharedRegisters);\n\t}\n\t\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentCodePerLight(shaderObject:ShaderLightingObject, methodVO:MethodVO, lightDirReg:ShaderRegisterElement, lightColReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tthis._pIsFirstLight = true;\n\t\tthis._lightColorReg = lightColReg;\n\t\treturn super.iGetFragmentCodePerLight(shaderObject, methodVO, lightDirReg, lightColReg, registerCache, sharedRegisters);\n\t}\n\t\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentPostLightingCode(shaderObject:ShaderLightingObject, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = super.iGetFragmentPostLightingCode(shaderObject, methodVO, targetReg, registerCache, sharedRegisters);\n\t\tvar temp:ShaderRegisterElement = registerCache.getFreeFragmentVectorTemp();\n\t\t\n\t\tcode += \"mul \" + temp + \".xyz, \" + this._lightColorReg + \".xyz, \" + this._targetReg + \".w\\n\" +\n\t\t\t\"mul \" + temp + \".xyz, \" + temp + \".xyz, \" + this._colorReg + \".xyz\\n\" +\n\t\t\t\"add \" + targetReg + \".xyz, \" + targetReg + \".xyz, \" + temp + \".xyz\\n\";\n\t\t\n\t\tif (this._targetReg != sharedRegisters.viewDirFragment)\n\t\t\tregisterCache.removeFragmentTempUsage(targetReg);\n\t\t\n\t\treturn code;\n\t}\n\t\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iActivate(shaderObject:ShaderLightingObject, methodVO:MethodVO, stage:Stage)\n\t{\n\t\tsuper.iActivate(shaderObject, methodVO, stage);\n\t\t\n\t\tvar index:number /*int*/ = methodVO.secondaryFragmentConstantsIndex;\n\t\tvar data:Array<number> = shaderObject.fragmentConstantData;\n\t\tdata[index] = this._scatterR;\n\t\tdata[index + 1] = this._scatterG;\n\t\tdata[index + 2] = this._scatterB;\n\t\tdata[index + 8] = this._scattering;\n\t\tdata[index + 9] = this._translucency;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iSetRenderState(shaderObject:ShaderObjectBase, methodVO:MethodVO, renderable:RenderableBase, stage:Stage, camera:Camera)\n\t{\n\t\tstage.activateTexture(methodVO.secondaryTexturesIndex, this._depthPass._iGetDepthMap(renderable));\n\n\t\tthis._depthPass._iGetProjection(renderable).copyRawDataTo(shaderObject.vertexConstantData, methodVO.secondaryVertexConstantsIndex + 4, true);\n\t}\n\t\n\t/**\n\t * Generates the code for this method\n\t */\n\tprivate scatterLight(shaderObject:ShaderObjectBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\t// only scatter first light\n\t\tif (!this._pIsFirstLight)\n\t\t\treturn \"\";\n\n\t\tthis._pIsFirstLight = false;\n\n\t\tvar code:string = \"\";\n\t\tvar depthReg:ShaderRegisterElement = registerCache.getFreeTextureReg();\n\n\t\tif (sharedRegisters.viewDirFragment) {\n\t\t\tthis._targetReg = sharedRegisters.viewDirFragment;\n\t\t} else {\n\t\t\tthis._targetReg = registerCache.getFreeFragmentVectorTemp();\n\t\t\tregisterCache.addFragmentTempUsages(this._targetReg, 1);\n\t\t}\n\n\t\tmethodVO.secondaryTexturesIndex = depthReg.index;\n\t\t\n\t\tvar temp:ShaderRegisterElement = registerCache.getFreeFragmentVectorTemp();\n\t\tcode += \"tex \" + temp + \", \" + this._lightProjVarying + \", \" + depthReg + \" <2d,nearest,clamp>\\n\" +\n\t\t\t// reencode RGBA\n\t\t\t\"dp4 \" + targetReg + \".z, \" + temp + \", \" + this._decReg + \"\\n\";\n\t\t// currentDistanceToLight - closestDistanceToLight\n\t\tcode += \"sub \" + targetReg + \".z, \" + this._lightProjVarying + \".z, \" + targetReg + \".z\\n\" +\n\t\t\t\n\t\t\t\"sub \" + targetReg + \".z, \" + this._propReg + \".x, \" + targetReg + \".z\\n\" +\n\t\t\t\"mul \" + targetReg + \".z, \" + this._propReg + \".y, \" + targetReg + \".z\\n\" +\n\t\t\t\"sat \" + targetReg + \".z, \" + targetReg + \".z\\n\" +\n\t\t\t\n\t\t\t// targetReg.x contains dot(lightDir, normal)\n\t\t\t// modulate according to incident light angle (scatter = scatter*(-.5*dot(light, normal) + .5)\n\t\t\t\"neg \" + targetReg + \".y, \" + targetReg + \".x\\n\" +\n\t\t\t\"mul \" + targetReg + \".y, \" + targetReg + \".y, \" + this._propReg + \".z\\n\" +\n\t\t\t\"add \" + targetReg + \".y, \" + targetReg + \".y, \" + this._propReg + \".z\\n\" +\n\t\t\t\"mul \" + this._targetReg + \".w, \" + targetReg + \".z, \" + targetReg + \".y\\n\" +\n\t\t\t\n\t\t\t// blend diffuse: d' = (1-s)*d + s*1\n\t\t\t\"sub \" + targetReg + \".y, \" + this._colorReg + \".w, \" + this._targetReg + \".w\\n\" +\n\t\t\t\"mul \" + targetReg + \".w, \" + targetReg + \".w, \" + targetReg + \".y\\n\";\n\t\t\n\t\treturn code;\n\t}\n}\n\nexport = DiffuseSubSurfaceMethod;","import Stage\t\t\t\t\t\t\t= require(\"awayjs-stagegl/lib/base/Stage\");\n\nimport ShaderLightingObject\t\t\t\t= require(\"awayjs-renderergl/lib/compilation/ShaderLightingObject\");\nimport ShaderRegisterCache\t\t\t\t= require(\"awayjs-renderergl/lib/compilation/ShaderRegisterCache\");\nimport ShaderRegisterData\t\t\t\t= require(\"awayjs-renderergl/lib/compilation/ShaderRegisterData\");\nimport ShaderRegisterElement\t\t\t= require(\"awayjs-renderergl/lib/compilation/ShaderRegisterElement\");\n\nimport MethodVO\t\t\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/data/MethodVO\");\nimport DiffuseBasicMethod\t\t\t\t= require(\"awayjs-methodmaterials/lib/methods/DiffuseBasicMethod\");\n\n/**\n * DiffuseWrapMethod is an alternative to DiffuseBasicMethod in which the light is allowed to be \"wrapped around\" the normally dark area, to some extent.\n * It can be used as a crude approximation to Oren-Nayar or simple subsurface scattering.\n */\nclass DiffuseWrapMethod extends DiffuseBasicMethod\n{\n\tprivate _wrapDataRegister:ShaderRegisterElement;\n\tprivate _wrapFactor:number;\n\n\t/**\n\t * Creates a new DiffuseWrapMethod object.\n\t * @param wrapFactor A factor to indicate the amount by which the light is allowed to wrap\n\t */\n\tconstructor(wrapFactor:number = .5)\n\t{\n\t\tsuper();\n\n\t\tthis.wrapFactor = wrapFactor;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iCleanCompilationData()\n\t{\n\t\tsuper.iCleanCompilationData();\n\n\t\tthis._wrapDataRegister = null;\n\t}\n\n\t/**\n\t * A factor to indicate the amount by which the light is allowed to wrap.\n\t */\n\tpublic get wrapFactor():number\n\t{\n\t\treturn this._wrapFactor;\n\t}\n\n\tpublic set wrapFactor(value:number)\n\t{\n\t\tthis._wrapFactor = value;\n\t\tthis._wrapFactor = 1/(value + 1);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentPreLightingCode(shaderObject:ShaderLightingObject, methodVO:MethodVO, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = super.iGetFragmentPreLightingCode(shaderObject, methodVO, registerCache, sharedRegisters);\n\t\tthis._pIsFirstLight = true;\n\t\tthis._wrapDataRegister = registerCache.getFreeFragmentConstant();\n\t\tmethodVO.secondaryFragmentConstantsIndex = this._wrapDataRegister.index*4;\n\n\t\treturn code;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentCodePerLight(shaderObject:ShaderLightingObject, methodVO:MethodVO, lightDirReg:ShaderRegisterElement, lightColReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = \"\";\n\t\tvar t:ShaderRegisterElement;\n\n\t\t// write in temporary if not first light, so we can add to total diffuse colour\n\t\tif (this._pIsFirstLight) {\n\t\t\tt = this._pTotalLightColorReg;\n\t\t} else {\n\t\t\tt = registerCache.getFreeFragmentVectorTemp();\n\t\t\tregisterCache.addFragmentTempUsages(t, 1);\n\t\t}\n\n\t\tcode += \"dp3 \" + t + \".x, \" + lightDirReg + \".xyz, \" + sharedRegisters.normalFragment + \".xyz\\n\" +\n\t\t\t\"add \" + t + \".y, \" + t + \".x, \" + this._wrapDataRegister + \".x\\n\" +\n\t\t\t\"mul \" + t + \".y, \" + t + \".y, \" + this._wrapDataRegister + \".y\\n\" +\n\t\t\t\"sat \" + t + \".w, \" + t + \".y\\n\" +\n\t\t\t\"mul \" + t + \".xz, \" + t + \".w, \" + lightDirReg + \".wz\\n\";\n\n\t\tif (this._iModulateMethod != null)\n\t\t\tcode += this._iModulateMethod(shaderObject, methodVO, lightDirReg, registerCache, sharedRegisters);\n\n\t\tcode += \"mul \" + t + \", \" + t + \".x, \" + lightColReg + \"\\n\";\n\n\t\tif (!this._pIsFirstLight) {\n\t\t\tcode += \"add \" + this._pTotalLightColorReg + \".xyz, \" + this._pTotalLightColorReg + \".xyz, \" + t + \".xyz\\n\";\n\t\t\tregisterCache.removeFragmentTempUsage(t);\n\t\t}\n\n\t\tthis._pIsFirstLight = false;\n\n\t\treturn code;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iActivate(shaderObject:ShaderLightingObject, methodVO:MethodVO, stage:Stage)\n\t{\n\t\tsuper.iActivate(shaderObject, methodVO, stage);\n\n\t\tvar index:number /*int*/ = methodVO.secondaryFragmentConstantsIndex;\n\t\tvar data:Array<number> = shaderObject.fragmentConstantData;\n\t\tdata[index] = this._wrapFactor;\n\t\tdata[index + 1] = 1/(this._wrapFactor + 1);\n\t}\n}\n\nexport = DiffuseWrapMethod;","import Texture2DBase\t\t\t\t\t= require(\"awayjs-core/lib/textures/Texture2DBase\");\n\nimport Stage\t\t\t\t\t\t\t= require(\"awayjs-stagegl/lib/base/Stage\");\n\nimport ShaderLightingObject\t\t\t\t= require(\"awayjs-renderergl/lib/compilation/ShaderLightingObject\");\nimport ShaderObjectBase\t\t\t\t\t= require(\"awayjs-renderergl/lib/compilation/ShaderObjectBase\");\nimport ShaderRegisterCache\t\t\t\t= require(\"awayjs-renderergl/lib/compilation/ShaderRegisterCache\");\nimport ShaderRegisterData\t\t\t\t= require(\"awayjs-renderergl/lib/compilation/ShaderRegisterData\");\nimport ShaderRegisterElement\t\t\t= require(\"awayjs-renderergl/lib/compilation/ShaderRegisterElement\");\nimport ShaderCompilerHelper\t\t\t\t= require(\"awayjs-renderergl/lib/utils/ShaderCompilerHelper\");\n\nimport MethodVO\t\t\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/data/MethodVO\");\nimport EffectMethodBase\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/methods/EffectMethodBase\");\n\n/**\n * EffectAlphaMaskMethod allows the use of an additional texture to specify the alpha value of the material. When used\n * with the secondary uv set, it allows for a tiled main texture with independently varying alpha (useful for water\n * etc).\n */\nclass EffectAlphaMaskMethod extends EffectMethodBase\n{\n\tprivate _texture:Texture2DBase;\n\tprivate _useSecondaryUV:boolean;\n\n\t/**\n\t * Creates a new EffectAlphaMaskMethod object.\n\t *\n\t * @param texture The texture to use as the alpha mask.\n\t * @param useSecondaryUV Indicated whether or not the secondary uv set for the mask. This allows mapping alpha independently.\n\t */\n\tconstructor(texture:Texture2DBase, useSecondaryUV:boolean = false)\n\t{\n\t\tsuper();\n\n\t\tthis._texture = texture;\n\t\tthis._useSecondaryUV = useSecondaryUV;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitVO(shaderObject:ShaderObjectBase, methodVO:MethodVO)\n\t{\n\t\tmethodVO.needsSecondaryUV = this._useSecondaryUV;\n\t\tmethodVO.needsUV = !this._useSecondaryUV;\n\t}\n\n\t/**\n\t * Indicated whether or not the secondary uv set for the mask. This allows mapping alpha independently, for\n\t * instance to tile the main texture and normal map while providing untiled alpha, for example to define the\n\t * transparency over a tiled water surface.\n\t */\n\tpublic get useSecondaryUV():boolean\n\t{\n\t\treturn this._useSecondaryUV;\n\t}\n\n\tpublic set useSecondaryUV(value:boolean)\n\t{\n\t\tif (this._useSecondaryUV == value)\n\t\t\treturn;\n\t\tthis._useSecondaryUV = value;\n\t\tthis.iInvalidateShaderProgram();\n\t}\n\n\t/**\n\t * The texture to use as the alpha mask.\n\t */\n\tpublic get texture():Texture2DBase\n\t{\n\t\treturn this._texture;\n\t}\n\n\tpublic set texture(value:Texture2DBase)\n\t{\n\t\tthis._texture = value;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iActivate(shaderObject:ShaderLightingObject, methodVO:MethodVO, stage:Stage)\n\t{\n\t\tstage.activateTexture(methodVO.texturesIndex, this._texture);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentCode(shaderObject:ShaderObjectBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar textureReg:ShaderRegisterElement = registerCache.getFreeTextureReg();\n\t\tvar temp:ShaderRegisterElement = registerCache.getFreeFragmentVectorTemp();\n\t\tvar uvReg:ShaderRegisterElement = this._useSecondaryUV? sharedRegisters.secondaryUVVarying : sharedRegisters.uvVarying;\n\t\tmethodVO.texturesIndex = textureReg.index;\n\n\t\treturn ShaderCompilerHelper.getTex2DSampleCode(temp, sharedRegisters, textureReg, this._texture, shaderObject.useSmoothTextures, shaderObject.repeatTextures, shaderObject.useMipmapping, uvReg) +\n\t\t\t\"mul \" + targetReg + \", \" + targetReg + \", \" + temp + \".x\\n\";\n\t}\n}\n\nexport = EffectAlphaMaskMethod;","import Stage\t\t\t\t\t\t\t= require(\"awayjs-stagegl/lib/base/Stage\");\n\nimport ShaderObjectBase\t\t\t\t\t= require(\"awayjs-renderergl/lib/compilation/ShaderObjectBase\");\nimport ShaderRegisterCache\t\t\t\t= require(\"awayjs-renderergl/lib/compilation/ShaderRegisterCache\");\nimport ShaderRegisterData\t\t\t\t= require(\"awayjs-renderergl/lib/compilation/ShaderRegisterData\");\nimport ShaderRegisterElement\t\t\t= require(\"awayjs-renderergl/lib/compilation/ShaderRegisterElement\");\n\nimport MethodVO\t\t\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/data/MethodVO\");\nimport EffectMethodBase\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/methods/EffectMethodBase\");\n\n/**\n * EffectColorMatrixMethod provides a shading method that changes the colour of a material analogous to a ColorMatrixFilter.\n */\nclass EffectColorMatrixMethod extends EffectMethodBase\n{\n\tprivate _matrix:Array<number>;\n\n\t/**\n\t * Creates a new EffectColorTransformMethod.\n\t *\n\t * @param matrix An array of 20 items for 4 x 5 color transform.\n\t */\n\tconstructor(matrix:Array<number>)\n\t{\n\t\tsuper();\n\n\t\tif (matrix.length != 20)\n\t\t\tthrow new Error(\"Matrix length must be 20!\");\n\n\t\tthis._matrix = matrix;\n\t}\n\n\t/**\n\t * The 4 x 5 matrix to transform the color of the material.\n\t */\n\tpublic get colorMatrix():Array<number>\n\t{\n\t\treturn this._matrix;\n\t}\n\n\tpublic set colorMatrix(value:Array<number>)\n\t{\n\t\tthis._matrix = value;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentCode(shaderObject:ShaderObjectBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = \"\";\n\t\tvar colorMultReg:ShaderRegisterElement = registerCache.getFreeFragmentConstant();\n\t\tregisterCache.getFreeFragmentConstant();\n\t\tregisterCache.getFreeFragmentConstant();\n\t\tregisterCache.getFreeFragmentConstant();\n\n\t\tvar colorOffsetReg:ShaderRegisterElement = registerCache.getFreeFragmentConstant();\n\n\t\tmethodVO.fragmentConstantsIndex = colorMultReg.index*4;\n\n\t\tvar temp:ShaderRegisterElement = registerCache.getFreeFragmentVectorTemp();\n\n\t\tcode += \"m44 \" + temp + \", \" + targetReg + \", \" + colorMultReg + \"\\n\" +\n\t\t\t\t\"add \" + targetReg + \", \" + temp + \", \" + colorOffsetReg + \"\\n\";\n\n\t\treturn code;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iActivate(shaderObject:ShaderObjectBase, methodVO:MethodVO, stage:Stage)\n\t{\n\t\tvar matrix:Array<number> = this._matrix;\n\t\tvar index:number /*int*/ = methodVO.fragmentConstantsIndex;\n\t\tvar data:Array<number> = shaderObject.fragmentConstantData;\n\n\t\t// r\n\t\tdata[index] = matrix[0];\n\t\tdata[index + 1] = matrix[1];\n\t\tdata[index + 2] = matrix[2];\n\t\tdata[index + 3] = matrix[3];\n\n\t\t// g\n\t\tdata[index + 4] = matrix[5];\n\t\tdata[index + 5] = matrix[6];\n\t\tdata[index + 6] = matrix[7];\n\t\tdata[index + 7] = matrix[8];\n\n\t\t// b\n\t\tdata[index + 8] = matrix[10];\n\t\tdata[index + 9] = matrix[11];\n\t\tdata[index + 10] = matrix[12];\n\t\tdata[index + 11] = matrix[13];\n\n\t\t// a\n\t\tdata[index + 12] = matrix[15];\n\t\tdata[index + 13] = matrix[16];\n\t\tdata[index + 14] = matrix[17];\n\t\tdata[index + 15] = matrix[18];\n\n\t\t// rgba offset\n\t\tdata[index + 16] = matrix[4];\n\t\tdata[index + 17] = matrix[9];\n\t\tdata[index + 18] = matrix[14];\n\t\tdata[index + 19] = matrix[19];\n\t}\n}\n\nexport = EffectColorMatrixMethod;","import ColorTransform\t\t\t\t= require(\"awayjs-core/lib/geom/ColorTransform\");\n\nimport Stage\t\t\t\t\t\t= require(\"awayjs-stagegl/lib/base/Stage\");\n\nimport ShaderObjectBase\t\t\t\t= require(\"awayjs-renderergl/lib/compilation/ShaderObjectBase\");\nimport ShaderRegisterCache\t\t\t= require(\"awayjs-renderergl/lib/compilation/ShaderRegisterCache\");\nimport ShaderRegisterData\t\t\t= require(\"awayjs-renderergl/lib/compilation/ShaderRegisterData\");\nimport ShaderRegisterElement\t\t= require(\"awayjs-renderergl/lib/compilation/ShaderRegisterElement\");\n\nimport MethodVO\t\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/data/MethodVO\");\nimport EffectMethodBase\t\t\t\t= require(\"awayjs-methodmaterials/lib/methods/EffectMethodBase\");\n\n/**\n * EffectColorTransformMethod provides a shading method that changes the colour of a material analogous to a\n * ColorTransform object.\n */\nclass EffectColorTransformMethod extends EffectMethodBase\n{\n\tprivate _colorTransform:ColorTransform;\n\n\t/**\n\t * Creates a new EffectColorTransformMethod.\n\t */\n\tconstructor()\n\t{\n\t\tsuper();\n\t}\n\n\t/**\n\t * The ColorTransform object to transform the colour of the material with.\n\t */\n\tpublic get colorTransform():ColorTransform\n\t{\n\t\treturn this._colorTransform;\n\t}\n\n\tpublic set colorTransform(value:ColorTransform)\n\t{\n\t\tthis._colorTransform = value;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentCode(shaderObject:ShaderObjectBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = \"\";\n\t\tvar colorMultReg:ShaderRegisterElement = registerCache.getFreeFragmentConstant();\n\t\tvar colorOffsReg:ShaderRegisterElement = registerCache.getFreeFragmentConstant();\n\n\t\tmethodVO.fragmentConstantsIndex = colorMultReg.index*4;\n\n\t\t//TODO: AGAL <> GLSL\n\n\t\tcode += \"mul \" + targetReg + \", \" + targetReg + \", \" + colorMultReg + \"\\n\" + \"add \" + targetReg + \", \" + targetReg + \", \" + colorOffsReg + \"\\n\";\n\n\t\treturn code;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iActivate(shaderObject:ShaderObjectBase, methodVO:MethodVO, stage:Stage)\n\t{\n\t\tvar inv:number = 1/0xff;\n\t\tvar index:number = methodVO.fragmentConstantsIndex;\n\t\tvar data:Array<number> = shaderObject.fragmentConstantData;\n\n\t\tdata[index] = this._colorTransform.redMultiplier;\n\t\tdata[index + 1] = this._colorTransform.greenMultiplier;\n\t\tdata[index + 2] = this._colorTransform.blueMultiplier;\n\t\tdata[index + 3] = this._colorTransform.alphaMultiplier;\n\t\tdata[index + 4] = this._colorTransform.redOffset*inv;\n\t\tdata[index + 5] = this._colorTransform.greenOffset*inv;\n\t\tdata[index + 6] = this._colorTransform.blueOffset*inv;\n\t\tdata[index + 7] = this._colorTransform.alphaOffset*inv;\n\n\t}\n}\n\nexport = EffectColorTransformMethod;","import CubeTextureBase\t\t\t\t\t= require(\"awayjs-core/lib/textures/CubeTextureBase\");\nimport Texture2DBase\t\t\t\t\t= require(\"awayjs-core/lib/textures/Texture2DBase\");\n\nimport Stage\t\t\t\t\t\t\t= require(\"awayjs-stagegl/lib/base/Stage\");\n\nimport ShaderObjectBase\t\t\t\t\t= require(\"awayjs-renderergl/lib/compilation/ShaderObjectBase\");\nimport ShaderRegisterCache\t\t\t\t= require(\"awayjs-renderergl/lib/compilation/ShaderRegisterCache\");\nimport ShaderRegisterData\t\t\t\t= require(\"awayjs-renderergl/lib/compilation/ShaderRegisterData\");\nimport ShaderRegisterElement\t\t\t= require(\"awayjs-renderergl/lib/compilation/ShaderRegisterElement\");\nimport ShaderCompilerHelper\t\t\t\t= require(\"awayjs-renderergl/lib/utils/ShaderCompilerHelper\");\n\nimport MethodVO\t\t\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/data/MethodVO\");\nimport EffectMethodBase\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/methods/EffectMethodBase\");\n\n/**\n * EffectEnvMapMethod provides a material method to perform reflection mapping using cube maps.\n */\nclass EffectEnvMapMethod extends EffectMethodBase\n{\n\tprivate _cubeTexture:CubeTextureBase;\n\tprivate _alpha:number;\n\tprivate _mask:Texture2DBase;\n\n\t/**\n\t * Creates an EffectEnvMapMethod object.\n\t * @param envMap The environment map containing the reflected scene.\n\t * @param alpha The reflectivity of the surface.\n\t */\n\tconstructor(envMap:CubeTextureBase, alpha:number = 1)\n\t{\n\t\tsuper();\n\t\tthis._cubeTexture = envMap;\n\t\tthis._alpha = alpha;\n\n\t}\n\n\t/**\n\t * An optional texture to modulate the reflectivity of the surface.\n\t */\n\tpublic get mask():Texture2DBase\n\t{\n\t\treturn this._mask;\n\t}\n\n\tpublic set mask(value:Texture2DBase)\n\t{\n\t\tif (value != this._mask || (value && this._mask && (value.hasMipmaps != this._mask.hasMipmaps || value.format != this._mask.format)))\n\t\t\tthis.iInvalidateShaderProgram();\n\n\t\tthis._mask = value;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitVO(shaderObject:ShaderObjectBase, methodVO:MethodVO)\n\t{\n\t\tmethodVO.needsNormals = true;\n\t\tmethodVO.needsView = true;\n\t\tmethodVO.needsUV = this._mask != null;\n\t}\n\n\t/**\n\t * The cubic environment map containing the reflected scene.\n\t */\n\tpublic get envMap():CubeTextureBase\n\t{\n\t\treturn this._cubeTexture;\n\t}\n\n\tpublic set envMap(value:CubeTextureBase)\n\t{\n\t\tthis._cubeTexture = value;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic dispose()\n\t{\n\t}\n\n\t/**\n\t * The reflectivity of the surface.\n\t */\n\tpublic get alpha():number\n\t{\n\t\treturn this._alpha;\n\t}\n\n\tpublic set alpha(value:number)\n\t{\n\t\tthis._alpha = value;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iActivate(shaderObject:ShaderObjectBase, methodVO:MethodVO, stage:Stage)\n\t{\n\t\tshaderObject.fragmentConstantData[methodVO.fragmentConstantsIndex] = this._alpha;\n\n\t\tstage.activateCubeTexture(methodVO.texturesIndex, this._cubeTexture);\n\t\tif (this._mask)\n\t\t\tstage.activateTexture(methodVO.texturesIndex + 1, this._mask);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentCode(shaderObject:ShaderObjectBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar dataRegister:ShaderRegisterElement = registerCache.getFreeFragmentConstant();\n\t\tvar temp:ShaderRegisterElement = registerCache.getFreeFragmentVectorTemp();\n\t\tvar code:string = \"\";\n\t\tvar cubeMapReg:ShaderRegisterElement = registerCache.getFreeTextureReg();\n\n\t\tmethodVO.texturesIndex = cubeMapReg.index;\n\t\tmethodVO.fragmentConstantsIndex = dataRegister.index*4;\n\n\t\tregisterCache.addFragmentTempUsages(temp, 1);\n\t\tvar temp2:ShaderRegisterElement = registerCache.getFreeFragmentVectorTemp();\n\n\t\t// r = I - 2(I.N)*N\n\t\tcode += \"dp3 \" + temp + \".w, \" + sharedRegisters.viewDirFragment + \".xyz, \" + sharedRegisters.normalFragment + \".xyz\\n\" +\n\t\t\t\t\"add \" + temp + \".w, \" + temp + \".w, \" + temp + \".w\\n\" +\n\t\t\t\t\"mul \" + temp + \".xyz, \" + sharedRegisters.normalFragment + \".xyz, \" + temp + \".w\\n\" +\n\t\t\t\t\"sub \" + temp + \".xyz, \" + temp + \".xyz, \" + sharedRegisters.viewDirFragment + \".xyz\\n\" +\n\t\t\tShaderCompilerHelper.getTexCubeSampleCode(temp, cubeMapReg, this._cubeTexture, shaderObject.useSmoothTextures, shaderObject.useMipmapping, temp) +\n\t\t\t\t\"sub \" + temp2 + \".w, \" + temp + \".w, fc0.x\\n\" + // -.5\n\t\t\t\t\"kil \" + temp2 + \".w\\n\" +\t// used for real time reflection mapping - if alpha is not 1 (mock texture) kil output\n\t\t\t\t\"sub \" + temp + \", \" + temp + \", \" + targetReg + \"\\n\";\n\n\t\tif (this._mask)\n\t\t\tcode += ShaderCompilerHelper.getTex2DSampleCode(temp2, sharedRegisters, registerCache.getFreeTextureReg(), this._mask, shaderObject.useSmoothTextures, shaderObject.repeatTextures, shaderObject.useMipmapping) +\n\t\t\t\t\"mul \" + temp + \", \" + temp2 + \", \" + temp + \"\\n\";\n\n\t\tcode += \"mul \" + temp + \", \" + temp + \", \" + dataRegister + \".x\\n\" +\n\t\t\t\t\"add \" + targetReg + \", \" + targetReg + \", \" + temp + \"\\n\";\n\n\t\tregisterCache.removeFragmentTempUsage(temp);\n\n\t\treturn code;\n\t}\n}\n\nexport = EffectEnvMapMethod;","import Stage\t\t\t\t\t\t\t= require(\"awayjs-stagegl/lib/base/Stage\");\n\nimport ShaderLightingObject\t\t\t\t= require(\"awayjs-renderergl/lib/compilation/ShaderLightingObject\");\nimport ShaderObjectBase\t\t\t\t\t= require(\"awayjs-renderergl/lib/compilation/ShaderObjectBase\");\nimport ShaderRegisterCache\t\t\t\t= require(\"awayjs-renderergl/lib/compilation/ShaderRegisterCache\");\nimport ShaderRegisterData\t\t\t\t= require(\"awayjs-renderergl/lib/compilation/ShaderRegisterData\");\nimport ShaderRegisterElement\t\t\t= require(\"awayjs-renderergl/lib/compilation/ShaderRegisterElement\");\n\nimport MethodVO\t\t\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/data/MethodVO\");\nimport EffectMethodBase\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/methods/EffectMethodBase\");\n\n/**\n * EffectFogMethod provides a method to add distance-based fog to a material.\n */\nclass EffectFogMethod extends EffectMethodBase\n{\n\tprivate _minDistance:number = 0;\n\tprivate _maxDistance:number = 1000;\n\tprivate _fogColor:number /*uint*/;\n\tprivate _fogR:number;\n\tprivate _fogG:number;\n\tprivate _fogB:number;\n\n\t/**\n\t * Creates a new EffectFogMethod object.\n\t * @param minDistance The distance from which the fog starts appearing.\n\t * @param maxDistance The distance at which the fog is densest.\n\t * @param fogColor The colour of the fog.\n\t */\n\tconstructor(minDistance:number, maxDistance:number, fogColor:number /*uint*/ = 0x808080)\n\t{\n\t\tsuper();\n\t\tthis.minDistance = minDistance;\n\t\tthis.maxDistance = maxDistance;\n\t\tthis.fogColor = fogColor;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitVO(shaderObject:ShaderLightingObject, methodVO:MethodVO)\n\t{\n\t\tmethodVO.needsProjection = true;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitConstants(shaderObject:ShaderObjectBase, methodVO:MethodVO)\n\t{\n\t\tvar data:Array<number> = shaderObject.fragmentConstantData;\n\t\tvar index:number /*int*/ = methodVO.fragmentConstantsIndex;\n\t\tdata[index + 3] = 1;\n\t\tdata[index + 6] = 0;\n\t\tdata[index + 7] = 0;\n\t}\n\n\t/**\n\t * The distance from which the fog starts appearing.\n\t */\n\tpublic get minDistance():number\n\t{\n\t\treturn this._minDistance;\n\t}\n\n\tpublic set minDistance(value:number)\n\t{\n\t\tthis._minDistance = value;\n\t}\n\n\t/**\n\t * The distance at which the fog is densest.\n\t */\n\tpublic get maxDistance():number\n\t{\n\t\treturn this._maxDistance;\n\t}\n\n\tpublic set maxDistance(value:number)\n\t{\n\t\tthis._maxDistance = value;\n\t}\n\n\t/**\n\t * The colour of the fog.\n\t */\n\tpublic get fogColor():number /*uint*/\n\t{\n\t\treturn this._fogColor;\n\t}\n\n\tpublic set fogColor(value:number/*uint*/)\n\t{\n\t\tthis._fogColor = value;\n\t\tthis._fogR = ((value >> 16) & 0xff)/0xff;\n\t\tthis._fogG = ((value >> 8) & 0xff)/0xff;\n\t\tthis._fogB = (value & 0xff)/0xff;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iActivate(shaderObject:ShaderObjectBase, methodVO:MethodVO, stage:Stage)\n\t{\n\t\tvar data:Array<number> = shaderObject.fragmentConstantData;\n\t\tvar index:number /*int*/ = methodVO.fragmentConstantsIndex;\n\t\tdata[index] = this._fogR;\n\t\tdata[index + 1] = this._fogG;\n\t\tdata[index + 2] = this._fogB;\n\t\tdata[index + 4] = this._minDistance;\n\t\tdata[index + 5] = 1/(this._maxDistance - this._minDistance);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentCode(shaderObject:ShaderObjectBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar fogColor:ShaderRegisterElement = registerCache.getFreeFragmentConstant();\n\t\tvar fogData:ShaderRegisterElement = registerCache.getFreeFragmentConstant();\n\t\tvar temp:ShaderRegisterElement = registerCache.getFreeFragmentVectorTemp();\n\t\tregisterCache.addFragmentTempUsages(temp, 1);\n\t\tvar temp2:ShaderRegisterElement = registerCache.getFreeFragmentVectorTemp();\n\t\tvar code:string = \"\";\n\t\tmethodVO.fragmentConstantsIndex = fogColor.index*4;\n\n\t\tcode += \"sub \" + temp2 + \".w, \" + sharedRegisters.projectionFragment + \".z, \" + fogData + \".x\\n\" +\n\t\t\t\t\"mul \" + temp2 + \".w, \" + temp2 + \".w, \" + fogData + \".y\\n\" +\n\t\t\t\t\"sat \" + temp2 + \".w, \" + temp2 + \".w\\n\" +\n\t\t\t\t\"sub \" + temp + \", \" + fogColor + \", \" + targetReg + \"\\n\" + // (fogColor- col)\n\t\t\t\t\"mul \" + temp + \", \" + temp + \", \" + temp2 + \".w\\n\" + // (fogColor- col)*fogRatio\n\t\t\t\t\"add \" + targetReg + \", \" + targetReg + \", \" + temp + \"\\n\"; // fogRatio*(fogColor- col) + col\n\n\t\tregisterCache.removeFragmentTempUsage(temp);\n\n\t\treturn code;\n\t}\n}\n\nexport = EffectFogMethod;","import CubeTextureBase\t\t\t\t\t= require(\"awayjs-core/lib/textures/CubeTextureBase\");\nimport Texture2DBase\t\t\t\t\t= require(\"awayjs-core/lib/textures/Texture2DBase\");\n\nimport Stage\t\t\t\t\t\t\t= require(\"awayjs-stagegl/lib/base/Stage\");\n\nimport ShaderObjectBase\t\t\t\t\t= require(\"awayjs-renderergl/lib/compilation/ShaderObjectBase\");\nimport ShaderRegisterCache\t\t\t\t= require(\"awayjs-renderergl/lib/compilation/ShaderRegisterCache\");\nimport ShaderRegisterData\t\t\t\t= require(\"awayjs-renderergl/lib/compilation/ShaderRegisterData\");\nimport ShaderRegisterElement\t\t\t= require(\"awayjs-renderergl/lib/compilation/ShaderRegisterElement\");\nimport ShaderCompilerHelper\t\t\t\t= require(\"awayjs-renderergl/lib/utils/ShaderCompilerHelper\");\n\nimport MethodVO\t\t\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/data/MethodVO\");\nimport EffectMethodBase\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/methods/EffectMethodBase\");\n\n/**\n * EffectFresnelEnvMapMethod provides a method to add fresnel-based reflectivity to an object using cube maps, which gets\n * stronger as the viewing angle becomes more grazing.\n */\nclass EffectFresnelEnvMapMethod extends EffectMethodBase\n{\n\tprivate _cubeTexture:CubeTextureBase;\n\tprivate _fresnelPower:number = 5;\n\tprivate _normalReflectance:number = 0;\n\tprivate _alpha:number;\n\tprivate _mask:Texture2DBase;\n\n\t/**\n\t * Creates a new <code>EffectFresnelEnvMapMethod</code> object.\n\t *\n\t * @param envMap The environment map containing the reflected scene.\n\t * @param alpha The reflectivity of the material.\n\t */\n\tconstructor(envMap:CubeTextureBase, alpha:number = 1)\n\t{\n\t\tsuper();\n\n\t\tthis._cubeTexture = envMap;\n\t\tthis._alpha = alpha;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitVO(shaderObject:ShaderObjectBase, methodVO:MethodVO)\n\t{\n\t\tmethodVO.needsNormals = true;\n\t\tmethodVO.needsView = true;\n\t\tmethodVO.needsUV = this._mask != null;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitConstants(shaderObject:ShaderObjectBase, methodVO:MethodVO)\n\t{\n\t\tshaderObject.fragmentConstantData[methodVO.fragmentConstantsIndex + 3] = 1;\n\t}\n\n\t/**\n\t * An optional texture to modulate the reflectivity of the surface.\n\t */\n\tpublic get mask():Texture2DBase\n\t{\n\t\treturn this._mask;\n\t}\n\n\tpublic set mask(value:Texture2DBase)\n\t{\n\t\tif (Boolean(value) != Boolean(this._mask) ||\n\t\t\t(value && this._mask && (value.hasMipmaps != this._mask.hasMipmaps || value.format != this._mask.format))) {\n\t\t\tthis.iInvalidateShaderProgram();\n\t\t}\n\t\tthis._mask = value;\n\t}\n\n\t/**\n\t * The power used in the Fresnel equation. Higher values make the fresnel effect more pronounced. Defaults to 5.\n\t */\n\tpublic get fresnelPower():number\n\t{\n\t\treturn this._fresnelPower;\n\t}\n\n\tpublic set fresnelPower(value:number)\n\t{\n\t\tthis._fresnelPower = value;\n\t}\n\n\t/**\n\t * The cubic environment map containing the reflected scene.\n\t */\n\tpublic get envMap():CubeTextureBase\n\t{\n\t\treturn this._cubeTexture;\n\t}\n\n\tpublic set envMap(value:CubeTextureBase)\n\t{\n\t\tthis._cubeTexture = value;\n\t}\n\n\t/**\n\t * The reflectivity of the surface.\n\t */\n\tpublic get alpha():number\n\t{\n\t\treturn this._alpha;\n\t}\n\n\tpublic set alpha(value:number)\n\t{\n\t\tthis._alpha = value;\n\t}\n\n\t/**\n\t * The minimum amount of reflectance, ie the reflectance when the view direction is normal to the surface or light direction.\n\t */\n\tpublic get normalReflectance():number\n\t{\n\t\treturn this._normalReflectance;\n\t}\n\n\tpublic set normalReflectance(value:number)\n\t{\n\t\tthis._normalReflectance = value;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iActivate(shaderObject:ShaderObjectBase, methodVO:MethodVO, stage:Stage)\n\t{\n\t\tvar data:Array<number> = shaderObject.fragmentConstantData;\n\t\tvar index:number /*int*/ = methodVO.fragmentConstantsIndex;\n\t\tdata[index] = this._alpha;\n\t\tdata[index + 1] = this._normalReflectance;\n\t\tdata[index + 2] = this._fresnelPower;\n\n\t\tstage.activateCubeTexture(methodVO.texturesIndex, this._cubeTexture);\n\n\t\tif (this._mask)\n\t\t\tstage.activateTexture(methodVO.texturesIndex + 1, this._mask);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentCode(shaderObject:ShaderObjectBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar dataRegister:ShaderRegisterElement = registerCache.getFreeFragmentConstant();\n\t\tvar temp:ShaderRegisterElement = registerCache.getFreeFragmentVectorTemp();\n\t\tvar code:string = \"\";\n\t\tvar cubeMapReg:ShaderRegisterElement = registerCache.getFreeTextureReg();\n\t\tvar viewDirReg:ShaderRegisterElement = sharedRegisters.viewDirFragment;\n\t\tvar normalReg:ShaderRegisterElement = sharedRegisters.normalFragment;\n\n\t\tmethodVO.texturesIndex = cubeMapReg.index;\n\t\tmethodVO.fragmentConstantsIndex = dataRegister.index*4;\n\n\t\tregisterCache.addFragmentTempUsages(temp, 1);\n\t\tvar temp2:ShaderRegisterElement = registerCache.getFreeFragmentVectorTemp();\n\n\t\t// r = V - 2(V.N)*N\n\t\tcode += \"dp3 \" + temp + \".w, \" + viewDirReg + \".xyz, \" + normalReg + \".xyz\\n\" +\n\t\t\t\t\"add \" + temp + \".w, \" + temp + \".w, \" + temp + \".w\\n\" +\n\t\t\t\t\"mul \" + temp + \".xyz, \" + normalReg + \".xyz, \" + temp + \".w\\n\" +\n\t\t\t\t\"sub \" + temp + \".xyz, \" + temp + \".xyz, \" + viewDirReg + \".xyz\\n\" +\n\t\t\tShaderCompilerHelper.getTexCubeSampleCode(temp, cubeMapReg, this._cubeTexture, shaderObject.useSmoothTextures, shaderObject.useMipmapping, temp) +\n\t\t\t\t\"sub \" + temp2 + \".w, \" + temp + \".w, fc0.x\\n\" +               \t// -.5\n\t\t\t\t\"kil \" + temp2 + \".w\\n\" +\t// used for real time reflection mapping - if alpha is not 1 (mock texture) kil output\n\t\t\t\t\"sub \" + temp + \", \" + temp + \", \" + targetReg + \"\\n\";\n\n\t\t// calculate fresnel term\n\t\tcode += \"dp3 \" + viewDirReg + \".w, \" + viewDirReg + \".xyz, \" + normalReg + \".xyz\\n\" +  // dot(V, H)\n\t\t\t\t\"sub \" + viewDirReg + \".w, \" + dataRegister + \".w, \" + viewDirReg + \".w\\n\" +       // base = 1-dot(V, H)\n\t\t\t\t\"pow \" + viewDirReg + \".w, \" + viewDirReg + \".w, \" + dataRegister + \".z\\n\" +       // exp = pow(base, 5)\n\t\t\t\t\"sub \" + normalReg + \".w, \" + dataRegister + \".w, \" + viewDirReg + \".w\\n\" +        // 1 - exp\n\t\t\t\t\"mul \" + normalReg + \".w, \" + dataRegister + \".y, \" + normalReg + \".w\\n\" +         // f0*(1 - exp)\n\t\t\t\t\"add \" + viewDirReg + \".w, \" + viewDirReg + \".w, \" + normalReg + \".w\\n\" +          // exp + f0*(1 - exp)\n\n\t\t\t\t// total alpha\n\t\t\t\t\"mul \" + viewDirReg + \".w, \" + dataRegister + \".x, \" + viewDirReg + \".w\\n\";\n\n\t\tif (this._mask) {\n\t\t\tvar maskReg:ShaderRegisterElement = registerCache.getFreeTextureReg();\n\t\t\tcode += ShaderCompilerHelper.getTex2DSampleCode(temp2, sharedRegisters, maskReg, this._mask, shaderObject.useSmoothTextures, shaderObject.repeatTextures, shaderObject.useMipmapping) +\n\t\t\t\t\"mul \" + viewDirReg + \".w, \" + temp2 + \".x, \" + viewDirReg + \".w\\n\";\n\t\t}\n\n\t\t// blend\n\t\tcode += \"mul \" + temp + \", \" + temp + \", \" + viewDirReg + \".w\\n\" +\n\t\t\t\t\"add \" + targetReg + \", \" + targetReg + \", \" + temp + \"\\n\";\n\n\t\tregisterCache.removeFragmentTempUsage(temp);\n\n\t\treturn code;\n\t}\n}\n\nexport = EffectFresnelEnvMapMethod;","import Texture2DBase\t\t\t\t\t= require(\"awayjs-core/lib/textures/Texture2DBase\");\n\nimport Stage\t\t\t\t\t\t\t= require(\"awayjs-stagegl/lib/base/Stage\");\n\nimport ShaderObjectBase\t\t\t\t\t= require(\"awayjs-renderergl/lib/compilation/ShaderObjectBase\");\nimport ShaderRegisterCache\t\t\t\t= require(\"awayjs-renderergl/lib/compilation/ShaderRegisterCache\");\nimport ShaderRegisterData\t\t\t\t= require(\"awayjs-renderergl/lib/compilation/ShaderRegisterData\");\nimport ShaderRegisterElement\t\t\t= require(\"awayjs-renderergl/lib/compilation/ShaderRegisterElement\");\nimport ShaderCompilerHelper\t\t\t\t= require(\"awayjs-renderergl/lib/utils/ShaderCompilerHelper\");\n\nimport MethodVO\t\t\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/data/MethodVO\");\nimport EffectMethodBase\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/methods/EffectMethodBase\");\n\n/**\n * EffectLightMapMethod provides a method that allows applying a light map texture to the calculated pixel colour.\n * It is different from DiffuseLightMapMethod in that the latter only modulates the diffuse shading value rather\n * than the whole pixel colour.\n */\nclass EffectLightMapMethod extends EffectMethodBase\n{\n\t/**\n\t * Indicates the light map should be multiplied with the calculated shading result.\n\t */\n\tpublic static MULTIPLY:string = \"multiply\";\n\n\t/**\n\t * Indicates the light map should be added into the calculated shading result.\n\t */\n\tpublic static ADD:string = \"add\";\n\n\tprivate _texture:Texture2DBase;\n\n\tprivate _blendMode:string;\n\tprivate _useSecondaryUV:boolean;\n\n\t/**\n\t * Creates a new EffectLightMapMethod object.\n\t *\n\t * @param texture The texture containing the light map.\n\t * @param blendMode The blend mode with which the light map should be applied to the lighting result.\n\t * @param useSecondaryUV Indicates whether the secondary UV set should be used to map the light map.\n\t */\n\tconstructor(texture:Texture2DBase, blendMode:string = \"multiply\", useSecondaryUV:boolean = false)\n\t{\n\t\tsuper();\n\n\t\tthis._useSecondaryUV = useSecondaryUV;\n\t\tthis._texture = texture;\n\t\tthis.blendMode = blendMode;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitVO(shaderObject:ShaderObjectBase, methodVO:MethodVO)\n\t{\n\t\tmethodVO.needsUV = !this._useSecondaryUV;\n\t\tmethodVO.needsSecondaryUV = this._useSecondaryUV;\n\t}\n\n\t/**\n\t * The blend mode with which the light map should be applied to the lighting result.\n\t *\n\t * @see EffectLightMapMethod.ADD\n\t * @see EffectLightMapMethod.MULTIPLY\n\t */\n\tpublic get blendMode():string\n\t{\n\t\treturn this._blendMode;\n\t}\n\n\tpublic set blendMode(value:string)\n\t{\n\t\tif (value != EffectLightMapMethod.ADD && value != EffectLightMapMethod.MULTIPLY)\n\t\t\tthrow new Error(\"Unknown blendmode!\");\n\t\tif (this._blendMode == value)\n\t\t\treturn;\n\n\t\tthis._blendMode = value;\n\n\t\tthis.iInvalidateShaderProgram();\n\t}\n\n\t/**\n\t * The texture containing the light map.\n\t */\n\tpublic get texture():Texture2DBase\n\t{\n\t\treturn this._texture;\n\t}\n\n\tpublic set texture(value:Texture2DBase)\n\t{\n\t\tif (value.hasMipmaps != this._texture.hasMipmaps || value.format != this._texture.format)\n\t\t\tthis.iInvalidateShaderProgram();\n\n\t\tthis._texture = value;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iActivate(shaderObject:ShaderObjectBase, methodVO:MethodVO, stage:Stage)\n\t{\n\t\tstage.activateTexture(methodVO.texturesIndex, this._texture);\n\n\t\tsuper.iActivate(shaderObject, methodVO, stage);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentCode(shaderObject:ShaderObjectBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string;\n\t\tvar lightMapReg:ShaderRegisterElement = registerCache.getFreeTextureReg();\n\t\tvar temp:ShaderRegisterElement = registerCache.getFreeFragmentVectorTemp();\n\t\tmethodVO.texturesIndex = lightMapReg.index;\n\n\t\tcode = ShaderCompilerHelper.getTex2DSampleCode(temp, sharedRegisters, lightMapReg, this._texture, shaderObject.useSmoothTextures, shaderObject.repeatTextures, shaderObject.useMipmapping, this._useSecondaryUV? sharedRegisters.secondaryUVVarying : sharedRegisters.uvVarying);\n\n\t\tswitch (this._blendMode) {\n\t\t\tcase EffectLightMapMethod.MULTIPLY:\n\t\t\t\tcode += \"mul \" + targetReg + \", \" + targetReg + \", \" + temp + \"\\n\";\n\t\t\t\tbreak;\n\t\t\tcase EffectLightMapMethod.ADD:\n\t\t\t\tcode += \"add \" + targetReg + \", \" + targetReg + \", \" + temp + \"\\n\";\n\t\t\t\tbreak;\n\t\t}\n\n\t\treturn code;\n\t}\n}\n\nexport = EffectLightMapMethod;","import AssetType\t\t\t\t\t= require(\"awayjs-core/lib/library/AssetType\");\nimport IAsset\t\t\t\t\t\t= require(\"awayjs-core/lib/library/IAsset\");\nimport AbstractMethodError\t\t\t= require(\"awayjs-core/lib/errors/AbstractMethodError\");\n\nimport ShaderObjectBase\t\t\t\t= require(\"awayjs-renderergl/lib/compilation/ShaderObjectBase\");\nimport ShaderRegisterCache\t\t\t= require(\"awayjs-renderergl/lib/compilation/ShaderRegisterCache\");\nimport ShaderRegisterData\t\t\t= require(\"awayjs-renderergl/lib/compilation/ShaderRegisterData\");\nimport ShaderRegisterElement\t\t= require(\"awayjs-renderergl/lib/compilation/ShaderRegisterElement\");\n\nimport MethodVO\t\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/data/MethodVO\");\nimport ShadingMethodBase\t\t\t= require(\"awayjs-methodmaterials/lib/methods/ShadingMethodBase\");\n\n/**\n * EffectMethodBase forms an abstract base class for shader methods that are not dependent on light sources,\n * and are in essence post-process effects on the materials.\n */\nclass EffectMethodBase extends ShadingMethodBase implements IAsset\n{\n\tconstructor()\n\t{\n\t\tsuper();\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic get assetType():string\n\t{\n\t\treturn AssetType.EFFECTS_METHOD;\n\t}\n\n\t/**\n\t * Get the fragment shader code that should be added after all per-light code. Usually composits everything to the target register.\n\t * @param methodVO The MethodVO object containing the method data for the currently compiled material pass.\n\t * @param regCache The register cache used during the compilation.\n\t * @param targetReg The register that will be containing the method's output.\n\t * @private\n\t */\n\tpublic iGetFragmentCode(shaderObject:ShaderObjectBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tthrow new AbstractMethodError();\n\t\treturn \"\";\n\t}\n}\n\nexport = EffectMethodBase;","import CubeTextureBase\t\t\t\t\t= require(\"awayjs-core/lib/textures/CubeTextureBase\");\n\nimport Stage\t\t\t\t\t\t\t= require(\"awayjs-stagegl/lib/base/Stage\");\n\nimport ShaderObjectBase\t\t\t\t\t= require(\"awayjs-renderergl/lib/compilation/ShaderObjectBase\");\nimport ShaderRegisterCache\t\t\t\t= require(\"awayjs-renderergl/lib/compilation/ShaderRegisterCache\");\nimport ShaderRegisterData\t\t\t\t= require(\"awayjs-renderergl/lib/compilation/ShaderRegisterData\");\nimport ShaderRegisterElement\t\t\t= require(\"awayjs-renderergl/lib/compilation/ShaderRegisterElement\");\nimport ShaderCompilerHelper\t\t\t\t= require(\"awayjs-renderergl/lib/utils/ShaderCompilerHelper\");\n\nimport MethodVO\t\t\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/data/MethodVO\");\nimport EffectMethodBase\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/methods/EffectMethodBase\");\n\n/**\n * EffectRefractionEnvMapMethod provides a method to add refracted transparency based on cube maps.\n */\nclass EffectRefractionEnvMapMethod extends EffectMethodBase\n{\n\tprivate _envMap:CubeTextureBase;\n\n\tprivate _dispersionR:number = 0;\n\tprivate _dispersionG:number = 0;\n\tprivate _dispersionB:number = 0;\n\tprivate _useDispersion:boolean;\n\tprivate _refractionIndex:number;\n\tprivate _alpha:number = 1;\n\n\t/**\n\t * Creates a new EffectRefractionEnvMapMethod object. Example values for dispersion are: dispersionR: -0.03, dispersionG: -0.01, dispersionB: = .0015\n\t *\n\t * @param envMap The environment map containing the refracted scene.\n\t * @param refractionIndex The refractive index of the material.\n\t * @param dispersionR The amount of chromatic dispersion of the red channel. Defaults to 0 (none).\n\t * @param dispersionG The amount of chromatic dispersion of the green channel. Defaults to 0 (none).\n\t * @param dispersionB The amount of chromatic dispersion of the blue channel. Defaults to 0 (none).\n\t */\n\tconstructor(envMap:CubeTextureBase, refractionIndex:number = .1, dispersionR:number = 0, dispersionG:number = 0, dispersionB:number = 0)\n\t{\n\t\tsuper();\n\t\tthis._envMap = envMap;\n\t\tthis._dispersionR = dispersionR;\n\t\tthis._dispersionG = dispersionG;\n\t\tthis._dispersionB = dispersionB;\n\t\tthis._useDispersion = !(this._dispersionR == this._dispersionB && this._dispersionR == this._dispersionG);\n\t\tthis._refractionIndex = refractionIndex;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitConstants(shaderObject:ShaderObjectBase, methodVO:MethodVO)\n\t{\n\t\tvar index:number /*int*/ = methodVO.fragmentConstantsIndex;\n\t\tvar data:Array<number> = shaderObject.fragmentConstantData;\n\t\tdata[index + 4] = 1;\n\t\tdata[index + 5] = 0;\n\t\tdata[index + 7] = 1;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitVO(shaderObject:ShaderObjectBase, methodVO:MethodVO)\n\t{\n\t\tmethodVO.needsNormals = true;\n\t\tmethodVO.needsView = true;\n\t}\n\n\t/**\n\t * The cube environment map to use for the refraction.\n\t */\n\tpublic get envMap():CubeTextureBase\n\t{\n\t\treturn this._envMap;\n\t}\n\n\tpublic set envMap(value:CubeTextureBase)\n\t{\n\t\tthis._envMap = value;\n\t}\n\n\t/**\n\t * The refractive index of the material.\n\t */\n\tpublic get refractionIndex():number\n\t{\n\t\treturn this._refractionIndex;\n\t}\n\n\tpublic set refractionIndex(value:number)\n\t{\n\t\tthis._refractionIndex = value;\n\t}\n\n\t/**\n\t * The amount of chromatic dispersion of the red channel. Defaults to 0 (none).\n\t */\n\tpublic get dispersionR():number\n\t{\n\t\treturn this._dispersionR;\n\t}\n\n\tpublic set dispersionR(value:number)\n\t{\n\t\tthis._dispersionR = value;\n\n\t\tvar useDispersion:boolean = !(this._dispersionR == this._dispersionB && this._dispersionR == this._dispersionG);\n\t\tif (this._useDispersion != useDispersion) {\n\t\t\tthis.iInvalidateShaderProgram();\n\t\t\tthis._useDispersion = useDispersion;\n\t\t}\n\t}\n\n\t/**\n\t * The amount of chromatic dispersion of the green channel. Defaults to 0 (none).\n\t */\n\tpublic get dispersionG():number\n\t{\n\t\treturn this._dispersionG;\n\t}\n\n\tpublic set dispersionG(value:number)\n\t{\n\t\tthis._dispersionG = value;\n\n\t\tvar useDispersion:boolean = !(this._dispersionR == this._dispersionB && this._dispersionR == this._dispersionG);\n\t\tif (this._useDispersion != useDispersion) {\n\t\t\tthis.iInvalidateShaderProgram();\n\t\t\tthis._useDispersion = useDispersion;\n\t\t}\n\t}\n\n\t/**\n\t * The amount of chromatic dispersion of the blue channel. Defaults to 0 (none).\n\t */\n\tpublic get dispersionB():number\n\t{\n\t\treturn this._dispersionB;\n\t}\n\n\tpublic set dispersionB(value:number)\n\t{\n\t\tthis._dispersionB = value;\n\n\t\tvar useDispersion:boolean = !(this._dispersionR == this._dispersionB && this._dispersionR == this._dispersionG);\n\t\tif (this._useDispersion != useDispersion) {\n\t\t\tthis.iInvalidateShaderProgram();\n\t\t\tthis._useDispersion = useDispersion;\n\t\t}\n\t}\n\n\t/**\n\t * The amount of transparency of the object. Warning: the alpha applies to the refracted color, not the actual\n\t * material. A value of 1 will make it appear fully transparent.\n\t */\n\tpublic get alpha():number\n\t{\n\t\treturn this._alpha;\n\t}\n\n\tpublic set alpha(value:number)\n\t{\n\t\tthis._alpha = value;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iActivate(shaderObject:ShaderObjectBase, methodVO:MethodVO, stage:Stage)\n\t{\n\t\tvar index:number /*int*/ = methodVO.fragmentConstantsIndex;\n\t\tvar data:Array<number> = shaderObject.fragmentConstantData;\n\n\t\tdata[index] = this._dispersionR + this._refractionIndex;\n\n\t\tif (this._useDispersion) {\n\t\t\tdata[index + 1] = this._dispersionG + this._refractionIndex;\n\t\t\tdata[index + 2] = this._dispersionB + this._refractionIndex;\n\t\t}\n\t\tdata[index + 3] = this._alpha;\n\n\t\tstage.activateCubeTexture(methodVO.texturesIndex, this._envMap);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentCode(shaderObject:ShaderObjectBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\t// todo: data2.x could use common reg, so only 1 reg is used\n\t\tvar data:ShaderRegisterElement = registerCache.getFreeFragmentConstant();\n\t\tvar data2:ShaderRegisterElement = registerCache.getFreeFragmentConstant();\n\t\tvar code:string = \"\";\n\t\tvar cubeMapReg:ShaderRegisterElement = registerCache.getFreeTextureReg();\n\t\tvar refractionDir:ShaderRegisterElement;\n\t\tvar refractionColor:ShaderRegisterElement;\n\t\tvar temp:ShaderRegisterElement;\n\n\t\tmethodVO.texturesIndex = cubeMapReg.index;\n\t\tmethodVO.fragmentConstantsIndex = data.index*4;\n\n\t\trefractionDir = registerCache.getFreeFragmentVectorTemp();\n\t\tregisterCache.addFragmentTempUsages(refractionDir, 1);\n\t\trefractionColor = registerCache.getFreeFragmentVectorTemp();\n\t\tregisterCache.addFragmentTempUsages(refractionColor, 1);\n\n\t\ttemp = registerCache.getFreeFragmentVectorTemp();\n\n\t\tvar viewDirReg:ShaderRegisterElement = sharedRegisters.viewDirFragment;\n\t\tvar normalReg:ShaderRegisterElement = sharedRegisters.normalFragment;\n\n\t\tcode += \"neg \" + viewDirReg + \".xyz, \" + viewDirReg + \".xyz\\n\";\n\n\t\tcode += \"dp3 \" + temp + \".x, \" + viewDirReg + \".xyz, \" + normalReg + \".xyz\\n\" +\n\t\t\t\"mul \" + temp + \".w, \" + temp + \".x, \" + temp + \".x\\n\" +\n\t\t\t\"sub \" + temp + \".w, \" + data2 + \".x, \" + temp + \".w\\n\" +\n\t\t\t\"mul \" + temp + \".w, \" + data + \".x, \" + temp + \".w\\n\" +\n\t\t\t\"mul \" + temp + \".w, \" + data + \".x, \" + temp + \".w\\n\" +\n\t\t\t\"sub \" + temp + \".w, \" + data2 + \".x, \" + temp + \".w\\n\" +\n\t\t\t\"sqt \" + temp + \".y, \" + temp + \".w\\n\" +\n\n\t\t\t\"mul \" + temp + \".x, \" + data + \".x, \" + temp + \".x\\n\" +\n\t\t\t\"add \" + temp + \".x, \" + temp + \".x, \" + temp + \".y\\n\" +\n\t\t\t\"mul \" + temp + \".xyz, \" + temp + \".x, \" + normalReg + \".xyz\\n\" +\n\n\t\t\t\"mul \" + refractionDir + \", \" + data + \".x, \" + viewDirReg + \"\\n\" +\n\t\t\t\"sub \" + refractionDir + \".xyz, \" + refractionDir + \".xyz, \" + temp + \".xyz\\n\" +\n\t\t\t\"nrm \" + refractionDir + \".xyz, \" + refractionDir + \".xyz\\n\";\n\t\tcode += ShaderCompilerHelper.getTexCubeSampleCode(refractionColor, cubeMapReg, this._envMap, shaderObject.useSmoothTextures, shaderObject.useMipmapping, refractionDir) +\n\t\t\t\"sub \" + refractionColor + \".w, \" + refractionColor + \".w, fc0.x\t\\n\" +\n\t\t\t\"kil \" + refractionColor + \".w\\n\";\n\n\t\tif (this._useDispersion) {\n\t\t\t// GREEN\n\t\t\tcode += \"dp3 \" + temp + \".x, \" + viewDirReg + \".xyz, \" + normalReg + \".xyz\\n\" +\n\t\t\t\t\"mul \" + temp + \".w, \" + temp + \".x, \" + temp + \".x\\n\" +\n\t\t\t\t\"sub \" + temp + \".w, \" + data2 + \".x, \" + temp + \".w\\n\" +\n\t\t\t\t\"mul \" + temp + \".w, \" + data + \".y, \" + temp + \".w\\n\" +\n\t\t\t\t\"mul \" + temp + \".w, \" + data + \".y, \" + temp + \".w\\n\" +\n\t\t\t\t\"sub \" + temp + \".w, \" + data2 + \".x, \" + temp + \".w\\n\" +\n\t\t\t\t\"sqt \" + temp + \".y, \" + temp + \".w\\n\" +\n\n\t\t\t\t\"mul \" + temp + \".x, \" + data + \".y, \" + temp + \".x\\n\" +\n\t\t\t\t\"add \" + temp + \".x, \" + temp + \".x, \" + temp + \".y\\n\" +\n\t\t\t\t\"mul \" + temp + \".xyz, \" + temp + \".x, \" + normalReg + \".xyz\\n\" +\n\n\t\t\t\t\"mul \" + refractionDir + \", \" + data + \".y, \" + viewDirReg + \"\\n\" +\n\t\t\t\t\"sub \" + refractionDir + \".xyz, \" + refractionDir + \".xyz, \" + temp + \".xyz\\n\" +\n\t\t\t\t\"nrm \" + refractionDir + \".xyz, \" + refractionDir + \".xyz\\n\";\n\t\t\tcode += ShaderCompilerHelper.getTexCubeSampleCode(temp, cubeMapReg, this._envMap, shaderObject.useSmoothTextures, shaderObject.useMipmapping, refractionDir) +\n\t\t\t\t\"mov \" + refractionColor + \".y, \" + temp + \".y\\n\";\n\n\t\t\t// BLUE\n\t\t\tcode += \"dp3 \" + temp + \".x, \" + viewDirReg + \".xyz, \" + normalReg + \".xyz\\n\" +\n\t\t\t\t\"mul \" + temp + \".w, \" + temp + \".x, \" + temp + \".x\\n\" +\n\t\t\t\t\"sub \" + temp + \".w, \" + data2 + \".x, \" + temp + \".w\\n\" +\n\t\t\t\t\"mul \" + temp + \".w, \" + data + \".z, \" + temp + \".w\\n\" +\n\t\t\t\t\"mul \" + temp + \".w, \" + data + \".z, \" + temp + \".w\\n\" +\n\t\t\t\t\"sub \" + temp + \".w, \" + data2 + \".x, \" + temp + \".w\\n\" +\n\t\t\t\t\"sqt \" + temp + \".y, \" + temp + \".w\\n\" +\n\n\t\t\t\t\"mul \" + temp + \".x, \" + data + \".z, \" + temp + \".x\\n\" +\n\t\t\t\t\"add \" + temp + \".x, \" + temp + \".x, \" + temp + \".y\\n\" +\n\t\t\t\t\"mul \" + temp + \".xyz, \" + temp + \".x, \" + normalReg + \".xyz\\n\" +\n\n\t\t\t\t\"mul \" + refractionDir + \", \" + data + \".z, \" + viewDirReg + \"\\n\" +\n\t\t\t\t\"sub \" + refractionDir + \".xyz, \" + refractionDir + \".xyz, \" + temp + \".xyz\\n\" +\n\t\t\t\t\"nrm \" + refractionDir + \".xyz, \" + refractionDir + \".xyz\\n\";\n\t\t\tcode += ShaderCompilerHelper.getTexCubeSampleCode(temp, cubeMapReg, this._envMap, shaderObject.useSmoothTextures, shaderObject.useMipmapping, refractionDir) +\n\t\t\t\t\"mov \" + refractionColor + \".z, \" + temp + \".z\\n\";\n\t\t}\n\n\t\tregisterCache.removeFragmentTempUsage(refractionDir);\n\n\t\tcode += \"sub \" + refractionColor + \".xyz, \" + refractionColor + \".xyz, \" + targetReg + \".xyz\\n\" +\n\t\t\t\"mul \" + refractionColor + \".xyz, \" + refractionColor + \".xyz, \" + data + \".w\\n\" +\n\t\t\t\"add \" + targetReg + \".xyz, \" + targetReg + \".xyz, \" + refractionColor + \".xyz\\n\";\n\n\t\tregisterCache.removeFragmentTempUsage(refractionColor);\n\n\t\t// restore\n\t\tcode += \"neg \" + viewDirReg + \".xyz, \" + viewDirReg + \".xyz\\n\";\n\n\t\treturn code;\n\t}\n}\n\nexport = EffectRefractionEnvMapMethod;","import Stage\t\t\t\t\t\t\t= require(\"awayjs-stagegl/lib/base/Stage\");\n\nimport ShaderObjectBase\t\t\t\t\t= require(\"awayjs-renderergl/lib/compilation/ShaderObjectBase\");\nimport ShaderRegisterCache\t\t\t\t= require(\"awayjs-renderergl/lib/compilation/ShaderRegisterCache\");\nimport ShaderRegisterData\t\t\t\t= require(\"awayjs-renderergl/lib/compilation/ShaderRegisterData\");\nimport ShaderRegisterElement\t\t\t= require(\"awayjs-renderergl/lib/compilation/ShaderRegisterElement\");\n\nimport MethodVO\t\t\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/data/MethodVO\");\nimport EffectMethodBase\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/methods/EffectMethodBase\");\n\n/**\n * EffectRimLightMethod provides a method to add rim lighting to a material. This adds a glow-like effect to edges of objects.\n */\nclass EffectRimLightMethod extends EffectMethodBase\n{\n\tpublic static ADD:string = \"add\";\n\tpublic static MULTIPLY:string = \"multiply\";\n\tpublic static MIX:string = \"mix\";\n\n\tprivate _color:number /*uint*/;\n\tprivate _blendMode:string;\n\tprivate _colorR:number;\n\tprivate _colorG:number;\n\tprivate _colorB:number;\n\tprivate _strength:number;\n\tprivate _power:number;\n\n\t/**\n\t * Creates a new <code>EffectRimLightMethod</code> object.\n\t *\n\t * @param color The colour of the rim light.\n\t * @param strength The strength of the rim light.\n\t * @param power The power of the rim light. Higher values will result in a higher edge fall-off.\n\t * @param blend The blend mode with which to add the light to the object.\n\t */\n\tconstructor(color:number /*uint*/ = 0xffffff, strength:number = .4, power:number = 2, blend:string = \"mix\")\n\t{\n\t\tsuper();\n\n\t\tthis._blendMode = blend;\n\t\tthis._strength = strength;\n\t\tthis._power = power;\n\n\t\tthis.color = color;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitConstants(shaderObject:ShaderObjectBase, methodVO:MethodVO)\n\t{\n\t\tshaderObject.fragmentConstantData[methodVO.fragmentConstantsIndex + 3] = 1;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitVO(shaderObject:ShaderObjectBase, methodVO:MethodVO)\n\t{\n\t\tmethodVO.needsNormals = true;\n\t\tmethodVO.needsView = true;\n\t}\n\n\n\t/**\n\t * The blend mode with which to add the light to the object.\n\t *\n\t * EffectRimLightMethod.MULTIPLY multiplies the rim light with the material's colour.\n\t * EffectRimLightMethod.ADD adds the rim light with the material's colour.\n\t * EffectRimLightMethod.MIX provides normal alpha blending.\n\t */\n\tpublic get blendMode():string\n\t{\n\t\treturn this._blendMode;\n\t}\n\n\tpublic set blendMode(value:string)\n\t{\n\t\tif (this._blendMode == value)\n\t\t\treturn;\n\n\t\tthis._blendMode = value;\n\n\t\tthis.iInvalidateShaderProgram();\n\t}\n\n\t/**\n\t * The color of the rim light.\n\t */\n\tpublic get color():number /*uint*/\n\t{\n\t\treturn this._color;\n\t}\n\n\tpublic set color(value:number /*uint*/)\n\t{\n\t\tthis._color = value;\n\t\tthis._colorR = ((value >> 16) & 0xff)/0xff;\n\t\tthis._colorG = ((value >> 8) & 0xff)/0xff;\n\t\tthis._colorB = (value & 0xff)/0xff;\n\t}\n\n\t/**\n\t * The strength of the rim light.\n\t */\n\tpublic get strength():number\n\t{\n\t\treturn this._strength;\n\t}\n\n\tpublic set strength(value:number)\n\t{\n\t\tthis._strength = value;\n\t}\n\n\t/**\n\t * The power of the rim light. Higher values will result in a higher edge fall-off.\n\t */\n\tpublic get power():number\n\t{\n\t\treturn this._power;\n\t}\n\n\tpublic set power(value:number)\n\t{\n\t\tthis._power = value;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iActivate(shaderObject:ShaderObjectBase, methodVO:MethodVO, stage:Stage)\n\t{\n\t\tvar index:number /*int*/ = methodVO.fragmentConstantsIndex;\n\t\tvar data:Array<number> = shaderObject.fragmentConstantData;\n\t\tdata[index] = this._colorR;\n\t\tdata[index + 1] = this._colorG;\n\t\tdata[index + 2] = this._colorB;\n\t\tdata[index + 4] = this._strength;\n\t\tdata[index + 5] = this._power;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentCode(shaderObject:ShaderObjectBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar dataRegister:ShaderRegisterElement = registerCache.getFreeFragmentConstant();\n\t\tvar dataRegister2:ShaderRegisterElement = registerCache.getFreeFragmentConstant();\n\t\tvar temp:ShaderRegisterElement = registerCache.getFreeFragmentVectorTemp();\n\t\tvar code:string = \"\";\n\n\t\tmethodVO.fragmentConstantsIndex = dataRegister.index*4;\n\n\t\tcode += \"dp3 \" + temp + \".x, \" + sharedRegisters.viewDirFragment + \".xyz, \" + sharedRegisters.normalFragment + \".xyz\\n\" +\n\t\t\t\"sat \" + temp + \".x, \" + temp + \".x\\n\" +\n\t\t\t\"sub \" + temp + \".x, \" + dataRegister + \".w, \" + temp + \".x\\n\" +\n\t\t\t\"pow \" + temp + \".x, \" + temp + \".x, \" + dataRegister2 + \".y\\n\" +\n\t\t\t\"mul \" + temp + \".x, \" + temp + \".x, \" + dataRegister2 + \".x\\n\" +\n\t\t\t\"sub \" + temp + \".x, \" + dataRegister + \".w, \" + temp + \".x\\n\" +\n\t\t\t\"mul \" + targetReg + \".xyz, \" + targetReg + \".xyz, \" + temp + \".x\\n\" +\n\t\t\t\"sub \" + temp + \".w, \" + dataRegister + \".w, \" + temp + \".x\\n\";\n\n\t\tif (this._blendMode == EffectRimLightMethod.ADD) {\n\t\t\tcode += \"mul \" + temp + \".xyz, \" + temp + \".w, \" + dataRegister + \".xyz\\n\" +\n\t\t\t\t\"add \" + targetReg + \".xyz, \" + targetReg + \".xyz, \" + temp + \".xyz\\n\";\n\t\t} else if (this._blendMode == EffectRimLightMethod.MULTIPLY) {\n\t\t\tcode += \"mul \" + temp + \".xyz, \" + temp + \".w, \" + dataRegister + \".xyz\\n\" +\n\t\t\t\t\"mul \" + targetReg + \".xyz, \" + targetReg + \".xyz, \" + temp + \".xyz\\n\";\n\t\t} else {\n\t\t\tcode += \"sub \" + temp + \".xyz, \" + dataRegister + \".xyz, \" + targetReg + \".xyz\\n\" +\n\t\t\t\t\"mul \" + temp + \".xyz, \" + temp + \".xyz, \" + temp + \".w\\n\" +\n\t\t\t\t\"add \" + targetReg + \".xyz, \" + targetReg + \".xyz, \" + temp + \".xyz\\n\";\n\t\t}\n\n\t\treturn code;\n\t}\n}\n\nexport = EffectRimLightMethod;","import ShaderObjectBase\t\t\t\t= require(\"awayjs-renderergl/lib/compilation/ShaderObjectBase\");\nimport ShaderLightingObject\t\t\t= require(\"awayjs-renderergl/lib/compilation/ShaderLightingObject\");\nimport ShaderRegisterCache\t\t\t= require(\"awayjs-renderergl/lib/compilation/ShaderRegisterCache\");\nimport ShaderRegisterData\t\t\t= require(\"awayjs-renderergl/lib/compilation/ShaderRegisterData\");\nimport ShaderRegisterElement\t\t= require(\"awayjs-renderergl/lib/compilation/ShaderRegisterElement\");\n\nimport MethodVO\t\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/data/MethodVO\");\nimport ShadingMethodBase\t\t\t= require(\"awayjs-methodmaterials/lib/methods/ShadingMethodBase\");\n\n/**\n * LightingMethodBase provides an abstract base method for shading methods that uses lights.\n * Used for diffuse and specular shaders only.\n */\nclass LightingMethodBase extends ShadingMethodBase\n{\n\t/**\n\t * A method that is exposed to wrappers in case the strength needs to be controlled\n\t */\n\tpublic _iModulateMethod:(shaderObject:ShaderObjectBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData) => string;\n\n\t/**\n\t * Creates a new LightingMethodBase.\n\t */\n\tconstructor()\n\t{\n\t\tsuper();\n\t}\n\n\t/**\n\t * Get the fragment shader code that will be needed before any per-light code is added.\n\t * @param methodVO The MethodVO object containing the method data for the currently compiled material pass.\n\t * @param regCache The register cache used during the compilation.\n\t * @private\n\t */\n\tpublic iGetFragmentPreLightingCode(shaderObject:ShaderLightingObject, methodVO:MethodVO, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\treturn \"\";\n\t}\n\n\t/**\n\t * Get the fragment shader code that will generate the code relevant to a single light.\n\t *\n\t * @param methodVO The MethodVO object containing the method data for the currently compiled material pass.\n\t * @param lightDirReg The register containing the light direction vector.\n\t * @param lightColReg The register containing the light colour.\n\t * @param regCache The register cache used during the compilation.\n\t */\n\tpublic iGetFragmentCodePerLight(shaderObject:ShaderLightingObject, methodVO:MethodVO, lightDirReg:ShaderRegisterElement, lightColReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\treturn \"\";\n\t}\n\n\t/**\n\t * Get the fragment shader code that will generate the code relevant to a single light probe object.\n\t *\n\t * @param methodVO The MethodVO object containing the method data for the currently compiled material pass.\n\t * @param cubeMapReg The register containing the cube map for the current probe\n\t * @param weightRegister A string representation of the register + component containing the current weight\n\t * @param regCache The register cache providing any necessary registers to the shader\n\t */\n\tpublic iGetFragmentCodePerProbe(shaderObject:ShaderLightingObject, methodVO:MethodVO, cubeMapReg:ShaderRegisterElement, weightRegister:string, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\treturn \"\";\n\t}\n\n\t/**\n\t * Get the fragment shader code that should be added after all per-light code. Usually composits everything to the target register.\n\t *\n\t * @param methodVO The MethodVO object containing the method data for the currently compiled material pass.\n\t * @param regCache The register cache used during the compilation.\n\t * @param targetReg The register containing the final shading output.\n\t * @private\n\t */\n\tpublic iGetFragmentPostLightingCode(shaderObject:ShaderLightingObject, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\treturn \"\";\n\t}\n}\n\nexport = LightingMethodBase;","import Texture2DBase\t\t\t\t= require(\"awayjs-core/lib/textures/Texture2DBase\");\n\nimport Stage\t\t\t\t\t\t= require(\"awayjs-stagegl/lib/base/Stage\");\nimport ContextGLMipFilter\t\t\t= require(\"awayjs-stagegl/lib/base/ContextGLMipFilter\");\nimport ContextGLTextureFilter\t\t= require(\"awayjs-stagegl/lib/base/ContextGLTextureFilter\");\nimport ContextGLWrapMode\t\t\t= require(\"awayjs-stagegl/lib/base/ContextGLWrapMode\");\n\nimport ShaderObjectBase\t\t\t\t= require(\"awayjs-renderergl/lib/compilation/ShaderObjectBase\");\nimport ShaderRegisterCache\t\t\t= require(\"awayjs-renderergl/lib/compilation/ShaderRegisterCache\");\nimport ShaderRegisterData\t\t\t= require(\"awayjs-renderergl/lib/compilation/ShaderRegisterData\");\nimport ShaderRegisterElement\t\t= require(\"awayjs-renderergl/lib/compilation/ShaderRegisterElement\");\nimport ShaderCompilerHelper\t\t\t= require(\"awayjs-renderergl/lib/utils/ShaderCompilerHelper\");\n\nimport MethodVO\t\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/data/MethodVO\");\nimport ShadingMethodBase\t\t\t= require(\"awayjs-methodmaterials/lib/methods/ShadingMethodBase\");\n\n/**\n * NormalBasicMethod is the default method for standard tangent-space normal mapping.\n */\nclass NormalBasicMethod extends ShadingMethodBase\n{\n\tprivate _texture:Texture2DBase;\n\tprivate _useTexture:boolean;\n\tpublic _pNormalTextureRegister:ShaderRegisterElement;\n\n\t/**\n\t * Creates a new NormalBasicMethod object.\n\t */\n\tconstructor()\n\t{\n\t\tsuper();\n\t}\n\n\tpublic iIsUsed(shaderObject:ShaderObjectBase):boolean\n\t{\n\t\tif (!this._useTexture || !shaderObject.normalDependencies)\n\t\t\treturn false;\n\n\t\treturn true;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitVO(shaderObject:ShaderObjectBase, methodVO:MethodVO)\n\t{\n\t\tmethodVO.needsUV = this._useTexture;\n\t}\n\n\t/**\n\t * Indicates whether or not this method outputs normals in tangent space. Override for object-space normals.\n\t */\n\tpublic iOutputsTangentNormals():boolean\n\t{\n\t\treturn true;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic copyFrom(method:ShadingMethodBase)\n\t{\n\t\tvar s:any = method;\n\t\tvar bnm:NormalBasicMethod = <NormalBasicMethod> method;\n\n\t\tif (bnm.normalMap != null)\n\t\t\tthis.normalMap = bnm.normalMap;\n\t}\n\n\t/**\n\t * The texture containing the normals per pixel.\n\t */\n\tpublic get normalMap():Texture2DBase\n\t{\n\t\treturn this._texture;\n\t}\n\n\tpublic set normalMap(value:Texture2DBase)\n\t{\n\t\tvar b:boolean = (value != null);\n\n\t\tif (b != this._useTexture || (value && this._texture && (value.hasMipmaps != this._texture.hasMipmaps || value.format != this._texture.format)))\n\t\t\tthis.iInvalidateShaderProgram();\n\n\t\tthis._useTexture = b;\n\t\tthis._texture = value;\n\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iCleanCompilationData()\n\t{\n\t\tsuper.iCleanCompilationData();\n\t\tthis._pNormalTextureRegister = null;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic dispose()\n\t{\n\t\tif (this._texture)\n\t\t\tthis._texture = null;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iActivate(shaderObject:ShaderObjectBase, methodVO:MethodVO, stage:Stage)\n\t{\n\t\tif (methodVO.texturesIndex >= 0) {\n\t\t\tstage.context.setSamplerStateAt(methodVO.texturesIndex, shaderObject.repeatTextures? ContextGLWrapMode.REPEAT:ContextGLWrapMode.CLAMP, shaderObject.useSmoothTextures? ContextGLTextureFilter.LINEAR : ContextGLTextureFilter.NEAREST, shaderObject.useMipmapping? ContextGLMipFilter.MIPLINEAR : ContextGLMipFilter.MIPNONE);\n\t\t\tstage.activateTexture(methodVO.texturesIndex, this._texture);\n\t\t}\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentCode(shaderObject:ShaderObjectBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tthis._pNormalTextureRegister = registerCache.getFreeTextureReg();\n\n\t\tmethodVO.texturesIndex = this._pNormalTextureRegister.index;\n\n\t\treturn ShaderCompilerHelper.getTex2DSampleCode(targetReg, sharedRegisters, this._pNormalTextureRegister, this._texture, shaderObject.useSmoothTextures, shaderObject.repeatTextures, shaderObject.useMipmapping) +\n\t\t\t\"sub \" + targetReg + \".xyz, \" + targetReg + \".xyz, \" + sharedRegisters.commons + \".xxx\\n\" +\n\t\t\t\"nrm \" + targetReg + \".xyz, \" + targetReg + \"\\n\";\n\t}\n}\n\nexport = NormalBasicMethod;","import Texture2DBase\t\t\t\t\t= require(\"awayjs-core/lib/textures/Texture2DBase\");\n\nimport ShaderObjectBase\t\t\t\t\t= require(\"awayjs-renderergl/lib/compilation/ShaderObjectBase\");\nimport ShaderRegisterCache\t\t\t\t= require(\"awayjs-renderergl/lib/compilation/ShaderRegisterCache\");\nimport ShaderRegisterData\t\t\t\t= require(\"awayjs-renderergl/lib/compilation/ShaderRegisterData\");\nimport ShaderRegisterElement\t\t\t= require(\"awayjs-renderergl/lib/compilation/ShaderRegisterElement\");\nimport ShaderCompilerHelper\t\t\t\t= require(\"awayjs-renderergl/lib/utils/ShaderCompilerHelper\");\n\nimport MethodVO\t\t\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/data/MethodVO\");\nimport NormalBasicMethod\t\t\t\t= require(\"awayjs-methodmaterials/lib/methods/NormalBasicMethod\");\nimport ShadingMethodBase\t\t\t\t= require(\"awayjs-methodmaterials/lib/methods/ShadingMethodBase\");\n\n/**\n * NormalHeightMapMethod provides a normal map method that uses a height map to calculate the normals.\n */\nclass NormalHeightMapMethod extends NormalBasicMethod\n{\n\tprivate _worldXYRatio:number;\n\tprivate _worldXZRatio:number;\n\n\t/**\n\t * Creates a new NormalHeightMapMethod method.\n\t *\n\t * @param heightMap The texture containing the height data. 0 means low, 1 means high.\n\t * @param worldWidth The width of the 'world'. This is used to map uv coordinates' u component to scene dimensions.\n\t * @param worldHeight The height of the 'world'. This is used to map the height map values to scene dimensions.\n\t * @param worldDepth The depth of the 'world'. This is used to map uv coordinates' v component to scene dimensions.\n\t */\n\tconstructor(heightMap:Texture2DBase, worldWidth:number, worldHeight:number, worldDepth:number)\n\t{\n\t\tsuper();\n\n\t\tthis.normalMap = heightMap;\n\t\tthis._worldXYRatio = worldWidth/worldHeight;\n\t\tthis._worldXZRatio = worldDepth/worldHeight;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitConstants(shaderObject:ShaderObjectBase, methodVO:MethodVO)\n\t{\n\t\tvar index:number /*int*/ = methodVO.fragmentConstantsIndex;\n\t\tvar data:Array<number> = shaderObject.fragmentConstantData;\n\t\tdata[index] = 1/this.normalMap.width;\n\t\tdata[index + 1] = 1/this.normalMap.height;\n\t\tdata[index + 2] = 0;\n\t\tdata[index + 3] = 1;\n\t\tdata[index + 4] = this._worldXYRatio;\n\t\tdata[index + 5] = this._worldXZRatio;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic get tangentSpace():boolean\n\t{\n\t\treturn false;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic copyFrom(method:ShadingMethodBase)\n\t{\n\t\tsuper.copyFrom(method);\n\n\t\tthis._worldXYRatio = (<NormalHeightMapMethod> method)._worldXYRatio;\n\t\tthis._worldXZRatio = (<NormalHeightMapMethod> method)._worldXZRatio;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentCode(shaderObject:ShaderObjectBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar temp:ShaderRegisterElement = registerCache.getFreeFragmentVectorTemp();\n\t\tvar dataReg:ShaderRegisterElement = registerCache.getFreeFragmentConstant();\n\t\tvar dataReg2:ShaderRegisterElement = registerCache.getFreeFragmentConstant();\n\t\tthis._pNormalTextureRegister = registerCache.getFreeTextureReg();\n\t\tmethodVO.texturesIndex = this._pNormalTextureRegister.index;\n\t\tmethodVO.fragmentConstantsIndex = dataReg.index*4;\n\n\t\treturn ShaderCompilerHelper.getTex2DSampleCode(targetReg, sharedRegisters, this._pNormalTextureRegister, this.normalMap, shaderObject.useSmoothTextures, shaderObject.repeatTextures, shaderObject.useMipmapping, sharedRegisters.uvVarying, \"clamp\") +\n\n\t\t\t\"add \" + temp + \", \" + sharedRegisters.uvVarying + \", \" + dataReg + \".xzzz\\n\" +\n\n\t\t\tShaderCompilerHelper.getTex2DSampleCode(temp, sharedRegisters, this._pNormalTextureRegister, this.normalMap, shaderObject.useSmoothTextures, shaderObject.repeatTextures, shaderObject.useMipmapping, temp, \"clamp\") +\n\n\t\t\t\"sub \" + targetReg + \".x, \" + targetReg + \".x, \" + temp + \".x\\n\" +\n\t\t\t\"add \" + temp + \", \" + sharedRegisters.uvVarying + \", \" + dataReg + \".zyzz\\n\" +\n\n\t\t\tShaderCompilerHelper.getTex2DSampleCode(temp, sharedRegisters, this._pNormalTextureRegister, this.normalMap, shaderObject.useSmoothTextures, shaderObject.repeatTextures, shaderObject.useMipmapping, temp, \"clamp\") +\n\n\t\t\t\"sub \" + targetReg + \".z, \" + targetReg + \".z, \" + temp + \".x\\n\" +\n\t\t\t\"mov \" + targetReg + \".y, \" + dataReg + \".w\\n\" +\n\t\t\t\"mul \" + targetReg + \".xz, \" + targetReg + \".xz, \" + dataReg2 + \".xy\\n\" +\n\t\t\t\"nrm \" + targetReg + \".xyz, \" + targetReg + \".xyz\\n\";\n\t}\n}\n\nexport = NormalHeightMapMethod;","import Texture2DBase\t\t\t\t\t= require(\"awayjs-core/lib/textures/Texture2DBase\");\n\nimport Stage\t\t\t\t\t\t\t= require(\"awayjs-stagegl/lib/base/Stage\");\n\nimport ShaderObjectBase\t\t\t\t\t= require(\"awayjs-renderergl/lib/compilation/ShaderObjectBase\");\nimport ShaderRegisterCache\t\t\t\t= require(\"awayjs-renderergl/lib/compilation/ShaderRegisterCache\");\nimport ShaderRegisterData\t\t\t\t= require(\"awayjs-renderergl/lib/compilation/ShaderRegisterData\");\nimport ShaderRegisterElement\t\t\t= require(\"awayjs-renderergl/lib/compilation/ShaderRegisterElement\");\nimport ShaderCompilerHelper\t\t\t\t= require(\"awayjs-renderergl/lib/utils/ShaderCompilerHelper\");\n\nimport MethodVO\t\t\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/data/MethodVO\");\nimport NormalBasicMethod\t\t\t\t= require(\"awayjs-methodmaterials/lib/methods/NormalBasicMethod\");\n\n/**\n * NormalSimpleWaterMethod provides a basic normal map method to create water ripples by translating two wave normal maps.\n */\nclass NormalSimpleWaterMethod extends NormalBasicMethod\n{\n\tprivate _texture2:Texture2DBase;\n\tprivate _normalTextureRegister2:ShaderRegisterElement;\n\tprivate _useSecondNormalMap:boolean = false;\n\tprivate _water1OffsetX:number = 0;\n\tprivate _water1OffsetY:number = 0;\n\tprivate _water2OffsetX:number = 0;\n\tprivate _water2OffsetY:number = 0;\n\n\t/**\n\t * Creates a new NormalSimpleWaterMethod object.\n\t * @param waveMap1 A normal map containing one layer of a wave structure.\n\t * @param waveMap2 A normal map containing a second layer of a wave structure.\n\t */\n\tconstructor(waveMap1:Texture2DBase, waveMap2:Texture2DBase)\n\t{\n\t\tsuper();\n\t\tthis.normalMap = waveMap1;\n\t\tthis.secondaryNormalMap = waveMap2;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitConstants(shaderObject:ShaderObjectBase, methodVO:MethodVO)\n\t{\n\t\tvar index:number = methodVO.fragmentConstantsIndex;\n\t\tvar data:Array<number> = shaderObject.fragmentConstantData;\n\t\tdata[index] = .5;\n\t\tdata[index + 1] = 0;\n\t\tdata[index + 2] = 0;\n\t\tdata[index + 3] = 1;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitVO(shaderObject:ShaderObjectBase, methodVO:MethodVO)\n\t{\n\t\tsuper.iInitVO(shaderObject, methodVO);\n\n\t\tthis._useSecondNormalMap = this.normalMap != this.secondaryNormalMap;\n\t}\n\n\t/**\n\t * The translation of the first wave layer along the X-axis.\n\t */\n\tpublic get water1OffsetX():number\n\t{\n\t\treturn this._water1OffsetX;\n\t}\n\n\tpublic set water1OffsetX(value:number)\n\t{\n\t\tthis._water1OffsetX = value;\n\t}\n\n\t/**\n\t * The translation of the first wave layer along the Y-axis.\n\t */\n\tpublic get water1OffsetY():number\n\t{\n\t\treturn this._water1OffsetY;\n\t}\n\n\tpublic set water1OffsetY(value:number)\n\t{\n\t\tthis._water1OffsetY = value;\n\t}\n\n\t/**\n\t * The translation of the second wave layer along the X-axis.\n\t */\n\tpublic get water2OffsetX():number\n\t{\n\t\treturn this._water2OffsetX;\n\t}\n\n\tpublic set water2OffsetX(value:number)\n\t{\n\t\tthis._water2OffsetX = value;\n\t}\n\n\t/**\n\t * The translation of the second wave layer along the Y-axis.\n\t */\n\tpublic get water2OffsetY():number\n\t{\n\t\treturn this._water2OffsetY;\n\t}\n\n\tpublic set water2OffsetY(value:number)\n\t{\n\t\tthis._water2OffsetY = value;\n\t}\n\n\t/**\n\t * A second normal map that will be combined with the first to create a wave-like animation pattern.\n\t */\n\tpublic get secondaryNormalMap():Texture2DBase\n\t{\n\t\treturn this._texture2;\n\t}\n\n\tpublic set secondaryNormalMap(value:Texture2DBase)\n\t{\n\t\tthis._texture2 = value;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iCleanCompilationData()\n\t{\n\t\tsuper.iCleanCompilationData();\n\t\tthis._normalTextureRegister2 = null;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic dispose()\n\t{\n\t\tsuper.dispose();\n\t\tthis._texture2 = null;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iActivate(shaderObject:ShaderObjectBase, methodVO:MethodVO, stage:Stage)\n\t{\n\t\tsuper.iActivate(shaderObject, methodVO, stage);\n\n\t\tvar data:Array<number> = shaderObject.fragmentConstantData;\n\t\tvar index:number = methodVO.fragmentConstantsIndex;\n\n\t\tdata[index + 4] = this._water1OffsetX;\n\t\tdata[index + 5] = this._water1OffsetY;\n\t\tdata[index + 6] = this._water2OffsetX;\n\t\tdata[index + 7] = this._water2OffsetY;\n\n\t\t//if (this._useSecondNormalMap >= 0)\n\t\tif (this._useSecondNormalMap)\n\t\t\tstage.activateTexture(methodVO.texturesIndex + 1, this._texture2);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentCode(shaderObject:ShaderObjectBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar temp:ShaderRegisterElement = registerCache.getFreeFragmentVectorTemp();\n\t\tvar dataReg:ShaderRegisterElement = registerCache.getFreeFragmentConstant();\n\t\tvar dataReg2:ShaderRegisterElement = registerCache.getFreeFragmentConstant();\n\t\tthis._pNormalTextureRegister = registerCache.getFreeTextureReg();\n\t\tthis._normalTextureRegister2 = this._useSecondNormalMap? registerCache.getFreeTextureReg():this._pNormalTextureRegister;\n\t\tmethodVO.texturesIndex = this._pNormalTextureRegister.index;\n\n\t\tmethodVO.fragmentConstantsIndex = dataReg.index*4;\n\n\t\treturn \"add \" + temp + \", \" + sharedRegisters.uvVarying + \", \" + dataReg2 + \".xyxy\\n\" +\n\t\t\tShaderCompilerHelper.getTex2DSampleCode(targetReg, sharedRegisters, this._pNormalTextureRegister, this.normalMap, shaderObject.useSmoothTextures, shaderObject.repeatTextures, shaderObject.useMipmapping, temp) +\n\t\t\t\"add \" + temp + \", \" + sharedRegisters.uvVarying + \", \" + dataReg2 + \".zwzw\\n\" +\n\t\t\tShaderCompilerHelper.getTex2DSampleCode(temp, sharedRegisters, this._normalTextureRegister2, this._texture2, shaderObject.useSmoothTextures, shaderObject.repeatTextures, shaderObject.useMipmapping, temp) +\n\t\t\t\"add \" + targetReg + \", \" + targetReg + \", \" + temp + \"\t\t\\n\" +\n\t\t\t\"mul \" + targetReg + \", \" + targetReg + \", \" + dataReg + \".x\t\\n\" +\n\t\t\t\"sub \" + targetReg + \".xyz, \" + targetReg + \".xyz, \" + sharedRegisters.commons + \".xxx\t\\n\" +\n\t\t\t\"nrm \" + targetReg + \".xyz, \" + targetReg + \".xyz\t\t\t\t\t\t\t\\n\";\n\t}\n}\n\nexport = NormalSimpleWaterMethod;","import NamedAssetBase\t\t\t\t= require(\"awayjs-core/lib/library/NamedAssetBase\");\n\nimport Camera\t\t\t\t\t\t= require(\"awayjs-display/lib/entities/Camera\");\n\nimport Stage\t\t\t\t\t\t= require(\"awayjs-stagegl/lib/base/Stage\");\n\nimport RenderableBase\t\t\t\t= require(\"awayjs-renderergl/lib/pool/RenderableBase\");\nimport ShadingMethodEvent\t\t\t= require(\"awayjs-renderergl/lib/events/ShadingMethodEvent\");\nimport ShaderObjectBase\t\t\t\t= require(\"awayjs-renderergl/lib/compilation/ShaderObjectBase\");\nimport ShaderRegisterCache\t\t\t= require(\"awayjs-renderergl/lib/compilation/ShaderRegisterCache\");\nimport ShaderRegisterData\t\t\t= require(\"awayjs-renderergl/lib/compilation/ShaderRegisterData\");\nimport ShaderRegisterElement\t\t= require(\"awayjs-renderergl/lib/compilation/ShaderRegisterElement\");\n\nimport MethodVO\t\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/data/MethodVO\");\n\n\n/**\n * ShadingMethodBase provides an abstract base method for shading methods, used by compiled passes to compile\n * the final shading program.\n */\nclass ShadingMethodBase extends NamedAssetBase\n{\n\t/**\n\t * Create a new ShadingMethodBase object.\n\t */\n\tconstructor()\n\t{\n\t\tsuper();\n\t}\n\n\tpublic iIsUsed(shaderObject:ShaderObjectBase):boolean\n\t{\n\t\treturn true;\n\t}\n\n\t/**\n\t * Initializes the properties for a MethodVO, including register and texture indices.\n\t *\n\t * @param methodVO The MethodVO object linking this method with the pass currently being compiled.\n\t *\n\t * @internal\n\t */\n\tpublic iInitVO(shaderObject:ShaderObjectBase, methodVO:MethodVO)\n\t{\n\n\t}\n\n\t/**\n\t * Initializes unchanging shader constants using the data from a MethodVO.\n\t *\n\t * @param methodVO The MethodVO object linking this method with the pass currently being compiled.\n\t *\n\t * @internal\n\t */\n\tpublic iInitConstants(shaderObject:ShaderObjectBase, methodVO:MethodVO)\n\t{\n\n\n\t}\n\n\t/**\n\t * Indicates whether or not this method expects normals in tangent space. Override for object-space normals.\n\t */\n\tpublic iUsesTangentSpace():boolean\n\t{\n\t\treturn true;\n\t}\n\n\t/**\n\t * Cleans up any resources used by the current object.\n\t */\n\tpublic dispose()\n\t{\n\n\t}\n\n\t/**\n\t * Resets the compilation state of the method.\n\t *\n\t * @internal\n\t */\n\tpublic iReset()\n\t{\n\t\tthis.iCleanCompilationData();\n\t}\n\n\t/**\n\t * Resets the method's state for compilation.\n\t *\n\t * @internal\n\t */\n\tpublic iCleanCompilationData()\n\t{\n\t}\n\n\t/**\n\t * Get the vertex shader code for this method.\n\t * @param vo The MethodVO object linking this method with the pass currently being compiled.\n\t * @param regCache The register cache used during the compilation.\n\t *\n\t * @internal\n\t */\n\tpublic iGetVertexCode(shaderObject:ShaderObjectBase, methodVO:MethodVO, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\treturn \"\";\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentCode(shaderObject:ShaderObjectBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\treturn null;\n\t}\n\n\t/**\n\t * Sets the render state for this method.\n\t *\n\t * @param methodVO The MethodVO object linking this method with the pass currently being compiled.\n\t * @param stage The Stage object currently used for rendering.\n\t *\n\t * @internal\n\t */\n\tpublic iActivate(shaderObject:ShaderObjectBase, methodVO:MethodVO, stage:Stage)\n\t{\n\n\t}\n\n\t/**\n\t * Sets the render state for a single renderable.\n\t *\n\t * @param vo The MethodVO object linking this method with the pass currently being compiled.\n\t * @param renderable The renderable currently being rendered.\n\t * @param stage The Stage object currently used for rendering.\n\t * @param camera The camera from which the scene is currently rendered.\n\t *\n\t * @internal\n\t */\n\tpublic iSetRenderState(shaderObject:ShaderObjectBase, methodVO:MethodVO, renderable:RenderableBase, stage:Stage, camera:Camera)\n\t{\n\n\t}\n\n\t/**\n\t * Clears the render state for this method.\n\t * @param vo The MethodVO object linking this method with the pass currently being compiled.\n\t * @param stage The Stage object currently used for rendering.\n\t *\n\t * @internal\n\t */\n\tpublic iDeactivate(shaderObject:ShaderObjectBase, methodVO:MethodVO, stage:Stage)\n\t{\n\n\t}\n\n\t/**\n\t * Marks the shader program as invalid, so it will be recompiled before the next render.\n\t *\n\t * @internal\n\t */\n\tpublic iInvalidateShaderProgram()\n\t{\n\t\tthis.dispatchEvent(new ShadingMethodEvent(ShadingMethodEvent.SHADER_INVALIDATED));\n\t}\n\n\t/**\n\t * Copies the state from a ShadingMethodBase object into the current object.\n\t */\n\tpublic copyFrom(method:ShadingMethodBase)\n\t{\n\t}\n}\n\nexport = ShadingMethodBase;","import Event\t\t\t\t\t\t\t= require(\"awayjs-core/lib/events/Event\");\nimport Texture2DBase\t\t\t\t\t= require(\"awayjs-core/lib/textures/Texture2DBase\");\n\nimport Camera\t\t\t\t\t\t\t= require(\"awayjs-display/lib/entities/Camera\");\nimport DirectionalLight\t\t\t\t\t= require(\"awayjs-display/lib/entities/DirectionalLight\");\nimport CascadeShadowMapper\t\t\t\t= require(\"awayjs-display/lib/materials/shadowmappers/CascadeShadowMapper\");\n\nimport Stage\t\t\t\t\t\t\t= require(\"awayjs-stagegl/lib/base/Stage\");\n\nimport RenderableBase\t\t\t\t\t= require(\"awayjs-renderergl/lib/pool/RenderableBase\");\nimport ShadingMethodEvent\t\t\t\t= require(\"awayjs-renderergl/lib/events/ShadingMethodEvent\");\nimport ShaderLightingObject\t\t\t\t= require(\"awayjs-renderergl/lib/compilation/ShaderLightingObject\");\nimport ShaderObjectBase\t\t\t\t\t= require(\"awayjs-renderergl/lib/compilation/ShaderObjectBase\");\nimport ShaderRegisterCache\t\t\t\t= require(\"awayjs-renderergl/lib/compilation/ShaderRegisterCache\");\nimport ShaderRegisterData\t\t\t\t= require(\"awayjs-renderergl/lib/compilation/ShaderRegisterData\");\nimport ShaderRegisterElement\t\t\t= require(\"awayjs-renderergl/lib/compilation/ShaderRegisterElement\");\nimport ShaderCompilerHelper\t\t\t\t= require(\"awayjs-renderergl/lib/utils/ShaderCompilerHelper\");\n\nimport MethodVO\t\t\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/data/MethodVO\");\nimport ShadowMapMethodBase\t\t\t\t= require(\"awayjs-methodmaterials/lib/methods/ShadowMapMethodBase\");\nimport ShadowMethodBase\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/methods/ShadowMethodBase\");\n\n/**\n * ShadowCascadeMethod is a shadow map method to apply cascade shadow mapping on materials.\n * Must be used with a DirectionalLight with a CascadeShadowMapper assigned to its shadowMapper property.\n *\n * @see away.lights.CascadeShadowMapper\n */\nclass ShadowCascadeMethod extends ShadowMapMethodBase\n{\n\tprivate _baseMethod:ShadowMethodBase;\n\tprivate _cascadeShadowMapper:CascadeShadowMapper;\n\tprivate _depthMapCoordVaryings:Array<ShaderRegisterElement>;\n\tprivate _cascadeProjections:Array<ShaderRegisterElement>;\n\n\t/**\n\t * Creates a new ShadowCascadeMethod object.\n\t *\n\t * @param shadowMethodBase The shadow map sampling method used to sample individual cascades (fe: ShadowHardMethod, ShadowSoftMethod)\n\t */\n\tconstructor(shadowMethodBase:ShadowMethodBase)\n\t{\n\t\tsuper(shadowMethodBase.castingLight);\n\n\t\tthis._baseMethod = shadowMethodBase;\n\t\tif (!(this._pCastingLight instanceof DirectionalLight))\n\t\t\tthrow new Error(\"ShadowCascadeMethod is only compatible with DirectionalLight\");\n\n\t\tthis._cascadeShadowMapper = <CascadeShadowMapper> this._pCastingLight.shadowMapper;\n\n\t\tif (!this._cascadeShadowMapper)\n\t\t\tthrow new Error(\"ShadowCascadeMethod requires a light that has a CascadeShadowMapper instance assigned to shadowMapper.\");\n\n\t\tthis._cascadeShadowMapper.addEventListener(Event.CHANGE, (event:Event) => this.onCascadeChange(event));\n\t\tthis._baseMethod.addEventListener(ShadingMethodEvent.SHADER_INVALIDATED, (event:ShadingMethodEvent) => this.onShaderInvalidated(event));\n\t}\n\n\t/**\n\t * The shadow map sampling method used to sample individual cascades. These are typically those used in conjunction\n\t * with a DirectionalShadowMapper.\n\t *\n\t * @see ShadowHardMethod\n\t * @see ShadowSoftMethod\n\t */\n\tpublic get baseMethod():ShadowMethodBase\n\t{\n\t\treturn this._baseMethod;\n\t}\n\n\tpublic set baseMethod(value:ShadowMethodBase)\n\t{\n\t\tif (this._baseMethod == value)\n\t\t\treturn;\n\n\t\tthis._baseMethod.removeEventListener(ShadingMethodEvent.SHADER_INVALIDATED, (event:ShadingMethodEvent) => this.onShaderInvalidated(event));\n\n\t\tthis._baseMethod = value;\n\n\t\tthis._baseMethod.addEventListener(ShadingMethodEvent.SHADER_INVALIDATED, (event:ShadingMethodEvent) => this.onShaderInvalidated(event));\n\n\t\tthis.iInvalidateShaderProgram();\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitVO(shaderObject:ShaderLightingObject, methodVO:MethodVO)\n\t{\n\t\tvar tempVO:MethodVO = new MethodVO(this._baseMethod);\n\t\tthis._baseMethod.iInitVO(shaderObject, tempVO);\n\n\t\tmethodVO.needsGlobalVertexPos = true;\n\t\tmethodVO.needsProjection = true;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitConstants(shaderObject:ShaderObjectBase, methodVO:MethodVO)\n\t{\n\t\tvar fragmentData:Array<number> = shaderObject.fragmentConstantData;\n\t\tvar vertexData:Array<number> = shaderObject.vertexConstantData;\n\t\tvar index:number = methodVO.fragmentConstantsIndex;\n\t\tfragmentData[index] = 1.0;\n\t\tfragmentData[index + 1] = 1/255.0;\n\t\tfragmentData[index + 2] = 1/65025.0;\n\t\tfragmentData[index + 3] = 1/16581375.0;\n\n\t\tfragmentData[index + 6] = .5;\n\t\tfragmentData[index + 7] = -.5;\n\n\t\tindex = methodVO.vertexConstantsIndex;\n\t\tvertexData[index] = .5;\n\t\tvertexData[index + 1] = -.5;\n\t\tvertexData[index + 2] = 0;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iCleanCompilationData()\n\t{\n\t\tsuper.iCleanCompilationData();\n\t\tthis._cascadeProjections = null;\n\t\tthis._depthMapCoordVaryings = null;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetVertexCode(shaderObject:ShaderObjectBase, methodVO:MethodVO, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = \"\";\n\t\tvar dataReg:ShaderRegisterElement = registerCache.getFreeVertexConstant();\n\n\t\tthis.initProjectionsRegs(registerCache);\n\t\tmethodVO.vertexConstantsIndex = dataReg.index*4;\n\n\t\tvar temp:ShaderRegisterElement = registerCache.getFreeVertexVectorTemp();\n\n\t\tfor (var i:number = 0; i < this._cascadeShadowMapper.numCascades; ++i) {\n\t\t\tcode += \"m44 \" + temp + \", \" + sharedRegisters.globalPositionVertex + \", \" + this._cascadeProjections[i] + \"\\n\" +\n\t\t\t\t\"add \" + this._depthMapCoordVaryings[i] + \", \" + temp + \", \" + dataReg + \".zzwz\\n\";\n\t\t}\n\n\t\treturn code;\n\t}\n\n\t/**\n\t * Creates the registers for the cascades' projection coordinates.\n\t */\n\tprivate initProjectionsRegs(registerCache:ShaderRegisterCache)\n\t{\n\t\tthis._cascadeProjections = new Array<ShaderRegisterElement>(this._cascadeShadowMapper.numCascades);\n\t\tthis._depthMapCoordVaryings = new Array<ShaderRegisterElement>(this._cascadeShadowMapper.numCascades);\n\n\t\tfor (var i:number = 0; i < this._cascadeShadowMapper.numCascades; ++i) {\n\t\t\tthis._depthMapCoordVaryings[i] = registerCache.getFreeVarying();\n\t\t\tthis._cascadeProjections[i] = registerCache.getFreeVertexConstant();\n\t\t\tregisterCache.getFreeVertexConstant();\n\t\t\tregisterCache.getFreeVertexConstant();\n\t\t\tregisterCache.getFreeVertexConstant();\n\t\t}\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentCode(shaderObject:ShaderObjectBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar numCascades:number = this._cascadeShadowMapper.numCascades;\n\t\tvar depthMapRegister:ShaderRegisterElement = registerCache.getFreeTextureReg();\n\t\tvar decReg:ShaderRegisterElement = registerCache.getFreeFragmentConstant();\n\t\tvar dataReg:ShaderRegisterElement = registerCache.getFreeFragmentConstant();\n\t\tvar planeDistanceReg:ShaderRegisterElement = registerCache.getFreeFragmentConstant();\n\t\tvar planeDistances:Array<string> = Array<string>( planeDistanceReg + \".x\", planeDistanceReg + \".y\", planeDistanceReg + \".z\", planeDistanceReg + \".w\" );\n\t\tvar code:string;\n\n\t\tmethodVO.fragmentConstantsIndex = decReg.index*4;\n\t\tmethodVO.texturesIndex = depthMapRegister.index;\n\n\t\tvar inQuad:ShaderRegisterElement = registerCache.getFreeFragmentVectorTemp();\n\t\tregisterCache.addFragmentTempUsages(inQuad, 1);\n\t\tvar uvCoord:ShaderRegisterElement = registerCache.getFreeFragmentVectorTemp();\n\t\tregisterCache.addFragmentTempUsages(uvCoord, 1);\n\n\t\t// assume lowest partition is selected, will be overwritten later otherwise\n\t\tcode = \"mov \" + uvCoord + \", \" + this._depthMapCoordVaryings[numCascades - 1] + \"\\n\";\n\n\t\tfor (var i:number = numCascades - 2; i >= 0; --i) {\n\t\t\tvar uvProjection:ShaderRegisterElement = this._depthMapCoordVaryings[i];\n\n\t\t\t// calculate if in texturemap (result == 0 or 1, only 1 for a single partition)\n\t\t\tcode += \"slt \" + inQuad + \".z, \" + sharedRegisters.projectionFragment + \".z, \" + planeDistances[i] + \"\\n\"; // z = x > minX, w = y > minY\n\n\t\t\tvar temp:ShaderRegisterElement = registerCache.getFreeFragmentVectorTemp();\n\n\t\t\t// linearly interpolate between old and new uv coords using predicate value == conditional toggle to new value if predicate == 1 (true)\n\t\t\tcode += \"sub \" + temp + \", \" + uvProjection + \", \" + uvCoord + \"\\n\" +\n\t\t\t\t\"mul \" + temp + \", \" + temp + \", \" + inQuad + \".z\\n\" +\n\t\t\t\t\"add \" + uvCoord + \", \" + uvCoord + \", \" + temp + \"\\n\";\n\t\t}\n\n\t\tregisterCache.removeFragmentTempUsage(inQuad);\n\n\t\tcode += \"div \" + uvCoord + \", \" + uvCoord + \", \" + uvCoord + \".w\\n\" +\n\t\t\t\"mul \" + uvCoord + \".xy, \" + uvCoord + \".xy, \" + dataReg + \".zw\\n\" +\n\t\t\t\"add \" + uvCoord + \".xy, \" + uvCoord + \".xy, \" + dataReg + \".zz\\n\";\n\n\t\tcode += this._baseMethod._iGetCascadeFragmentCode(shaderObject, methodVO, decReg, depthMapRegister, uvCoord, targetReg, registerCache, sharedRegisters) +\n\t\t\t\"add \" + targetReg + \".w, \" + targetReg + \".w, \" + dataReg + \".y\\n\";\n\n\t\tregisterCache.removeFragmentTempUsage(uvCoord);\n\n\t\treturn code;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iActivate(shaderObject:ShaderObjectBase, methodVO:MethodVO, stage:Stage)\n\t{\n\t\tstage.activateTexture(methodVO.texturesIndex, <Texture2DBase> this._pCastingLight.shadowMapper.depthMap);\n\n\t\tvar vertexData:Array<number> = shaderObject.vertexConstantData;\n\t\tvar vertexIndex:number = methodVO.vertexConstantsIndex;\n\n\t\tshaderObject.vertexConstantData[methodVO.vertexConstantsIndex + 3] = -1/(this._cascadeShadowMapper.depth*this._pEpsilon);\n\n\t\tvar numCascades:number = this._cascadeShadowMapper.numCascades;\n\t\tvertexIndex += 4;\n\t\tfor (var k:number = 0; k < numCascades; ++k) {\n\t\t\tthis._cascadeShadowMapper.getDepthProjections(k).copyRawDataTo(vertexData, vertexIndex, true);\n\t\t\tvertexIndex += 16;\n\t\t}\n\n\t\tvar fragmentData:Array<number> = shaderObject.fragmentConstantData;\n\t\tvar fragmentIndex:number = methodVO.fragmentConstantsIndex;\n\t\tfragmentData[fragmentIndex + 5] = 1 - this._pAlpha;\n\n\t\tvar nearPlaneDistances:Array<number> = this._cascadeShadowMapper._iNearPlaneDistances;\n\n\t\tfragmentIndex += 8;\n\t\tfor (var i:number = 0; i < numCascades; ++i)\n\t\t\tfragmentData[fragmentIndex + i] = nearPlaneDistances[i];\n\n\t\tthis._baseMethod.iActivateForCascade(shaderObject, methodVO, stage);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iSetRenderState(shaderObject:ShaderObjectBase, methodVO:MethodVO, renderable:RenderableBase, stage:Stage, camera:Camera)\n\t{\n\t}\n\n\t/**\n\t * Called when the shadow mappers cascade configuration changes.\n\t */\n\tprivate onCascadeChange(event:Event)\n\t{\n\t\tthis.iInvalidateShaderProgram();\n\t}\n\n\t/**\n\t * Called when the base method's shader code is invalidated.\n\t */\n\tprivate onShaderInvalidated(event:ShadingMethodEvent)\n\t{\n\t\tthis.iInvalidateShaderProgram();\n\t}\n}\n\nexport = ShadowCascadeMethod;","import BitmapData\t\t\t\t\t\t= require(\"awayjs-core/lib/base/BitmapData\");\nimport BitmapTexture\t\t\t\t\t= require(\"awayjs-core/lib/textures/BitmapTexture\");\n\nimport DirectionalLight\t\t\t\t\t= require(\"awayjs-display/lib/entities/DirectionalLight\");\n\nimport Stage\t\t\t\t\t\t\t= require(\"awayjs-stagegl/lib/base/Stage\");\n\nimport ShaderLightingObject\t\t\t\t= require(\"awayjs-renderergl/lib/compilation/ShaderLightingObject\");\nimport ShaderObjectBase\t\t\t\t\t= require(\"awayjs-renderergl/lib/compilation/ShaderObjectBase\");\nimport ShaderRegisterCache\t\t\t\t= require(\"awayjs-renderergl/lib/compilation/ShaderRegisterCache\");\nimport ShaderRegisterData\t\t\t\t= require(\"awayjs-renderergl/lib/compilation/ShaderRegisterData\");\nimport ShaderRegisterElement\t\t\t= require(\"awayjs-renderergl/lib/compilation/ShaderRegisterElement\");\n\nimport MethodVO\t\t\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/data/MethodVO\");\nimport ShadowMethodBase\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/methods/ShadowMethodBase\");\n\n/**\n * ShadowDitheredMethod provides a soft shadowing technique by randomly distributing sample points differently for each fragment.\n */\nclass ShadowDitheredMethod extends ShadowMethodBase\n{\n\tprivate static _grainTexture:BitmapTexture;\n\tprivate static _grainUsages:number /*int*/;\n\tprivate static _grainBitmapData:BitmapData;\n\tprivate _depthMapSize:number /*int*/;\n\tprivate _range:number;\n\tprivate _numSamples:number /*int*/;\n\n\t/**\n\t * Creates a new ShadowDitheredMethod object.\n\t * @param castingLight The light casting the shadows\n\t * @param numSamples The amount of samples to take for dithering. Minimum 1, maximum 24.\n\t */\n\tconstructor(castingLight:DirectionalLight, numSamples:number /*int*/ = 4, range:number = 1)\n\t{\n\t\tsuper(castingLight);\n\n\t\tthis._depthMapSize = this._pCastingLight.shadowMapper.depthMapSize;\n\n\t\tthis.numSamples = numSamples;\n\t\tthis.range = range;\n\n\t\t++ShadowDitheredMethod._grainUsages;\n\n\t\tif (!ShadowDitheredMethod._grainTexture)\n\t\t\tthis.initGrainTexture();\n\t}\n\n\t/**\n\t * The amount of samples to take for dithering. Minimum 1, maximum 24. The actual maximum may depend on the\n\t * complexity of the shader.\n\t */\n\tpublic get numSamples():number /*int*/\n\t{\n\t\treturn this._numSamples;\n\t}\n\n\tpublic set numSamples(value:number /*int*/)\n\t{\n\t\tthis._numSamples = value;\n\t\tif (this._numSamples < 1)\n\t\t\tthis._numSamples = 1; else if (this._numSamples > 24)\n\t\t\tthis._numSamples = 24;\n\t\tthis.iInvalidateShaderProgram();\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitVO(shaderObject:ShaderLightingObject, methodVO:MethodVO)\n\t{\n\t\tsuper.iInitVO(shaderObject, methodVO);\n\n\t\tmethodVO.needsProjection = true;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitConstants(shaderObject:ShaderObjectBase, methodVO:MethodVO)\n\t{\n\t\tsuper.iInitConstants(shaderObject, methodVO);\n\n\t\tvar fragmentData:Array<number> = shaderObject.fragmentConstantData;\n\t\tvar index:number /*int*/ = methodVO.fragmentConstantsIndex;\n\t\tfragmentData[index + 8] = 1/this._numSamples;\n\t}\n\n\t/**\n\t * The range in the shadow map in which to distribute the samples.\n\t */\n\tpublic get range():number\n\t{\n\t\treturn this._range*2;\n\t}\n\n\tpublic set range(value:number)\n\t{\n\t\tthis._range = value/2;\n\t}\n\n\t/**\n\t * Creates a texture containing the dithering noise texture.\n\t */\n\tprivate initGrainTexture()\n\t{\n\t\tShadowDitheredMethod._grainBitmapData = new BitmapData(64, 64, false);\n\t\tvar vec:Array<number> /*uint*/ = new Array<number>();\n\t\tvar len:number /*uint*/ = 4096;\n\t\tvar step:number = 1/(this._depthMapSize*this._range);\n\t\tvar r:number, g:number;\n\n\t\tfor (var i:number /*uint*/ = 0; i < len; ++i) {\n\t\t\tr = 2*(Math.random() - .5);\n\t\t\tg = 2*(Math.random() - .5);\n\t\t\tif (r < 0)\n\t\t\t\tr -= step; else\n\t\t\t\tr += step;\n\t\t\tif (g < 0)\n\t\t\t\tg -= step; else\n\t\t\t\tg += step;\n\t\t\tif (r > 1)\n\t\t\t\tr = 1; else if (r < -1)\n\t\t\t\tr = -1;\n\t\t\tif (g > 1)\n\t\t\t\tg = 1; else if (g < -1)\n\t\t\t\tg = -1;\n\t\t\tvec[i] = (Math.floor((r*.5 + .5)*0xff) << 16) | (Math.floor((g*.5 + .5)*0xff) << 8);\n\t\t}\n\n\t\tShadowDitheredMethod._grainBitmapData.setVector(ShadowDitheredMethod._grainBitmapData.rect, vec);\n\t\tShadowDitheredMethod._grainTexture = new BitmapTexture(ShadowDitheredMethod._grainBitmapData);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic dispose()\n\t{\n\t\tif (--ShadowDitheredMethod._grainUsages == 0) {\n\t\t\tShadowDitheredMethod._grainTexture.dispose();\n\t\t\tShadowDitheredMethod._grainBitmapData.dispose();\n\t\t\tShadowDitheredMethod._grainTexture = null;\n\t\t}\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iActivate(shaderObject:ShaderObjectBase, methodVO:MethodVO, stage:Stage)\n\t{\n\t\tsuper.iActivate(shaderObject, methodVO, stage);\n\n\t\tvar data:Array<number> = shaderObject.fragmentConstantData;\n\t\tvar index:number /*uint*/ = methodVO.fragmentConstantsIndex;\n\t\tdata[index + 9] = (stage.width - 1)/63;\n\t\tdata[index + 10] = (stage.height - 1)/63;\n\t\tdata[index + 11] = 2*this._range/this._depthMapSize;\n\n\t\tstage.activateTexture(methodVO.texturesIndex + 1, ShadowDitheredMethod._grainTexture);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic _pGetPlanarFragmentCode(methodVO:MethodVO, targetReg:ShaderRegisterElement, regCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar depthMapRegister:ShaderRegisterElement = regCache.getFreeTextureReg();\n\t\tvar decReg:ShaderRegisterElement = regCache.getFreeFragmentConstant();\n\t\tvar dataReg:ShaderRegisterElement = regCache.getFreeFragmentConstant();\n\t\tvar customDataReg:ShaderRegisterElement = regCache.getFreeFragmentConstant();\n\n\t\tmethodVO.fragmentConstantsIndex = decReg.index*4;\n\t\tmethodVO.texturesIndex = depthMapRegister.index;\n\n\t\treturn this.getSampleCode(customDataReg, depthMapRegister, decReg, targetReg, regCache, sharedRegisters);\n\t}\n\n\t/**\n\t * Get the actual shader code for shadow mapping\n\t * @param regCache The register cache managing the registers.\n\t * @param depthMapRegister The texture register containing the depth map.\n\t * @param decReg The register containing the depth map decoding data.\n\t * @param targetReg The target register to add the shadow coverage.\n\t */\n\tprivate getSampleCode(customDataReg:ShaderRegisterElement, depthMapRegister:ShaderRegisterElement, decReg:ShaderRegisterElement, targetReg:ShaderRegisterElement, regCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = \"\";\n\t\tvar grainRegister:ShaderRegisterElement = regCache.getFreeTextureReg();\n\t\tvar uvReg:ShaderRegisterElement = regCache.getFreeFragmentVectorTemp();\n\t\tvar numSamples:number /*int*/ = this._numSamples;\n\t\tregCache.addFragmentTempUsages(uvReg, 1);\n\n\t\tvar temp:ShaderRegisterElement = regCache.getFreeFragmentVectorTemp();\n\n\t\tvar projectionReg:ShaderRegisterElement = sharedRegisters.projectionFragment;\n\n\t\tcode += \"div \" + uvReg + \", \" + projectionReg + \", \" + projectionReg + \".w\\n\" + \"mul \" + uvReg + \".xy, \" + uvReg + \".xy, \" + customDataReg + \".yz\\n\";\n\n\t\twhile (numSamples > 0) {\n\t\t\tif (numSamples == this._numSamples)\n\t\t\t\tcode += \"tex \" + uvReg + \", \" + uvReg + \", \" + grainRegister + \" <2d,nearest,repeat,mipnone>\\n\";\n\t\t\telse\n\t\t\t\tcode += \"tex \" + uvReg + \", \" + uvReg + \".zwxy, \" + grainRegister + \" <2d,nearest,repeat,mipnone>\\n\";\n\n\t\t\t// keep grain in uvReg.zw\n\t\t\tcode += \"sub \" + uvReg + \".zw, \" + uvReg + \".xy, fc0.xx\\n\" + // uv-.5\n\t\t\t\t\"mul \" + uvReg + \".zw, \" + uvReg + \".zw, \" + customDataReg + \".w\\n\"; // (tex unpack scale and tex scale in one)\n\n\t\t\tif (numSamples == this._numSamples) {\n\t\t\t\t// first sample\n\t\t\t\tcode += \"add \" + uvReg + \".xy, \" + uvReg + \".zw, \" + this._pDepthMapCoordReg + \".xy\\n\" +\n\t\t\t\t\t\"tex \" + temp + \", \" + uvReg + \", \" + depthMapRegister + \" <2d,nearest,clamp,mipnone>\\n\" +\n\t\t\t\t\t\"dp4 \" + temp + \".z, \" + temp + \", \" + decReg + \"\\n\" +\n\t\t\t\t\t\"slt \" + targetReg + \".w, \" + this._pDepthMapCoordReg + \".z, \" + temp + \".z\\n\"; // 0 if in shadow\n\t\t\t} else {\n\t\t\t\tcode += this.addSample(uvReg, depthMapRegister, decReg, targetReg, regCache);\n\t\t\t}\n\n\t\t\tif (numSamples > 4)\n\t\t\t\tcode += \"add \" + uvReg + \".xy, \" + uvReg + \".xy, \" + uvReg + \".zw\\n\" + this.addSample(uvReg, depthMapRegister, decReg, targetReg, regCache);\n\n\t\t\tif (numSamples > 1)\n\t\t\t\tcode += \"sub \" + uvReg + \".xy, \" + this._pDepthMapCoordReg + \".xy, \" + uvReg + \".zw\\n\" + this.addSample(uvReg, depthMapRegister, decReg, targetReg, regCache);\n\n\t\t\tif (numSamples > 5)\n\t\t\t\tcode += \"sub \" + uvReg + \".xy, \" + uvReg + \".xy, \" + uvReg + \".zw\\n\" + this.addSample(uvReg, depthMapRegister, decReg, targetReg, regCache);\n\n\t\t\tif (numSamples > 2) {\n\t\t\t\tcode += \"neg \" + uvReg + \".w, \" + uvReg + \".w\\n\"; // will be rotated 90 degrees when being accessed as wz\n\t\t\t\tcode += \"add \" + uvReg + \".xy, \" + uvReg + \".wz, \" + this._pDepthMapCoordReg + \".xy\\n\" + this.addSample(uvReg, depthMapRegister, decReg, targetReg, regCache);\n\t\t\t}\n\n\t\t\tif (numSamples > 6)\n\t\t\t\tcode += \"add \" + uvReg + \".xy, \" + uvReg + \".xy, \" + uvReg + \".wz\\n\" + this.addSample(uvReg, depthMapRegister, decReg, targetReg, regCache);\n\n\t\t\tif (numSamples > 3)\n\t\t\t\tcode += \"sub \" + uvReg + \".xy, \" + this._pDepthMapCoordReg + \".xy, \" + uvReg + \".wz\\n\" + this.addSample(uvReg, depthMapRegister, decReg, targetReg, regCache);\n\n\t\t\tif (numSamples > 7)\n\t\t\t\tcode += \"sub \" + uvReg + \".xy, \" + uvReg + \".xy, \" + uvReg + \".wz\\n\" + this.addSample(uvReg, depthMapRegister, decReg, targetReg, regCache);\n\n\t\t\tnumSamples -= 8;\n\t\t}\n\n\t\tregCache.removeFragmentTempUsage(uvReg);\n\t\tcode += \"mul \" + targetReg + \".w, \" + targetReg + \".w, \" + customDataReg + \".x\\n\"; // average\n\t\treturn code;\n\t}\n\n\t/**\n\t * Adds the code for another tap to the shader code.\n\t * @param uvReg The uv register for the tap.\n\t * @param depthMapRegister The texture register containing the depth map.\n\t * @param decReg The register containing the depth map decoding data.\n\t * @param targetReg The target register to add the tap comparison result.\n\t * @param regCache The register cache managing the registers.\n\t * @return\n\t */\n\tprivate addSample(uvReg:ShaderRegisterElement, depthMapRegister:ShaderRegisterElement, decReg:ShaderRegisterElement, targetReg:ShaderRegisterElement, regCache:ShaderRegisterCache):string\n\t{\n\t\tvar temp:ShaderRegisterElement = regCache.getFreeFragmentVectorTemp();\n\n\t\treturn \"tex \" + temp + \", \" + uvReg + \", \" + depthMapRegister + \" <2d,nearest,clamp,mipnone>\\n\" +\n\t\t\t\"dp4 \" + temp + \".z, \" + temp + \", \" + decReg + \"\\n\" +\n\t\t\t\"slt \" + temp + \".z, \" + this._pDepthMapCoordReg + \".z, \" + temp + \".z\\n\" + // 0 if in shadow\n\t\t\t\"add \" + targetReg + \".w, \" + targetReg + \".w, \" + temp + \".z\\n\";\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iActivateForCascade(shaderObject:ShaderObjectBase, methodVO:MethodVO, stage:Stage)\n\t{\n\t\tvar data:Array<number> = shaderObject.fragmentConstantData;\n\t\tvar index:number /*uint*/ = methodVO.secondaryFragmentConstantsIndex;\n\t\tdata[index] = 1/this._numSamples;\n\t\tdata[index + 1] = (stage.width - 1)/63;\n\t\tdata[index + 2] = (stage.height - 1)/63;\n\t\tdata[index + 3] = 2*this._range/this._depthMapSize;\n\n\t\tstage.activateTexture(methodVO.texturesIndex + 1, ShadowDitheredMethod._grainTexture);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic _iGetCascadeFragmentCode(shaderObject:ShaderObjectBase, methodVO:MethodVO, decodeRegister:ShaderRegisterElement, depthTexture:ShaderRegisterElement, depthProjection:ShaderRegisterElement, targetRegister:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tthis._pDepthMapCoordReg = depthProjection;\n\n\t\tvar dataReg:ShaderRegisterElement = registerCache.getFreeFragmentConstant();\n\t\tmethodVO.secondaryFragmentConstantsIndex = dataReg.index*4;\n\n\t\treturn this.getSampleCode(dataReg, depthTexture, decodeRegister, targetRegister, registerCache, sharedRegisters);\n\t}\n}\n\nexport = ShadowDitheredMethod;","import DirectionalLight\t\t\t\t\t= require(\"awayjs-display/lib/entities/DirectionalLight\");\n\nimport Stage\t\t\t\t\t\t\t= require(\"awayjs-stagegl/lib/base/Stage\");\n\nimport ShaderLightingObject\t\t\t\t= require(\"awayjs-renderergl/lib/compilation/ShaderLightingObject\");\nimport ShaderObjectBase\t\t\t\t\t= require(\"awayjs-renderergl/lib/compilation/ShaderObjectBase\");\nimport ShaderRegisterCache\t\t\t\t= require(\"awayjs-renderergl/lib/compilation/ShaderRegisterCache\");\nimport ShaderRegisterData\t\t\t\t= require(\"awayjs-renderergl/lib/compilation/ShaderRegisterData\");\nimport ShaderRegisterElement\t\t\t= require(\"awayjs-renderergl/lib/compilation/ShaderRegisterElement\");\n\nimport MethodVO\t\t\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/data/MethodVO\");\nimport ShadowMethodBase\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/methods/ShadowMethodBase\");\n\n/**\n * ShadowFilteredMethod provides a softened shadowing technique by bilinearly interpolating shadow comparison\n * results of neighbouring pixels.\n */\nclass ShadowFilteredMethod extends ShadowMethodBase\n{\n\t/**\n\t * Creates a new DiffuseBasicMethod object.\n\t *\n\t * @param castingLight The light casting the shadow\n\t */\n\tconstructor(castingLight:DirectionalLight)\n\t{\n\t\tsuper(castingLight);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitConstants(shaderObject:ShaderLightingObject, methodVO:MethodVO)\n\t{\n\t\tsuper.iInitConstants(shaderObject, methodVO);\n\n\t\tvar fragmentData:Array<number> = shaderObject.fragmentConstantData;\n\t\tvar index:number /*int*/ = methodVO.fragmentConstantsIndex;\n\t\tfragmentData[index + 8] = .5;\n\t\tvar size:number /*int*/ = this.castingLight.shadowMapper.depthMapSize;\n\t\tfragmentData[index + 9] = size;\n\t\tfragmentData[index + 10] = 1/size;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic _pGetPlanarFragmentCode(methodVO:MethodVO, targetReg:ShaderRegisterElement, regCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar depthMapRegister:ShaderRegisterElement = regCache.getFreeTextureReg();\n\t\tvar decReg:ShaderRegisterElement = regCache.getFreeFragmentConstant();\n\t\tvar dataReg:ShaderRegisterElement = regCache.getFreeFragmentConstant();\n\t\t// TODO: not used\n\t\tdataReg = dataReg;\n\t\tvar customDataReg:ShaderRegisterElement = regCache.getFreeFragmentConstant();\n\t\tvar depthCol:ShaderRegisterElement = regCache.getFreeFragmentVectorTemp();\n\t\tvar uvReg:ShaderRegisterElement;\n\t\tvar code:string = \"\";\n\t\tmethodVO.fragmentConstantsIndex = decReg.index*4;\n\n\t\tregCache.addFragmentTempUsages(depthCol, 1);\n\n\t\tuvReg = regCache.getFreeFragmentVectorTemp();\n\t\tregCache.addFragmentTempUsages(uvReg, 1);\n\n\t\tcode += \"mov \" + uvReg + \", \" + this._pDepthMapCoordReg + \"\\n\" +\n\n\t\t\t\"tex \" + depthCol + \", \" + this._pDepthMapCoordReg + \", \" + depthMapRegister + \" <2d, nearest, clamp>\\n\" + \"dp4 \" + depthCol + \".z, \" + depthCol + \", \" + decReg + \"\\n\" + \"slt \" + uvReg + \".z, \" + this._pDepthMapCoordReg + \".z, \" + depthCol + \".z\\n\" +   // 0 if in shadow\n\n\t\t\t\"add \" + uvReg + \".x, \" + this._pDepthMapCoordReg + \".x, \" + customDataReg + \".z\\n\" + \t// (1, 0)\n\t\t\t\"tex \" + depthCol + \", \" + uvReg + \", \" + depthMapRegister + \" <2d, nearest, clamp>\\n\" + \"dp4 \" + depthCol + \".z, \" + depthCol + \", \" + decReg + \"\\n\" + \"slt \" + uvReg + \".w, \" + this._pDepthMapCoordReg + \".z, \" + depthCol + \".z\\n\" +   // 0 if in shadow\n\n\t\t\t\"mul \" + depthCol + \".x, \" + this._pDepthMapCoordReg + \".x, \" + customDataReg + \".y\\n\" + \"frc \" + depthCol + \".x, \" + depthCol + \".x\\n\" + \"sub \" + uvReg + \".w, \" + uvReg + \".w, \" + uvReg + \".z\\n\" + \"mul \" + uvReg + \".w, \" + uvReg + \".w, \" + depthCol + \".x\\n\" + \"add \" + targetReg + \".w, \" + uvReg + \".z, \" + uvReg + \".w\\n\" +\n\n\t\t\t\"mov \" + uvReg + \".x, \" + this._pDepthMapCoordReg + \".x\\n\" + \"add \" + uvReg + \".y, \" + this._pDepthMapCoordReg + \".y, \" + customDataReg + \".z\\n\" +\t// (0, 1)\n\t\t\t\"tex \" + depthCol + \", \" + uvReg + \", \" + depthMapRegister + \" <2d, nearest, clamp>\\n\" + \"dp4 \" + depthCol + \".z, \" + depthCol + \", \" + decReg + \"\\n\" + \"slt \" + uvReg + \".z, \" + this._pDepthMapCoordReg + \".z, \" + depthCol + \".z\\n\" +   // 0 if in shadow\n\n\t\t\t\"add \" + uvReg + \".x, \" + this._pDepthMapCoordReg + \".x, \" + customDataReg + \".z\\n\" +\t// (1, 1)\n\t\t\t\"tex \" + depthCol + \", \" + uvReg + \", \" + depthMapRegister + \" <2d, nearest, clamp>\\n\" + \"dp4 \" + depthCol + \".z, \" + depthCol + \", \" + decReg + \"\\n\" + \"slt \" + uvReg + \".w, \" + this._pDepthMapCoordReg + \".z, \" + depthCol + \".z\\n\" +   // 0 if in shadow\n\n\t\t\t// recalculate fraction, since we ran out of registers :(\n\t\t\t\"mul \" + depthCol + \".x, \" + this._pDepthMapCoordReg + \".x, \" + customDataReg + \".y\\n\" + \"frc \" + depthCol + \".x, \" + depthCol + \".x\\n\" + \"sub \" + uvReg + \".w, \" + uvReg + \".w, \" + uvReg + \".z\\n\" + \"mul \" + uvReg + \".w, \" + uvReg + \".w, \" + depthCol + \".x\\n\" + \"add \" + uvReg + \".w, \" + uvReg + \".z, \" + uvReg + \".w\\n\" +\n\n\t\t\t\"mul \" + depthCol + \".x, \" + this._pDepthMapCoordReg + \".y, \" + customDataReg + \".y\\n\" + \"frc \" + depthCol + \".x, \" + depthCol + \".x\\n\" + \"sub \" + uvReg + \".w, \" + uvReg + \".w, \" + targetReg + \".w\\n\" + \"mul \" + uvReg + \".w, \" + uvReg + \".w, \" + depthCol + \".x\\n\" + \"add \" + targetReg + \".w, \" + targetReg + \".w, \" + uvReg + \".w\\n\";\n\n\t\tregCache.removeFragmentTempUsage(depthCol);\n\t\tregCache.removeFragmentTempUsage(uvReg);\n\n\t\tmethodVO.texturesIndex = depthMapRegister.index;\n\n\t\treturn code;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iActivateForCascade(shaderObject:ShaderObjectBase, methodVO:MethodVO, stage:Stage)\n\t{\n\t\tvar size:number /*int*/ = this.castingLight.shadowMapper.depthMapSize;\n\t\tvar index:number /*int*/ = methodVO.secondaryFragmentConstantsIndex;\n\t\tvar data:Array<number> = shaderObject.fragmentConstantData;\n\t\tdata[index] = size;\n\t\tdata[index + 1] = 1/size;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic _iGetCascadeFragmentCode(shaderObject:ShaderObjectBase, methodVO:MethodVO, decodeRegister:ShaderRegisterElement, depthTexture:ShaderRegisterElement, depthProjection:ShaderRegisterElement, targetRegister:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string;\n\t\tvar dataReg:ShaderRegisterElement = registerCache.getFreeFragmentConstant();\n\t\tmethodVO.secondaryFragmentConstantsIndex = dataReg.index*4;\n\t\tvar temp:ShaderRegisterElement = registerCache.getFreeFragmentVectorTemp();\n\t\tregisterCache.addFragmentTempUsages(temp, 1);\n\t\tvar predicate:ShaderRegisterElement = registerCache.getFreeFragmentVectorTemp();\n\t\tregisterCache.addFragmentTempUsages(predicate, 1);\n\n\t\tcode = \"tex \" + temp + \", \" + depthProjection + \", \" + depthTexture + \" <2d, nearest, clamp>\\n\" + \"dp4 \" + temp + \".z, \" + temp + \", \" + decodeRegister + \"\\n\" + \"slt \" + predicate + \".x, \" + depthProjection + \".z, \" + temp + \".z\\n\" +\n\n\t\t\t\"add \" + depthProjection + \".x, \" + depthProjection + \".x, \" + dataReg + \".y\\n\" + \"tex \" + temp + \", \" + depthProjection + \", \" + depthTexture + \" <2d, nearest, clamp>\\n\" + \"dp4 \" + temp + \".z, \" + temp + \", \" + decodeRegister + \"\\n\" + \"slt \" + predicate + \".z, \" + depthProjection + \".z, \" + temp + \".z\\n\" +\n\n\t\t\t\"add \" + depthProjection + \".y, \" + depthProjection + \".y, \" + dataReg + \".y\\n\" + \"tex \" + temp + \", \" + depthProjection + \", \" + depthTexture + \" <2d, nearest, clamp>\\n\" + \"dp4 \" + temp + \".z, \" + temp + \", \" + decodeRegister + \"\\n\" + \"slt \" + predicate + \".w, \" + depthProjection + \".z, \" + temp + \".z\\n\" +\n\n\t\t\t\"sub \" + depthProjection + \".x, \" + depthProjection + \".x, \" + dataReg + \".y\\n\" + \"tex \" + temp + \", \" + depthProjection + \", \" + depthTexture + \" <2d, nearest, clamp>\\n\" + \"dp4 \" + temp + \".z, \" + temp + \", \" + decodeRegister + \"\\n\" + \"slt \" + predicate + \".y, \" + depthProjection + \".z, \" + temp + \".z\\n\" +\n\n\t\t\t\"mul \" + temp + \".xy, \" + depthProjection + \".xy, \" + dataReg + \".x\\n\" + \"frc \" + temp + \".xy, \" + temp + \".xy\\n\" +\n\n\t\t\t// some strange register juggling to prevent agal bugging out\n\t\t\t\"sub \" + depthProjection + \", \" + predicate + \".xyzw, \" + predicate + \".zwxy\\n\" + \"mul \" + depthProjection + \", \" + depthProjection + \", \" + temp + \".x\\n\" +\n\n\t\t\t\"add \" + predicate + \".xy, \" + predicate + \".xy, \" + depthProjection + \".zw\\n\" +\n\n\t\t\t\"sub \" + predicate + \".y, \" + predicate + \".y, \" + predicate + \".x\\n\" + \"mul \" + predicate + \".y, \" + predicate + \".y, \" + temp + \".y\\n\" + \"add \" + targetRegister + \".w, \" + predicate + \".x, \" + predicate + \".y\\n\";\n\n\t\tregisterCache.removeFragmentTempUsage(temp);\n\t\tregisterCache.removeFragmentTempUsage(predicate);\n\t\treturn code;\n\t}\n}\n\nexport = ShadowFilteredMethod;","import LightBase\t\t\t\t\t= require(\"awayjs-display/lib/base/LightBase\");\n\nimport Stage\t\t\t\t\t\t= require(\"awayjs-stagegl/lib/base/Stage\");\n\nimport ShaderObjectBase\t\t\t\t= require(\"awayjs-renderergl/lib/compilation/ShaderObjectBase\");\nimport ShaderRegisterCache\t\t\t= require(\"awayjs-renderergl/lib/compilation/ShaderRegisterCache\");\nimport ShaderRegisterData\t\t\t= require(\"awayjs-renderergl/lib/compilation/ShaderRegisterData\");\nimport ShaderRegisterElement\t\t= require(\"awayjs-renderergl/lib/compilation/ShaderRegisterElement\");\n\nimport MethodVO\t\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/data/MethodVO\");\nimport ShadowMethodBase\t\t\t\t= require(\"awayjs-methodmaterials/lib/methods/ShadowMethodBase\");\n\n/**\n * ShadowHardMethod provides the cheapest shadow map method by using a single tap without any filtering.\n */\nclass ShadowHardMethod extends ShadowMethodBase\n{\n\t/**\n\t * Creates a new ShadowHardMethod object.\n\t */\n\tconstructor(castingLight:LightBase)\n\t{\n\t\tsuper(castingLight);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic _pGetPlanarFragmentCode(methodVO:MethodVO, targetReg:ShaderRegisterElement, regCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar depthMapRegister:ShaderRegisterElement = regCache.getFreeTextureReg();\n\t\tvar decReg:ShaderRegisterElement = regCache.getFreeFragmentConstant();\n\n\t\t// needs to be reserved anyway. DO NOT REMOVE\n\t\tvar dataReg:ShaderRegisterElement = regCache.getFreeFragmentConstant();\n\n\t\tvar depthCol:ShaderRegisterElement = regCache.getFreeFragmentVectorTemp();\n\t\tvar code:string = \"\";\n\n\t\tmethodVO.fragmentConstantsIndex = decReg.index*4;\n\t\tmethodVO.texturesIndex = depthMapRegister.index;\n\n\t\tcode += \"tex \" + depthCol + \", \" + this._pDepthMapCoordReg + \", \" + depthMapRegister + \" <2d, nearest, clamp>\\n\" +\n\t\t\t\"dp4 \" + depthCol + \".z, \" + depthCol + \", \" + decReg + \"\\n\" +\n\t\t\t\"slt \" + targetReg + \".w, \" + this._pDepthMapCoordReg + \".z, \" + depthCol + \".z\\n\"; // 0 if in shadow\n\n\t\treturn code;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic _pGetPointFragmentCode(methodVO:MethodVO, targetReg:ShaderRegisterElement, regCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar depthMapRegister:ShaderRegisterElement = regCache.getFreeTextureReg();\n\t\tvar decReg:ShaderRegisterElement = regCache.getFreeFragmentConstant();\n\t\tvar epsReg:ShaderRegisterElement = regCache.getFreeFragmentConstant();\n\t\tvar posReg:ShaderRegisterElement = regCache.getFreeFragmentConstant();\n\t\tvar depthSampleCol:ShaderRegisterElement = regCache.getFreeFragmentVectorTemp();\n\t\tregCache.addFragmentTempUsages(depthSampleCol, 1);\n\t\tvar lightDir:ShaderRegisterElement = regCache.getFreeFragmentVectorTemp();\n\t\tvar code:string = \"\";\n\n\t\tmethodVO.fragmentConstantsIndex = decReg.index*4;\n\t\tmethodVO.texturesIndex = depthMapRegister.index;\n\n\t\tcode += \"sub \" + lightDir + \", \" + sharedRegisters.globalPositionVarying + \", \" + posReg + \"\\n\" +\n\t\t\t\"dp3 \" + lightDir + \".w, \" + lightDir + \".xyz, \" + lightDir + \".xyz\\n\" +\n\t\t\t\"mul \" + lightDir + \".w, \" + lightDir + \".w, \" + posReg + \".w\\n\" +\n\t\t\t\"nrm \" + lightDir + \".xyz, \" + lightDir + \".xyz\\n\" +\n\n\t\t\t\"tex \" + depthSampleCol + \", \" + lightDir + \", \" + depthMapRegister + \" <cube, nearest, clamp>\\n\" +\n\t\t\t\"dp4 \" + depthSampleCol + \".z, \" + depthSampleCol + \", \" + decReg + \"\\n\" +\n\t\t\t\"add \" + targetReg + \".w, \" + lightDir + \".w, \" + epsReg + \".x\\n\" +    // offset by epsilon\n\n\t\t\t\"slt \" + targetReg + \".w, \" + targetReg + \".w, \" + depthSampleCol + \".z\\n\"; // 0 if in shadow\n\n\t\tregCache.removeFragmentTempUsage(depthSampleCol);\n\n\t\treturn code;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic _iGetCascadeFragmentCode(shaderObject:ShaderObjectBase, methodVO:MethodVO, decodeRegister:ShaderRegisterElement, depthTexture:ShaderRegisterElement, depthProjection:ShaderRegisterElement, targetRegister:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar temp:ShaderRegisterElement = registerCache.getFreeFragmentVectorTemp();\n\t\treturn \"tex \" + temp + \", \" + depthProjection + \", \" + depthTexture + \" <2d, nearest, clamp>\\n\" +\n\t\t\t\"dp4 \" + temp + \".z, \" + temp + \", \" + decodeRegister + \"\\n\" +\n\t\t\t\"slt \" + targetRegister + \".w, \" + depthProjection + \".z, \" + temp + \".z\\n\"; // 0 if in shadow\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iActivateForCascade(shaderObject:ShaderObjectBase, methodVO:MethodVO, stage:Stage)\n\t{\n\t}\n}\n\nexport = ShadowHardMethod;","import AssetType\t\t\t\t\t= require(\"awayjs-core/lib/library/AssetType\");\nimport IAsset\t\t\t\t\t\t= require(\"awayjs-core/lib/library/IAsset\");\n\nimport LightBase\t\t\t\t\t= require(\"awayjs-display/lib/base/LightBase\");\nimport ShadowMapperBase\t\t\t\t= require(\"awayjs-display/lib/materials/shadowmappers/ShadowMapperBase\");\n\nimport ShadingMethodBase\t\t\t= require(\"awayjs-methodmaterials/lib/methods/ShadingMethodBase\");\n\n/**\n * ShadowMapMethodBase provides an abstract base method for shadow map methods.\n */\nclass ShadowMapMethodBase extends ShadingMethodBase implements IAsset\n{\n\tpublic _pCastingLight:LightBase;\n\tpublic _pShadowMapper:ShadowMapperBase;\n\n\tpublic _pEpsilon:number = .02;\n\tpublic _pAlpha:number = 1;\n\n\t/**\n\t * Creates a new ShadowMapMethodBase object.\n\t * @param castingLight The light used to cast shadows.\n\t */\n\tconstructor(castingLight:LightBase)\n\t{\n\t\tsuper();\n\t\tthis._pCastingLight = castingLight;\n\t\tcastingLight.castsShadows = true;\n\t\tthis._pShadowMapper = castingLight.shadowMapper;\n\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic get assetType():string\n\t{\n\t\treturn AssetType.SHADOW_MAP_METHOD;\n\t}\n\n\t/**\n\t * The \"transparency\" of the shadows. This allows making shadows less strong.\n\t */\n\tpublic get alpha():number\n\t{\n\t\treturn this._pAlpha;\n\t}\n\n\tpublic set alpha(value:number)\n\t{\n\t\tthis._pAlpha = value;\n\t}\n\n\t/**\n\t * The light casting the shadows.\n\t */\n\tpublic get castingLight():LightBase\n\t{\n\t\treturn this._pCastingLight;\n\t}\n\n\t/**\n\t * A small value to counter floating point precision errors when comparing values in the shadow map with the\n\t * calculated depth value. Increase this if shadow banding occurs, decrease it if the shadow seems to be too detached.\n\t */\n\tpublic get epsilon():number\n\t{\n\t\treturn this._pEpsilon;\n\t}\n\n\tpublic set epsilon(value:number)\n\t{\n\t\tthis._pEpsilon = value;\n\t}\n}\n\nexport = ShadowMapMethodBase;","import Vector3D\t\t\t\t\t\t= require(\"awayjs-core/lib/geom/Vector3D\");\nimport AbstractMethodError\t\t\t= require(\"awayjs-core/lib/errors/AbstractMethodError\");\nimport CubeTextureBase\t\t\t\t= require(\"awayjs-core/lib/textures/CubeTextureBase\");\nimport Texture2DBase\t\t\t\t= require(\"awayjs-core/lib/textures/Texture2DBase\");\n\nimport LightBase\t\t\t\t\t= require(\"awayjs-display/lib/base/LightBase\");\nimport Camera\t\t\t\t\t\t= require(\"awayjs-display/lib/entities/Camera\");\nimport DirectionalLight\t\t\t\t= require(\"awayjs-display/lib/entities/DirectionalLight\");\nimport PointLight\t\t\t\t\t= require(\"awayjs-display/lib/entities/PointLight\");\nimport DirectionalShadowMapper\t\t= require(\"awayjs-display/lib/materials/shadowmappers/DirectionalShadowMapper\");\n\nimport Stage\t\t\t\t\t\t= require(\"awayjs-stagegl/lib/base/Stage\");\n\nimport RenderableBase\t\t\t\t= require(\"awayjs-renderergl/lib/pool/RenderableBase\");\nimport ShaderLightingObject\t\t\t= require(\"awayjs-renderergl/lib/compilation/ShaderLightingObject\");\nimport ShaderObjectBase\t\t\t\t= require(\"awayjs-renderergl/lib/compilation/ShaderObjectBase\");\nimport ShaderRegisterCache\t\t\t= require(\"awayjs-renderergl/lib/compilation/ShaderRegisterCache\");\nimport ShaderRegisterData\t\t\t= require(\"awayjs-renderergl/lib/compilation/ShaderRegisterData\");\nimport ShaderRegisterElement\t\t= require(\"awayjs-renderergl/lib/compilation/ShaderRegisterElement\");\n\nimport MethodVO\t\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/data/MethodVO\");\nimport ShadowMapMethodBase\t\t\t= require(\"awayjs-methodmaterials/lib/methods/ShadowMapMethodBase\");\n\n/**\n * ShadowMethodBase provides an abstract method for simple (non-wrapping) shadow map methods.\n */\nclass ShadowMethodBase extends ShadowMapMethodBase\n{\n\tpublic _pDepthMapCoordReg:ShaderRegisterElement;\n\tpublic _pUsePoint:boolean;\n\n\t/**\n\t * Creates a new ShadowMethodBase object.\n\t * @param castingLight The light used to cast shadows.\n\t */\n\tconstructor(castingLight:LightBase)\n\t{\n\t\tthis._pUsePoint = (castingLight instanceof PointLight);\n\n\t\tsuper(castingLight);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitVO(shaderObject:ShaderLightingObject, methodVO:MethodVO)\n\t{\n\t\tmethodVO.needsView = true;\n\t\tmethodVO.needsGlobalVertexPos = true;\n\t\tmethodVO.needsGlobalFragmentPos = this._pUsePoint;\n\t\tmethodVO.needsNormals = shaderObject.numLights > 0;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitConstants(shaderObject:ShaderObjectBase, methodVO:MethodVO)\n\t{\n\t\tvar fragmentData:Array<number> = shaderObject.fragmentConstantData;\n\t\tvar vertexData:Array<number> = shaderObject.vertexConstantData;\n\t\tvar index:number /*int*/ = methodVO.fragmentConstantsIndex;\n\t\tfragmentData[index] = 1.0;\n\t\tfragmentData[index + 1] = 1/255.0;\n\t\tfragmentData[index + 2] = 1/65025.0;\n\t\tfragmentData[index + 3] = 1/16581375.0;\n\n\t\tfragmentData[index + 6] = 0;\n\t\tfragmentData[index + 7] = 1;\n\n\t\tif (this._pUsePoint) {\n\t\t\tfragmentData[index + 8] = 0;\n\t\t\tfragmentData[index + 9] = 0;\n\t\t\tfragmentData[index + 10] = 0;\n\t\t\tfragmentData[index + 11] = 1;\n\t\t}\n\n\t\tindex = methodVO.vertexConstantsIndex;\n\t\tif (index != -1) {\n\t\t\tvertexData[index] = .5;\n\t\t\tvertexData[index + 1] = .5;\n\t\t\tvertexData[index + 2] = 0.0;\n\t\t\tvertexData[index + 3] = 1.0;\n\t\t}\n\t}\n\n\t/**\n\t * Wrappers that override the vertex shader need to set this explicitly\n\t */\n\tpublic get _iDepthMapCoordReg():ShaderRegisterElement\n\t{\n\t\treturn this._pDepthMapCoordReg;\n\t}\n\n\tpublic set _iDepthMapCoordReg(value:ShaderRegisterElement)\n\t{\n\t\tthis._pDepthMapCoordReg = value;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iCleanCompilationData()\n\t{\n\t\tsuper.iCleanCompilationData();\n\n\t\tthis._pDepthMapCoordReg = null;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetVertexCode(shaderObject:ShaderObjectBase, methodVO:MethodVO, regCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\treturn this._pUsePoint? this._pGetPointVertexCode(methodVO, regCache, sharedRegisters):this.pGetPlanarVertexCode(methodVO, regCache, sharedRegisters);\n\t}\n\n\t/**\n\t * Gets the vertex code for shadow mapping with a point light.\n\t *\n\t * @param methodVO The MethodVO object linking this method with the pass currently being compiled.\n\t * @param regCache The register cache used during the compilation.\n\t */\n\tpublic _pGetPointVertexCode(methodVO:MethodVO, regCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tmethodVO.vertexConstantsIndex = -1;\n\t\treturn \"\";\n\t}\n\n\t/**\n\t * Gets the vertex code for shadow mapping with a planar shadow map (fe: directional lights).\n\t *\n\t * @param methodVO The MethodVO object linking this method with the pass currently being compiled.\n\t * @param regCache The register cache used during the compilation.\n\t */\n\tpublic pGetPlanarVertexCode(methodVO:MethodVO, regCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = \"\";\n\t\tvar temp:ShaderRegisterElement = regCache.getFreeVertexVectorTemp();\n\t\tvar dataReg:ShaderRegisterElement = regCache.getFreeVertexConstant();\n\t\tvar depthMapProj:ShaderRegisterElement = regCache.getFreeVertexConstant();\n\t\tregCache.getFreeVertexConstant();\n\t\tregCache.getFreeVertexConstant();\n\t\tregCache.getFreeVertexConstant();\n\t\tthis._pDepthMapCoordReg = regCache.getFreeVarying();\n\t\tmethodVO.vertexConstantsIndex = dataReg.index*4;\n\n\t\t// todo: can epsilon be applied here instead of fragment shader?\n\n\t\tcode += \"m44 \" + temp + \", \" + sharedRegisters.globalPositionVertex + \", \" + depthMapProj + \"\\n\" + \"div \" + temp + \", \" + temp + \", \" + temp + \".w\\n\" + \"mul \" + temp + \".xy, \" + temp + \".xy, \" + dataReg + \".xy\\n\" + \"add \" + this._pDepthMapCoordReg + \", \" + temp + \", \" + dataReg + \".xxwz\\n\";\n\t\t//\"sub \" + this._pDepthMapCoordReg + \".z, \" + this._pDepthMapCoordReg + \".z, \" + this._pDepthMapCoordReg + \".w\\n\";\n\n\t\treturn code;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentCode(shaderObject:ShaderObjectBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = this._pUsePoint? this._pGetPointFragmentCode(methodVO, targetReg, registerCache, sharedRegisters):this._pGetPlanarFragmentCode(methodVO, targetReg, registerCache, sharedRegisters);\n\t\tcode += \"add \" + targetReg + \".w, \" + targetReg + \".w, fc\" + (methodVO.fragmentConstantsIndex/4 + 1) + \".y\\n\" + \"sat \" + targetReg + \".w, \" + targetReg + \".w\\n\";\n\t\treturn code;\n\t}\n\n\t/**\n\t * Gets the fragment code for shadow mapping with a planar shadow map.\n\t * @param methodVO The MethodVO object linking this method with the pass currently being compiled.\n\t * @param regCache The register cache used during the compilation.\n\t * @param targetReg The register to contain the shadow coverage\n\t * @return\n\t */\n\tpublic _pGetPlanarFragmentCode(methodVO:MethodVO, targetReg:ShaderRegisterElement, regCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tthrow new AbstractMethodError();\n\t\treturn \"\";\n\t}\n\n\t/**\n\t * Gets the fragment code for shadow mapping with a point light.\n\t * @param methodVO The MethodVO object linking this method with the pass currently being compiled.\n\t * @param regCache The register cache used during the compilation.\n\t * @param targetReg The register to contain the shadow coverage\n\t * @return\n\t */\n\tpublic _pGetPointFragmentCode(methodVO:MethodVO, targetReg:ShaderRegisterElement, regCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tthrow new AbstractMethodError();\n\t\treturn \"\";\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iSetRenderState(shaderObject:ShaderObjectBase, methodVO:MethodVO, renderable:RenderableBase, stage:Stage, camera:Camera)\n\t{\n\t\tif (!this._pUsePoint)\n\t\t\t(<DirectionalShadowMapper> this._pShadowMapper).iDepthProjection.copyRawDataTo(shaderObject.vertexConstantData, methodVO.vertexConstantsIndex + 4, true);\n\t}\n\n\t/**\n\t * Gets the fragment code for combining this method with a cascaded shadow map method.\n\t * @param methodVO The MethodVO object linking this method with the pass currently being compiled.\n\t * @param regCache The register cache used during the compilation.\n\t * @param decodeRegister The register containing the data to decode the shadow map depth value.\n\t * @param depthTexture The texture containing the shadow map.\n\t * @param depthProjection The projection of the fragment relative to the light.\n\t * @param targetRegister The register to contain the shadow coverage\n\t * @return\n\t */\n\tpublic _iGetCascadeFragmentCode(shaderObject:ShaderObjectBase, methodVO:MethodVO, decodeRegister:ShaderRegisterElement, depthTexture:ShaderRegisterElement, depthProjection:ShaderRegisterElement, targetRegister:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tthrow new Error(\"This shadow method is incompatible with cascade shadows\");\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iActivate(shaderObject:ShaderObjectBase, methodVO:MethodVO, stage:Stage)\n\t{\n\t\tvar fragmentData:Array<number> = shaderObject.fragmentConstantData;\n\t\tvar index:number /*int*/ = methodVO.fragmentConstantsIndex;\n\n\t\tif (this._pUsePoint)\n\t\t\tfragmentData[index + 4] = -Math.pow(1/((<PointLight> this._pCastingLight).fallOff*this._pEpsilon), 2);\n\t\telse\n\t\t\tshaderObject.vertexConstantData[methodVO.vertexConstantsIndex + 3] = -1/((<DirectionalShadowMapper> this._pShadowMapper).depth*this._pEpsilon);\n\n\t\tfragmentData[index + 5] = 1 - this._pAlpha;\n\n\t\tif (this._pUsePoint) {\n\t\t\tvar pos:Vector3D = this._pCastingLight.scenePosition;\n\t\t\tfragmentData[index + 8] = pos.x;\n\t\t\tfragmentData[index + 9] = pos.y;\n\t\t\tfragmentData[index + 10] = pos.z;\n\t\t\t// used to decompress distance\n\t\t\tvar f:number = (<PointLight> this._pCastingLight).fallOff;\n\t\t\tfragmentData[index + 11] = 1/(2*f*f);\n\t\t}\n\n\t\tif (!this._pUsePoint)\n\t\t\tstage.activateRenderTexture(methodVO.texturesIndex, <Texture2DBase> this._pCastingLight.shadowMapper.depthMap);\n\t\t//else\n\t\t//\tstage.activateCubeRenderTexture(methodVO.texturesIndex, <CubeTextureBase> this._pCastingLight.shadowMapper.depthMap);\n\t}\n\n\t/**\n\t * Sets the method state for cascade shadow mapping.\n\t */\n\tpublic iActivateForCascade(shaderObject:ShaderObjectBase, methodVO:MethodVO, stage:Stage)\n\t{\n\t\tthrow new Error(\"This shadow method is incompatible with cascade shadows\");\n\t}\n}\n\nexport = ShadowMethodBase;","import NearDirectionalShadowMapper\t\t= require(\"awayjs-display/lib/materials/shadowmappers/NearDirectionalShadowMapper\");\nimport Camera\t\t\t\t\t\t\t= require(\"awayjs-display/lib/entities/Camera\");\n\nimport Stage\t\t\t\t\t\t\t= require(\"awayjs-stagegl/lib/base/Stage\");\n\nimport RenderableBase\t\t\t\t\t= require(\"awayjs-renderergl/lib/pool/RenderableBase\");\nimport ShadingMethodEvent\t\t\t\t= require(\"awayjs-renderergl/lib/events/ShadingMethodEvent\");\nimport ShaderLightingObject\t\t\t\t= require(\"awayjs-renderergl/lib/compilation/ShaderLightingObject\");\nimport ShaderObjectBase\t\t\t\t\t= require(\"awayjs-renderergl/lib/compilation/ShaderObjectBase\");\nimport ShaderRegisterCache\t\t\t\t= require(\"awayjs-renderergl/lib/compilation/ShaderRegisterCache\");\nimport ShaderRegisterData\t\t\t\t= require(\"awayjs-renderergl/lib/compilation/ShaderRegisterData\");\nimport ShaderRegisterElement\t\t\t= require(\"awayjs-renderergl/lib/compilation/ShaderRegisterElement\");\n\nimport MethodVO\t\t\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/data/MethodVO\");\nimport ShadowMethodBase\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/methods/ShadowMethodBase\");\n\n// TODO: shadow mappers references in materials should be an interface so that this class should NOT extend ShadowMapMethodBase just for some delegation work\n/**\n * ShadowNearMethod provides a shadow map method that restricts the shadowed area near the camera to optimize\n * shadow map usage. This method needs to be used in conjunction with a NearDirectionalShadowMapper.\n *\n * @see away.lights.NearDirectionalShadowMapper\n */\nclass ShadowNearMethod extends ShadowMethodBase\n{\n\tprivate _baseMethod:ShadowMethodBase;\n\n\tprivate _fadeRatio:number;\n\tprivate _nearShadowMapper:NearDirectionalShadowMapper;\n\n\tprivate _onShaderInvalidatedDelegate:Function;\n\n\t/**\n\t * Creates a new ShadowNearMethod object.\n\t * @param baseMethod The shadow map sampling method used to sample individual cascades (fe: ShadowHardMethod, ShadowSoftMethod)\n\t * @param fadeRatio The amount of shadow fading to the outer shadow area. A value of 1 would mean the shadows start fading from the camera's near plane.\n\t */\n\tconstructor(baseMethod:ShadowMethodBase, fadeRatio:number = .1)\n\t{\n\t\tsuper(baseMethod.castingLight);\n\n\t\tthis._onShaderInvalidatedDelegate = (event:ShadingMethodEvent) => this.onShaderInvalidated(event);\n\n\t\tthis._baseMethod = baseMethod;\n\t\tthis._fadeRatio = fadeRatio;\n\t\tthis._nearShadowMapper = <NearDirectionalShadowMapper> this._pCastingLight.shadowMapper;\n\t\tif (!this._nearShadowMapper)\n\t\t\tthrow new Error(\"ShadowNearMethod requires a light that has a NearDirectionalShadowMapper instance assigned to shadowMapper.\");\n\t\tthis._baseMethod.addEventListener(ShadingMethodEvent.SHADER_INVALIDATED, this._onShaderInvalidatedDelegate);\n\t}\n\n\t/**\n\t * The base shadow map method on which this method's shading is based.\n\t */\n\tpublic get baseMethod():ShadowMethodBase\n\t{\n\t\treturn this._baseMethod;\n\t}\n\n\tpublic set baseMethod(value:ShadowMethodBase)\n\t{\n\t\tif (this._baseMethod == value)\n\t\t\treturn;\n\n\t\tthis._baseMethod.removeEventListener(ShadingMethodEvent.SHADER_INVALIDATED, this._onShaderInvalidatedDelegate);\n\n\t\tthis._baseMethod = value;\n\n\t\tthis._baseMethod.addEventListener(ShadingMethodEvent.SHADER_INVALIDATED, this._onShaderInvalidatedDelegate);\n\n\t\tthis.iInvalidateShaderProgram();\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitConstants(shaderObject:ShaderObjectBase, methodVO:MethodVO)\n\t{\n\t\tsuper.iInitConstants(shaderObject, methodVO);\n\t\tthis._baseMethod.iInitConstants(shaderObject, methodVO);\n\n\t\tvar fragmentData:Array<number> = shaderObject.fragmentConstantData;\n\t\tvar index:number /*int*/ = methodVO.secondaryFragmentConstantsIndex;\n\t\tfragmentData[index + 2] = 0;\n\t\tfragmentData[index + 3] = 1;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitVO(shaderObject:ShaderLightingObject, methodVO:MethodVO)\n\t{\n\t\tthis._baseMethod.iInitVO(shaderObject, methodVO);\n\n\t\tmethodVO.needsProjection = true;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic dispose()\n\t{\n\t\tthis._baseMethod.removeEventListener(ShadingMethodEvent.SHADER_INVALIDATED, this._onShaderInvalidatedDelegate);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic get alpha():number\n\t{\n\t\treturn this._baseMethod.alpha;\n\t}\n\n\tpublic set alpha(value:number)\n\t{\n\t\tthis._baseMethod.alpha = value;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic get epsilon():number\n\t{\n\t\treturn this._baseMethod.epsilon;\n\t}\n\n\tpublic set epsilon(value:number)\n\t{\n\t\tthis._baseMethod.epsilon = value;\n\t}\n\n\t/**\n\t * The amount of shadow fading to the outer shadow area. A value of 1 would mean the shadows start fading from the camera's near plane.\n\t */\n\tpublic get fadeRatio():number\n\t{\n\t\treturn this._fadeRatio;\n\t}\n\n\tpublic set fadeRatio(value:number)\n\t{\n\t\tthis._fadeRatio = value;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentCode(shaderObject:ShaderObjectBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = this._baseMethod.iGetFragmentCode(shaderObject, methodVO, targetReg, registerCache, sharedRegisters);\n\n\t\tvar dataReg:ShaderRegisterElement = registerCache.getFreeFragmentConstant();\n\t\tvar temp:ShaderRegisterElement = registerCache.getFreeFragmentSingleTemp();\n\t\tmethodVO.secondaryFragmentConstantsIndex = dataReg.index*4;\n\n\t\tcode += \"abs \" + temp + \", \" + sharedRegisters.projectionFragment + \".w\\n\" +\n\t\t\t\"sub \" + temp + \", \" + temp + \", \" + dataReg + \".x\\n\" +\n\t\t\t\"mul \" + temp + \", \" + temp + \", \" + dataReg + \".y\\n\" +\n\t\t\t\"sat \" + temp + \", \" + temp + \"\\n\" +\n\t\t\t\"sub \" + temp + \", \" + dataReg + \".w,\" + temp + \"\\n\" +\n\t\t\t\"sub \" + targetReg + \".w, \" + dataReg + \".w,\" + targetReg + \".w\\n\" +\n\t\t\t\"mul \" + targetReg + \".w, \" + targetReg + \".w, \" + temp + \"\\n\" +\n\t\t\t\"sub \" + targetReg + \".w, \" + dataReg + \".w,\" + targetReg + \".w\\n\";\n\n\t\treturn code;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iActivate(shaderObject:ShaderObjectBase, methodVO:MethodVO, stage:Stage)\n\t{\n\t\tthis._baseMethod.iActivate(shaderObject, methodVO, stage);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iDeactivate(shaderObject:ShaderObjectBase, methodVO:MethodVO, stage:Stage)\n\t{\n\t\tthis._baseMethod.iDeactivate(shaderObject, methodVO, stage);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iSetRenderState(shaderObject:ShaderObjectBase, methodVO:MethodVO, renderable:RenderableBase, stage:Stage, camera:Camera)\n\t{\n\t\t// todo: move this to activate (needs camera)\n\t\tvar near:number = camera.projection.near;\n\t\tvar d:number = camera.projection.far - near;\n\t\tvar maxDistance:number = this._nearShadowMapper.coverageRatio;\n\t\tvar minDistance:number = maxDistance*(1 - this._fadeRatio);\n\n\t\tmaxDistance = near + maxDistance*d;\n\t\tminDistance = near + minDistance*d;\n\n\t\tvar fragmentData:Array<number> = shaderObject.fragmentConstantData;\n\t\tvar index:number /*int*/ = methodVO.secondaryFragmentConstantsIndex;\n\t\tfragmentData[index] = minDistance;\n\t\tfragmentData[index + 1] = 1/(maxDistance - minDistance);\n\n\t\tthis._baseMethod.iSetRenderState(shaderObject, methodVO, renderable, stage, camera);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetVertexCode(shaderObject:ShaderObjectBase, methodVO:MethodVO, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\treturn this._baseMethod.iGetVertexCode(shaderObject, methodVO, registerCache, sharedRegisters);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iReset()\n\t{\n\t\tthis._baseMethod.iReset();\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iCleanCompilationData()\n\t{\n\t\tsuper.iCleanCompilationData();\n\t\tthis._baseMethod.iCleanCompilationData();\n\t}\n\n\t/**\n\t * Called when the base method's shader code is invalidated.\n\t */\n\tprivate onShaderInvalidated(event:ShadingMethodEvent)\n\t{\n\t\tthis.iInvalidateShaderProgram();\n\t}\n}\n\nexport = ShadowNearMethod;","import PoissonLookup\t\t\t\t\t= require(\"awayjs-core/lib/geom/PoissonLookup\");\n\nimport DirectionalLight\t\t\t\t\t= require(\"awayjs-display/lib/entities/DirectionalLight\");\n\nimport Stage\t\t\t\t\t\t\t= require(\"awayjs-stagegl/lib/base/Stage\");\n\nimport ShaderObjectBase\t\t\t\t\t= require(\"awayjs-renderergl/lib/compilation/ShaderObjectBase\");\nimport ShaderRegisterCache\t\t\t\t= require(\"awayjs-renderergl/lib/compilation/ShaderRegisterCache\");\nimport ShaderRegisterData\t\t\t\t= require(\"awayjs-renderergl/lib/compilation/ShaderRegisterData\");\nimport ShaderRegisterElement\t\t\t= require(\"awayjs-renderergl/lib/compilation/ShaderRegisterElement\");\n\nimport MethodVO\t\t\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/data/MethodVO\");\nimport ShadowMethodBase\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/methods/ShadowMethodBase\");\n\n/**\n * ShadowSoftMethod provides a soft shadowing technique by randomly distributing sample points.\n */\nclass ShadowSoftMethod extends ShadowMethodBase\n{\n\tprivate _range:number = 1;\n\tprivate _numSamples:number /*int*/;\n\tprivate _offsets:Array<number>;\n\n\t/**\n\t * Creates a new DiffuseBasicMethod object.\n\t *\n\t * @param castingLight The light casting the shadows\n\t * @param numSamples The amount of samples to take for dithering. Minimum 1, maximum 32.\n\t */\n\tconstructor(castingLight:DirectionalLight, numSamples:number /*int*/ = 5, range:number = 1)\n\t{\n\t\tsuper(castingLight);\n\n\t\tthis.numSamples = numSamples;\n\t\tthis.range = range;\n\t}\n\n\t/**\n\t * The amount of samples to take for dithering. Minimum 1, maximum 32. The actual maximum may depend on the\n\t * complexity of the shader.\n\t */\n\tpublic get numSamples():number /*int*/\n\t{\n\t\treturn this._numSamples;\n\t}\n\n\tpublic set numSamples(value:number /*int*/)\n\t{\n\t\tthis._numSamples = value;\n\t\t\n\t\tif (this._numSamples < 1)\n\t\t\tthis._numSamples = 1;\n\t\telse if (this._numSamples > 32)\n\t\t\tthis._numSamples = 32;\n\n\t\tthis._offsets = PoissonLookup.getDistribution(this._numSamples);\n\t\t\n\t\tthis.iInvalidateShaderProgram();\n\t}\n\n\t/**\n\t * The range in the shadow map in which to distribute the samples.\n\t */\n\tpublic get range():number\n\t{\n\t\treturn this._range;\n\t}\n\n\tpublic set range(value:number)\n\t{\n\t\tthis._range = value;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitConstants(shaderObject:ShaderObjectBase, methodVO:MethodVO)\n\t{\n\t\tsuper.iInitConstants(shaderObject, methodVO);\n\n\t\tshaderObject.fragmentConstantData[methodVO.fragmentConstantsIndex + 8] = 1/this._numSamples;\n\t\tshaderObject.fragmentConstantData[methodVO.fragmentConstantsIndex + 9] = 0;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iActivate(shaderObject:ShaderObjectBase, methodVO:MethodVO, stage:Stage)\n\t{\n\t\tsuper.iActivate(shaderObject, methodVO, stage);\n\n\t\tvar texRange:number = .5*this._range/this._pCastingLight.shadowMapper.depthMapSize;\n\t\tvar data:Array<number> = shaderObject.fragmentConstantData;\n\t\tvar index:number /*uint*/ = methodVO.fragmentConstantsIndex + 10;\n\t\tvar len:number /*uint*/ = this._numSamples << 1;\n\n\t\tfor (var i:number /*int*/ = 0; i < len; ++i)\n\t\t\tdata[index + i] = this._offsets[i]*texRange;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic _pGetPlanarFragmentCode(methodVO:MethodVO, targetReg:ShaderRegisterElement, regCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\t// todo: move some things to super\n\t\tvar depthMapRegister:ShaderRegisterElement = regCache.getFreeTextureReg();\n\t\tvar decReg:ShaderRegisterElement = regCache.getFreeFragmentConstant();\n\t\tvar dataReg:ShaderRegisterElement = regCache.getFreeFragmentConstant();\n\t\tvar customDataReg:ShaderRegisterElement = regCache.getFreeFragmentConstant();\n\n\t\tmethodVO.fragmentConstantsIndex = decReg.index*4;\n\t\tmethodVO.texturesIndex = depthMapRegister.index;\n\n\t\treturn this.getSampleCode(regCache, depthMapRegister, decReg, targetReg, customDataReg);\n\t}\n\n\t/**\n\t * Adds the code for another tap to the shader code.\n\t * @param uv The uv register for the tap.\n\t * @param texture The texture register containing the depth map.\n\t * @param decode The register containing the depth map decoding data.\n\t * @param target The target register to add the tap comparison result.\n\t * @param regCache The register cache managing the registers.\n\t * @return\n\t */\n\tprivate addSample(uv:ShaderRegisterElement, texture:ShaderRegisterElement, decode:ShaderRegisterElement, target:ShaderRegisterElement, regCache:ShaderRegisterCache):string\n\t{\n\t\tvar temp:ShaderRegisterElement = regCache.getFreeFragmentVectorTemp();\n\t\treturn \"tex \" + temp + \", \" + uv + \", \" + texture + \" <2d,nearest,clamp>\\n\" +\n\t\t\t\"dp4 \" + temp + \".z, \" + temp + \", \" + decode + \"\\n\" +\n\t\t\t\"slt \" + uv + \".w, \" + this._pDepthMapCoordReg + \".z, \" + temp + \".z\\n\" + // 0 if in shadow\n\t\t\t\"add \" + target + \".w, \" + target + \".w, \" + uv + \".w\\n\";\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iActivateForCascade(shaderObject:ShaderObjectBase, methodVO:MethodVO, stage:Stage)\n\t{\n\t\tsuper.iActivate(shaderObject, methodVO, stage);\n\n\t\tvar texRange:number = this._range/this._pCastingLight.shadowMapper.depthMapSize;\n\t\tvar data:Array<number> = shaderObject.fragmentConstantData;\n\t\tvar index:number /*uint*/ = methodVO.secondaryFragmentConstantsIndex;\n\t\tvar len:number /*uint*/ = this._numSamples << 1;\n\t\tdata[index] = 1/this._numSamples;\n\t\tdata[index + 1] = 0;\n\t\tindex += 2;\n\n\t\tfor (var i:number /*int*/ = 0; i < len; ++i)\n\t\t\tdata[index + i] = this._offsets[i]*texRange;\n\n\t\tif (len%4 == 0) {\n\t\t\tdata[index + len] = 0;\n\t\t\tdata[index + len + 1] = 0;\n\t\t}\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic _iGetCascadeFragmentCode(shaderObject:ShaderObjectBase, methodVO:MethodVO, decodeRegister:ShaderRegisterElement, depthTexture:ShaderRegisterElement, depthProjection:ShaderRegisterElement, targetRegister:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tthis._pDepthMapCoordReg = depthProjection;\n\n\t\tvar dataReg:ShaderRegisterElement = registerCache.getFreeFragmentConstant();\n\t\tmethodVO.secondaryFragmentConstantsIndex = dataReg.index*4;\n\n\t\treturn this.getSampleCode(registerCache, depthTexture, decodeRegister, targetRegister, dataReg);\n\t}\n\n\t/**\n\t * Get the actual shader code for shadow mapping\n\t * @param regCache The register cache managing the registers.\n\t * @param depthTexture The texture register containing the depth map.\n\t * @param decodeRegister The register containing the depth map decoding data.\n\t * @param targetReg The target register to add the shadow coverage.\n\t * @param dataReg The register containing additional data.\n\t */\n\tprivate getSampleCode(regCache:ShaderRegisterCache, depthTexture:ShaderRegisterElement, decodeRegister:ShaderRegisterElement, targetRegister:ShaderRegisterElement, dataReg:ShaderRegisterElement):string\n\t{\n\t\tvar uvReg:ShaderRegisterElement;\n\t\tvar code:string;\n\t\tvar offsets:Array<string> = new Array<string>(dataReg + \".zw\");\n\t\tuvReg = regCache.getFreeFragmentVectorTemp();\n\t\tregCache.addFragmentTempUsages(uvReg, 1);\n\n\t\tvar temp:ShaderRegisterElement = regCache.getFreeFragmentVectorTemp();\n\n\t\tvar numRegs:number /*int*/ = this._numSamples >> 1;\n\t\tfor (var i:number /*int*/ = 0; i < numRegs; ++i) {\n\t\t\tvar reg:ShaderRegisterElement = regCache.getFreeFragmentConstant();\n\t\t\toffsets.push(reg + \".xy\");\n\t\t\toffsets.push(reg + \".zw\");\n\t\t}\n\n\t\tfor (i = 0; i < this._numSamples; ++i) {\n\t\t\tif (i == 0) {\n\t\t\t\tcode = \"add \" + uvReg + \", \" + this._pDepthMapCoordReg + \", \" + dataReg + \".zwyy\\n\" +\n\t\t\t\t\t\"tex \" + temp + \", \" + uvReg + \", \" + depthTexture + \" <2d,nearest,clamp>\\n\" +\n\t\t\t\t\t\"dp4 \" + temp + \".z, \" + temp + \", \" + decodeRegister + \"\\n\" +\n\t\t\t\t\t\"slt \" + targetRegister + \".w, \" + this._pDepthMapCoordReg + \".z, \" + temp + \".z\\n\"; // 0 if in shadow;\n\t\t\t} else {\n\t\t\t\tcode += \"add \" + uvReg + \".xy, \" + this._pDepthMapCoordReg + \".xy, \" + offsets[i] + \"\\n\" +\n\t\t\t\t\tthis.addSample(uvReg, depthTexture, decodeRegister, targetRegister, regCache);\n\t\t\t}\n\t\t}\n\n\t\tregCache.removeFragmentTempUsage(uvReg);\n\n\t\tcode += \"mul \" + targetRegister + \".w, \" + targetRegister + \".w, \" + dataReg + \".x\\n\"; // average\n\n\t\treturn code;\n\t}\n}\n\nexport = ShadowSoftMethod;","import ShaderLightingObject\t\t\t\t= require(\"awayjs-renderergl/lib/compilation/ShaderLightingObject\");\nimport ShaderRegisterCache\t\t\t\t= require(\"awayjs-renderergl/lib/compilation/ShaderRegisterCache\");\nimport ShaderRegisterData\t\t\t\t= require(\"awayjs-renderergl/lib/compilation/ShaderRegisterData\");\nimport ShaderRegisterElement\t\t\t= require(\"awayjs-renderergl/lib/compilation/ShaderRegisterElement\");\n\nimport MethodVO\t\t\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/data/MethodVO\");\nimport SpecularBasicMethod\t\t\t\t= require(\"awayjs-methodmaterials/lib/methods/SpecularBasicMethod\");\n\n/**\n * SpecularAnisotropicMethod provides a specular method resulting in anisotropic highlights. These are typical for\n * surfaces with microfacet details such as tiny grooves. In particular, this uses the Heidrich-Seidel distrubution.\n * The tangent vectors are used as the surface groove directions.\n */\nclass SpecularAnisotropicMethod extends SpecularBasicMethod\n{\n\t/**\n\t * Creates a new SpecularAnisotropicMethod object.\n\t */\n\tconstructor()\n\t{\n\t\tsuper();\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitVO(shaderObject:ShaderLightingObject, methodVO:MethodVO)\n\t{\n\t\tmethodVO.needsTangents = true;\n\t\tmethodVO.needsView = true;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentCodePerLight(shaderObject:ShaderLightingObject, methodVO:MethodVO, lightDirReg:ShaderRegisterElement, lightColReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = \"\";\n\t\tvar t:ShaderRegisterElement;\n\n\t\tif (this._pIsFirstLight)\n\t\t\tt = this._pTotalLightColorReg;\n\t\telse {\n\t\t\tt = registerCache.getFreeFragmentVectorTemp();\n\t\t\tregisterCache.addFragmentTempUsages(t, 1);\n\t\t}\n\n\t\t// (sin(l,t) * sin(v,t) - cos(l,t)*cos(v,t)) ^ k\n\n\t\tcode += \"nrm \" + t + \".xyz, \" + sharedRegisters.tangentVarying + \".xyz\\n\" +\n\t\t\t\"dp3 \" + t + \".w, \" + t + \".xyz, \" + lightDirReg + \".xyz\\n\" +\n\t\t\t\"dp3 \" + t + \".z, \" + t + \".xyz, \" + sharedRegisters.viewDirFragment + \".xyz\\n\";\n\n\t\t// (sin(t.w) * sin(t.z) - cos(t.w)*cos(t.z)) ^ k\n\t\tcode += \"sin \" + t + \".x, \" + t + \".w\\n\" +\n\t\t\t\"sin \" + t + \".y, \" + t + \".z\\n\" +\n\t\t\t// (t.x * t.y - cos(t.w)*cos(t.z)) ^ k\n\t\t\t\"mul \" + t + \".x, \" + t + \".x, \" + t + \".y\\n\" +\n\t\t\t// (t.x - cos(t.w)*cos(t.z)) ^ k\n\t\t\t\"cos \" + t + \".z, \" + t + \".z\\n\" +\n\t\t\t\"cos \" + t + \".w, \" + t + \".w\\n\" +\n\t\t\t// (t.x - t.w*t.z) ^ k\n\t\t\t\"mul \" + t + \".w, \" + t + \".w, \" + t + \".z\\n\" +\n\t\t\t// (t.x - t.w) ^ k\n\t\t\t\"sub \" + t + \".w, \" + t + \".x, \" + t + \".w\\n\";\n\n\t\tif (this._pUseTexture) {\n\t\t\t// apply gloss modulation from texture\n\t\t\tcode += \"mul \" + this._pSpecularTexData + \".w, \" + this._pSpecularTexData + \".y, \" + this._pSpecularDataRegister + \".w\\n\" +\n\t\t\t\t\"pow \" + t + \".w, \" + t + \".w, \" + this._pSpecularTexData + \".w\\n\";\n\t\t} else\n\t\t\tcode += \"pow \" + t + \".w, \" + t + \".w, \" + this._pSpecularDataRegister + \".w\\n\";\n\n\t\t// attenuate\n\t\tcode += \"mul \" + t + \".w, \" + t + \".w, \" + lightDirReg + \".w\\n\";\n\n\t\tif (this._iModulateMethod != null)\n\t\t\tcode += this._iModulateMethod(shaderObject, methodVO, t, registerCache, sharedRegisters);\n\n\t\tcode += \"mul \" + t + \".xyz, \" + lightColReg + \".xyz, \" + t + \".w\\n\";\n\n\t\tif (!this._pIsFirstLight) {\n\t\t\tcode += \"add \" + this._pTotalLightColorReg + \".xyz, \" + this._pTotalLightColorReg + \".xyz, \" + t + \".xyz\\n\";\n\t\t\tregisterCache.removeFragmentTempUsage(t);\n\t\t}\n\n\t\tthis._pIsFirstLight = false;\n\n\t\treturn code;\n\t}\n}\n\nexport = SpecularAnisotropicMethod;","import Texture2DBase\t\t\t\t= require(\"awayjs-core/lib/textures/Texture2DBase\");\n\nimport Stage\t\t\t\t\t\t= require(\"awayjs-stagegl/lib/base/Stage\");\nimport ContextGLMipFilter\t\t\t= require(\"awayjs-stagegl/lib/base/ContextGLMipFilter\");\nimport ContextGLTextureFilter\t\t= require(\"awayjs-stagegl/lib/base/ContextGLTextureFilter\");\nimport ContextGLWrapMode\t\t\t= require(\"awayjs-stagegl/lib/base/ContextGLWrapMode\");\nimport IContextGL\t\t\t\t\t= require(\"awayjs-stagegl/lib/base/IContextGL\");\n\nimport ShaderLightingObject\t\t\t= require(\"awayjs-renderergl/lib/compilation/ShaderLightingObject\");\nimport ShaderRegisterCache\t\t\t= require(\"awayjs-renderergl/lib/compilation/ShaderRegisterCache\");\nimport ShaderRegisterData\t\t\t= require(\"awayjs-renderergl/lib/compilation/ShaderRegisterData\");\nimport ShaderRegisterElement\t\t= require(\"awayjs-renderergl/lib/compilation/ShaderRegisterElement\");\nimport ShaderCompilerHelper\t\t\t= require(\"awayjs-renderergl/lib/utils/ShaderCompilerHelper\");\n\nimport MethodVO\t\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/data/MethodVO\");\nimport LightingMethodBase\t\t\t= require(\"awayjs-methodmaterials/lib/methods/LightingMethodBase\");\nimport ShadingMethodBase\t\t\t= require(\"awayjs-methodmaterials/lib/methods/ShadingMethodBase\");\n\n/**\n * SpecularBasicMethod provides the default shading method for Blinn-Phong specular highlights (an optimized but approximated\n * version of Phong specularity).\n */\nclass SpecularBasicMethod extends LightingMethodBase\n{\n\tpublic _pUseTexture:boolean;\n\tpublic _pTotalLightColorReg:ShaderRegisterElement;\n\tpublic _pSpecularTextureRegister:ShaderRegisterElement;\n\tpublic _pSpecularTexData:ShaderRegisterElement;\n\tpublic _pSpecularDataRegister:ShaderRegisterElement;\n\n\tprivate _texture:Texture2DBase;\n\n\tprivate _gloss:number = 50;\n\tprivate _specular:number = 1;\n\tprivate _specularColor:number = 0xffffff;\n\tpublic _iSpecularR:number = 1;\n\tpublic _iSpecularG:number = 1;\n\tpublic _iSpecularB:number = 1;\n\tpublic _pIsFirstLight:boolean;\n\n\t/**\n\t * Creates a new SpecularBasicMethod object.\n\t */\n\tconstructor()\n\t{\n\t\tsuper();\n\t}\n\n\tpublic iIsUsed(shaderObject:ShaderLightingObject):boolean\n\t{\n\t\tif (!shaderObject.numLights)\n\t\t\treturn false;\n\n\t\treturn true;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitVO(shaderObject:ShaderLightingObject, methodVO:MethodVO)\n\t{\n\t\tmethodVO.needsUV = this._pUseTexture;\n\t\tmethodVO.needsNormals = shaderObject.numLights > 0;\n\t\tmethodVO.needsView = shaderObject.numLights > 0;\n\t}\n\n\t/**\n\t * The sharpness of the specular highlight.\n\t */\n\tpublic get gloss():number\n\t{\n\t\treturn this._gloss;\n\t}\n\n\tpublic set gloss(value:number)\n\t{\n\t\tthis._gloss = value;\n\t}\n\n\t/**\n\t * The overall strength of the specular highlights.\n\t */\n\tpublic get specular():number\n\t{\n\t\treturn this._specular;\n\t}\n\n\tpublic set specular(value:number)\n\t{\n\t\tif (value == this._specular)\n\t\t\treturn;\n\n\t\tthis._specular = value;\n\t\tthis.updateSpecular();\n\t}\n\n\t/**\n\t * The colour of the specular reflection of the surface.\n\t */\n\tpublic get specularColor():number\n\t{\n\t\treturn this._specularColor;\n\t}\n\n\tpublic set specularColor(value:number)\n\t{\n\t\tif (this._specularColor == value)\n\t\t\treturn;\n\n\t\t// specular is now either enabled or disabled\n\t\tif (this._specularColor == 0 || value == 0)\n\t\t\tthis.iInvalidateShaderProgram();\n\n\t\tthis._specularColor = value;\n\t\tthis.updateSpecular();\n\t}\n\n\t/**\n\t * The bitmapData that encodes the specular highlight strength per texel in the red channel, and the sharpness\n\t * in the green channel. You can use SpecularBitmapTexture if you want to easily set specular and gloss maps\n\t * from grayscale images, but prepared images are preferred.\n\t */\n\tpublic get texture():Texture2DBase\n\t{\n\t\treturn this._texture;\n\t}\n\n\tpublic set texture(value:Texture2DBase)\n\t{\n\t\tvar b:boolean = ( value != null );\n\n\t\tif (b != this._pUseTexture || (value && this._texture && (value.hasMipmaps != this._texture.hasMipmaps || value.format != this._texture.format)))\n\t\t\tthis.iInvalidateShaderProgram();\n\n\t\tthis._pUseTexture = b;\n\t\tthis._texture = value;\n\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic copyFrom(method:ShadingMethodBase)\n\t{\n\n\t\tvar m:any = method;\n\t\tvar bsm:SpecularBasicMethod = <SpecularBasicMethod> method;\n\n\t\tvar spec:SpecularBasicMethod = bsm;//SpecularBasicMethod(method);\n\t\tthis.texture = spec.texture;\n\t\tthis.specular = spec.specular;\n\t\tthis.specularColor = spec.specularColor;\n\t\tthis.gloss = spec.gloss;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iCleanCompilationData()\n\t{\n\t\tsuper.iCleanCompilationData();\n\t\tthis._pTotalLightColorReg = null;\n\t\tthis._pSpecularTextureRegister = null;\n\t\tthis._pSpecularTexData = null;\n\t\tthis._pSpecularDataRegister = null;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentPreLightingCode(shaderObject:ShaderLightingObject, methodVO:MethodVO, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = \"\";\n\n\t\tthis._pIsFirstLight = true;\n\n\t\tthis._pSpecularDataRegister = registerCache.getFreeFragmentConstant();\n\t\tmethodVO.fragmentConstantsIndex = this._pSpecularDataRegister.index*4;\n\n\t\tif (this._pUseTexture) {\n\n\t\t\tthis._pSpecularTexData = registerCache.getFreeFragmentVectorTemp();\n\t\t\tregisterCache.addFragmentTempUsages(this._pSpecularTexData, 1);\n\t\t\tthis._pSpecularTextureRegister = registerCache.getFreeTextureReg();\n\t\t\tmethodVO.texturesIndex = this._pSpecularTextureRegister.index;\n\t\t\tcode = ShaderCompilerHelper.getTex2DSampleCode(this._pSpecularTexData, sharedRegisters, this._pSpecularTextureRegister, this._texture, shaderObject.useSmoothTextures, shaderObject.repeatTextures, shaderObject.useMipmapping);\n\n\t\t} else {\n\n\t\t\tthis._pSpecularTextureRegister = null;\n\t\t}\n\n\t\tthis._pTotalLightColorReg = registerCache.getFreeFragmentVectorTemp();\n\t\tregisterCache.addFragmentTempUsages(this._pTotalLightColorReg, 1);\n\n\t\treturn code;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentCodePerLight(shaderObject:ShaderLightingObject, methodVO:MethodVO, lightDirReg:ShaderRegisterElement, lightColReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = \"\";\n\t\tvar t:ShaderRegisterElement;\n\n\t\tif (this._pIsFirstLight) {\n\t\t\tt = this._pTotalLightColorReg;\n\t\t} else {\n\t\t\tt = registerCache.getFreeFragmentVectorTemp();\n\t\t\tregisterCache.addFragmentTempUsages(t, 1);\n\t\t}\n\n\t\tvar viewDirReg:ShaderRegisterElement = sharedRegisters.viewDirFragment;\n\t\tvar normalReg:ShaderRegisterElement = sharedRegisters.normalFragment;\n\n\t\t// blinn-phong half vector model\n\t\tcode += \"add \" + t + \", \" + lightDirReg + \", \" + viewDirReg + \"\\n\" +\n\t\t\t\t\"nrm \" + t + \".xyz, \" + t + \"\\n\" +\n\t\t\t\t\"dp3 \" + t + \".w, \" + normalReg + \", \" + t + \"\\n\" +\n\t\t\t\t\"sat \" + t + \".w, \" + t + \".w\\n\";\n\n\t\tif (this._pUseTexture) {\n\t\t\t// apply gloss modulation from texture\n\t\t\tcode += \"mul \" + this._pSpecularTexData + \".w, \" + this._pSpecularTexData + \".y, \" + this._pSpecularDataRegister + \".w\\n\" +\n\t\t\t\t\t\"pow \" + t + \".w, \" + t + \".w, \" + this._pSpecularTexData + \".w\\n\";\n\t\t} else {\n\t\t\tcode += \"pow \" + t + \".w, \" + t + \".w, \" + this._pSpecularDataRegister + \".w\\n\";\n\t\t}\n\n\t\t// attenuate\n\t\tif (shaderObject.usesLightFallOff)\n\t\t\tcode += \"mul \" + t + \".w, \" + t + \".w, \" + lightDirReg + \".w\\n\";\n\n\t\tif (this._iModulateMethod != null)\n\t\t\tcode += this._iModulateMethod(shaderObject, methodVO, t, registerCache, sharedRegisters);\n\n\t\tcode += \"mul \" + t + \".xyz, \" + lightColReg + \", \" + t + \".w\\n\";\n\n\t\tif (!this._pIsFirstLight) {\n\t\t\tcode += \"add \" + this._pTotalLightColorReg + \".xyz, \" + this._pTotalLightColorReg + \", \" + t + \"\\n\";\n\t\t\tregisterCache.removeFragmentTempUsage(t);\n\t\t}\n\n\t\tthis._pIsFirstLight = false;\n\n\t\treturn code;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentCodePerProbe(shaderObject:ShaderLightingObject, methodVO:MethodVO, cubeMapReg:ShaderRegisterElement, weightRegister:string, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = \"\";\n\t\tvar t:ShaderRegisterElement;\n\n\t\t// write in temporary if not first light, so we can add to total diffuse colour\n\t\tif (this._pIsFirstLight) {\n\t\t\tt = this._pTotalLightColorReg;\n\t\t} else {\n\t\t\tt = registerCache.getFreeFragmentVectorTemp();\n\t\t\tregisterCache.addFragmentTempUsages(t, 1);\n\t\t}\n\n\t\tvar normalReg:ShaderRegisterElement = sharedRegisters.normalFragment;\n\t\tvar viewDirReg:ShaderRegisterElement = sharedRegisters.viewDirFragment;\n\n\t\tcode += \"dp3 \" + t + \".w, \" + normalReg + \", \" + viewDirReg + \"\\n\" +\n\t\t\t\t\"add \" + t + \".w, \" + t + \".w, \" + t + \".w\\n\" +\n\t\t\t\t\"mul \" + t + \", \" + t + \".w, \" + normalReg + \"\\n\" +\n\t\t\t\t\"sub \" + t + \", \" + t + \", \" + viewDirReg + \"\\n\" +\n\t\t\t\t\"tex \" + t + \", \" + t + \", \" + cubeMapReg + \" <cube,\" + (shaderObject.useSmoothTextures? \"linear\":\"nearest\") + \",miplinear>\\n\" +\n\t\t\t\t\"mul \" + t + \".xyz, \" + t + \", \" + weightRegister + \"\\n\";\n\n\t\tif (this._iModulateMethod != null)\n\t\t\tcode += this._iModulateMethod(shaderObject, methodVO, t, registerCache, sharedRegisters);\n\n\t\tif (!this._pIsFirstLight) {\n\t\t\tcode += \"add \" + this._pTotalLightColorReg + \".xyz, \" + this._pTotalLightColorReg + \", \" + t + \"\\n\";\n\t\t\tregisterCache.removeFragmentTempUsage(t);\n\t\t}\n\n\t\tthis._pIsFirstLight = false;\n\n\t\treturn code;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentPostLightingCode(shaderObject:ShaderLightingObject, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = \"\";\n\n\t\tif (sharedRegisters.shadowTarget)\n\t\t\tcode += \"mul \" + this._pTotalLightColorReg + \".xyz, \" + this._pTotalLightColorReg + \", \" + sharedRegisters.shadowTarget + \".w\\n\";\n\n\t\tif (this._pUseTexture) {\n\t\t\t// apply strength modulation from texture\n\t\t\tcode += \"mul \" + this._pTotalLightColorReg + \".xyz, \" + this._pTotalLightColorReg + \", \" + this._pSpecularTexData + \".x\\n\";\n\t\t\tregisterCache.removeFragmentTempUsage(this._pSpecularTexData);\n\t\t}\n\n\t\t// apply material's specular reflection\n\t\tcode += \"mul \" + this._pTotalLightColorReg + \".xyz, \" + this._pTotalLightColorReg + \", \" + this._pSpecularDataRegister + \"\\n\" +\n\t\t\t\"add \" + targetReg + \".xyz, \" + targetReg + \", \" + this._pTotalLightColorReg + \"\\n\";\n\t\tregisterCache.removeFragmentTempUsage(this._pTotalLightColorReg);\n\n\t\treturn code;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iActivate(shaderObject:ShaderLightingObject, methodVO:MethodVO, stage:Stage)\n\t{\n\t\tif (this._pUseTexture) {\n\t\t\tstage.context.setSamplerStateAt(methodVO.texturesIndex, shaderObject.repeatTextures? ContextGLWrapMode.REPEAT:ContextGLWrapMode.CLAMP, shaderObject.useSmoothTextures? ContextGLTextureFilter.LINEAR:ContextGLTextureFilter.NEAREST, shaderObject.useMipmapping? ContextGLMipFilter.MIPLINEAR:ContextGLMipFilter.MIPNONE);\n\t\t\tstage.activateTexture(methodVO.texturesIndex, this._texture);\n\t\t}\n\n\t\tvar index:number = methodVO.fragmentConstantsIndex;\n\t\tvar data:Array<number> = shaderObject.fragmentConstantData;\n\t\tdata[index] = this._iSpecularR;\n\t\tdata[index + 1] = this._iSpecularG;\n\t\tdata[index + 2] = this._iSpecularB;\n\t\tdata[index + 3] = this._gloss;\n\t}\n\n\t/**\n\t * Updates the specular color data used by the render state.\n\t */\n\tprivate updateSpecular()\n\t{\n\t\tthis._iSpecularR = (( this._specularColor >> 16) & 0xff)/0xff*this._specular;\n\t\tthis._iSpecularG = (( this._specularColor >> 8) & 0xff)/0xff*this._specular;\n\t\tthis._iSpecularB = ( this._specularColor & 0xff)/0xff*this._specular;\n\t}\n}\n\nexport = SpecularBasicMethod;","import Stage\t\t\t\t\t\t\t= require(\"awayjs-stagegl/lib/base/Stage\");\n\nimport ShaderLightingObject\t\t\t\t= require(\"awayjs-renderergl/lib/compilation/ShaderLightingObject\");\nimport ShaderObjectBase\t\t\t\t\t= require(\"awayjs-renderergl/lib/compilation/ShaderObjectBase\");\nimport ShaderRegisterCache\t\t\t\t= require(\"awayjs-renderergl/lib/compilation/ShaderRegisterCache\");\nimport ShaderRegisterData\t\t\t\t= require(\"awayjs-renderergl/lib/compilation/ShaderRegisterData\");\nimport ShaderRegisterElement\t\t\t= require(\"awayjs-renderergl/lib/compilation/ShaderRegisterElement\");\n\nimport MethodVO\t\t\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/data/MethodVO\");\nimport SpecularBasicMethod\t\t\t\t= require(\"awayjs-methodmaterials/lib/methods/SpecularBasicMethod\");\nimport SpecularCompositeMethod\t\t\t= require(\"awayjs-methodmaterials/lib/methods/SpecularCompositeMethod\");\n\n/**\n * SpecularCelMethod provides a shading method to add specular cel (cartoon) shading.\n */\nclass SpecularCelMethod extends SpecularCompositeMethod\n{\n\tprivate _dataReg:ShaderRegisterElement;\n\tprivate _smoothness:number = .1;\n\tprivate _specularCutOff:number = .1;\n\n\t/**\n\t * Creates a new SpecularCelMethod object.\n\t * @param specularCutOff The threshold at which the specular highlight should be shown.\n\t * @param baseMethod An optional specular method on which the cartoon shading is based. If ommitted, SpecularBasicMethod is used.\n\t */\n\tconstructor(specularCutOff:number = .5, baseMethod:SpecularBasicMethod = null)\n\t{\n\t\tsuper(null, baseMethod);\n\n\t\tthis.baseMethod._iModulateMethod = (shaderObject:ShaderObjectBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData) => this.clampSpecular(shaderObject, methodVO, targetReg, registerCache, sharedRegisters);\n\n\t\tthis._specularCutOff = specularCutOff;\n\t}\n\n\t/**\n\t * The smoothness of the highlight edge.\n\t */\n\tpublic get smoothness():number\n\t{\n\t\treturn this._smoothness;\n\t}\n\n\tpublic set smoothness(value:number)\n\t{\n\t\tthis._smoothness = value;\n\t}\n\n\t/**\n\t * The threshold at which the specular highlight should be shown.\n\t */\n\tpublic get specularCutOff():number\n\t{\n\t\treturn this._specularCutOff;\n\t}\n\n\tpublic set specularCutOff(value:number)\n\t{\n\t\tthis._specularCutOff = value;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iActivate(shaderObject:ShaderLightingObject, methodVO:MethodVO, stage:Stage)\n\t{\n\t\tsuper.iActivate(shaderObject, methodVO, stage);\n\n\t\tvar index:number /*int*/ = methodVO.secondaryFragmentConstantsIndex;\n\t\tvar data:Array<number> = shaderObject.fragmentConstantData;\n\t\tdata[index] = this._smoothness;\n\t\tdata[index + 1] = this._specularCutOff;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iCleanCompilationData()\n\t{\n\t\tsuper.iCleanCompilationData();\n\t\tthis._dataReg = null;\n\t}\n\n\t/**\n\t * Snaps the specular shading strength of the wrapped method to zero or one, depending on whether or not it exceeds the specularCutOff\n\t * @param vo The MethodVO used to compile the current shader.\n\t * @param t The register containing the specular strength in the \"w\" component, and either the half-vector or the reflection vector in \"xyz\".\n\t * @param regCache The register cache used for the shader compilation.\n\t * @param sharedRegisters The shared register data for this shader.\n\t * @return The AGAL fragment code for the method.\n\t */\n\tprivate clampSpecular(shaderObject:ShaderObjectBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\treturn \"sub \" + targetReg + \".y, \" + targetReg + \".w, \" + this._dataReg + \".y\\n\" + // x - cutoff\n\t\t\t\"div \" + targetReg + \".y, \" + targetReg + \".y, \" + this._dataReg + \".x\\n\" + // (x - cutoff)/epsilon\n\t\t\t\"sat \" + targetReg + \".y, \" + targetReg + \".y\\n\" +\n\t\t\t\"sge \" + targetReg + \".w, \" + targetReg + \".w, \" + this._dataReg + \".y\\n\" +\n\t\t\t\"mul \" + targetReg + \".w, \" + targetReg + \".w, \" + targetReg + \".y\\n\";\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentPreLightingCode(shaderObject:ShaderLightingObject, methodVO:MethodVO, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tthis._dataReg = registerCache.getFreeFragmentConstant();\n\t\tmethodVO.secondaryFragmentConstantsIndex = this._dataReg.index*4;\n\n\t\treturn super.iGetFragmentPreLightingCode(shaderObject, methodVO, registerCache, sharedRegisters);\n\t}\n}\n\nexport = SpecularCelMethod;","import Camera\t\t\t\t\t\t\t= require(\"awayjs-display/lib/entities/Camera\");\n\nimport Texture2DBase\t\t\t\t\t= require(\"awayjs-core/lib/textures/Texture2DBase\");\n\nimport Stage\t\t\t\t\t\t\t= require(\"awayjs-stagegl/lib/base/Stage\");\n\nimport RenderableBase\t\t\t\t\t= require(\"awayjs-renderergl/lib/pool/RenderableBase\");\nimport ShadingMethodEvent\t\t\t\t= require(\"awayjs-renderergl/lib/events/ShadingMethodEvent\");\nimport ShaderLightingObject\t\t\t\t= require(\"awayjs-renderergl/lib/compilation/ShaderLightingObject\");\nimport ShaderObjectBase\t\t\t\t\t= require(\"awayjs-renderergl/lib/compilation/ShaderObjectBase\");\nimport ShaderRegisterCache\t\t\t\t= require(\"awayjs-renderergl/lib/compilation/ShaderRegisterCache\");\nimport ShaderRegisterData\t\t\t\t= require(\"awayjs-renderergl/lib/compilation/ShaderRegisterData\");\nimport ShaderRegisterElement\t\t\t= require(\"awayjs-renderergl/lib/compilation/ShaderRegisterElement\");\n\nimport MethodVO\t\t\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/data/MethodVO\");\nimport SpecularBasicMethod\t\t\t\t= require(\"awayjs-methodmaterials/lib/methods/SpecularBasicMethod\");\n\n/**\n * SpecularCompositeMethod provides a base class for specular methods that wrap a specular method to alter the\n * calculated specular reflection strength.\n */\nclass SpecularCompositeMethod extends SpecularBasicMethod\n{\n\tprivate _baseMethod:SpecularBasicMethod;\n\n\tprivate _onShaderInvalidatedDelegate:Function;\n\n\t/**\n\t * Creates a new <code>SpecularCompositeMethod</code> object.\n\t *\n\t * @param modulateMethod The method which will add the code to alter the base method's strength. It needs to have the signature modSpecular(t:ShaderRegisterElement, regCache:ShaderRegisterCache):string, in which t.w will contain the specular strength and t.xyz will contain the half-vector or the reflection vector.\n\t * @param baseMethod The base specular method on which this method's shading is based.\n\t */\n\tconstructor(modulateMethod:(shaderObject:ShaderObjectBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData) => string, baseMethod:SpecularBasicMethod = null)\n\t{\n\t\tsuper();\n\n\t\tthis._onShaderInvalidatedDelegate = (event:ShadingMethodEvent) => this.onShaderInvalidated(event);\n\n\t\tthis._baseMethod = baseMethod || new SpecularBasicMethod();\n\t\tthis._baseMethod._iModulateMethod = modulateMethod;\n\t\tthis._baseMethod.addEventListener(ShadingMethodEvent.SHADER_INVALIDATED, this._onShaderInvalidatedDelegate);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitVO(shaderObject:ShaderLightingObject, methodVO:MethodVO)\n\t{\n\t\tthis._baseMethod.iInitVO(shaderObject, methodVO);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitConstants(shaderObject:ShaderObjectBase, methodVO:MethodVO)\n\t{\n\t\tthis._baseMethod.iInitConstants(shaderObject, methodVO);\n\t}\n\n\t/**\n\t * The base specular method on which this method's shading is based.\n\t */\n\tpublic get baseMethod():SpecularBasicMethod\n\t{\n\t\treturn this._baseMethod;\n\t}\n\n\tpublic set baseMethod(value:SpecularBasicMethod)\n\t{\n\t\tif (this._baseMethod == value)\n\t\t\treturn;\n\n\t\tthis._baseMethod.removeEventListener(ShadingMethodEvent.SHADER_INVALIDATED, this._onShaderInvalidatedDelegate);\n\n\t\tthis._baseMethod = value;\n\n\t\tthis._baseMethod.addEventListener(ShadingMethodEvent.SHADER_INVALIDATED, this._onShaderInvalidatedDelegate);\n\n\t\tthis.iInvalidateShaderProgram();\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic get gloss():number\n\t{\n\t\treturn this._baseMethod.gloss;\n\t}\n\n\tpublic set gloss(value:number)\n\t{\n\t\tthis._baseMethod.gloss = value;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic get specular():number\n\t{\n\t\treturn this._baseMethod.specular;\n\t}\n\n\tpublic set specular(value:number)\n\t{\n\t\tthis._baseMethod.specular = value;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic dispose()\n\t{\n\t\tthis._baseMethod.removeEventListener(ShadingMethodEvent.SHADER_INVALIDATED, this._onShaderInvalidatedDelegate);\n\t\tthis._baseMethod.dispose();\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic get texture():Texture2DBase\n\t{\n\t\treturn this._baseMethod.texture;\n\t}\n\n\tpublic set texture(value:Texture2DBase)\n\t{\n\t\tthis._baseMethod.texture = value;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iActivate(shaderObject:ShaderLightingObject, methodVO:MethodVO, stage:Stage)\n\t{\n\t\tthis._baseMethod.iActivate(shaderObject, methodVO, stage);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iSetRenderState(shaderObject:ShaderLightingObject, methodVO:MethodVO, renderable:RenderableBase, stage:Stage, camera:Camera)\n\t{\n\t\tthis._baseMethod.iSetRenderState(shaderObject, methodVO, renderable, stage, camera);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iDeactivate(shaderObject:ShaderObjectBase, methodVO:MethodVO, stage:Stage)\n\t{\n\t\tthis._baseMethod.iDeactivate(shaderObject, methodVO, stage);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetVertexCode(shaderObject:ShaderObjectBase, methodVO:MethodVO, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\treturn this._baseMethod.iGetVertexCode(shaderObject, methodVO, registerCache, sharedRegisters);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentPreLightingCode(shaderObject:ShaderLightingObject, methodVO:MethodVO, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\treturn this._baseMethod.iGetFragmentPreLightingCode(shaderObject, methodVO, registerCache, sharedRegisters);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentCodePerLight(shaderObject:ShaderLightingObject, methodVO:MethodVO, lightDirReg:ShaderRegisterElement, lightColReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\treturn this._baseMethod.iGetFragmentCodePerLight(shaderObject, methodVO, lightDirReg, lightColReg, registerCache, sharedRegisters);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t * @return\n\t */\n\tpublic iGetFragmentCodePerProbe(shaderObject:ShaderLightingObject, methodVO:MethodVO, cubeMapReg:ShaderRegisterElement, weightRegister:string, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\treturn this._baseMethod.iGetFragmentCodePerProbe(shaderObject, methodVO, cubeMapReg, weightRegister, registerCache, sharedRegisters);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentPostLightingCode(shaderObject:ShaderLightingObject, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\treturn this._baseMethod.iGetFragmentPostLightingCode(shaderObject, methodVO, targetReg, registerCache, sharedRegisters);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iReset()\n\t{\n\t\tthis._baseMethod.iReset();\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iCleanCompilationData()\n\t{\n\t\tsuper.iCleanCompilationData();\n\t\tthis._baseMethod.iCleanCompilationData();\n\t}\n\n\t/**\n\t * Called when the base method's shader code is invalidated.\n\t */\n\tprivate onShaderInvalidated(event:ShadingMethodEvent)\n\t{\n\t\tthis.iInvalidateShaderProgram();\n\t}\n}\n\nexport = SpecularCompositeMethod;","import Camera\t\t\t\t\t\t\t= require(\"awayjs-display/lib/entities/Camera\");\n\nimport Stage\t\t\t\t\t\t\t= require(\"awayjs-stagegl/lib/base/Stage\");\n\nimport ShaderLightingObject\t\t\t\t= require(\"awayjs-renderergl/lib/compilation/ShaderLightingObject\");\nimport ShaderObjectBase\t\t\t\t\t= require(\"awayjs-renderergl/lib/compilation/ShaderObjectBase\");\nimport ShaderRegisterCache\t\t\t\t= require(\"awayjs-renderergl/lib/compilation/ShaderRegisterCache\");\nimport ShaderRegisterData\t\t\t\t= require(\"awayjs-renderergl/lib/compilation/ShaderRegisterData\");\nimport ShaderRegisterElement\t\t\t= require(\"awayjs-renderergl/lib/compilation/ShaderRegisterElement\");\n\nimport MethodVO\t\t\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/data/MethodVO\");\nimport SpecularBasicMethod\t\t\t\t= require(\"awayjs-methodmaterials/lib/methods/SpecularBasicMethod\");\nimport SpecularCompositeMethod\t\t\t= require(\"awayjs-methodmaterials/lib/methods/SpecularCompositeMethod\");\n\n/**\n * SpecularFresnelMethod provides a specular shading method that causes stronger highlights on grazing view angles.\n */\nclass SpecularFresnelMethod extends SpecularCompositeMethod\n{\n\tprivate _dataReg:ShaderRegisterElement;\n\tprivate _incidentLight:boolean;\n\tprivate _fresnelPower:number = 5;\n\tprivate _normalReflectance:number = .028; // default value for skin\n\n\t/**\n\t * Creates a new SpecularFresnelMethod object.\n\t * @param basedOnSurface Defines whether the fresnel effect should be based on the view angle on the surface (if true), or on the angle between the light and the view.\n\t * @param baseMethod The specular method to which the fresnel equation. Defaults to SpecularBasicMethod.\n\t */\n\tconstructor(basedOnSurface:boolean = true, baseMethod:SpecularBasicMethod = null)\n\t{\n\t\t// may want to offer diff speculars\n\t\tsuper(null, baseMethod);\n\n\t\tthis.baseMethod._iModulateMethod = (shaderObject:ShaderObjectBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData) => this.modulateSpecular(shaderObject, methodVO, targetReg, registerCache, sharedRegisters);\n\n\t\tthis._incidentLight = !basedOnSurface;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitConstants(shaderObject:ShaderObjectBase, methodVO:MethodVO)\n\t{\n\n\t\tvar index:number = methodVO.secondaryFragmentConstantsIndex;\n\t\tshaderObject.fragmentConstantData[index + 2] = 1;\n\t\tshaderObject.fragmentConstantData[index + 3] = 0;\n\t}\n\n\t/**\n\t * Defines whether the fresnel effect should be based on the view angle on the surface (if true), or on the angle between the light and the view.\n\t */\n\tpublic get basedOnSurface():boolean\n\t{\n\t\treturn !this._incidentLight;\n\t}\n\n\tpublic set basedOnSurface(value:boolean)\n\t{\n\t\tif (this._incidentLight != value)\n\t\t\treturn;\n\n\t\tthis._incidentLight = !value;\n\n\t\tthis.iInvalidateShaderProgram();\n\t}\n\n\t/**\n\t * The power used in the Fresnel equation. Higher values make the fresnel effect more pronounced. Defaults to 5.\n\t */\n\tpublic get fresnelPower():number\n\t{\n\t\treturn this._fresnelPower;\n\t}\n\n\tpublic set fresnelPower(value:number)\n\t{\n\t\tthis._fresnelPower = value;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iCleanCompilationData()\n\t{\n\t\tsuper.iCleanCompilationData();\n\t\tthis._dataReg = null;\n\t}\n\n\t/**\n\t * The minimum amount of reflectance, ie the reflectance when the view direction is normal to the surface or light direction.\n\t */\n\tpublic get normalReflectance():number\n\t{\n\t\treturn this._normalReflectance;\n\t}\n\n\tpublic set normalReflectance(value:number)\n\t{\n\t\tthis._normalReflectance = value;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iActivate(shaderObject:ShaderLightingObject, methodVO:MethodVO, stage:Stage)\n\t{\n\t\tsuper.iActivate(shaderObject, methodVO, stage);\n\n\t\tvar fragmentData:Array<number> = shaderObject.fragmentConstantData;\n\n\t\tvar index:number = methodVO.secondaryFragmentConstantsIndex;\n\t\tfragmentData[index] = this._normalReflectance;\n\t\tfragmentData[index + 1] = this._fresnelPower;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentPreLightingCode(shaderObject:ShaderLightingObject, methodVO:MethodVO, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tthis._dataReg = registerCache.getFreeFragmentConstant();\n\n\t\tconsole.log('SpecularFresnelMethod', 'iGetFragmentPreLightingCode', this._dataReg);\n\n\t\tmethodVO.secondaryFragmentConstantsIndex = this._dataReg.index*4;\n\n\t\treturn super.iGetFragmentPreLightingCode(shaderObject, methodVO, registerCache, sharedRegisters);\n\t}\n\n\t/**\n\t * Applies the fresnel effect to the specular strength.\n\t *\n\t * @param vo The MethodVO object containing the method data for the currently compiled material pass.\n\t * @param target The register containing the specular strength in the \"w\" component, and the half-vector/reflection vector in \"xyz\".\n\t * @param regCache The register cache used for the shader compilation.\n\t * @param sharedRegisters The shared registers created by the compiler.\n\t * @return The AGAL fragment code for the method.\n\t */\n\tprivate modulateSpecular(shaderObject:ShaderObjectBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string;\n\n\t\tcode = \"dp3 \" + targetReg + \".y, \" + sharedRegisters.viewDirFragment + \".xyz, \" + (this._incidentLight? targetReg : sharedRegisters.normalFragment) + \".xyz\\n\" +   // dot(V, H)\n\t\t\t\"sub \" + targetReg + \".y, \" + this._dataReg + \".z, \" + targetReg + \".y\\n\" +             // base = 1-dot(V, H)\n\t\t\t\"pow \" + targetReg + \".x, \" + targetReg + \".y, \" + this._dataReg + \".y\\n\" +             // exp = pow(base, 5)\n\t\t\t\"sub \" + targetReg + \".y, \" + this._dataReg + \".z, \" + targetReg + \".y\\n\" +             // 1 - exp\n\t\t\t\"mul \" + targetReg + \".y, \" + this._dataReg + \".x, \" + targetReg + \".y\\n\" +             // f0*(1 - exp)\n\t\t\t\"add \" + targetReg + \".y, \" + targetReg + \".x, \" + targetReg + \".y\\n\" +          // exp + f0*(1 - exp)\n\t\t\t\"mul \" + targetReg + \".w, \" + targetReg + \".w, \" + targetReg + \".y\\n\";\n\n\n\t\tconsole.log('SpecularFresnelMethod', 'modulateSpecular', code);\n\n\t\treturn code;\n\t}\n\n}\n\nexport = SpecularFresnelMethod;","import ShaderLightingObject\t\t\t\t= require(\"awayjs-renderergl/lib/compilation/ShaderLightingObject\");\nimport ShaderRegisterCache\t\t\t\t= require(\"awayjs-renderergl/lib/compilation/ShaderRegisterCache\");\nimport ShaderRegisterData\t\t\t\t= require(\"awayjs-renderergl/lib/compilation/ShaderRegisterData\");\nimport ShaderRegisterElement\t\t\t= require(\"awayjs-renderergl/lib/compilation/ShaderRegisterElement\");\n\nimport MethodVO\t\t\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/data/MethodVO\");\nimport SpecularBasicMethod\t\t\t\t= require(\"awayjs-methodmaterials/lib/methods/SpecularBasicMethod\");\n\n/**\n * SpecularPhongMethod provides a specular method that provides Phong highlights.\n */\nclass SpecularPhongMethod extends SpecularBasicMethod\n{\n\t/**\n\t * Creates a new SpecularPhongMethod object.\n\t */\n\tconstructor()\n\t{\n\t\tsuper();\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentCodePerLight(shaderObject:ShaderLightingObject, methodVO:MethodVO, lightDirReg:ShaderRegisterElement, lightColReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = \"\";\n\t\tvar t:ShaderRegisterElement;\n\n\t\tif (this._pIsFirstLight) {\n\t\t\tt = this._pTotalLightColorReg;\n\t\t} else {\n\t\t\tt = registerCache.getFreeFragmentVectorTemp();\n\t\t\tregisterCache.addFragmentTempUsages(t, 1);\n\t\t}\n\n\t\tvar viewDirReg:ShaderRegisterElement =sharedRegisters.viewDirFragment;\n\t\tvar normalReg:ShaderRegisterElement =sharedRegisters.normalFragment;\n\n\t\t// phong model\n\t\tcode += \"dp3 \" + t + \".w, \" + lightDirReg + \", \" + normalReg + \"\\n\" + // sca1 = light.normal\n\n\t\t\t//find the reflected light vector R\n\t\t\t\"add \" + t + \".w, \" + t + \".w, \" + t + \".w\\n\" + // sca1 = sca1*2\n\t\t\t\"mul \" + t + \".xyz, \" + normalReg + \", \" + t + \".w\\n\" + // vec1 = normal*sca1\n\t\t\t\"sub \" + t + \".xyz, \" + t + \", \" + lightDirReg + \"\\n\" + // vec1 = vec1 - light (light vector is negative)\n\n\t\t\t//smooth the edge as incidence angle approaches 90\n\t\t\t\"add \" + t + \".w, \" + t + \".w, \" +sharedRegisters.commons + \".w\\n\" + // sca1 = sca1 + smoothtep;\n\t\t\t\"sat \" + t + \".w, \" + t + \".w\\n\" + // sca1 range 0 - 1\n\t\t\t\"mul \" + t + \".xyz, \" + t + \", \" + t + \".w\\n\" + // vec1 = vec1*sca1\n\n\t\t\t//find the dot product between R and V\n\t\t\t\"dp3 \" + t + \".w, \" + t + \", \" + viewDirReg + \"\\n\" + // sca1 = vec1.view\n\t\t\t\"sat \" + t + \".w, \" + t + \".w\\n\";\n\n\t\tif (this._pUseTexture) {\n\t\t\t// apply gloss modulation from texture\n\t\t\tcode += \"mul \" + this._pSpecularTexData + \".w, \" + this._pSpecularTexData + \".y, \" + this._pSpecularDataRegister + \".w\\n\" + \"pow \" + t + \".w, \" + t + \".w, \" + this._pSpecularTexData + \".w\\n\";\n\t\t} else\n\t\t\tcode += \"pow \" + t + \".w, \" + t + \".w, \" + this._pSpecularDataRegister + \".w\\n\";\n\n\t\t// attenuate\n\t\tif (shaderObject.usesLightFallOff)\n\t\t\tcode += \"mul \" + t + \".w, \" + t + \".w, \" + lightDirReg + \".w\\n\";\n\n\t\tif (this._iModulateMethod != null)\n\t\t\tcode += this._iModulateMethod(shaderObject, methodVO, t, registerCache, sharedRegisters);\n\n\t\tcode += \"mul \" + t + \".xyz, \" + lightColReg + \".xyz, \" + t + \".w\\n\";\n\n\t\tif (!this._pIsFirstLight) {\n\t\t\tcode += \"add \" + this._pTotalLightColorReg + \".xyz, \" + this._pTotalLightColorReg + \".xyz, \" + t + \".xyz\\n\";\n\t\t\tregisterCache.removeFragmentTempUsage(t);\n\t\t}\n\n\t\tthis._pIsFirstLight = false;\n\n\t\treturn code;\n\t}\n}\n\nexport = SpecularPhongMethod;","class MaterialPassMode\n{\n\tpublic static EFFECTS:number = 0x01\n\t/**\n\t *\n\t */\n\tpublic static LIGHTING:number = 0x02;\n\t/**\n\t *\n\t */\n\tpublic static SUPER_SHADER:number = 0x03;\n}\n\nexport = MaterialPassMode;","import Matrix3D\t\t\t\t\t\t\t= require(\"awayjs-core/lib/geom/Matrix3D\");\nimport RenderTexture\t\t\t\t\t= require(\"awayjs-core/lib/textures/RenderTexture\");\n\nimport LightBase\t\t\t\t\t\t= require(\"awayjs-display/lib/base/LightBase\");\nimport TriangleSubGeometry\t\t\t\t= require(\"awayjs-display/lib/base/TriangleSubGeometry\");\nimport Camera\t\t\t\t\t\t\t= require(\"awayjs-display/lib/entities/Camera\");\nimport MaterialBase\t\t\t\t\t\t= require(\"awayjs-display/lib/materials/MaterialBase\");\n\nimport ContextGLProgramType\t\t\t\t= require(\"awayjs-stagegl/lib/base/ContextGLProgramType\");\nimport IContextGL\t\t\t\t\t\t= require(\"awayjs-stagegl/lib/base/IContextGL\");\nimport Stage\t\t\t\t\t\t\t= require(\"awayjs-stagegl/lib/base/Stage\");\n\nimport RendererBase\t\t\t\t\t\t= require(\"awayjs-renderergl/lib/base/RendererBase\");\nimport MaterialPassData\t\t\t\t\t= require(\"awayjs-renderergl/lib/pool/MaterialPassData\");\nimport RenderableBase\t\t\t\t\t= require(\"awayjs-renderergl/lib/pool/RenderableBase\");\nimport ShaderObjectBase\t\t\t\t\t= require(\"awayjs-renderergl/lib/compilation/ShaderObjectBase\");\nimport ShaderRegisterCache\t\t\t\t= require(\"awayjs-renderergl/lib/compilation/ShaderRegisterCache\");\nimport ShaderRegisterData\t\t\t\t= require(\"awayjs-renderergl/lib/compilation/ShaderRegisterData\");\nimport MaterialPassGLBase\t\t\t\t= require(\"awayjs-renderergl/lib/passes/MaterialPassGLBase\");\n\n/**\n * The SingleObjectDepthPass provides a material pass that renders a single object to a depth map from the point\n * of view from a light.\n */\nclass SingleObjectDepthPass extends MaterialPassGLBase\n{\n\tprivate _textures:Object;\n\tprivate _projections:Object;\n\tprivate _textureSize:number /*uint*/ = 512;\n\tprivate _polyOffset:Array<number> = Array<number>(15, 0, 0, 0);\n\tprivate _enc:Array<number>;\n\tprivate _projectionTexturesInvalid:Boolean = true;\n\n\t/**\n\t * The size of the depth map texture to render to.\n\t */\n\tpublic get textureSize():number\n\t{\n\t\treturn this._textureSize;\n\t}\n\n\tpublic set textureSize(value:number)\n\t{\n\t\tthis._textureSize = value;\n\t}\n\n\t/**\n\t * The amount by which the rendered object will be inflated, to prevent depth map rounding errors.\n\t */\n\tpublic get polyOffset():number\n\t{\n\t\treturn this._polyOffset[0];\n\t}\n\n\tpublic set polyOffset(value:number)\n\t{\n\t\tthis._polyOffset[0] = value;\n\t}\n\n\t/**\n\t * Creates a new SingleObjectDepthPass object.\n\t */\n\tconstructor()\n\t{\n\t\tsuper();\n\n\t\t//this._pNumUsedStreams = 2;\n\t\t//this._pNumUsedVertexConstants = 7;\n\t\t//this._enc = Array<number>(1.0, 255.0, 65025.0, 16581375.0, 1.0/255.0, 1.0/255.0, 1.0/255.0, 0.0);\n\t\t//\n\t\t//this._pAnimatableAttributes = Array<string>(\"va0\", \"va1\");\n\t\t//this._pAnimationTargetRegisters = Array<string>(\"vt0\", \"vt1\");\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic dispose()\n\t{\n\t\tif (this._textures) {\n\t\t\tfor (var key in this._textures) {\n\t\t\t\tvar texture:RenderTexture = this._textures[key];\n\t\t\t\ttexture.dispose();\n\t\t\t}\n\t\t\tthis._textures = null;\n\t\t}\n\t}\n\n\t/**\n\t * Updates the projection textures used to contain the depth renders.\n\t */\n\tprivate updateProjectionTextures()\n\t{\n\t\tif (this._textures) {\n\t\t\tfor (var key in this._textures) {\n\t\t\t\tvar texture:RenderTexture = this._textures[key];\n\t\t\t\ttexture.dispose();\n\t\t\t}\n\t\t}\n\n\t\tthis._textures = new Object();\n\t\tthis._projections = new Object();\n\t\tthis._projectionTexturesInvalid = false;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic _iGetVertexCode():string\n\t{\n\t\tvar code:string;\n\t\t// offset\n\t\tcode = \"mul vt7, vt1, vc4.x\t\\n\" +\n\t\t\t\t\"add vt7, vt7, vt0\\n\" +\n\t\t\t\t\"mov vt7.w, vt0.w\\n\";\n\t\t// project\n\t\tcode += \"m44 vt2, vt7, vc0\\n\" +\n\t\t\t\t\"mov op, vt2\\n\";\n\n\t\t// perspective divide\n\t\tcode += \"div v0, vt2, vt2.w\\n\";\n\n\t\treturn code;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic _iGetFragmentCode(shaderObject:ShaderObjectBase, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = \"\";\n\n\t\t// encode float -> rgba\n\t\tcode += \"mul ft0, fc0, v0.z\\n\" +\n\t\t\t\t\"frc ft0, ft0\\n\" +\n\t\t\t\t\"mul ft1, ft0.yzww, fc1\\n\" +\n\t\t\t\t\"sub ft0, ft0, ft1\\n\" +\n\t\t\t\t\"mov oc, ft0\\n\";\n\n\t\treturn code;\n\t}\n\n\t/**\n\t * Gets the depth maps rendered for this object from all lights.\n\t * @param renderable The renderable for which to retrieve the depth maps.\n\t * @param stage3DProxy The Stage3DProxy object currently used for rendering.\n\t * @return A list of depth map textures for all supported lights.\n\t */\n\tpublic _iGetDepthMap(renderable:RenderableBase):RenderTexture\n\t{\n\t\treturn this._textures[renderable.materialOwner.id];\n\t}\n\n\t/**\n\t * Retrieves the depth map projection maps for all lights.\n\t * @param renderable The renderable for which to retrieve the projection maps.\n\t * @return A list of projection maps for all supported lights.\n\t */\n\tpublic _iGetProjection(renderable:RenderableBase):Matrix3D\n\t{\n\t\treturn this._projections[renderable.materialOwner.id];\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic _iRender(pass:MaterialPassData, renderable:RenderableBase, stage:Stage, camera:Camera, viewProjection:Matrix3D)\n\t{\n\t\tvar matrix:Matrix3D;\n\t\tvar context:IContextGL = stage.context;\n\t\tvar len:number /*uint*/;\n\t\tvar light:LightBase;\n\t\tvar lights:Array<LightBase> = this._pLightPicker.allPickedLights;\n\t\tvar rId:number = renderable.materialOwner.id;\n\n\t\tif (!this._textures[rId])\n\t\t\tthis._textures[rId] = new RenderTexture(this._textureSize, this._textureSize);\n\n\t\tif (!this._projections[rId])\n\t\t\tthis._projections[rId] = new Matrix3D();\n\n\t\tlen = lights.length;\n\n\t\t// local position = enough\n\t\tlight = lights[0];\n\n\t\tmatrix = light.iGetObjectProjectionMatrix(renderable.sourceEntity, camera, this._projections[rId]);\n\n\t\tstage.setRenderTarget(this._textures[rId], true);\n\t\tcontext.clear(1.0, 1.0, 1.0);\n\t\tcontext.setProgramConstantsFromMatrix(ContextGLProgramType.VERTEX, 0, matrix, true);\n\t\tcontext.setProgramConstantsFromArray(ContextGLProgramType.FRAGMENT, 0, this._enc, 2);\n\n\t\tstage.activateBuffer(0, renderable.getVertexData(TriangleSubGeometry.POSITION_DATA), renderable.getVertexOffset(TriangleSubGeometry.POSITION_DATA), TriangleSubGeometry.POSITION_FORMAT);\n\t\tstage.activateBuffer(1, renderable.getVertexData(TriangleSubGeometry.NORMAL_DATA), renderable.getVertexOffset(TriangleSubGeometry.NORMAL_DATA), TriangleSubGeometry.NORMAL_FORMAT);\n\t\tcontext.drawTriangles(stage.getIndexBuffer(renderable.getIndexData()), 0, renderable.numTriangles);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic _iActivate(pass:MaterialPassData, renderer:RendererBase, camera:Camera)\n\t{\n\t\tif (this._projectionTexturesInvalid)\n\t\t\tthis.updateProjectionTextures();\n\n\t\t// never scale\n\t\tsuper._iActivate(pass, renderer, camera);\n\n\t\trenderer.context.setProgramConstantsFromArray(ContextGLProgramType.VERTEX, 4, this._polyOffset, 1);\n\t}\n}\n\nexport = SingleObjectDepthPass;","import ColorTransform\t\t\t\t\t= require(\"awayjs-core/lib/geom/ColorTransform\");\nimport Matrix\t\t\t\t\t\t\t= require(\"awayjs-core/lib/geom/Matrix\");\nimport Matrix3D\t\t\t\t\t\t\t= require(\"awayjs-core/lib/geom/Matrix3D\");\nimport Matrix3DUtils\t\t\t\t\t= require(\"awayjs-core/lib/geom/Matrix3DUtils\");\nimport Vector3D\t\t\t\t\t\t\t= require(\"awayjs-core/lib/geom/Vector3D\");\nimport AbstractMethodError\t\t\t\t= require(\"awayjs-core/lib/errors/AbstractMethodError\");\nimport Texture2DBase\t\t\t\t\t= require(\"awayjs-core/lib/textures/Texture2DBase\");\n\nimport TriangleSubGeometry\t\t\t\t= require(\"awayjs-display/lib/base/TriangleSubGeometry\");\nimport Camera\t\t\t\t\t\t\t= require(\"awayjs-display/lib/entities/Camera\");\n\nimport Stage\t\t\t\t\t\t\t= require(\"awayjs-stagegl/lib/base/Stage\");\n\nimport RendererBase\t\t\t\t\t\t= require(\"awayjs-renderergl/lib/base/RendererBase\");\nimport ShaderLightingObject\t\t\t\t= require(\"awayjs-renderergl/lib/compilation/ShaderLightingObject\");\nimport ShadingMethodEvent\t\t\t\t= require(\"awayjs-renderergl/lib/events/ShadingMethodEvent\");\nimport ShaderObjectBase\t\t\t\t\t= require(\"awayjs-renderergl/lib/compilation/ShaderObjectBase\");\nimport ShaderRegisterCache\t\t\t\t= require(\"awayjs-renderergl/lib/compilation/ShaderRegisterCache\");\nimport ShaderRegisterData\t\t\t\t= require(\"awayjs-renderergl/lib/compilation/ShaderRegisterData\");\nimport ShaderRegisterElement\t\t\t= require(\"awayjs-renderergl/lib/compilation/ShaderRegisterElement\");\nimport MaterialPassData\t\t\t\t\t= require(\"awayjs-renderergl/lib/pool/MaterialPassData\");\nimport RenderableBase\t\t\t\t\t= require(\"awayjs-renderergl/lib/pool/RenderableBase\");\nimport LightingPassGLBase\t\t\t\t= require(\"awayjs-renderergl/lib/passes/LightingPassGLBase\");\n\nimport MethodVO\t\t\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/data/MethodVO\");\nimport AmbientBasicMethod\t\t\t\t= require(\"awayjs-methodmaterials/lib/methods/AmbientBasicMethod\");\nimport DiffuseBasicMethod\t\t\t\t= require(\"awayjs-methodmaterials/lib/methods/DiffuseBasicMethod\");\nimport EffectColorTransformMethod\t\t= require(\"awayjs-methodmaterials/lib/methods/EffectColorTransformMethod\");\nimport EffectMethodBase\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/methods/EffectMethodBase\");\nimport LightingMethodBase\t\t\t\t= require(\"awayjs-methodmaterials/lib/methods/LightingMethodBase\");\nimport NormalBasicMethod\t\t\t\t= require(\"awayjs-methodmaterials/lib/methods/NormalBasicMethod\");\nimport ShadowMapMethodBase\t\t\t\t= require(\"awayjs-methodmaterials/lib/methods/ShadowMapMethodBase\");\nimport SpecularBasicMethod\t\t\t\t= require(\"awayjs-methodmaterials/lib/methods/SpecularBasicMethod\");\nimport MaterialPassMode\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/passes/MaterialPassMode\");\n\n/**\n * CompiledPass forms an abstract base class for the default compiled pass materials provided by Away3D,\n * using material methods to define their appearance.\n */\nclass TriangleMethodPass extends LightingPassGLBase\n{\n\tpublic _pNumLights:number = 0;\n\n\tprivate _passMode:number;\n\n\tprivate _includeCasters:boolean = true;\n\tprivate _maxLights:number = 3;\n\n\tpublic _iColorTransformMethodVO:MethodVO;\n\tpublic _iNormalMethodVO:MethodVO;\n\tpublic _iAmbientMethodVO:MethodVO;\n\tpublic _iShadowMethodVO:MethodVO;\n\tpublic _iDiffuseMethodVO:MethodVO;\n\tpublic _iSpecularMethodVO:MethodVO;\n\tpublic _iMethodVOs:Array<MethodVO> = new Array<MethodVO>();\n\n\tpublic _numEffectDependencies:number = 0;\n\n\tprivate _onShaderInvalidatedDelegate:(event:ShadingMethodEvent) => void;\n\n\t/**\n\t *\n\t */\n\tpublic get passMode():number\n\t{\n\t\treturn this._passMode;\n\t}\n\n\tpublic set passMode(value:number)\n\t{\n\t\tthis._passMode = value;\n\n\t\tthis._pInvalidatePass();\n\t}\n\n\t/**\n\t * Indicates whether or not shadow casting lights need to be included.\n\t */\n\tpublic get includeCasters():boolean\n\t{\n\t\treturn this._includeCasters;\n\t}\n\n\tpublic set includeCasters(value:boolean)\n\t{\n\t\tif (this._includeCasters == value)\n\t\t\treturn;\n\n\t\tthis._includeCasters = value;\n\n\t\tthis._pInvalidatePass();\n\t}\n\n\t/**\n\t * Creates a new CompiledPass object.\n\t *\n\t * @param material The material to which this pass belongs.\n\t */\n\tconstructor(passMode:number = 0x03)\n\t{\n\t\tsuper();\n\n\t\tthis._passMode = passMode;\n\n\t\tthis._onShaderInvalidatedDelegate = (event:ShadingMethodEvent) => this.onShaderInvalidated(event);\n\t}\n\n\t/**\n\t * Factory method to create a concrete shader object for this pass.\n\t *\n\t * @param profile The compatibility profile used by the renderer.\n\t */\n\tpublic createShaderObject(profile:string):ShaderObjectBase\n\t{\n\t\tif (this._pLightPicker && (this.passMode & MaterialPassMode.LIGHTING))\n\t\t\treturn new ShaderLightingObject(profile);\n\n\t\treturn new ShaderObjectBase(profile);\n\t}\n\n\t/**\n\t * Initializes the unchanging constant data for this material.\n\t */\n\tpublic _iInitConstantData(shaderObject:ShaderObjectBase)\n\t{\n\t\tsuper._iInitConstantData(shaderObject);\n\n\t\t//Updates method constants if they have changed.\n\t\tvar len:number = this._iMethodVOs.length;\n\t\tfor (var i:number = 0; i < len; ++i)\n\t\t\tthis._iMethodVOs[i].method.iInitConstants(shaderObject, this._iMethodVOs[i]);\n\t}\n\n\t/**\n\t * The ColorTransform object to transform the colour of the material with. Defaults to null.\n\t */\n\tpublic get colorTransform():ColorTransform\n\t{\n\t\treturn this.colorTransformMethod? this.colorTransformMethod.colorTransform : null;\n\t}\n\n\tpublic set colorTransform(value:ColorTransform)\n\t{\n\t\tif (value) {\n\t\t\tif (this.colorTransformMethod == null)\n\t\t\t\tthis.colorTransformMethod = new EffectColorTransformMethod();\n\n\t\t\tthis.colorTransformMethod.colorTransform = value;\n\n\t\t} else if (!value) {\n\t\t\tif (this.colorTransformMethod)\n\t\t\t\tthis.colorTransformMethod = null;\n\t\t}\n\t}\n\n\t/**\n\t * The EffectColorTransformMethod object to transform the colour of the material with. Defaults to null.\n\t */\n\tpublic get colorTransformMethod():EffectColorTransformMethod\n\t{\n\t\treturn this._iColorTransformMethodVO? <EffectColorTransformMethod> this._iColorTransformMethodVO.method : null;\n\t}\n\n\tpublic set colorTransformMethod(value:EffectColorTransformMethod)\n\t{\n\t\tif (this._iColorTransformMethodVO && this._iColorTransformMethodVO.method == value)\n\t\t\treturn;\n\n\t\tif (this._iColorTransformMethodVO) {\n\t\t\tthis._removeDependency(this._iColorTransformMethodVO);\n\t\t\tthis._iColorTransformMethodVO = null;\n\t\t}\n\n\t\tif (value) {\n\t\t\tthis._iColorTransformMethodVO = new MethodVO(value);\n\t\t\tthis._addDependency(this._iColorTransformMethodVO);\n\t\t}\n\t}\n\n\t/**\n\t * Implemented by subclasses if the pass uses lights to update the shader.\n\t */\n\tpublic pUpdateLights()\n\t{\n\t\tvar numDirectionalLightsOld:number = this._pNumDirectionalLights;\n\t\tvar numPointLightsOld:number = this._pNumPointLights;\n\t\tvar numLightProbesOld:number = this._pNumLightProbes;\n\n\t\tif (this._pLightPicker && (this._passMode & MaterialPassMode.LIGHTING)) {\n\t\t\tthis._pNumDirectionalLights = this.calculateNumDirectionalLights(this._pLightPicker.numDirectionalLights);\n\t\t\tthis._pNumPointLights = this.calculateNumPointLights(this._pLightPicker.numPointLights);\n\t\t\tthis._pNumLightProbes = this.calculateNumProbes(this._pLightPicker.numLightProbes);\n\n\t\t\tif (this._includeCasters) {\n\t\t\t\tthis._pNumDirectionalLights += this._pLightPicker.numCastingDirectionalLights;\n\t\t\t\tthis._pNumPointLights += this._pLightPicker.numCastingPointLights;\n\t\t\t}\n\n\t\t} else {\n\t\t\tthis._pNumDirectionalLights = 0;\n\t\t\tthis._pNumPointLights = 0;\n\t\t\tthis._pNumLightProbes = 0;\n\t\t}\n\n\t\tthis._pNumLights = this._pNumDirectionalLights + this._pNumPointLights;\n\n\t\tif (numDirectionalLightsOld != this._pNumDirectionalLights || numPointLightsOld != this._pNumPointLights || numLightProbesOld != this._pNumLightProbes)\n\t\t\tthis._pInvalidatePass();\n\t}\n\t\n\tprivate _removeDependency(methodVO:MethodVO, effectsDependency:boolean = false)\n\t{\n\t\tvar index:number = this._iMethodVOs.indexOf(methodVO);\n\n\t\tif (!effectsDependency)\n\t\t\tthis._numEffectDependencies--;\n\n\t\tmethodVO.method.removeEventListener(ShadingMethodEvent.SHADER_INVALIDATED, this._onShaderInvalidatedDelegate);\n\t\tthis._iMethodVOs.splice(index, 1);\n\n\t\tthis._pInvalidatePass();\n\t}\n\n\tprivate _addDependency(methodVO:MethodVO, effectsDependency:boolean = false, index:number = -1)\n\t{\n\t\tmethodVO.method.addEventListener(ShadingMethodEvent.SHADER_INVALIDATED, this._onShaderInvalidatedDelegate);\n\n\t\tif (effectsDependency) {\n\t\t\tif (index != -1)\n\t\t\t\tthis._iMethodVOs.splice(index + this._iMethodVOs.length - this._numEffectDependencies, 0, methodVO);\n\t\t\telse\n\t\t\t\tthis._iMethodVOs.push(methodVO);\n\t\t\tthis._numEffectDependencies++;\n\t\t} else {\n\t\t\tthis._iMethodVOs.splice(this._iMethodVOs.length - this._numEffectDependencies, 0, methodVO);\n\t\t}\n\n\t\tthis._pInvalidatePass();\n\t}\n\n\t/**\n\t * Appends an \"effect\" shading method to the shader. Effect methods are those that do not influence the lighting\n\t * but modulate the shaded colour, used for fog, outlines, etc. The method will be applied to the result of the\n\t * methods added prior.\n\t */\n\tpublic addEffectMethod(method:EffectMethodBase)\n\t{\n\t\tthis._addDependency(new MethodVO(method), true);\n\t}\n\n\t/**\n\t * The number of \"effect\" methods added to the material.\n\t */\n\tpublic get numEffectMethods():number\n\t{\n\t\treturn this._numEffectDependencies;\n\t}\n\n\t/**\n\t * Queries whether a given effects method was added to the material.\n\t *\n\t * @param method The method to be queried.\n\t * @return true if the method was added to the material, false otherwise.\n\t */\n\tpublic hasEffectMethod(method:EffectMethodBase):boolean\n\t{\n\t\treturn this.getDependencyForMethod(method) != null;\n\t}\n\n\t/**\n\t * Returns the method added at the given index.\n\t * @param index The index of the method to retrieve.\n\t * @return The method at the given index.\n\t */\n\tpublic getEffectMethodAt(index:number):EffectMethodBase\n\t{\n\t\tif (index < 0 || index > this._numEffectDependencies - 1)\n\t\t\treturn null;\n\n\t\treturn <EffectMethodBase> this._iMethodVOs[index + this._iMethodVOs.length - this._numEffectDependencies].method;\n\t}\n\n\t/**\n\t * Adds an effect method at the specified index amongst the methods already added to the material. Effect\n\t * methods are those that do not influence the lighting but modulate the shaded colour, used for fog, outlines,\n\t * etc. The method will be applied to the result of the methods with a lower index.\n\t */\n\tpublic addEffectMethodAt(method:EffectMethodBase, index:number)\n\t{\n\t\tthis._addDependency(new MethodVO(method), true, index);\n\t}\n\n\t/**\n\t * Removes an effect method from the material.\n\t * @param method The method to be removed.\n\t */\n\tpublic removeEffectMethod(method:EffectMethodBase)\n\t{\n\t\tvar methodVO:MethodVO = this.getDependencyForMethod(method);\n\n\t\tif (methodVO != null)\n\t\t\tthis._removeDependency(methodVO, true);\n\t}\n\n\n\tprivate getDependencyForMethod(method:EffectMethodBase):MethodVO\n\t{\n\t\tvar len:number = this._iMethodVOs.length;\n\t\tfor (var i:number = 0; i < len; ++i)\n\t\t\tif (this._iMethodVOs[i].method == method)\n\t\t\t\treturn this._iMethodVOs[i];\n\n\t\treturn null;\n\t}\n\n\t/**\n\t * The method used to generate the per-pixel normals. Defaults to NormalBasicMethod.\n\t */\n\tpublic get normalMethod():NormalBasicMethod\n\t{\n\t\treturn this._iNormalMethodVO? <NormalBasicMethod> this._iNormalMethodVO.method : null;\n\t}\n\n\tpublic set normalMethod(value:NormalBasicMethod)\n\t{\n\t\tif (this._iNormalMethodVO && this._iNormalMethodVO.method == value)\n\t\t\treturn;\n\n\t\tif (this._iNormalMethodVO) {\n\t\t\tthis._removeDependency(this._iNormalMethodVO);\n\t\t\tthis._iNormalMethodVO = null;\n\t\t}\n\n\t\tif (value) {\n\t\t\tthis._iNormalMethodVO = new MethodVO(value);\n\t\t\tthis._addDependency(this._iNormalMethodVO);\n\t\t}\n\t}\n\n\t/**\n\t * The method that provides the ambient lighting contribution. Defaults to AmbientBasicMethod.\n\t */\n\tpublic get ambientMethod():AmbientBasicMethod\n\t{\n\t\treturn this._iAmbientMethodVO? <AmbientBasicMethod> this._iAmbientMethodVO.method : null;\n\t}\n\n\tpublic set ambientMethod(value:AmbientBasicMethod)\n\t{\n\t\tif (this._iAmbientMethodVO && this._iAmbientMethodVO.method == value)\n\t\t\treturn;\n\n\t\tif (this._iAmbientMethodVO) {\n\t\t\tthis._removeDependency(this._iAmbientMethodVO);\n\t\t\tthis._iAmbientMethodVO = null;\n\t\t}\n\n\t\tif (value) {\n\t\t\tthis._iAmbientMethodVO = new MethodVO(value);\n\t\t\tthis._addDependency(this._iAmbientMethodVO);\n\t\t}\n\t}\n\n\t/**\n\t * The method used to render shadows cast on this surface, or null if no shadows are to be rendered. Defaults to null.\n\t */\n\tpublic get shadowMethod():ShadowMapMethodBase\n\t{\n\t\treturn this._iShadowMethodVO? <ShadowMapMethodBase> this._iShadowMethodVO.method : null;\n\t}\n\n\tpublic set shadowMethod(value:ShadowMapMethodBase)\n\t{\n\t\tif (this._iShadowMethodVO && this._iShadowMethodVO.method == value)\n\t\t\treturn;\n\n\t\tif (this._iShadowMethodVO) {\n\t\t\tthis._removeDependency(this._iShadowMethodVO);\n\t\t\tthis._iShadowMethodVO = null;\n\t\t}\n\n\t\tif (value) {\n\t\t\tthis._iShadowMethodVO = new MethodVO(value);\n\t\t\tthis._addDependency(this._iShadowMethodVO);\n\t\t}\n\t}\n\n\t/**\n\t * The method that provides the diffuse lighting contribution. Defaults to DiffuseBasicMethod.\n\t */\n\tpublic get diffuseMethod():DiffuseBasicMethod\n\t{\n\t\treturn this._iDiffuseMethodVO? <DiffuseBasicMethod> this._iDiffuseMethodVO.method : null;\n\t}\n\n\tpublic set diffuseMethod(value:DiffuseBasicMethod)\n\t{\n\t\tif (this._iDiffuseMethodVO && this._iDiffuseMethodVO.method == value)\n\t\t\treturn;\n\n\t\tif (this._iDiffuseMethodVO) {\n\t\t\tthis._removeDependency(this._iDiffuseMethodVO);\n\t\t\tthis._iDiffuseMethodVO = null;\n\t\t}\n\n\t\tif (value) {\n\t\t\tthis._iDiffuseMethodVO = new MethodVO(value);\n\t\t\tthis._addDependency(this._iDiffuseMethodVO);\n\t\t}\n\t}\n\n\t/**\n\t * The method that provides the specular lighting contribution. Defaults to SpecularBasicMethod.\n\t */\n\tpublic get specularMethod():SpecularBasicMethod\n\t{\n\t\treturn this._iSpecularMethodVO? <SpecularBasicMethod> this._iSpecularMethodVO.method : null;\n\t}\n\n\tpublic set specularMethod(value:SpecularBasicMethod)\n\t{\n\t\tif (this._iSpecularMethodVO && this._iSpecularMethodVO.method == value)\n\t\t\treturn;\n\n\t\tif (this._iSpecularMethodVO) {\n\t\t\tthis._removeDependency(this._iSpecularMethodVO);\n\t\t\tthis._iSpecularMethodVO = null;\n\t\t}\n\n\t\tif (value) {\n\t\t\tthis._iSpecularMethodVO = new MethodVO(value);\n\t\t\tthis._addDependency(this._iSpecularMethodVO);\n\t\t}\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic dispose()\n\t{\n\t\tsuper.dispose();\n\n\t\twhile (this._iMethodVOs.length)\n\t\t\tthis._removeDependency(this._iMethodVOs[0]);\n\n\t\tthis._iMethodVOs = null;\n\t}\n\n\t/**\n\t * Called when any method's shader code is invalidated.\n\t */\n\tprivate onShaderInvalidated(event:ShadingMethodEvent)\n\t{\n\t\tthis._pInvalidatePass();\n\t}\n\n\t// RENDER LOOP\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic _iActivate(pass:MaterialPassData, renderer:RendererBase, camera:Camera)\n\t{\n\t\tsuper._iActivate(pass, renderer, camera);\n\n\t\tvar methodVO:MethodVO;\n\t\tvar len:number = this._iMethodVOs.length;\n\t\tfor (var i:number = 0; i < len; ++i) {\n\t\t\tmethodVO = this._iMethodVOs[i];\n\t\t\tif (methodVO.useMethod)\n\t\t\t\tmethodVO.method.iActivate(pass.shaderObject, methodVO, renderer.stage);\n\t\t}\n\t}\n\n\t/**\n\t *\n\t *\n\t * @param renderable\n\t * @param stage\n\t * @param camera\n\t */\n\tpublic setRenderState(pass:MaterialPassData, renderable:RenderableBase, stage:Stage, camera:Camera, viewProjection:Matrix3D)\n\t{\n\t\tsuper.setRenderState(pass, renderable, stage, camera, viewProjection);\n\n\t\tvar methodVO:MethodVO;\n\t\tvar len:number = this._iMethodVOs.length;\n\t\tfor (var i:number = 0; i < len; ++i) {\n\t\t\tmethodVO = this._iMethodVOs[i];\n\t\t\tif (methodVO.useMethod)\n\t\t\t\tmethodVO.method.iSetRenderState(pass.shaderObject, methodVO, renderable, stage, camera);\n\t\t}\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic _iDeactivate(pass:MaterialPassData, renderer:RendererBase)\n\t{\n\t\tsuper._iDeactivate(pass, renderer);\n\n\t\tvar methodVO:MethodVO;\n\t\tvar len:number = this._iMethodVOs.length;\n\t\tfor (var i:number = 0; i < len; ++i) {\n\t\t\tmethodVO = this._iMethodVOs[i];\n\t\t\tif (methodVO.useMethod)\n\t\t\t\tmethodVO.method.iDeactivate(pass.shaderObject, methodVO, renderer.stage);\n\t\t}\n\t}\n\n\tpublic _iIncludeDependencies(shaderObject:ShaderLightingObject)\n\t{\n\t\t//TODO: fragment animtion should be compatible with lighting pass\n\t\tshaderObject.usesFragmentAnimation = Boolean(this._passMode == MaterialPassMode.SUPER_SHADER);\n\n\t\tif (!shaderObject.usesTangentSpace && shaderObject.numPointLights > 0 && shaderObject.usesLights) {\n\t\t\tshaderObject.globalPosDependencies++;\n\n\t\t\tif (Boolean(this._passMode & MaterialPassMode.EFFECTS))\n\t\t\t\tshaderObject.usesGlobalPosFragment = true;\n\t\t}\n\n\t\tvar i:number;\n\t\tvar len:number = this._iMethodVOs.length;\n\t\tfor (i = 0; i < len; ++i)\n\t\t\tthis.setupAndCountDependencies(shaderObject, this._iMethodVOs[i]);\n\n\t\tfor (i = 0; i < len; ++i)\n\t\t\tthis._iMethodVOs[i].useMethod = this._iMethodVOs[i].method.iIsUsed(shaderObject);\n\n\t\tsuper._iIncludeDependencies(shaderObject);\n\t}\n\n\n\t/**\n\t * Counts the dependencies for a given method.\n\t * @param method The method to count the dependencies for.\n\t * @param methodVO The method's data for this material.\n\t */\n\tprivate setupAndCountDependencies(shaderObject:ShaderObjectBase, methodVO:MethodVO)\n\t{\n\t\tmethodVO.reset();\n\n\t\tmethodVO.method.iInitVO(shaderObject, methodVO);\n\n\t\tif (methodVO.needsProjection)\n\t\t\tshaderObject.projectionDependencies++;\n\n\t\tif (methodVO.needsGlobalVertexPos) {\n\n\t\t\tshaderObject.globalPosDependencies++;\n\n\t\t\tif (methodVO.needsGlobalFragmentPos)\n\t\t\t\tshaderObject.usesGlobalPosFragment = true;\n\n\t\t} else if (methodVO.needsGlobalFragmentPos) {\n\t\t\tshaderObject.globalPosDependencies++;\n\t\t\tshaderObject.usesGlobalPosFragment = true;\n\t\t}\n\n\t\tif (methodVO.needsNormals)\n\t\t\tshaderObject.normalDependencies++;\n\n\t\tif (methodVO.needsTangents)\n\t\t\tshaderObject.tangentDependencies++;\n\n\t\tif (methodVO.needsView)\n\t\t\tshaderObject.viewDirDependencies++;\n\n\t\tif (methodVO.needsUV)\n\t\t\tshaderObject.uvDependencies++;\n\n\t\tif (methodVO.needsSecondaryUV)\n\t\t\tshaderObject.secondaryUVDependencies++;\n\t}\n\n\tpublic _iGetPreLightingVertexCode(shaderObject:ShaderObjectBase, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = \"\";\n\n\t\tif (this._iAmbientMethodVO && this._iAmbientMethodVO.useMethod)\n\t\t\tcode += this._iAmbientMethodVO.method.iGetVertexCode(shaderObject, this._iAmbientMethodVO, registerCache, sharedRegisters);\n\n\t\tif (this._iDiffuseMethodVO && this._iDiffuseMethodVO.useMethod)\n\t\t\tcode += this._iDiffuseMethodVO.method.iGetVertexCode(shaderObject, this._iDiffuseMethodVO, registerCache, sharedRegisters);\n\n\t\tif (this._iSpecularMethodVO && this._iSpecularMethodVO.useMethod)\n\t\t\tcode += this._iSpecularMethodVO.method.iGetVertexCode(shaderObject, this._iSpecularMethodVO, registerCache, sharedRegisters);\n\n\t\treturn code;\n\t}\n\n\tpublic _iGetPreLightingFragmentCode(shaderObject:ShaderObjectBase, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = \"\";\n\n\t\tif (this._iAmbientMethodVO && this._iAmbientMethodVO.useMethod) {\n\t\t\tcode += this._iAmbientMethodVO.method.iGetFragmentCode(shaderObject, this._iAmbientMethodVO, sharedRegisters.shadedTarget, registerCache, sharedRegisters);\n\n\t\t\tif (this._iAmbientMethodVO.needsNormals)\n\t\t\t\tregisterCache.removeFragmentTempUsage(sharedRegisters.normalFragment);\n\n\t\t\tif (this._iAmbientMethodVO.needsView)\n\t\t\t\tregisterCache.removeFragmentTempUsage(sharedRegisters.viewDirFragment);\n\t\t}\n\n\t\tif (this._iDiffuseMethodVO && this._iDiffuseMethodVO.useMethod)\n\t\t\tcode += (<LightingMethodBase> this._iDiffuseMethodVO.method).iGetFragmentPreLightingCode(<ShaderLightingObject> shaderObject, this._iDiffuseMethodVO, registerCache, sharedRegisters);\n\n\t\tif (this._iSpecularMethodVO && this._iSpecularMethodVO.useMethod)\n\t\t\tcode += (<LightingMethodBase> this._iSpecularMethodVO.method).iGetFragmentPreLightingCode(<ShaderLightingObject> shaderObject, this._iSpecularMethodVO, registerCache, sharedRegisters);\n\n\t\treturn code;\n\t}\n\n\tpublic _iGetPerLightDiffuseFragmentCode(shaderObject:ShaderLightingObject, lightDirReg:ShaderRegisterElement, diffuseColorReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\treturn (<LightingMethodBase> this._iDiffuseMethodVO.method).iGetFragmentCodePerLight(shaderObject, this._iDiffuseMethodVO, lightDirReg, diffuseColorReg, registerCache, sharedRegisters);\n\t}\n\n\tpublic _iGetPerLightSpecularFragmentCode(shaderObject:ShaderLightingObject, lightDirReg:ShaderRegisterElement, specularColorReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\treturn (<LightingMethodBase> this._iSpecularMethodVO.method).iGetFragmentCodePerLight(shaderObject, this._iSpecularMethodVO, lightDirReg, specularColorReg, registerCache, sharedRegisters);\n\t}\n\n\tpublic _iGetPerProbeDiffuseFragmentCode(shaderObject:ShaderLightingObject, texReg:ShaderRegisterElement, weightReg:string, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\treturn (<LightingMethodBase> this._iDiffuseMethodVO.method).iGetFragmentCodePerProbe(shaderObject, this._iDiffuseMethodVO, texReg, weightReg, registerCache, sharedRegisters);\n\t}\n\n\tpublic _iGetPerProbeSpecularFragmentCode(shaderObject:ShaderLightingObject, texReg:ShaderRegisterElement, weightReg:string, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\treturn (<LightingMethodBase> this._iSpecularMethodVO.method).iGetFragmentCodePerProbe(shaderObject, this._iSpecularMethodVO, texReg, weightReg, registerCache, sharedRegisters);\n\t}\n\n\tpublic _iGetPostLightingVertexCode(shaderObject:ShaderLightingObject, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = \"\";\n\n\t\tif (this._iShadowMethodVO)\n\t\t\tcode += this._iShadowMethodVO.method.iGetVertexCode(shaderObject, this._iShadowMethodVO, registerCache, sharedRegisters);\n\n\t\treturn code;\n\t}\n\n\tpublic _iGetPostLightingFragmentCode(shaderObject:ShaderLightingObject, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = \"\";\n\n\t\tif (shaderObject.useAlphaPremultiplied && this._pEnableBlending) {\n\t\t\tcode += \"add \" + sharedRegisters.shadedTarget + \".w, \" + sharedRegisters.shadedTarget + \".w, \" + sharedRegisters.commons + \".z\\n\" +\n\t\t\t\t\"div \" + sharedRegisters.shadedTarget + \".xyz, \" + sharedRegisters.shadedTarget + \", \" + sharedRegisters.shadedTarget + \".w\\n\" +\n\t\t\t\t\"sub \" + sharedRegisters.shadedTarget + \".w, \" + sharedRegisters.shadedTarget + \".w, \" + sharedRegisters.commons + \".z\\n\" +\n\t\t\t\t\"sat \" + sharedRegisters.shadedTarget + \".xyz, \" + sharedRegisters.shadedTarget + \"\\n\";\n\t\t}\n\n\t\tif (this._iShadowMethodVO)\n\t\t\tcode += this._iShadowMethodVO.method.iGetFragmentCode(shaderObject, this._iShadowMethodVO, sharedRegisters.shadowTarget, registerCache, sharedRegisters);\n\n\t\tif (this._iDiffuseMethodVO && this._iDiffuseMethodVO.useMethod) {\n\t\t\tcode += (<LightingMethodBase> this._iDiffuseMethodVO.method).iGetFragmentPostLightingCode(shaderObject, this._iDiffuseMethodVO, sharedRegisters.shadedTarget, registerCache, sharedRegisters);\n\n\t\t\t// resolve other dependencies as well?\n\t\t\tif (this._iDiffuseMethodVO.needsNormals)\n\t\t\t\tregisterCache.removeFragmentTempUsage(sharedRegisters.normalFragment);\n\n\t\t\tif (this._iDiffuseMethodVO.needsView)\n\t\t\t\tregisterCache.removeFragmentTempUsage(sharedRegisters.viewDirFragment);\n\t\t}\n\n\t\tif (this._iSpecularMethodVO && this._iSpecularMethodVO.useMethod) {\n\t\t\tcode += (<LightingMethodBase> this._iSpecularMethodVO.method).iGetFragmentPostLightingCode(shaderObject, this._iSpecularMethodVO, sharedRegisters.shadedTarget, registerCache, sharedRegisters);\n\t\t\tif (this._iSpecularMethodVO.needsNormals)\n\t\t\t\tregisterCache.removeFragmentTempUsage(sharedRegisters.normalFragment);\n\t\t\tif (this._iSpecularMethodVO.needsView)\n\t\t\t\tregisterCache.removeFragmentTempUsage(sharedRegisters.viewDirFragment);\n\t\t}\n\n\t\tif (this._iShadowMethodVO)\n\t\t\tregisterCache.removeFragmentTempUsage(sharedRegisters.shadowTarget);\n\n\t\treturn code;\n\t}\n\n\t/**\n\t * Indicates whether or not normals are allowed in tangent space. This is only the case if no object-space\n\t * dependencies exist.\n\t */\n\tpublic _pUsesTangentSpace(shaderObject:ShaderLightingObject):boolean\n\t{\n\t\tif (shaderObject.usesProbes)\n\t\t\treturn false;\n\n\t\tvar methodVO:MethodVO;\n\t\tvar len:number = this._iMethodVOs.length;\n\t\tfor (var i:number = 0; i < len; ++i) {\n\t\t\tmethodVO = this._iMethodVOs[i];\n\t\t\tif (methodVO.useMethod && !methodVO.method.iUsesTangentSpace())\n\t\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t}\n\n\t/**\n\t * Indicates whether or not normals are output in tangent space.\n\t */\n\tpublic _pOutputsTangentNormals(shaderObject:ShaderObjectBase):boolean\n\t{\n\t\treturn (<NormalBasicMethod> this._iNormalMethodVO.method).iOutputsTangentNormals();\n\t}\n\n\t/**\n\t * Indicates whether or not normals are output by the pass.\n\t */\n\tpublic _pOutputsNormals(shaderObject:ShaderObjectBase):boolean\n\t{\n\t\treturn this._iNormalMethodVO && this._iNormalMethodVO.useMethod;\n\t}\n\n\n\tpublic _iGetNormalVertexCode(shaderObject:ShaderObjectBase, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\treturn this._iNormalMethodVO.method.iGetVertexCode(shaderObject, this._iNormalMethodVO, registerCache, sharedRegisters);\n\t}\n\n\tpublic _iGetNormalFragmentCode(shaderObject:ShaderObjectBase, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = this._iNormalMethodVO.method.iGetFragmentCode(shaderObject, this._iNormalMethodVO, sharedRegisters.normalFragment, registerCache, sharedRegisters);\n\n\t\tif (this._iNormalMethodVO.needsView)\n\t\t\tregisterCache.removeFragmentTempUsage(sharedRegisters.viewDirFragment);\n\n\t\tif (this._iNormalMethodVO.needsGlobalFragmentPos || this._iNormalMethodVO.needsGlobalVertexPos)\n\t\t\tregisterCache.removeVertexTempUsage(sharedRegisters.globalPositionVertex);\n\n\t\treturn code;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic _iGetVertexCode(shaderObject:ShaderObjectBase, regCache:ShaderRegisterCache, sharedReg:ShaderRegisterData):string\n\t{\n\t\tvar code:string = \"\";\n\t\tvar methodVO:MethodVO;\n\t\tvar len:number = this._iMethodVOs.length;\n\t\tfor (var i:number = len - this._numEffectDependencies; i < len; i++) {\n\t\t\tmethodVO = this._iMethodVOs[i];\n\t\t\tif (methodVO.useMethod) {\n\t\t\t\tcode += methodVO.method.iGetVertexCode(shaderObject, methodVO, regCache, sharedReg);\n\n\t\t\t\tif (methodVO.needsGlobalVertexPos || methodVO.needsGlobalFragmentPos)\n\t\t\t\t\tregCache.removeVertexTempUsage(sharedReg.globalPositionVertex);\n\t\t\t}\n\t\t}\n\n\t\tif (this._iColorTransformMethodVO && this._iColorTransformMethodVO.useMethod)\n\t\t\tcode += this._iColorTransformMethodVO.method.iGetVertexCode(shaderObject, this._iColorTransformMethodVO, regCache, sharedReg);\n\n\t\treturn code;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic _iGetFragmentCode(shaderObject:ShaderObjectBase, regCache:ShaderRegisterCache, sharedReg:ShaderRegisterData):string\n\t{\n\t\tvar code:string = \"\";\n\t\tvar alphaReg:ShaderRegisterElement;\n\n\t\tif (this.preserveAlpha && this._numEffectDependencies > 0) {\n\t\t\talphaReg = regCache.getFreeFragmentSingleTemp();\n\t\t\tregCache.addFragmentTempUsages(alphaReg, 1);\n\t\t\tcode += \"mov \" + alphaReg + \", \" + sharedReg.shadedTarget + \".w\\n\";\n\t\t}\n\n\t\tvar methodVO:MethodVO;\n\t\tvar len:number = this._iMethodVOs.length;\n\t\tfor (var i:number = len - this._numEffectDependencies; i < len; i++) {\n\t\t\tmethodVO = this._iMethodVOs[i];\n\t\t\tif (methodVO.useMethod) {\n\t\t\t\tcode += methodVO.method.iGetFragmentCode(shaderObject, methodVO, sharedReg.shadedTarget, regCache, sharedReg);\n\n\t\t\t\tif (methodVO.needsNormals)\n\t\t\t\t\tregCache.removeFragmentTempUsage(sharedReg.normalFragment);\n\n\t\t\t\tif (methodVO.needsView)\n\t\t\t\t\tregCache.removeFragmentTempUsage(sharedReg.viewDirFragment);\n\n\t\t\t}\n\t\t}\n\n\t\tif (this.preserveAlpha && this._numEffectDependencies > 0) {\n\t\t\tcode += \"mov \" + sharedReg.shadedTarget + \".w, \" + alphaReg + \"\\n\";\n\t\t\tregCache.removeFragmentTempUsage(alphaReg);\n\t\t}\n\n\t\tif (this._iColorTransformMethodVO && this._iColorTransformMethodVO.useMethod)\n\t\t\tcode += this._iColorTransformMethodVO.method.iGetFragmentCode(shaderObject, this._iColorTransformMethodVO, sharedReg.shadedTarget, regCache, sharedReg);\n\n\t\treturn code;\n\t}\n\t/**\n\t * Indicates whether the shader uses any shadows.\n\t */\n\tpublic _iUsesShadows():boolean\n\t{\n\t\treturn Boolean(this._iShadowMethodVO || this.lightPicker.castingDirectionalLights.length > 0 || this.lightPicker.castingPointLights.length > 0);\n\t}\n\n\t/**\n\t * Indicates whether the shader uses any specular component.\n\t */\n\tpublic _iUsesSpecular():boolean\n\t{\n\t\treturn Boolean(this._iSpecularMethodVO);\n\t}\n\n\t/**\n\t * Calculates the amount of directional lights this material will support.\n\t * @param numDirectionalLights The maximum amount of directional lights to support.\n\t * @return The amount of directional lights this material will support, bounded by the amount necessary.\n\t */\n\tprivate calculateNumDirectionalLights(numDirectionalLights:number):number\n\t{\n\t\treturn Math.min(numDirectionalLights - this.directionalLightsOffset, this._maxLights);\n\t}\n\n\t/**\n\t * Calculates the amount of point lights this material will support.\n\t * @param numDirectionalLights The maximum amount of point lights to support.\n\t * @return The amount of point lights this material will support, bounded by the amount necessary.\n\t */\n\tprivate calculateNumPointLights(numPointLights:number):number\n\t{\n\t\tvar numFree:number = this._maxLights - this._pNumDirectionalLights;\n\t\treturn Math.min(numPointLights - this.pointLightsOffset, numFree);\n\t}\n\n\t/**\n\t * Calculates the amount of light probes this material will support.\n\t * @param numDirectionalLights The maximum amount of light probes to support.\n\t * @return The amount of light probes this material will support, bounded by the amount necessary.\n\t */\n\tprivate calculateNumProbes(numLightProbes:number):number\n\t{\n\t\tvar numChannels:number = 0;\n\t\t//\t\t\tif ((this._pSpecularLightSources & LightSources.PROBES) != 0)\n\t\t//\t\t\t\t++numChannels;\n\t\t//\n\t\t//\t\t\tif ((this._pDiffuseLightSources & LightSources.PROBES) != 0)\n\t\t//\t\t\t\t++numChannels;\n\n\t\t// 4 channels available\n\t\treturn Math.min(numLightProbes - this.lightProbesOffset, (4/numChannels) | 0);\n\t}\n}\n\nexport = TriangleMethodPass;"],"sourceRoot":"./"}