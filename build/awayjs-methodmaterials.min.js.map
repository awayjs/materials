{
  "version": 3,
  "sources": [
    "node_modules/browserify/node_modules/browser-pack/_prelude.js",
    "awayjs-methodmaterials.js",
    "../index.ts",
    "lib/MethodMaterialMode.ts",
    "lib/MethodMaterial.ts",
    "lib/lib/data/MethodVO.ts",
    "lib/data.ts",
    "lib/lib/methods/AmbientBasicMethod.ts",
    "lib/lib/methods/AmbientEnvMapMethod.ts",
    "lib/lib/methods/CurveBasicMethod.ts",
    "lib/lib/methods/DiffuseBasicMethod.ts",
    "lib/lib/methods/DiffuseCelMethod.ts",
    "lib/lib/methods/DiffuseCompositeMethod.ts",
    "lib/lib/methods/DiffuseDepthMethod.ts",
    "lib/lib/methods/DiffuseGradientMethod.ts",
    "lib/lib/methods/DiffuseLightMapMethod.ts",
    "lib/lib/methods/DiffuseSubSurfaceMethod.ts",
    "lib/lib/methods/DiffuseWrapMethod.ts",
    "lib/lib/methods/EffectAlphaMaskMethod.ts",
    "lib/lib/methods/EffectColorMatrixMethod.ts",
    "lib/lib/methods/EffectColorTransformMethod.ts",
    "lib/lib/methods/EffectEnvMapMethod.ts",
    "lib/lib/methods/EffectFogMethod.ts",
    "lib/lib/methods/EffectFresnelEnvMapMethod.ts",
    "lib/lib/methods/EffectLightMapMethod.ts",
    "lib/lib/methods/EffectMethodBase.ts",
    "lib/lib/methods/EffectRefractionEnvMapMethod.ts",
    "lib/lib/methods/EffectRimLightMethod.ts",
    "lib/lib/methods/LightingMethodBase.ts",
    "lib/lib/methods/NormalBasicMethod.ts",
    "lib/lib/methods/NormalHeightMapMethod.ts",
    "lib/lib/methods/NormalSimpleWaterMethod.ts",
    "lib/lib/methods/ShadingMethodBase.ts",
    "lib/lib/methods/ShadowCascadeMethod.ts",
    "lib/lib/methods/ShadowDitheredMethod.ts",
    "lib/lib/methods/ShadowFilteredMethod.ts",
    "lib/lib/methods/ShadowHardMethod.ts",
    "lib/lib/methods/ShadowMapMethodBase.ts",
    "lib/lib/methods/ShadowMethodBase.ts",
    "lib/lib/methods/ShadowNearMethod.ts",
    "lib/lib/methods/ShadowSoftMethod.ts",
    "lib/lib/methods/SpecularAnisotropicMethod.ts",
    "lib/lib/methods/SpecularBasicMethod.ts",
    "lib/lib/methods/SpecularCelMethod.ts",
    "lib/lib/methods/SpecularCompositeMethod.ts",
    "lib/lib/methods/SpecularFresnelMethod.ts",
    "lib/lib/methods/SpecularPhongMethod.ts",
    "lib/methods.ts",
    "lib/lib/surfaces/GL_MethodMaterialSurface.ts",
    "lib/surfaces/lib/surfaces/passes/MethodPassMode.ts",
    "lib/surfaces/lib/surfaces/passes/MethodPass.ts",
    "lib/surfaces/lib/surfaces/passes/SingleObjectDepthPass.ts",
    "lib/surfaces.ts"
  ],
  "names": [
    "require",
    "e",
    "t",
    "n",
    "r",
    "s",
    "o",
    "u",
    "a",
    "i",
    "f",
    "Error",
    "code",
    "l",
    "exports",
    "call",
    "length",
    1,
    "module",
    "data",
    "methods",
    "surfaces",
    "MethodMaterial_1",
    "MethodMaterial",
    "default",
    "MethodMaterialMode_1",
    "MethodMaterialMode",
    "SurfacePool_1",
    "registerAbstraction",
    "GL_MethodMaterialSurface",
    "./lib/MethodMaterial",
    "./lib/MethodMaterialMode",
    "./lib/data",
    "./lib/methods",
    "./lib/surfaces",
    "awayjs-renderergl/lib/surfaces/SurfacePool",
    "undefined",
    "awayjs-methodmaterials/lib/MethodMaterialMode",
    "SINGLE_PASS",
    "MULTI_PASS",
    "Object",
    "defineProperty",
    "value",
    "awayjs-methodmaterials/lib/MethodMaterial",
    "__extends",
    "this",
    "d",
    "b",
    "p",
    "hasOwnProperty",
    "__",
    "constructor",
    "prototype",
    "create",
    "Image2D_1",
    "MaterialBase_1",
    "Single2DTexture_1",
    "ContextGLCompareMode_1",
    "AmbientBasicMethod_1",
    "DiffuseBasicMethod_1",
    "NormalBasicMethod_1",
    "SpecularBasicMethod_1",
    "_super",
    "imageColor",
    "alpha",
    "_effectMethods",
    "Array",
    "_ambientMethod",
    "_diffuseMethod",
    "_normalMethod",
    "_specularMethod",
    "_depthCompareMode",
    "LESS_EQUAL",
    "_mode",
    "iAddOwner",
    "texture",
    "get",
    "assetType",
    "enumerable",
    "configurable",
    "set",
    "invalidate",
    "iRemoveOwner",
    "_shadowMethod",
    "addEffectMethod",
    "method",
    "push",
    "getEffectMethodAt",
    "index",
    "addEffectMethodAt",
    "splice",
    "removeEffectMethod",
    "indexOf",
    "./MethodMaterialMode",
    "./methods/AmbientBasicMethod",
    "./methods/DiffuseBasicMethod",
    "./methods/NormalBasicMethod",
    "./methods/SpecularBasicMethod",
    "awayjs-core/lib/image/Image2D",
    "awayjs-display/lib/materials/MaterialBase",
    "awayjs-display/lib/textures/Single2DTexture",
    "awayjs-stagegl/lib/base/ContextGLCompareMode",
    "awayjs-methodmaterials/lib/data/MethodVO",
    "MethodVO",
    "pass",
    "useMethod",
    "reset",
    "iReset",
    "vertexConstantsIndex",
    "secondaryVertexConstantsIndex",
    "fragmentConstantsIndex",
    "secondaryFragmentConstantsIndex",
    "needsProjection",
    "needsView",
    "needsNormals",
    "needsTangents",
    "needsGlobalVertexPos",
    "needsGlobalFragmentPos",
    "awayjs-methodmaterials/lib/data",
    "MethodVO_1",
    "./data/MethodVO",
    "awayjs-methodmaterials/lib/methods/AmbientBasicMethod",
    "AssetEvent_1",
    "ShadingMethodBase_1",
    "AmbientBasicMethod",
    "_alpha",
    "_colorR",
    "_colorG",
    "_colorB",
    "_strength",
    "iInitVO",
    "shader",
    "methodVO",
    "_texture",
    "textureGL",
    "getAbstraction",
    "uvDependencies",
    "onClear",
    "CLEAR",
    "iInitConstants",
    "_color",
    "numLights",
    "_surface",
    "style",
    "color",
    "updateColor",
    "iRemoveTexture",
    "iAddTexture",
    "iInvalidateShaderProgram",
    "copyFrom",
    "m",
    "iGetFragmentCode",
    "targetReg",
    "registerCache",
    "sharedRegisters",
    "_iGetFragmentCode",
    "uvVarying",
    "alphaThreshold",
    "cutOffReg",
    "getFreeFragmentConstant",
    "ambientInputRegister",
    "iActivate",
    "stage",
    "activate",
    "_render",
    "fragmentConstantData",
    "iSetRenderState",
    "renderable",
    "camera",
    "_setRenderState",
    "../methods/ShadingMethodBase",
    "awayjs-core/lib/events/AssetEvent",
    "awayjs-methodmaterials/lib/methods/AmbientEnvMapMethod",
    "AmbientEnvMapMethod",
    "regCache",
    "normalFragment",
    "../methods/AmbientBasicMethod",
    "awayjs-methodmaterials/lib/methods/CurveBasicMethod",
    "CurveBasicMethod",
    "_ambient",
    "awayjs-methodmaterials/lib/methods/DiffuseBasicMethod",
    "LightingMethodBase_1",
    "DiffuseBasicMethod",
    "_multiply",
    "_ambientColorR",
    "_ambientColorG",
    "_ambientColorB",
    "iIsUsed",
    "usesCommonData",
    "_ambientColor",
    "updateAmbientColor",
    "dispose",
    "diff",
    "multiply",
    "iCleanCompilationData",
    "_pTotalLightColorReg",
    "iGetFragmentPreLightingCode",
    "_pIsFirstLight",
    "addFragmentTempUsages",
    "getFreeFragmentVectorTemp",
    "iGetFragmentCodePerLight",
    "lightDirReg",
    "lightColReg",
    "commons",
    "usesLightFallOff",
    "_iModulateMethod",
    "removeFragmentTempUsage",
    "iGetFragmentCodePerProbe",
    "cubeMapReg",
    "weightRegister",
    "iGetFragmentPostLightingCode",
    "diffuseColor",
    "shadowTarget",
    "pApplyShadow",
    "ambientColorRegister",
    "diffuseInputRegister",
    "ambientR",
    "ambientG",
    "ambientB",
    "../methods/LightingMethodBase",
    "awayjs-methodmaterials/lib/methods/DiffuseCelMethod",
    "DiffuseCompositeMethod_1",
    "DiffuseCelMethod",
    "levels",
    "baseMethod",
    "_this",
    "_smoothness",
    "clampDiffuse",
    "_levels",
    "_dataReg",
    "../methods/DiffuseCompositeMethod",
    "awayjs-methodmaterials/lib/methods/DiffuseCompositeMethod",
    "ShadingMethodEvent_1",
    "DiffuseCompositeMethod",
    "modulateMethod",
    "_onShaderInvalidatedDelegate",
    "event",
    "onShaderInvalidated",
    "pBaseMethod",
    "addEventListener",
    "SHADER_INVALIDATED",
    "removeEventListener",
    "owner",
    "iDeactivate",
    "iGetVertexCode",
    "../methods/DiffuseBasicMethod",
    "awayjs-renderergl/lib/events/ShadingMethodEvent",
    "awayjs-methodmaterials/lib/methods/DiffuseDepthMethod",
    "DiffuseDepthMethod",
    "temp",
    "decReg",
    "awayjs-methodmaterials/lib/methods/DiffuseGradientMethod",
    "DiffuseGradientMethod",
    "gradient",
    "_gradient",
    "secondaryTextureGL",
    "awayjs-methodmaterials/lib/methods/DiffuseLightMapMethod",
    "DiffuseLightMapMethod",
    "lightMap",
    "blendMode",
    "useSecondaryUV",
    "_useSecondaryUV",
    "_lightMap",
    "secondaryUVDependencies",
    "_blendMode",
    "ADD",
    "MULTIPLY",
    "secondaryUVVarying",
    "awayjs-methodmaterials/lib/methods/DiffuseSubSurfaceMethod",
    "DiffuseSubSurfaceMethod",
    "depthMapSize",
    "depthMapOffset",
    "_translucency",
    "_scatterColor",
    "_scatterR",
    "_scatterG",
    "_scatterB",
    "scatterLight",
    "_scattering",
    "vertexConstantData",
    "_lightProjVarying",
    "_propReg",
    "_lightColorReg",
    "_colorReg",
    "_decReg",
    "_targetReg",
    "scatterColor",
    "lightProjection",
    "toTexRegister",
    "getFreeVertexVectorTemp",
    "getFreeVertexConstant",
    "getFreeVarying",
    "viewDirFragment",
    "_depthPass",
    "_iGetDepthMap",
    "_iGetProjection",
    "copyRawDataTo",
    "awayjs-methodmaterials/lib/methods/DiffuseWrapMethod",
    "DiffuseWrapMethod",
    "wrapFactor",
    "_wrapDataRegister",
    "_wrapFactor",
    "awayjs-methodmaterials/lib/methods/EffectAlphaMaskMethod",
    "EffectMethodBase_1",
    "EffectAlphaMaskMethod",
    "../methods/EffectMethodBase",
    "awayjs-methodmaterials/lib/methods/EffectColorMatrixMethod",
    "EffectColorMatrixMethod",
    "matrix",
    "_matrix",
    "colorMultReg",
    "colorOffsetReg",
    "awayjs-methodmaterials/lib/methods/EffectColorTransformMethod",
    "EffectColorTransformMethod",
    "_colorTransform",
    "colorOffsReg",
    "inv",
    "redMultiplier",
    "greenMultiplier",
    "blueMultiplier",
    "alphaMultiplier",
    "redOffset",
    "greenOffset",
    "blueOffset",
    "alphaOffset",
    "awayjs-methodmaterials/lib/methods/EffectEnvMapMethod",
    "EffectEnvMapMethod",
    "envMap",
    "_envMap",
    "_mask",
    "dataRegister",
    "temp2",
    "awayjs-methodmaterials/lib/methods/EffectFogMethod",
    "EffectFogMethod",
    "minDistance",
    "maxDistance",
    "fogColor",
    "_minDistance",
    "_maxDistance",
    "_fogColor",
    "_fogR",
    "_fogG",
    "_fogB",
    "fogData",
    "projectionFragment",
    "awayjs-methodmaterials/lib/methods/EffectFresnelEnvMapMethod",
    "EffectFresnelEnvMapMethod",
    "_fresnelPower",
    "_normalReflectance",
    "viewDirReg",
    "normalReg",
    "awayjs-methodmaterials/lib/methods/EffectLightMapMethod",
    "EffectLightMapMethod",
    "awayjs-methodmaterials/lib/methods/EffectMethodBase",
    "AbstractMethodError_1",
    "EffectMethodBase",
    "awayjs-core/lib/errors/AbstractMethodError",
    "awayjs-methodmaterials/lib/methods/EffectRefractionEnvMapMethod",
    "EffectRefractionEnvMapMethod",
    "refractionIndex",
    "dispersionR",
    "dispersionG",
    "dispersionB",
    "_dispersionR",
    "_dispersionG",
    "_dispersionB",
    "_useDispersion",
    "_refractionIndex",
    "useDispersion",
    "data2",
    "refractionDir",
    "refractionColor",
    "awayjs-methodmaterials/lib/methods/EffectRimLightMethod",
    "EffectRimLightMethod",
    "strength",
    "power",
    "blend",
    "_power",
    "dataRegister2",
    "MIX",
    "awayjs-methodmaterials/lib/methods/LightingMethodBase",
    "LightingMethodBase",
    "awayjs-methodmaterials/lib/methods/NormalBasicMethod",
    "NormalBasicMethod",
    "normalDependencies",
    "iOutputsTangentNormals",
    "bnm",
    "awayjs-methodmaterials/lib/methods/NormalHeightMapMethod",
    "NormalHeightMapMethod",
    "heightMap",
    "worldWidth",
    "worldHeight",
    "worldDepth",
    "_worldXYRatio",
    "_worldXZRatio",
    "image2D",
    "width",
    "height",
    "dataReg",
    "dataReg2",
    "../methods/NormalBasicMethod",
    "awayjs-methodmaterials/lib/methods/NormalSimpleWaterMethod",
    "NormalSimpleWaterMethod",
    "normalMap",
    "secondaryNormalMap",
    "_water1OffsetX",
    "_water1OffsetY",
    "_water2OffsetX",
    "_water2OffsetY",
    "_secondaryNormalMap",
    "awayjs-methodmaterials/lib/methods/ShadingMethodBase",
    "AssetBase_1",
    "ShadingMethodBase",
    "_textures",
    "_owners",
    "_counts",
    "iUsesTangentSpace",
    "len",
    "addTexture",
    "removeTexture",
    "dispatchEvent",
    "awayjs-core/lib/library/AssetBase",
    "awayjs-methodmaterials/lib/methods/ShadowCascadeMethod",
    "DirectionalLight_1",
    "ShadowMapMethodBase_1",
    "ShadowCascadeMethod",
    "shadowMethodBase",
    "castingLight",
    "_baseMethod",
    "_pCastingLight",
    "_cascadeShadowMapper",
    "shadowMapper",
    "INVALIDATE",
    "onCascadeChange",
    "tempVO",
    "depthMap",
    "fragmentData",
    "vertexData",
    "_cascadeProjections",
    "_depthMapCoordVaryings",
    "initProjectionsRegs",
    "numCascades",
    "globalPositionVertex",
    "planeDistanceReg",
    "planeDistances",
    "inQuad",
    "uvCoord",
    "uvProjection",
    "_iGetCascadeFragmentCode",
    "vertexIndex",
    "depth",
    "_pEpsilon",
    "k",
    "getDepthProjections",
    "fragmentIndex",
    "_pAlpha",
    "nearPlaneDistances",
    "_iNearPlaneDistances",
    "iActivateForCascade",
    "../data/MethodVO",
    "../methods/ShadowMapMethodBase",
    "awayjs-display/lib/display/DirectionalLight",
    "awayjs-methodmaterials/lib/methods/ShadowDitheredMethod",
    "BitmapImage2D_1",
    "ShadowMethodBase_1",
    "ShadowDitheredMethod",
    "numSamples",
    "range",
    "_depthMapSize",
    "_grainUsages",
    "_grainTexture",
    "initGrainTexture",
    "_numSamples",
    "_range",
    "_grainBitmapImage2D",
    "vec",
    "step",
    "g",
    "Math",
    "random",
    "floor",
    "setArray",
    "rect",
    "_pGetPlanarFragmentCode",
    "customDataReg",
    "getSampleCode",
    "uvReg",
    "projectionReg",
    "_pDepthMapCoordReg",
    "addSample",
    "decodeRegister",
    "depthProjection",
    "targetRegister",
    "../methods/ShadowMethodBase",
    "awayjs-core/lib/image/BitmapImage2D",
    "awayjs-methodmaterials/lib/methods/ShadowFilteredMethod",
    "ShadowFilteredMethod",
    "size",
    "depthCol",
    "predicate",
    "awayjs-methodmaterials/lib/methods/ShadowHardMethod",
    "ShadowHardMethod",
    "_pGetPointFragmentCode",
    "epsReg",
    "posReg",
    "depthSampleCol",
    "lightDir",
    "globalPositionVarying",
    "awayjs-methodmaterials/lib/methods/ShadowMapMethodBase",
    "ShadowMapMethodBase",
    "shadowsEnabled",
    "_pShadowMapper",
    "awayjs-methodmaterials/lib/methods/ShadowMethodBase",
    "PointLight_1",
    "ShadowMethodBase",
    "_pUsePoint",
    "_pGetPointVertexCode",
    "pGetPlanarVertexCode",
    "depthMapProj",
    "iDepthProjection",
    "pow",
    "fallOff",
    "pos",
    "scenePosition",
    "x",
    "y",
    "z",
    "awayjs-display/lib/display/PointLight",
    "awayjs-methodmaterials/lib/methods/ShadowNearMethod",
    "ShadowNearMethod",
    "fadeRatio",
    "_fadeRatio",
    "_nearShadowMapper",
    "epsilon",
    "getFreeFragmentSingleTemp",
    "near",
    "projection",
    "far",
    "coverageRatio",
    "awayjs-methodmaterials/lib/methods/ShadowSoftMethod",
    "PoissonLookup_1",
    "ShadowSoftMethod",
    "_offsets",
    "getDistribution",
    "texRange",
    "offsets",
    "numRegs",
    "reg",
    "awayjs-core/lib/geom/PoissonLookup",
    "awayjs-methodmaterials/lib/methods/SpecularAnisotropicMethod",
    "SpecularAnisotropicMethod",
    "tangentVarying",
    "_pSpecularTexData",
    "_pSpecularDataRegister",
    "../methods/SpecularBasicMethod",
    "awayjs-methodmaterials/lib/methods/SpecularBasicMethod",
    "SpecularBasicMethod",
    "_gloss",
    "_iSpecularR",
    "_iSpecularG",
    "_iSpecularB",
    "updateSpecular",
    "bsm",
    "spec",
    "gloss",
    "awayjs-methodmaterials/lib/methods/SpecularCelMethod",
    "SpecularCompositeMethod_1",
    "SpecularCelMethod",
    "specularCutOff",
    "_specularCutOff",
    "clampSpecular",
    "../methods/SpecularCompositeMethod",
    "awayjs-methodmaterials/lib/methods/SpecularCompositeMethod",
    "SpecularCompositeMethod",
    "awayjs-methodmaterials/lib/methods/SpecularFresnelMethod",
    "SpecularFresnelMethod",
    "basedOnSurface",
    "modulateSpecular",
    "_incidentLight",
    "awayjs-methodmaterials/lib/methods/SpecularPhongMethod",
    "SpecularPhongMethod",
    "awayjs-methodmaterials/lib/methods",
    "AmbientEnvMapMethod_1",
    "CurveBasicMethod_1",
    "DiffuseCelMethod_1",
    "DiffuseDepthMethod_1",
    "DiffuseGradientMethod_1",
    "DiffuseLightMapMethod_1",
    "DiffuseSubSurfaceMethod_1",
    "DiffuseWrapMethod_1",
    "EffectAlphaMaskMethod_1",
    "EffectColorMatrixMethod_1",
    "EffectColorTransformMethod_1",
    "EffectEnvMapMethod_1",
    "EffectFogMethod_1",
    "EffectFresnelEnvMapMethod_1",
    "EffectLightMapMethod_1",
    "EffectRefractionEnvMapMethod_1",
    "EffectRimLightMethod_1",
    "NormalHeightMapMethod_1",
    "NormalSimpleWaterMethod_1",
    "ShadowCascadeMethod_1",
    "ShadowDitheredMethod_1",
    "ShadowFilteredMethod_1",
    "ShadowHardMethod_1",
    "ShadowNearMethod_1",
    "ShadowSoftMethod_1",
    "SpecularAnisotropicMethod_1",
    "SpecularCelMethod_1",
    "SpecularFresnelMethod_1",
    "SpecularPhongMethod_1",
    "./methods/AmbientEnvMapMethod",
    "./methods/CurveBasicMethod",
    "./methods/DiffuseCelMethod",
    "./methods/DiffuseCompositeMethod",
    "./methods/DiffuseDepthMethod",
    "./methods/DiffuseGradientMethod",
    "./methods/DiffuseLightMapMethod",
    "./methods/DiffuseSubSurfaceMethod",
    "./methods/DiffuseWrapMethod",
    "./methods/EffectAlphaMaskMethod",
    "./methods/EffectColorMatrixMethod",
    "./methods/EffectColorTransformMethod",
    "./methods/EffectEnvMapMethod",
    "./methods/EffectFogMethod",
    "./methods/EffectFresnelEnvMapMethod",
    "./methods/EffectLightMapMethod",
    "./methods/EffectMethodBase",
    "./methods/EffectRefractionEnvMapMethod",
    "./methods/EffectRimLightMethod",
    "./methods/LightingMethodBase",
    "./methods/NormalHeightMapMethod",
    "./methods/NormalSimpleWaterMethod",
    "./methods/ShadingMethodBase",
    "./methods/ShadowCascadeMethod",
    "./methods/ShadowDitheredMethod",
    "./methods/ShadowFilteredMethod",
    "./methods/ShadowHardMethod",
    "./methods/ShadowMapMethodBase",
    "./methods/ShadowMethodBase",
    "./methods/ShadowNearMethod",
    "./methods/ShadowSoftMethod",
    "./methods/SpecularAnisotropicMethod",
    "./methods/SpecularCelMethod",
    "./methods/SpecularCompositeMethod",
    "./methods/SpecularFresnelMethod",
    "./methods/SpecularPhongMethod",
    "awayjs-methodmaterials/lib/surfaces/GL_MethodMaterialSurface",
    "BlendMode_1",
    "StaticLightPicker_1",
    "GL_SurfaceBase_1",
    "MethodPassMode_1",
    "MethodPass_1",
    "material",
    "elementsClass",
    "pool",
    "_material",
    "lightPicker",
    "numLightProbes",
    "numDirectionalLights",
    "numPointLights",
    "numCastingDirectionalLights",
    "numCastingPointLights",
    "_pUpdateRender",
    "initPasses",
    "setBlendAndCompareModes",
    "_pClearPasses",
    "mode",
    "_casterLightPass",
    "_pAddPass",
    "_nonCasterLightPasses",
    "_pass",
    "numEffectMethods",
    "initEffectPass",
    "removeEffectPass",
    "shadowMethod",
    "initCasterLightPass",
    "removeCasterLightPass",
    "numNonCasters",
    "initNonCasterLightPasses",
    "removeNonCasterLightPasses",
    "forceSeparateMVP",
    "Boolean",
    "setBlendMode",
    "NORMAL",
    "depthCompareMode",
    "firstAdditiveIndex",
    "_pRequiresBlending",
    "EFFECTS",
    "LAYER",
    "alphaBlending",
    "colorTransform",
    "SUPER_SHADER",
    "preserveAlpha",
    "LIGHTING",
    "_elementsClass",
    "_stage",
    "diffuseMethod",
    "ambientMethod",
    "normalMethod",
    "specularMethod",
    "_pRemovePass",
    "numDirLights",
    "dirLightOffset",
    "pointLightOffset",
    "probeOffset",
    "includeCasters",
    "directionalLightsOffset",
    "pointLightsOffset",
    "lightProbesOffset",
    "effectMethod",
    "max",
    "removeEffectMethodAt",
    "../MethodMaterialMode",
    "../surfaces/passes/MethodPass",
    "../surfaces/passes/MethodPassMode",
    "awayjs-core/lib/image/BlendMode",
    "awayjs-display/lib/materials/lightpickers/StaticLightPicker",
    "awayjs-renderergl/lib/surfaces/GL_SurfaceBase",
    "awayjs-methodmaterials/lib/surfaces/passes/MethodPassMode",
    "PassMode",
    "awayjs-methodmaterials/lib/surfaces/passes/MethodPass",
    "LightSources_1",
    "LightingShader_1",
    "ShaderBase_1",
    "PassBase_1",
    "MethodPass",
    "render",
    "renderOwner",
    "_maxLights",
    "_includeCasters",
    "_iMethodVOs",
    "_numEffectDependencies",
    "_onLightsChangeDelegate",
    "onLightsChange",
    "_onMethodInvalidatedDelegate",
    "onMethodInvalidated",
    "_shader",
    "_updateShader",
    "_updateLights",
    "_lightPicker",
    "enableLightFallOff",
    "diffuseLightSources",
    "specularLightSources",
    "_iInitConstantData",
    "colorTransformMethod",
    "_iColorTransformMethodVO",
    "_removeDependency",
    "_addDependency",
    "effectsDependency",
    "hasEffectMethod",
    "getDependencyForMethod",
    "_iNormalMethodVO",
    "_iAmbientMethodVO",
    "_iShadowMethodVO",
    "_iDiffuseMethodVO",
    "_iSpecularMethodVO",
    "_iActivate",
    "_iRender",
    "viewProjection",
    "_iDeactivate",
    "_iIncludeDependencies",
    "usesFragmentAnimation",
    "useAlphaPremultiplied",
    "usesBlending",
    "setupAndCountDependencies",
    "usesTangentSpace",
    "outputsNormals",
    "outputsTangentNormals",
    "usesProbes",
    "viewDirDependencies",
    "globalPosDependencies",
    "usesLights",
    "usesGlobalPosFragment",
    "projectionDependencies",
    "tangentDependencies",
    "_iGetPreLightingVertexCode",
    "_iGetPreLightingFragmentCode",
    "shadedTarget",
    "_iGetPerLightDiffuseFragmentCode",
    "diffuseColorReg",
    "_iGetPerLightSpecularFragmentCode",
    "specularColorReg",
    "_iGetPerProbeDiffuseFragmentCode",
    "texReg",
    "weightReg",
    "_iGetPerProbeSpecularFragmentCode",
    "_iGetPostLightingVertexCode",
    "_iGetPostLightingFragmentCode",
    "_iGetNormalVertexCode",
    "_iGetNormalFragmentCode",
    "removeVertexTempUsage",
    "_iGetVertexCode",
    "sharedReg",
    "alphaReg",
    "_iUsesShadows",
    "castingDirectionalLights",
    "castingPointLights",
    "_iUsesSpecular",
    "_iUsesDiffuse",
    "numDirectionalLightsOld",
    "numPointLightsOld",
    "numLightProbesOld",
    "calculateNumDirectionalLights",
    "calculateNumPointLights",
    "calculateNumProbes",
    "min",
    "numFree",
    "numChannels",
    "PROBES",
    "../../data/MethodVO",
    "../../methods/EffectColorTransformMethod",
    "../../surfaces/passes/MethodPassMode",
    "awayjs-display/lib/materials/LightSources",
    "awayjs-renderergl/lib/shaders/LightingShader",
    "awayjs-renderergl/lib/shaders/ShaderBase",
    "awayjs-renderergl/lib/surfaces/passes/PassBase",
    "awayjs-methodmaterials/lib/surfaces/passes/SingleObjectDepthPass",
    "Matrix3D_1",
    "ContextGLDrawMode_1",
    "SingleObjectDepthPass",
    "_textureSize",
    "_polyOffset",
    "Float32Array",
    "_projectionTexturesInvalid",
    "key",
    "updateProjectionTextures",
    "_projections",
    "renderableGL",
    "id",
    "context",
    "light",
    "lights",
    "allPickedLights",
    "rId",
    "iGetObjectProjectionMatrix",
    "sourceEntity",
    "sceneTransform",
    "setRenderTarget",
    "clear",
    "elements",
    "elementsGL",
    "_elementsPool",
    "activateVertexBufferVO",
    "positions",
    "normals",
    "getIndexBufferGL",
    "draw",
    "TRIANGLES",
    "numElements",
    "awayjs-core/lib/geom/Matrix3D",
    "awayjs-stagegl/lib/base/ContextGLDrawMode",
    "awayjs-methodmaterials/lib/surfaces",
    "MethodPassMode",
    "SingleObjectDepthPass_1",
    "GL_MethodMaterialSurface_1",
    "./surfaces/GL_MethodMaterialSurface",
    "./surfaces/passes/MethodPass",
    "./surfaces/passes/MethodPassMode",
    "./surfaces/passes/SingleObjectDepthPass"
  ],
  "mappings": "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",
  "file": "awayjs-methodmaterials.min.js",
  "sourcesContent": [
    "(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})",
    "require=(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){\n\"use strict\";\nvar data = require(\"./lib/data\");\nexports.data = data;\nvar methods = require(\"./lib/methods\");\nexports.methods = methods;\nvar surfaces = require(\"./lib/surfaces\");\nexports.surfaces = surfaces;\nvar MethodMaterial_1 = require(\"./lib/MethodMaterial\");\nexports.MethodMaterial = MethodMaterial_1.default;\nvar MethodMaterialMode_1 = require(\"./lib/MethodMaterialMode\");\nexports.MethodMaterialMode = MethodMaterialMode_1.default;\nvar SurfacePool_1 = require(\"awayjs-renderergl/lib/surfaces/SurfacePool\");\nSurfacePool_1.default.registerAbstraction(surfaces.GL_MethodMaterialSurface, MethodMaterial_1.default);\n\n},{\"./lib/MethodMaterial\":\"awayjs-methodmaterials/lib/MethodMaterial\",\"./lib/MethodMaterialMode\":\"awayjs-methodmaterials/lib/MethodMaterialMode\",\"./lib/data\":\"awayjs-methodmaterials/lib/data\",\"./lib/methods\":\"awayjs-methodmaterials/lib/methods\",\"./lib/surfaces\":\"awayjs-methodmaterials/lib/surfaces\",\"awayjs-renderergl/lib/surfaces/SurfacePool\":undefined}],\"awayjs-methodmaterials/lib/MethodMaterialMode\":[function(require,module,exports){\n\"use strict\";\nvar MethodMaterialMode = (function () {\n    function MethodMaterialMode() {\n    }\n    /**\n     *\n     */\n    MethodMaterialMode.SINGLE_PASS = \"singlePass\";\n    /**\n     *\n     */\n    MethodMaterialMode.MULTI_PASS = \"multiPass\";\n    return MethodMaterialMode;\n}());\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = MethodMaterialMode;\n\n},{}],\"awayjs-methodmaterials/lib/MethodMaterial\":[function(require,module,exports){\n\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Image2D_1 = require(\"awayjs-core/lib/image/Image2D\");\nvar MaterialBase_1 = require(\"awayjs-display/lib/materials/MaterialBase\");\nvar Single2DTexture_1 = require(\"awayjs-display/lib/textures/Single2DTexture\");\nvar ContextGLCompareMode_1 = require(\"awayjs-stagegl/lib/base/ContextGLCompareMode\");\nvar MethodMaterialMode_1 = require(\"./MethodMaterialMode\");\nvar AmbientBasicMethod_1 = require(\"./methods/AmbientBasicMethod\");\nvar DiffuseBasicMethod_1 = require(\"./methods/DiffuseBasicMethod\");\nvar NormalBasicMethod_1 = require(\"./methods/NormalBasicMethod\");\nvar SpecularBasicMethod_1 = require(\"./methods/SpecularBasicMethod\");\n/**\n * MethodMaterial forms an abstract base class for the default shaded materials provided by Stage,\n * using material methods to define their appearance.\n */\nvar MethodMaterial = (function (_super) {\n    __extends(MethodMaterial, _super);\n    function MethodMaterial(imageColor, alpha) {\n        if (imageColor === void 0) { imageColor = null; }\n        if (alpha === void 0) { alpha = 1; }\n        _super.call(this, imageColor, alpha);\n        this._effectMethods = new Array();\n        this._ambientMethod = new AmbientBasicMethod_1.default();\n        this._diffuseMethod = new DiffuseBasicMethod_1.default();\n        this._normalMethod = new NormalBasicMethod_1.default();\n        this._specularMethod = new SpecularBasicMethod_1.default();\n        this._depthCompareMode = ContextGLCompareMode_1.default.LESS_EQUAL;\n        this._mode = MethodMaterialMode_1.default.SINGLE_PASS;\n        //add default methods owners\n        this._ambientMethod.iAddOwner(this);\n        this._diffuseMethod.iAddOwner(this);\n        this._normalMethod.iAddOwner(this);\n        this._specularMethod.iAddOwner(this);\n        //set a texture if an image is present\n        if (imageColor instanceof Image2D_1.default)\n            this._ambientMethod.texture = new Single2DTexture_1.default();\n    }\n    Object.defineProperty(MethodMaterial.prototype, \"assetType\", {\n        /**\n         *\n         */\n        get: function () {\n            return MethodMaterial.assetType;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MethodMaterial.prototype, \"mode\", {\n        get: function () {\n            return this._mode;\n        },\n        set: function (value) {\n            if (this._mode == value)\n                return;\n            this._mode = value;\n            this.invalidate();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MethodMaterial.prototype, \"depthCompareMode\", {\n        /**\n         * The depth compare mode used to render the renderables using this material.\n         *\n         * @see away.stagegl.ContextGLCompareMode\n         */\n        get: function () {\n            return this._depthCompareMode;\n        },\n        set: function (value) {\n            if (this._depthCompareMode == value)\n                return;\n            this._depthCompareMode = value;\n            this.invalidate();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MethodMaterial.prototype, \"diffuseTexture\", {\n        /**\n         * The texture object to use for the ambient colour.\n         */\n        get: function () {\n            return this._diffuseMethod.texture;\n        },\n        set: function (value) {\n            this._diffuseMethod.texture = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MethodMaterial.prototype, \"ambientMethod\", {\n        /**\n         * The method that provides the ambient lighting contribution. Defaults to AmbientBasicMethod.\n         */\n        get: function () {\n            return this._ambientMethod;\n        },\n        set: function (value) {\n            if (this._ambientMethod == value)\n                return;\n            if (this._ambientMethod)\n                this._ambientMethod.iRemoveOwner(this);\n            this._ambientMethod = value;\n            if (this._ambientMethod)\n                this._ambientMethod.iAddOwner(this);\n            this.invalidate();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MethodMaterial.prototype, \"shadowMethod\", {\n        /**\n         * The method used to render shadows cast on this surface, or null if no shadows are to be rendered. Defaults to null.\n         */\n        get: function () {\n            return this._shadowMethod;\n        },\n        set: function (value) {\n            if (this._shadowMethod == value)\n                return;\n            if (this._shadowMethod)\n                this._shadowMethod.iRemoveOwner(this);\n            this._shadowMethod = value;\n            if (this._shadowMethod)\n                this._shadowMethod.iAddOwner(this);\n            this.invalidate();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MethodMaterial.prototype, \"diffuseMethod\", {\n        /**\n         * The method that provides the diffuse lighting contribution. Defaults to DiffuseBasicMethod.\n         */\n        get: function () {\n            return this._diffuseMethod;\n        },\n        set: function (value) {\n            if (this._diffuseMethod == value)\n                return;\n            if (this._diffuseMethod)\n                this._diffuseMethod.iRemoveOwner(this);\n            this._diffuseMethod = value;\n            if (this._diffuseMethod)\n                this._diffuseMethod.iAddOwner(this);\n            this.invalidate();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MethodMaterial.prototype, \"specularMethod\", {\n        /**\n         * The method that provides the specular lighting contribution. Defaults to SpecularBasicMethod.\n         */\n        get: function () {\n            return this._specularMethod;\n        },\n        set: function (value) {\n            if (this._specularMethod == value)\n                return;\n            if (this._specularMethod)\n                this._specularMethod.iRemoveOwner(this);\n            this._specularMethod = value;\n            if (this._specularMethod)\n                this._specularMethod.iAddOwner(this);\n            this.invalidate();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MethodMaterial.prototype, \"normalMethod\", {\n        /**\n         * The method used to generate the per-pixel normals. Defaults to NormalBasicMethod.\n         */\n        get: function () {\n            return this._normalMethod;\n        },\n        set: function (value) {\n            if (this._normalMethod == value)\n                return;\n            if (this._normalMethod)\n                this._normalMethod.iRemoveOwner(this);\n            this._normalMethod = value;\n            if (this._normalMethod)\n                this._normalMethod.iAddOwner(this);\n            this.invalidate();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MethodMaterial.prototype, \"numEffectMethods\", {\n        get: function () {\n            return this._effectMethods.length;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Appends an \"effect\" shading method to the shader. Effect methods are those that do not influence the lighting\n     * but modulate the shaded colour, used for fog, outlines, etc. The method will be applied to the result of the\n     * methods added prior.\n     */\n    MethodMaterial.prototype.addEffectMethod = function (method) {\n        method.iAddOwner(this);\n        this._effectMethods.push(method);\n        this.invalidate();\n    };\n    /**\n     * Returns the method added at the given index.\n     * @param index The index of the method to retrieve.\n     * @return The method at the given index.\n     */\n    MethodMaterial.prototype.getEffectMethodAt = function (index) {\n        return this._effectMethods[index];\n    };\n    /**\n     * Adds an effect method at the specified index amongst the methods already added to the material. Effect\n     * methods are those that do not influence the lighting but modulate the shaded colour, used for fog, outlines,\n     * etc. The method will be applied to the result of the methods with a lower index.\n     */\n    MethodMaterial.prototype.addEffectMethodAt = function (method, index) {\n        method.iAddOwner(this);\n        this._effectMethods.splice(index, 0, method);\n        this.invalidate();\n    };\n    /**\n     * Removes an effect method from the material.\n     * @param method The method to be removed.\n     */\n    MethodMaterial.prototype.removeEffectMethod = function (method) {\n        method.iRemoveOwner(this);\n        this._effectMethods.splice(this._effectMethods.indexOf(method), 1);\n        this.invalidate();\n    };\n    MethodMaterial.assetType = \"[materials MethodMaterial]\";\n    return MethodMaterial;\n}(MaterialBase_1.default));\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = MethodMaterial;\n\n},{\"./MethodMaterialMode\":\"awayjs-methodmaterials/lib/MethodMaterialMode\",\"./methods/AmbientBasicMethod\":\"awayjs-methodmaterials/lib/methods/AmbientBasicMethod\",\"./methods/DiffuseBasicMethod\":\"awayjs-methodmaterials/lib/methods/DiffuseBasicMethod\",\"./methods/NormalBasicMethod\":\"awayjs-methodmaterials/lib/methods/NormalBasicMethod\",\"./methods/SpecularBasicMethod\":\"awayjs-methodmaterials/lib/methods/SpecularBasicMethod\",\"awayjs-core/lib/image/Image2D\":undefined,\"awayjs-display/lib/materials/MaterialBase\":undefined,\"awayjs-display/lib/textures/Single2DTexture\":undefined,\"awayjs-stagegl/lib/base/ContextGLCompareMode\":undefined}],\"awayjs-methodmaterials/lib/data/MethodVO\":[function(require,module,exports){\n\"use strict\";\n/**\n * MethodVO contains data for a given shader object for the use within a single material.\n * This allows shader methods to be shared across materials while their non-public state differs.\n */\nvar MethodVO = (function () {\n    /**\n     * Creates a new MethodVO object.\n     */\n    function MethodVO(method, pass) {\n        this.useMethod = true;\n        this.method = method;\n        this.pass = pass;\n    }\n    /**\n     * Resets the values of the value object to their \"unused\" state.\n     */\n    MethodVO.prototype.reset = function () {\n        this.method.iReset();\n        this.vertexConstantsIndex = -1;\n        this.secondaryVertexConstantsIndex = -1;\n        this.fragmentConstantsIndex = -1;\n        this.secondaryFragmentConstantsIndex = -1;\n        this.needsProjection = false;\n        this.needsView = false;\n        this.needsNormals = false;\n        this.needsTangents = false;\n        this.needsGlobalVertexPos = false;\n        this.needsGlobalFragmentPos = false;\n    };\n    return MethodVO;\n}());\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = MethodVO;\n\n},{}],\"awayjs-methodmaterials/lib/data\":[function(require,module,exports){\n\"use strict\";\nvar MethodVO_1 = require(\"./data/MethodVO\");\nexports.MethodVO = MethodVO_1.default;\n\n},{\"./data/MethodVO\":\"awayjs-methodmaterials/lib/data/MethodVO\"}],\"awayjs-methodmaterials/lib/methods/AmbientBasicMethod\":[function(require,module,exports){\n\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar AssetEvent_1 = require(\"awayjs-core/lib/events/AssetEvent\");\nvar ShadingMethodBase_1 = require(\"../methods/ShadingMethodBase\");\n/**\n * AmbientBasicMethod provides the default shading method for uniform ambient lighting.\n */\nvar AmbientBasicMethod = (function (_super) {\n    __extends(AmbientBasicMethod, _super);\n    /**\n     * Creates a new AmbientBasicMethod object.\n     */\n    function AmbientBasicMethod() {\n        _super.call(this);\n        this._alpha = 1;\n        this._colorR = 1;\n        this._colorG = 1;\n        this._colorB = 1;\n        this._strength = 1;\n    }\n    /**\n     * @inheritDoc\n     */\n    AmbientBasicMethod.prototype.iInitVO = function (shader, methodVO) {\n        if (this._texture) {\n            methodVO.textureGL = shader.getAbstraction(this._texture);\n            shader.uvDependencies++;\n        }\n        else if (methodVO.textureGL) {\n            methodVO.textureGL.onClear(new AssetEvent_1.default(AssetEvent_1.default.CLEAR, this._texture));\n            methodVO.textureGL = null;\n        }\n    };\n    /**\n     * @inheritDoc\n     */\n    AmbientBasicMethod.prototype.iInitConstants = function (shader, methodVO) {\n        if (!methodVO.textureGL) {\n            this._color = shader.numLights ? 0xFFFFFF : methodVO.pass._surface.style.color;\n            this.updateColor();\n        }\n    };\n    Object.defineProperty(AmbientBasicMethod.prototype, \"strength\", {\n        /**\n         * The strength of the ambient reflection of the surface.\n         */\n        get: function () {\n            return this._strength;\n        },\n        set: function (value) {\n            if (this._strength == value)\n                return;\n            this._strength = value;\n            this.updateColor();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(AmbientBasicMethod.prototype, \"alpha\", {\n        /**\n         * The alpha component of the surface.\n         */\n        get: function () {\n            return this._alpha;\n        },\n        set: function (value) {\n            if (this._alpha == value)\n                return;\n            this._alpha = value;\n            this.updateColor();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(AmbientBasicMethod.prototype, \"texture\", {\n        /**\n         * The texture to use to define the diffuse reflection color per texel.\n         */\n        get: function () {\n            return this._texture;\n        },\n        set: function (value) {\n            if (this._texture == value)\n                return;\n            if (this._texture)\n                this.iRemoveTexture(this._texture);\n            this._texture = value;\n            if (this._texture)\n                this.iAddTexture(this._texture);\n            this.iInvalidateShaderProgram();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * @inheritDoc\n     */\n    AmbientBasicMethod.prototype.copyFrom = function (method) {\n        var m = method;\n        var b = m;\n    };\n    /**\n     * @inheritDoc\n     */\n    AmbientBasicMethod.prototype.iGetFragmentCode = function (shader, methodVO, targetReg, registerCache, sharedRegisters) {\n        var code = \"\";\n        if (methodVO.textureGL) {\n            code += methodVO.textureGL._iGetFragmentCode(targetReg, registerCache, sharedRegisters, sharedRegisters.uvVarying);\n            if (shader.alphaThreshold > 0) {\n                var cutOffReg = registerCache.getFreeFragmentConstant();\n                methodVO.fragmentConstantsIndex = cutOffReg.index * 4;\n                code += \"sub \" + targetReg + \".w, \" + targetReg + \".w, \" + cutOffReg + \".x\\n\" +\n                    \"kil \" + targetReg + \".w\\n\" +\n                    \"add \" + targetReg + \".w, \" + targetReg + \".w, \" + cutOffReg + \".x\\n\";\n            }\n        }\n        else {\n            var ambientInputRegister = registerCache.getFreeFragmentConstant();\n            methodVO.fragmentConstantsIndex = ambientInputRegister.index * 4;\n            code += \"mov \" + targetReg + \", \" + ambientInputRegister + \"\\n\";\n        }\n        return code;\n    };\n    /**\n     * @inheritDoc\n     */\n    AmbientBasicMethod.prototype.iActivate = function (shader, methodVO, stage) {\n        if (methodVO.textureGL) {\n            methodVO.textureGL.activate(methodVO.pass._render);\n            if (shader.alphaThreshold > 0)\n                shader.fragmentConstantData[methodVO.fragmentConstantsIndex] = shader.alphaThreshold;\n        }\n        else {\n            var index = methodVO.fragmentConstantsIndex;\n            var data = shader.fragmentConstantData;\n            data[index] = this._colorR;\n            data[index + 1] = this._colorG;\n            data[index + 2] = this._colorB;\n            data[index + 3] = this._alpha;\n        }\n    };\n    AmbientBasicMethod.prototype.iSetRenderState = function (shader, methodVO, renderable, stage, camera) {\n        if (methodVO.textureGL)\n            methodVO.textureGL._setRenderState(renderable);\n    };\n    /**\n     * Updates the ambient color data used by the render state.\n     */\n    AmbientBasicMethod.prototype.updateColor = function () {\n        this._colorR = ((this._color >> 16) & 0xff) / 0xff * this._strength;\n        this._colorG = ((this._color >> 8) & 0xff) / 0xff * this._strength;\n        this._colorB = (this._color & 0xff) / 0xff * this._strength;\n    };\n    return AmbientBasicMethod;\n}(ShadingMethodBase_1.default));\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = AmbientBasicMethod;\n\n},{\"../methods/ShadingMethodBase\":\"awayjs-methodmaterials/lib/methods/ShadingMethodBase\",\"awayjs-core/lib/events/AssetEvent\":undefined}],\"awayjs-methodmaterials/lib/methods/AmbientEnvMapMethod\":[function(require,module,exports){\n\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar AssetEvent_1 = require(\"awayjs-core/lib/events/AssetEvent\");\nvar AmbientBasicMethod_1 = require(\"../methods/AmbientBasicMethod\");\n/**\n * AmbientEnvMapMethod provides a diffuse shading method that uses a diffuse irradiance environment map to\n * approximate global lighting rather than lights.\n */\nvar AmbientEnvMapMethod = (function (_super) {\n    __extends(AmbientEnvMapMethod, _super);\n    /**\n     * Creates a new <code>AmbientEnvMapMethod</code> object.\n     *\n     * @param envMap The cube environment map to use for the ambient lighting.\n     */\n    function AmbientEnvMapMethod() {\n        _super.call(this);\n    }\n    /**\n     * @inheritDoc\n     */\n    AmbientEnvMapMethod.prototype.iInitVO = function (shader, methodVO) {\n        methodVO.needsNormals = true;\n        if (this._texture) {\n            methodVO.textureGL = shader.getAbstraction(this._texture);\n            shader.uvDependencies++;\n        }\n        else if (methodVO.textureGL) {\n            methodVO.textureGL.onClear(new AssetEvent_1.default(AssetEvent_1.default.CLEAR, this._texture));\n            methodVO.textureGL = null;\n        }\n    };\n    /**\n     * @inheritDoc\n     */\n    AmbientEnvMapMethod.prototype.iGetFragmentCode = function (shader, methodVO, targetReg, regCache, sharedRegisters) {\n        return (this._texture) ? methodVO.textureGL._iGetFragmentCode(targetReg, regCache, sharedRegisters, sharedRegisters.normalFragment) : \"\";\n    };\n    return AmbientEnvMapMethod;\n}(AmbientBasicMethod_1.default));\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = AmbientEnvMapMethod;\n\n},{\"../methods/AmbientBasicMethod\":\"awayjs-methodmaterials/lib/methods/AmbientBasicMethod\",\"awayjs-core/lib/events/AssetEvent\":undefined}],\"awayjs-methodmaterials/lib/methods/CurveBasicMethod\":[function(require,module,exports){\n\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar AssetEvent_1 = require(\"awayjs-core/lib/events/AssetEvent\");\nvar ShadingMethodBase_1 = require(\"../methods/ShadingMethodBase\");\n/**\n * AmbientBasicMethod provides the default shading method for uniform ambient lighting.\n */\nvar CurveBasicMethod = (function (_super) {\n    __extends(CurveBasicMethod, _super);\n    /**\n     * Creates a new AmbientBasicMethod object.\n     */\n    function CurveBasicMethod() {\n        _super.call(this);\n        this._color = 0xffffff;\n        this._alpha = 1;\n        this._colorR = 1;\n        this._colorG = 1;\n        this._colorB = 1;\n        this._ambient = 1;\n    }\n    /**\n     * @inheritDoc\n     */\n    CurveBasicMethod.prototype.iInitVO = function (shader, methodVO) {\n        if (this._texture) {\n            methodVO.textureGL = shader.getAbstraction(this._texture);\n            shader.uvDependencies++;\n        }\n        else if (methodVO.textureGL) {\n            methodVO.textureGL.onClear(new AssetEvent_1.default(AssetEvent_1.default.CLEAR, this._texture));\n            methodVO.textureGL = null;\n        }\n    };\n    /**\n     * @inheritDoc\n     */\n    CurveBasicMethod.prototype.iInitConstants = function (shader, methodVO) {\n        if (!methodVO.textureGL) {\n            this._color = methodVO.pass._surface.style.color;\n            this.updateColor();\n        }\n    };\n    Object.defineProperty(CurveBasicMethod.prototype, \"ambient\", {\n        /**\n         * The strength of the ambient reflection of the surface.\n         */\n        get: function () {\n            return this._ambient;\n        },\n        set: function (value) {\n            if (this._ambient == value)\n                return;\n            this._ambient = value;\n            this.updateColor();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(CurveBasicMethod.prototype, \"alpha\", {\n        /**\n         * The alpha component of the surface.\n         */\n        get: function () {\n            return this._alpha;\n        },\n        set: function (value) {\n            if (this._alpha == value)\n                return;\n            this._alpha = value;\n            this.updateColor();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(CurveBasicMethod.prototype, \"texture\", {\n        /**\n         * The texture to use to define the diffuse reflection color per texel.\n         */\n        get: function () {\n            return this._texture;\n        },\n        set: function (value) {\n            if (this._texture == value)\n                return;\n            if (this._texture)\n                this.iRemoveTexture(this._texture);\n            this._texture = value;\n            if (this._texture)\n                this.iAddTexture(this._texture);\n            this.iInvalidateShaderProgram();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * @inheritDoc\n     */\n    CurveBasicMethod.prototype.copyFrom = function (method) {\n        var m = method;\n        var b = m;\n    };\n    /**\n     * @inheritDoc\n     */\n    /*\n    public iGeVertexCode(shader:ShaderBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string {\n        var code:string = \"\";\n        code = \"mov \" + sharedRegisters.uvVarying + \" \" + registerCache.uv +  \" \\n\";\n    }*/\n    CurveBasicMethod.prototype.iGetFragmentCode = function (shader, methodVO, targetReg, registerCache, sharedRegisters) {\n        var code = \"\";\n        var ambientInputRegister;\n        if (methodVO.textureGL) {\n            code += methodVO.textureGL._iGetFragmentCode(targetReg, registerCache, sharedRegisters, sharedRegisters.uvVarying);\n            if (shader.alphaThreshold > 0) {\n                var cutOffReg = registerCache.getFreeFragmentConstant();\n                methodVO.fragmentConstantsIndex = cutOffReg.index * 4;\n                code += \"sub \" + targetReg + \".w, \" + targetReg + \".w, \" + cutOffReg + \".x\\n\" +\n                    \"kil \" + targetReg + \".w\\n\" +\n                    \"add \" + targetReg + \".w, \" + targetReg + \".w, \" + cutOffReg + \".x\\n\";\n            }\n        }\n        else {\n            ambientInputRegister = registerCache.getFreeFragmentConstant();\n            methodVO.fragmentConstantsIndex = ambientInputRegister.index * 4;\n            code += \"mov \" + targetReg + \", \" + ambientInputRegister + \"\\n\";\n        }\n        code = \"mov \" + targetReg + \", \" + sharedRegisters.uvVarying + \"\\n\";\n        return code;\n    };\n    /**\n     * @inheritDoc\n     */\n    CurveBasicMethod.prototype.iActivate = function (shader, methodVO, stage) {\n        if (methodVO.textureGL) {\n            methodVO.textureGL.activate(methodVO.pass._render);\n            if (shader.alphaThreshold > 0)\n                shader.fragmentConstantData[methodVO.fragmentConstantsIndex] = shader.alphaThreshold;\n        }\n        else {\n            var index = methodVO.fragmentConstantsIndex;\n            var data = shader.fragmentConstantData;\n            data[index] = this._colorR;\n            data[index + 1] = this._colorG;\n            data[index + 2] = this._colorB;\n            data[index + 3] = this._alpha;\n        }\n    };\n    CurveBasicMethod.prototype.iSetRenderState = function (shader, methodVO, renderable, stage, camera) {\n        if (methodVO.textureGL)\n            methodVO.textureGL._setRenderState(renderable);\n    };\n    /**\n     * Updates the ambient color data used by the render state.\n     */\n    CurveBasicMethod.prototype.updateColor = function () {\n        this._colorR = ((this._color >> 16) & 0xff) / 0xff * this._ambient;\n        this._colorG = ((this._color >> 8) & 0xff) / 0xff * this._ambient;\n        this._colorB = (this._color & 0xff) / 0xff * this._ambient;\n    };\n    return CurveBasicMethod;\n}(ShadingMethodBase_1.default));\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = CurveBasicMethod;\n\n},{\"../methods/ShadingMethodBase\":\"awayjs-methodmaterials/lib/methods/ShadingMethodBase\",\"awayjs-core/lib/events/AssetEvent\":undefined}],\"awayjs-methodmaterials/lib/methods/DiffuseBasicMethod\":[function(require,module,exports){\n\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar AssetEvent_1 = require(\"awayjs-core/lib/events/AssetEvent\");\nvar LightingMethodBase_1 = require(\"../methods/LightingMethodBase\");\n/**\n * DiffuseBasicMethod provides the default shading method for Lambert (dot3) diffuse lighting.\n */\nvar DiffuseBasicMethod = (function (_super) {\n    __extends(DiffuseBasicMethod, _super);\n    /**\n     * Creates a new DiffuseBasicMethod object.\n     */\n    function DiffuseBasicMethod() {\n        _super.call(this);\n        this._multiply = true;\n        this._ambientColorR = 1;\n        this._ambientColorG = 1;\n        this._ambientColorB = 1;\n        this._color = 0xffffff;\n        this._colorR = 1;\n        this._colorG = 1;\n        this._colorB = 1;\n    }\n    DiffuseBasicMethod.prototype.iIsUsed = function (shader) {\n        if (!shader.numLights)\n            return false;\n        return true;\n    };\n    Object.defineProperty(DiffuseBasicMethod.prototype, \"multiply\", {\n        /**\n         * Set internally if diffuse color component multiplies or replaces the ambient color\n         */\n        get: function () {\n            return this._multiply;\n        },\n        set: function (value) {\n            if (this._multiply == value)\n                return;\n            this._multiply = value;\n            this.iInvalidateShaderProgram();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    DiffuseBasicMethod.prototype.iInitVO = function (shader, methodVO) {\n        if (this._texture) {\n            methodVO.textureGL = shader.getAbstraction(this._texture);\n            shader.uvDependencies++;\n        }\n        else if (methodVO.textureGL) {\n            methodVO.textureGL.onClear(new AssetEvent_1.default(AssetEvent_1.default.CLEAR, null));\n            methodVO.textureGL = null;\n        }\n        if (shader.numLights > 0) {\n            shader.usesCommonData = true;\n            methodVO.needsNormals = true;\n        }\n    };\n    /**\n     * @inheritDoc\n     */\n    DiffuseBasicMethod.prototype.iInitConstants = function (shader, methodVO) {\n        if (shader.numLights > 0) {\n            this._ambientColor = methodVO.pass._surface.style.color;\n            this.updateAmbientColor();\n        }\n        else {\n            this._ambientColor = null;\n        }\n    };\n    Object.defineProperty(DiffuseBasicMethod.prototype, \"color\", {\n        /**\n         * The color of the diffuse reflection when not using a texture.\n         */\n        get: function () {\n            return this._color;\n        },\n        set: function (value) {\n            if (this._color == value)\n                return;\n            this._color = value;\n            this.updateColor();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(DiffuseBasicMethod.prototype, \"texture\", {\n        /**\n         * The texture to use to define the diffuse reflection color per texel.\n         */\n        get: function () {\n            return this._texture;\n        },\n        set: function (value) {\n            if (this._texture == value)\n                return;\n            if (this._texture)\n                this.iRemoveTexture(this._texture);\n            this._texture = value;\n            if (this._texture)\n                this.iAddTexture(this._texture);\n            this.iInvalidateShaderProgram();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * @inheritDoc\n     */\n    DiffuseBasicMethod.prototype.dispose = function () {\n        this._texture = null;\n    };\n    /**\n     * @inheritDoc\n     */\n    DiffuseBasicMethod.prototype.copyFrom = function (method) {\n        var diff = method;\n        this.texture = diff.texture;\n        this.multiply = diff.multiply;\n        this.color = diff.color;\n    };\n    /**\n     * @inheritDoc\n     */\n    DiffuseBasicMethod.prototype.iCleanCompilationData = function () {\n        _super.prototype.iCleanCompilationData.call(this);\n        this._pTotalLightColorReg = null;\n    };\n    /**\n     * @inheritDoc\n     */\n    DiffuseBasicMethod.prototype.iGetFragmentPreLightingCode = function (shader, methodVO, registerCache, sharedRegisters) {\n        var code = \"\";\n        this._pIsFirstLight = true;\n        registerCache.addFragmentTempUsages(this._pTotalLightColorReg = registerCache.getFreeFragmentVectorTemp(), 1);\n        return code;\n    };\n    /**\n     * @inheritDoc\n     */\n    DiffuseBasicMethod.prototype.iGetFragmentCodePerLight = function (shader, methodVO, lightDirReg, lightColReg, registerCache, sharedRegisters) {\n        var code = \"\";\n        var t;\n        // write in temporary if not first light, so we can add to total diffuse colour\n        if (this._pIsFirstLight) {\n            t = this._pTotalLightColorReg;\n        }\n        else {\n            t = registerCache.getFreeFragmentVectorTemp();\n            registerCache.addFragmentTempUsages(t, 1);\n        }\n        code += \"dp3 \" + t + \".x, \" + lightDirReg + \", \" + sharedRegisters.normalFragment + \"\\n\" +\n            \"max \" + t + \".w, \" + t + \".x, \" + sharedRegisters.commons + \".y\\n\";\n        if (shader.usesLightFallOff)\n            code += \"mul \" + t + \".w, \" + t + \".w, \" + lightDirReg + \".w\\n\";\n        if (this._iModulateMethod != null)\n            code += this._iModulateMethod(shader, methodVO, t, registerCache, sharedRegisters);\n        code += \"mul \" + t + \", \" + t + \".w, \" + lightColReg + \"\\n\";\n        if (!this._pIsFirstLight) {\n            code += \"add \" + this._pTotalLightColorReg + \".xyz, \" + this._pTotalLightColorReg + \", \" + t + \"\\n\";\n            registerCache.removeFragmentTempUsage(t);\n        }\n        this._pIsFirstLight = false;\n        return code;\n    };\n    /**\n     * @inheritDoc\n     */\n    DiffuseBasicMethod.prototype.iGetFragmentCodePerProbe = function (shader, methodVO, cubeMapReg, weightRegister, registerCache, sharedRegisters) {\n        var code = \"\";\n        var t;\n        // write in temporary if not first light, so we can add to total diffuse colour\n        if (this._pIsFirstLight) {\n            t = this._pTotalLightColorReg;\n        }\n        else {\n            t = registerCache.getFreeFragmentVectorTemp();\n            registerCache.addFragmentTempUsages(t, 1);\n        }\n        code += \"tex \" + t + \", \" + sharedRegisters.normalFragment + \", \" + cubeMapReg + \" <cube,linear,miplinear>\\n\" +\n            \"mul \" + t + \".xyz, \" + t + \".xyz, \" + weightRegister + \"\\n\";\n        if (this._iModulateMethod != null)\n            code += this._iModulateMethod(shader, methodVO, t, registerCache, sharedRegisters);\n        if (!this._pIsFirstLight) {\n            code += \"add \" + this._pTotalLightColorReg + \".xyz, \" + this._pTotalLightColorReg + \", \" + t + \"\\n\";\n            registerCache.removeFragmentTempUsage(t);\n        }\n        this._pIsFirstLight = false;\n        return code;\n    };\n    /**\n     * @inheritDoc\n     */\n    DiffuseBasicMethod.prototype.iGetFragmentPostLightingCode = function (shader, methodVO, targetReg, registerCache, sharedRegisters) {\n        var code = \"\";\n        var diffuseColor;\n        var cutOffReg;\n        // incorporate input from ambient\n        if (sharedRegisters.shadowTarget)\n            code += this.pApplyShadow(shader, methodVO, registerCache, sharedRegisters);\n        registerCache.addFragmentTempUsages(diffuseColor = registerCache.getFreeFragmentVectorTemp(), 1);\n        var ambientColorRegister = registerCache.getFreeFragmentConstant();\n        methodVO.fragmentConstantsIndex = ambientColorRegister.index * 4;\n        if (this._texture) {\n            code += methodVO.textureGL._iGetFragmentCode(diffuseColor, registerCache, sharedRegisters, sharedRegisters.uvVarying);\n        }\n        else {\n            var diffuseInputRegister = registerCache.getFreeFragmentConstant();\n            code += \"mov \" + diffuseColor + \", \" + diffuseInputRegister + \"\\n\";\n        }\n        code += \"sat \" + this._pTotalLightColorReg + \", \" + this._pTotalLightColorReg + \"\\n\" +\n            \"mul \" + diffuseColor + \".xyz, \" + diffuseColor + \", \" + this._pTotalLightColorReg + \"\\n\";\n        if (this._multiply) {\n            code += \"add \" + diffuseColor + \".xyz, \" + diffuseColor + \", \" + ambientColorRegister + \"\\n\" +\n                \"mul \" + targetReg + \".xyz, \" + targetReg + \", \" + diffuseColor + \"\\n\";\n        }\n        else if (this._texture) {\n            code += \"mul \" + targetReg + \".xyz, \" + targetReg + \", \" + ambientColorRegister + \"\\n\" +\n                \"mul \" + this._pTotalLightColorReg + \".xyz, \" + targetReg + \", \" + this._pTotalLightColorReg + \"\\n\" +\n                \"sub \" + targetReg + \".xyz, \" + targetReg + \", \" + this._pTotalLightColorReg + \"\\n\" +\n                \"add \" + targetReg + \".xyz, \" + targetReg + \", \" + diffuseColor + \"\\n\"; //add diffuse color and ambient color\n        }\n        else {\n            code += \"mul \" + this._pTotalLightColorReg + \".xyz, \" + ambientColorRegister + \", \" + this._pTotalLightColorReg + \"\\n\" +\n                \"sub \" + this._pTotalLightColorReg + \".xyz, \" + ambientColorRegister + \", \" + this._pTotalLightColorReg + \"\\n\" +\n                \"add \" + diffuseColor + \".xyz, \" + diffuseColor + \", \" + this._pTotalLightColorReg + \"\\n\" +\n                \"mul \" + targetReg + \".xyz, \" + targetReg + \", \" + diffuseColor + \"\\n\"; // multiply by target which could be texture or white\n        }\n        registerCache.removeFragmentTempUsage(this._pTotalLightColorReg);\n        registerCache.removeFragmentTempUsage(diffuseColor);\n        return code;\n    };\n    /**\n     * Generate the code that applies the calculated shadow to the diffuse light\n     * @param methodVO The MethodVO object for which the compilation is currently happening.\n     * @param regCache The register cache the compiler is currently using for the register management.\n     */\n    DiffuseBasicMethod.prototype.pApplyShadow = function (shader, methodVO, regCache, sharedRegisters) {\n        return \"mul \" + this._pTotalLightColorReg + \".xyz, \" + this._pTotalLightColorReg + \", \" + sharedRegisters.shadowTarget + \".w\\n\";\n    };\n    /**\n     * @inheritDoc\n     */\n    DiffuseBasicMethod.prototype.iActivate = function (shader, methodVO, stage) {\n        if (this._texture) {\n            methodVO.textureGL.activate(methodVO.pass._render);\n        }\n        else {\n            var index = methodVO.fragmentConstantsIndex;\n            var data = shader.fragmentConstantData;\n            if (this._multiply) {\n                data[index + 4] = this._colorR * this._ambientColorR;\n                data[index + 5] = this._colorG * this._ambientColorG;\n                data[index + 6] = this._colorB * this._ambientColorB;\n            }\n            else {\n                data[index + 4] = this._colorR;\n                data[index + 5] = this._colorG;\n                data[index + 6] = this._colorB;\n            }\n            data[index + 7] = 1;\n        }\n    };\n    /**\n     * Updates the diffuse color data used by the render state.\n     */\n    DiffuseBasicMethod.prototype.updateColor = function () {\n        this._colorR = ((this._color >> 16) & 0xff) / 0xff;\n        this._colorG = ((this._color >> 8) & 0xff) / 0xff;\n        this._colorB = (this._color & 0xff) / 0xff;\n    };\n    /**\n     * Updates the ambient color data used by the render state.\n     */\n    DiffuseBasicMethod.prototype.updateAmbientColor = function () {\n        this._ambientColorR = ((this._ambientColor >> 16) & 0xff) / 0xff;\n        this._ambientColorG = ((this._ambientColor >> 8) & 0xff) / 0xff;\n        this._ambientColorB = (this._ambientColor & 0xff) / 0xff;\n    };\n    /**\n     * @inheritDoc\n     */\n    DiffuseBasicMethod.prototype.iSetRenderState = function (shader, methodVO, renderable, stage, camera) {\n        if (this._texture)\n            methodVO.textureGL._setRenderState(renderable);\n        //TODO move this to Activate (ambientR/G/B currently calc'd in render state)\n        var index = methodVO.fragmentConstantsIndex;\n        var data = shader.fragmentConstantData;\n        data[index] = shader.ambientR * this._ambientColorR;\n        data[index + 1] = shader.ambientG * this._ambientColorG;\n        data[index + 2] = shader.ambientB * this._ambientColorB;\n        data[index + 3] = 1;\n    };\n    return DiffuseBasicMethod;\n}(LightingMethodBase_1.default));\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = DiffuseBasicMethod;\n\n},{\"../methods/LightingMethodBase\":\"awayjs-methodmaterials/lib/methods/LightingMethodBase\",\"awayjs-core/lib/events/AssetEvent\":undefined}],\"awayjs-methodmaterials/lib/methods/DiffuseCelMethod\":[function(require,module,exports){\n\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar DiffuseCompositeMethod_1 = require(\"../methods/DiffuseCompositeMethod\");\n/**\n * DiffuseCelMethod provides a shading method to add diffuse cel (cartoon) shading.\n */\nvar DiffuseCelMethod = (function (_super) {\n    __extends(DiffuseCelMethod, _super);\n    /**\n     * Creates a new DiffuseCelMethod object.\n     * @param levels The amount of shadow gradations.\n     * @param baseMethod An optional diffuse method on which the cartoon shading is based. If omitted, DiffuseBasicMethod is used.\n     */\n    function DiffuseCelMethod(levels, baseMethod) {\n        var _this = this;\n        if (levels === void 0) { levels = 3; }\n        if (baseMethod === void 0) { baseMethod = null; }\n        _super.call(this, null, baseMethod);\n        this._smoothness = .1;\n        this.baseMethod._iModulateMethod = function (shader, methodVO, targetReg, registerCache, sharedRegisters) { return _this.clampDiffuse(shader, methodVO, targetReg, registerCache, sharedRegisters); };\n        this._levels = levels;\n    }\n    /**\n     * @inheritDoc\n     */\n    DiffuseCelMethod.prototype.iInitConstants = function (shader, methodVO) {\n        var data = shader.fragmentConstantData;\n        var index = methodVO.secondaryFragmentConstantsIndex;\n        _super.prototype.iInitConstants.call(this, shader, methodVO);\n        data[index + 1] = 1;\n        data[index + 2] = 0;\n    };\n    Object.defineProperty(DiffuseCelMethod.prototype, \"levels\", {\n        /**\n         * The amount of shadow gradations.\n         */\n        get: function () {\n            return this._levels;\n        },\n        set: function (value /*uint*/) {\n            this._levels = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(DiffuseCelMethod.prototype, \"smoothness\", {\n        /**\n         * The smoothness of the edge between 2 shading levels.\n         */\n        get: function () {\n            return this._smoothness;\n        },\n        set: function (value) {\n            this._smoothness = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * @inheritDoc\n     */\n    DiffuseCelMethod.prototype.iCleanCompilationData = function () {\n        _super.prototype.iCleanCompilationData.call(this);\n        this._dataReg = null;\n    };\n    /**\n     * @inheritDoc\n     */\n    DiffuseCelMethod.prototype.iGetFragmentPreLightingCode = function (shader, methodVO, registerCache, sharedRegisters) {\n        this._dataReg = registerCache.getFreeFragmentConstant();\n        methodVO.secondaryFragmentConstantsIndex = this._dataReg.index * 4;\n        return _super.prototype.iGetFragmentPreLightingCode.call(this, shader, methodVO, registerCache, sharedRegisters);\n    };\n    /**\n     * @inheritDoc\n     */\n    DiffuseCelMethod.prototype.iActivate = function (shader, methodVO, stage) {\n        _super.prototype.iActivate.call(this, shader, methodVO, stage);\n        var data = shader.fragmentConstantData;\n        var index = methodVO.secondaryFragmentConstantsIndex;\n        data[index] = this._levels;\n        data[index + 3] = this._smoothness;\n    };\n    /**\n     * Snaps the diffuse shading of the wrapped method to one of the levels.\n     * @param vo The MethodVO used to compile the current shader.\n     * @param t The register containing the diffuse strength in the \"w\" component.\n     * @param regCache The register cache used for the shader compilation.\n     * @param sharedRegisters The shared register data for this shader.\n     * @return The AGAL fragment code for the method.\n     */\n    DiffuseCelMethod.prototype.clampDiffuse = function (shader, methodVO, targetReg, registerCache, sharedRegisters) {\n        return \"mul \" + targetReg + \".w, \" + targetReg + \".w, \" + this._dataReg + \".x\\n\" +\n            \"frc \" + targetReg + \".z, \" + targetReg + \".w\\n\" +\n            \"sub \" + targetReg + \".y, \" + targetReg + \".w, \" + targetReg + \".z\\n\" +\n            \"mov \" + targetReg + \".x, \" + this._dataReg + \".x\\n\" +\n            \"sub \" + targetReg + \".x, \" + targetReg + \".x, \" + this._dataReg + \".y\\n\" +\n            \"rcp \" + targetReg + \".x,\" + targetReg + \".x\\n\" +\n            \"mul \" + targetReg + \".w, \" + targetReg + \".y, \" + targetReg + \".x\\n\" +\n            // previous clamped strength\n            \"sub \" + targetReg + \".y, \" + targetReg + \".w, \" + targetReg + \".x\\n\" +\n            // fract/epsilon (so 0 - epsilon will become 0 - 1)\n            \"div \" + targetReg + \".z, \" + targetReg + \".z, \" + this._dataReg + \".w\\n\" +\n            \"sat \" + targetReg + \".z, \" + targetReg + \".z\\n\" +\n            \"mul \" + targetReg + \".w, \" + targetReg + \".w, \" + targetReg + \".z\\n\" +\n            // 1-z\n            \"sub \" + targetReg + \".z, \" + this._dataReg + \".y, \" + targetReg + \".z\\n\" +\n            \"mul \" + targetReg + \".y, \" + targetReg + \".y, \" + targetReg + \".z\\n\" +\n            \"add \" + targetReg + \".w, \" + targetReg + \".w, \" + targetReg + \".y\\n\" +\n            \"sat \" + targetReg + \".w, \" + targetReg + \".w\\n\";\n    };\n    return DiffuseCelMethod;\n}(DiffuseCompositeMethod_1.default));\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = DiffuseCelMethod;\n\n},{\"../methods/DiffuseCompositeMethod\":\"awayjs-methodmaterials/lib/methods/DiffuseCompositeMethod\"}],\"awayjs-methodmaterials/lib/methods/DiffuseCompositeMethod\":[function(require,module,exports){\n\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar ShadingMethodEvent_1 = require(\"awayjs-renderergl/lib/events/ShadingMethodEvent\");\nvar DiffuseBasicMethod_1 = require(\"../methods/DiffuseBasicMethod\");\n/**\n * DiffuseCompositeMethod provides a base class for diffuse methods that wrap a diffuse method to alter the\n * calculated diffuse reflection strength.\n */\nvar DiffuseCompositeMethod = (function (_super) {\n    __extends(DiffuseCompositeMethod, _super);\n    /**\n     * Creates a new <code>DiffuseCompositeMethod</code> object.\n     *\n     * @param modulateMethod The method which will add the code to alter the base method's strength. It needs to have the signature clampDiffuse(t:ShaderRegisterElement, regCache:ShaderRegisterCache):string, in which t.w will contain the diffuse strength.\n     * @param baseMethod The base diffuse method on which this method's shading is based.\n     */\n    function DiffuseCompositeMethod(modulateMethod, baseMethod) {\n        var _this = this;\n        if (baseMethod === void 0) { baseMethod = null; }\n        _super.call(this);\n        this._onShaderInvalidatedDelegate = function (event) { return _this.onShaderInvalidated(event); };\n        this.pBaseMethod = baseMethod || new DiffuseBasicMethod_1.default();\n        this.pBaseMethod._iModulateMethod = modulateMethod;\n        this.pBaseMethod.addEventListener(ShadingMethodEvent_1.default.SHADER_INVALIDATED, this._onShaderInvalidatedDelegate);\n    }\n    Object.defineProperty(DiffuseCompositeMethod.prototype, \"baseMethod\", {\n        /**\n         * The base diffuse method on which this method's shading is based.\n         */\n        get: function () {\n            return this.pBaseMethod;\n        },\n        set: function (value) {\n            if (this.pBaseMethod == value)\n                return;\n            this.pBaseMethod.removeEventListener(ShadingMethodEvent_1.default.SHADER_INVALIDATED, this._onShaderInvalidatedDelegate);\n            this.pBaseMethod = value;\n            this.pBaseMethod.addEventListener(ShadingMethodEvent_1.default.SHADER_INVALIDATED, this._onShaderInvalidatedDelegate);\n            this.iInvalidateShaderProgram();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * @inheritDoc\n     */\n    DiffuseCompositeMethod.prototype.iInitVO = function (shader, methodVO) {\n        this.pBaseMethod.iInitVO(shader, methodVO);\n    };\n    /**\n     * @inheritDoc\n     */\n    DiffuseCompositeMethod.prototype.iInitConstants = function (shader, methodVO) {\n        this.pBaseMethod.iInitConstants(shader, methodVO);\n    };\n    DiffuseCompositeMethod.prototype.iAddOwner = function (owner) {\n        _super.prototype.iAddOwner.call(this, owner);\n        this.pBaseMethod.iAddOwner(owner);\n    };\n    DiffuseCompositeMethod.prototype.iRemoveOwner = function (owner) {\n        _super.prototype.iRemoveOwner.call(this, owner);\n        this.pBaseMethod.iRemoveOwner(owner);\n    };\n    /**\n     * @inheritDoc\n     */\n    DiffuseCompositeMethod.prototype.dispose = function () {\n        this.pBaseMethod.removeEventListener(ShadingMethodEvent_1.default.SHADER_INVALIDATED, this._onShaderInvalidatedDelegate);\n        this.pBaseMethod.dispose();\n    };\n    Object.defineProperty(DiffuseCompositeMethod.prototype, \"texture\", {\n        /**\n         * @inheritDoc\n         */\n        get: function () {\n            return this.pBaseMethod.texture;\n        },\n        /**\n         * @inheritDoc\n         */\n        set: function (value) {\n            this.pBaseMethod.texture = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(DiffuseCompositeMethod.prototype, \"color\", {\n        /**\n         * @inheritDoc\n         */\n        get: function () {\n            return this.pBaseMethod.color;\n        },\n        /**\n         * @inheritDoc\n         */\n        set: function (value) {\n            this.pBaseMethod.color = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(DiffuseCompositeMethod.prototype, \"multiply\", {\n        /**\n         * @inheritDoc\n         */\n        get: function () {\n            return this.pBaseMethod.multiply;\n        },\n        /**\n         * @inheritDoc\n         */\n        set: function (value) {\n            this.pBaseMethod.multiply = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * @inheritDoc\n     */\n    DiffuseCompositeMethod.prototype.iGetFragmentPreLightingCode = function (shader, methodVO, registerCache, sharedRegisters) {\n        return this.pBaseMethod.iGetFragmentPreLightingCode(shader, methodVO, registerCache, sharedRegisters);\n    };\n    /**\n     * @inheritDoc\n     */\n    DiffuseCompositeMethod.prototype.iGetFragmentCodePerLight = function (shader, methodVO, lightDirReg, lightColReg, registerCache, sharedRegisters) {\n        var code = this.pBaseMethod.iGetFragmentCodePerLight(shader, methodVO, lightDirReg, lightColReg, registerCache, sharedRegisters);\n        this._pTotalLightColorReg = this.pBaseMethod._pTotalLightColorReg;\n        return code;\n    };\n    /**\n     * @inheritDoc\n     */\n    DiffuseCompositeMethod.prototype.iGetFragmentCodePerProbe = function (shader, methodVO, cubeMapReg, weightRegister, registerCache, sharedRegisters) {\n        var code = this.pBaseMethod.iGetFragmentCodePerProbe(shader, methodVO, cubeMapReg, weightRegister, registerCache, sharedRegisters);\n        this._pTotalLightColorReg = this.pBaseMethod._pTotalLightColorReg;\n        return code;\n    };\n    /**\n     * @inheritDoc\n     */\n    DiffuseCompositeMethod.prototype.iActivate = function (shader, methodVO, stage) {\n        this.pBaseMethod.iActivate(shader, methodVO, stage);\n    };\n    /**\n     * @inheritDoc\n     */\n    DiffuseCompositeMethod.prototype.iSetRenderState = function (shader, methodVO, renderable, stage, camera) {\n        this.pBaseMethod.iSetRenderState(shader, methodVO, renderable, stage, camera);\n    };\n    /**\n     * @inheritDoc\n     */\n    DiffuseCompositeMethod.prototype.iDeactivate = function (shader, methodVO, stage) {\n        this.pBaseMethod.iDeactivate(shader, methodVO, stage);\n    };\n    /**\n     * @inheritDoc\n     */\n    DiffuseCompositeMethod.prototype.iGetVertexCode = function (shader, methodVO, registerCache, sharedRegisters) {\n        return this.pBaseMethod.iGetVertexCode(shader, methodVO, registerCache, sharedRegisters);\n    };\n    /**\n     * @inheritDoc\n     */\n    DiffuseCompositeMethod.prototype.iGetFragmentPostLightingCode = function (shader, methodVO, targetReg, registerCache, sharedRegisters) {\n        return this.pBaseMethod.iGetFragmentPostLightingCode(shader, methodVO, targetReg, registerCache, sharedRegisters);\n    };\n    /**\n     * @inheritDoc\n     */\n    DiffuseCompositeMethod.prototype.iReset = function () {\n        this.pBaseMethod.iReset();\n    };\n    /**\n     * @inheritDoc\n     */\n    DiffuseCompositeMethod.prototype.iCleanCompilationData = function () {\n        _super.prototype.iCleanCompilationData.call(this);\n        this.pBaseMethod.iCleanCompilationData();\n    };\n    /**\n     * Called when the base method's shader code is invalidated.\n     */\n    DiffuseCompositeMethod.prototype.onShaderInvalidated = function (event) {\n        this.iInvalidateShaderProgram();\n    };\n    return DiffuseCompositeMethod;\n}(DiffuseBasicMethod_1.default));\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = DiffuseCompositeMethod;\n\n},{\"../methods/DiffuseBasicMethod\":\"awayjs-methodmaterials/lib/methods/DiffuseBasicMethod\",\"awayjs-renderergl/lib/events/ShadingMethodEvent\":undefined}],\"awayjs-methodmaterials/lib/methods/DiffuseDepthMethod\":[function(require,module,exports){\n\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar DiffuseBasicMethod_1 = require(\"../methods/DiffuseBasicMethod\");\n/**\n * DiffuseDepthMethod provides a debug method to visualise depth maps\n */\nvar DiffuseDepthMethod = (function (_super) {\n    __extends(DiffuseDepthMethod, _super);\n    /**\n     * Creates a new DiffuseBasicMethod object.\n     */\n    function DiffuseDepthMethod() {\n        _super.call(this);\n    }\n    /**\n     * @inheritDoc\n     */\n    DiffuseDepthMethod.prototype.iInitConstants = function (shader, methodVO) {\n        var data = shader.fragmentConstantData;\n        var index = methodVO.fragmentConstantsIndex;\n        data[index] = 1.0;\n        data[index + 1] = 1 / 255.0;\n        data[index + 2] = 1 / 65025.0;\n        data[index + 3] = 1 / 16581375.0;\n    };\n    /**\n     * @inheritDoc\n     */\n    DiffuseDepthMethod.prototype.iGetFragmentPostLightingCode = function (shader, methodVO, targetReg, registerCache, sharedRegisters) {\n        var code = \"\";\n        var temp;\n        var decReg;\n        if (!this._texture)\n            throw new Error(\"DiffuseDepthMethod requires texture!\");\n        // incorporate input from ambient\n        if (shader.numLights > 0) {\n            if (sharedRegisters.shadowTarget)\n                code += \"mul \" + this._pTotalLightColorReg + \".xyz, \" + this._pTotalLightColorReg + \".xyz, \" + sharedRegisters.shadowTarget + \".w\\n\";\n            code += \"add \" + targetReg + \".xyz, \" + this._pTotalLightColorReg + \".xyz, \" + targetReg + \".xyz\\n\" +\n                \"sat \" + targetReg + \".xyz, \" + targetReg + \".xyz\\n\";\n            registerCache.removeFragmentTempUsage(this._pTotalLightColorReg);\n            registerCache.addFragmentTempUsages(temp = registerCache.getFreeFragmentVectorTemp(), 1);\n        }\n        else {\n            temp = targetReg;\n        }\n        decReg = registerCache.getFreeFragmentConstant();\n        methodVO.fragmentConstantsIndex = decReg.index * 4;\n        code += methodVO.textureGL._iGetFragmentCode(temp, registerCache, sharedRegisters, sharedRegisters.uvVarying) +\n            \"dp4 \" + temp + \".x, \" + temp + \", \" + decReg + \"\\n\" +\n            \"mov \" + temp + \".yz, \" + temp + \".xx\t\t\t\\n\" +\n            \"mov \" + temp + \".w, \" + decReg + \".x\\n\" +\n            \"sub \" + temp + \".xyz, \" + decReg + \".xxx, \" + temp + \".xyz\\n\";\n        if (shader.numLights == 0)\n            return code;\n        code += \"mul \" + targetReg + \".xyz, \" + temp + \".xyz, \" + targetReg + \".xyz\\n\" +\n            \"mov \" + targetReg + \".w, \" + temp + \".w\\n\";\n        if (shader.numLights > 0)\n            registerCache.removeFragmentTempUsage(temp);\n        return code;\n    };\n    return DiffuseDepthMethod;\n}(DiffuseBasicMethod_1.default));\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = DiffuseDepthMethod;\n\n},{\"../methods/DiffuseBasicMethod\":\"awayjs-methodmaterials/lib/methods/DiffuseBasicMethod\"}],\"awayjs-methodmaterials/lib/methods/DiffuseGradientMethod\":[function(require,module,exports){\n\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar DiffuseBasicMethod_1 = require(\"../methods/DiffuseBasicMethod\");\n/**\n * DiffuseGradientMethod is an alternative to DiffuseBasicMethod in which the shading can be modulated with a gradient\n * to introduce color-tinted shading as opposed to the single-channel diffuse strength. This can be used as a crude\n * approximation to subsurface scattering (for instance, the mid-range shading for skin can be tinted red to similate\n * scattered light within the skin attributing to the final colour)\n */\nvar DiffuseGradientMethod = (function (_super) {\n    __extends(DiffuseGradientMethod, _super);\n    /**\n     * Creates a new DiffuseGradientMethod object.\n     * @param gradient A texture that contains the light colour based on the angle. This can be used to change\n     * the light colour due to subsurface scattering when the surface faces away from the light.\n     */\n    function DiffuseGradientMethod(gradient) {\n        _super.call(this);\n        this._gradient = gradient;\n        if (this._gradient)\n            this.iAddTexture(this._gradient);\n    }\n    DiffuseGradientMethod.prototype.iInitVO = function (shader, methodVO) {\n        _super.prototype.iInitVO.call(this, shader, methodVO);\n        methodVO.secondaryTextureGL = shader.getAbstraction(this._gradient);\n    };\n    Object.defineProperty(DiffuseGradientMethod.prototype, \"gradient\", {\n        /**\n         * A texture that contains the light colour based on the angle. This can be used to change the light colour\n         * due to subsurface scattering when the surface faces away from the light.\n         */\n        get: function () {\n            return this._gradient;\n        },\n        set: function (value) {\n            if (this._gradient == value)\n                return;\n            if (this._gradient)\n                this.iRemoveTexture(this._gradient);\n            this._gradient = value;\n            if (this._gradient)\n                this.iAddTexture(this._gradient);\n            this.iInvalidateShaderProgram();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * @inheritDoc\n     */\n    DiffuseGradientMethod.prototype.iCleanCompilationData = function () {\n        _super.prototype.iCleanCompilationData.call(this);\n    };\n    /**\n     * @inheritDoc\n     */\n    DiffuseGradientMethod.prototype.iGetFragmentPreLightingCode = function (shader, methodVO, registerCache, sharedRegisters) {\n        var code = _super.prototype.iGetFragmentPreLightingCode.call(this, shader, methodVO, registerCache, sharedRegisters);\n        this._pIsFirstLight = true;\n        return code;\n    };\n    /**\n     * @inheritDoc\n     */\n    DiffuseGradientMethod.prototype.iGetFragmentCodePerLight = function (shader, methodVO, lightDirReg, lightColReg, registerCache, sharedRegisters) {\n        var code = \"\";\n        var t;\n        // write in temporary if not first light, so we can add to total diffuse colour\n        if (this._pIsFirstLight)\n            t = this._pTotalLightColorReg;\n        else {\n            t = registerCache.getFreeFragmentVectorTemp();\n            registerCache.addFragmentTempUsages(t, 1);\n        }\n        code += \"dp3 \" + t + \".w, \" + lightDirReg + \".xyz, \" + sharedRegisters.normalFragment + \".xyz\\n\" +\n            \"mul \" + t + \".w, \" + t + \".w, \" + sharedRegisters.commons + \".x\\n\" +\n            \"add \" + t + \".w, \" + t + \".w, \" + sharedRegisters.commons + \".x\\n\" +\n            \"mul \" + t + \".xyz, \" + t + \".w, \" + lightDirReg + \".w\\n\";\n        if (this._iModulateMethod != null)\n            code += this._iModulateMethod(shader, methodVO, t, registerCache, sharedRegisters);\n        code += methodVO.secondaryTextureGL._iGetFragmentCode(t, registerCache, sharedRegisters, t) +\n            //\t\t\t\t\t\"mul \" + t + \".xyz, \" + t + \".xyz, \" + t + \".w\\n\" +\n            \"mul \" + t + \".xyz, \" + t + \".xyz, \" + lightColReg + \".xyz\\n\";\n        if (!this._pIsFirstLight) {\n            code += \"add \" + this._pTotalLightColorReg + \".xyz, \" + this._pTotalLightColorReg + \".xyz, \" + t + \".xyz\\n\";\n            registerCache.removeFragmentTempUsage(t);\n        }\n        this._pIsFirstLight = false;\n        return code;\n    };\n    /**\n     * @inheritDoc\n     */\n    DiffuseGradientMethod.prototype.pApplyShadow = function (shader, methodVO, regCache, sharedRegisters) {\n        var t = regCache.getFreeFragmentVectorTemp();\n        return \"mov \" + t + \", \" + sharedRegisters.shadowTarget + \".wwww\\n\" +\n            methodVO.secondaryTextureGL._iGetFragmentCode(t, regCache, sharedRegisters, sharedRegisters.uvVarying) +\n            \"mul \" + this._pTotalLightColorReg + \".xyz, \" + this._pTotalLightColorReg + \", \" + t + \"\\n\";\n    };\n    /**\n     * @inheritDoc\n     */\n    DiffuseGradientMethod.prototype.iActivate = function (shader, methodVO, stage) {\n        _super.prototype.iActivate.call(this, shader, methodVO, stage);\n        methodVO.secondaryTextureGL.activate(methodVO.pass._render);\n    };\n    /**\n     * @inheritDoc\n     */\n    DiffuseGradientMethod.prototype.iSetRenderState = function (shader, methodVO, renderable, stage, camera) {\n        _super.prototype.iSetRenderState.call(this, shader, methodVO, renderable, stage, camera);\n        if (shader.numLights > 0)\n            methodVO.secondaryTextureGL._setRenderState(renderable);\n    };\n    return DiffuseGradientMethod;\n}(DiffuseBasicMethod_1.default));\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = DiffuseGradientMethod;\n\n},{\"../methods/DiffuseBasicMethod\":\"awayjs-methodmaterials/lib/methods/DiffuseBasicMethod\"}],\"awayjs-methodmaterials/lib/methods/DiffuseLightMapMethod\":[function(require,module,exports){\n\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar DiffuseCompositeMethod_1 = require(\"../methods/DiffuseCompositeMethod\");\n/**\n * DiffuseLightMapMethod provides a diffuse shading method that uses a light map to modulate the calculated diffuse\n * lighting. It is different from EffectLightMapMethod in that the latter modulates the entire calculated pixel color, rather\n * than only the diffuse lighting value.\n */\nvar DiffuseLightMapMethod = (function (_super) {\n    __extends(DiffuseLightMapMethod, _super);\n    /**\n     * Creates a new DiffuseLightMapMethod method.\n     *\n     * @param lightMap The texture containing the light map.\n     * @param blendMode The blend mode with which the light map should be applied to the lighting result.\n     * @param useSecondaryUV Indicates whether the secondary UV set should be used to map the light map.\n     * @param baseMethod The diffuse method used to calculate the regular diffuse-based lighting.\n     */\n    function DiffuseLightMapMethod(lightMap, blendMode, useSecondaryUV, baseMethod) {\n        if (blendMode === void 0) { blendMode = \"multiply\"; }\n        if (useSecondaryUV === void 0) { useSecondaryUV = false; }\n        if (baseMethod === void 0) { baseMethod = null; }\n        _super.call(this, null, baseMethod);\n        this._useSecondaryUV = useSecondaryUV;\n        this._lightMap = lightMap;\n        this.blendMode = blendMode;\n        if (this._lightMap)\n            this.iAddTexture(this._lightMap);\n    }\n    /**\n     * @inheritDoc\n     */\n    DiffuseLightMapMethod.prototype.iInitVO = function (shader, methodVO) {\n        methodVO.secondaryTextureGL = shader.getAbstraction(this._lightMap);\n        if (this._useSecondaryUV)\n            shader.secondaryUVDependencies++;\n        else\n            shader.uvDependencies++;\n    };\n    Object.defineProperty(DiffuseLightMapMethod.prototype, \"blendMode\", {\n        /**\n         * The blend mode with which the light map should be applied to the lighting result.\n         *\n         * @see DiffuseLightMapMethod.ADD\n         * @see DiffuseLightMapMethod.MULTIPLY\n         */\n        get: function () {\n            return this._blendMode;\n        },\n        set: function (value) {\n            if (value != DiffuseLightMapMethod.ADD && value != DiffuseLightMapMethod.MULTIPLY)\n                throw new Error(\"Unknown blendmode!\");\n            if (this._blendMode == value)\n                return;\n            this._blendMode = value;\n            this.iInvalidateShaderProgram();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(DiffuseLightMapMethod.prototype, \"lightMap\", {\n        /**\n         * The texture containing the light map data.\n         */\n        get: function () {\n            return this._lightMap;\n        },\n        set: function (value) {\n            if (this._lightMap == value)\n                return;\n            if (this._lightMap)\n                this.iRemoveTexture(this._lightMap);\n            this._lightMap = value;\n            if (this._lightMap)\n                this.iAddTexture(this._lightMap);\n            this.iInvalidateShaderProgram();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(DiffuseLightMapMethod.prototype, \"useSecondaryUV\", {\n        /**\n         * Indicates whether the secondary UV set should be used to map the light map.\n         */\n        get: function () {\n            return this._useSecondaryUV;\n        },\n        set: function (value) {\n            if (this._useSecondaryUV == value)\n                return;\n            this._useSecondaryUV = value;\n            this.iInvalidateShaderProgram();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * @inheritDoc\n     */\n    DiffuseLightMapMethod.prototype.iGetFragmentPostLightingCode = function (shader, methodVO, targetReg, registerCache, sharedRegisters) {\n        var code;\n        var temp = registerCache.getFreeFragmentVectorTemp();\n        code = methodVO.secondaryTextureGL._iGetFragmentCode(temp, registerCache, sharedRegisters, this._useSecondaryUV ? sharedRegisters.secondaryUVVarying : sharedRegisters.uvVarying);\n        switch (this._blendMode) {\n            case DiffuseLightMapMethod.MULTIPLY:\n                code += \"mul \" + this._pTotalLightColorReg + \", \" + this._pTotalLightColorReg + \", \" + temp + \"\\n\";\n                break;\n            case DiffuseLightMapMethod.ADD:\n                code += \"add \" + this._pTotalLightColorReg + \", \" + this._pTotalLightColorReg + \", \" + temp + \"\\n\";\n                break;\n        }\n        code += _super.prototype.iGetFragmentPostLightingCode.call(this, shader, methodVO, targetReg, registerCache, sharedRegisters);\n        return code;\n    };\n    /**\n     * @inheritDoc\n     */\n    DiffuseLightMapMethod.prototype.iActivate = function (shader, methodVO, stage) {\n        _super.prototype.iActivate.call(this, shader, methodVO, stage);\n        methodVO.secondaryTextureGL.activate(methodVO.pass._render);\n    };\n    /**\n     * @inheritDoc\n     */\n    DiffuseLightMapMethod.prototype.iSetRenderState = function (shader, methodVO, renderable, stage, camera) {\n        _super.prototype.iSetRenderState.call(this, shader, methodVO, renderable, stage, camera);\n        methodVO.secondaryTextureGL._setRenderState(renderable);\n    };\n    /**\n     * Indicates the light map should be multiplied with the calculated shading result.\n     * This can be used to add pre-calculated shadows or occlusion.\n     */\n    DiffuseLightMapMethod.MULTIPLY = \"multiply\";\n    /**\n     * Indicates the light map should be added into the calculated shading result.\n     * This can be used to add pre-calculated lighting or global illumination.\n     */\n    DiffuseLightMapMethod.ADD = \"add\";\n    return DiffuseLightMapMethod;\n}(DiffuseCompositeMethod_1.default));\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = DiffuseLightMapMethod;\n\n},{\"../methods/DiffuseCompositeMethod\":\"awayjs-methodmaterials/lib/methods/DiffuseCompositeMethod\"}],\"awayjs-methodmaterials/lib/methods/DiffuseSubSurfaceMethod\":[function(require,module,exports){\n\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar DiffuseCompositeMethod_1 = require(\"../methods/DiffuseCompositeMethod\");\n/**\n * DiffuseSubSurfaceMethod provides a depth map-based diffuse shading method that mimics the scattering of\n * light inside translucent surfaces. It allows light to shine through an object and to soften the diffuse shading.\n * It can be used for candle wax, ice, skin, ...\n */\nvar DiffuseSubSurfaceMethod = (function (_super) {\n    __extends(DiffuseSubSurfaceMethod, _super);\n    /**\n     * Creates a new <code>DiffuseSubSurfaceMethod</code> object.\n     *\n     * @param depthMapSize The size of the depth map used.\n     * @param depthMapOffset The amount by which the rendered object will be inflated, to prevent depth map rounding errors.\n     * @param baseMethod The diffuse method used to calculate the regular diffuse-based lighting.\n     */\n    function DiffuseSubSurfaceMethod(depthMapSize, depthMapOffset, baseMethod) {\n        var _this = this;\n        if (depthMapSize === void 0) { depthMapSize = 512; }\n        if (depthMapOffset === void 0) { depthMapOffset = 15; }\n        if (baseMethod === void 0) { baseMethod = null; }\n        _super.call(this, null, baseMethod);\n        this._translucency = 1;\n        this._scatterColor = 0xffffff;\n        this._scatterR = 1.0;\n        this._scatterG = 1.0;\n        this._scatterB = 1.0;\n        this.pBaseMethod._iModulateMethod = function (shader, methodVO, targetReg, registerCache, sharedRegisters) { return _this.scatterLight(shader, methodVO, targetReg, registerCache, sharedRegisters); };\n        //this._passes = new Array<MaterialPassGLBase>();\n        //this._depthPass = new SingleObjectDepthPass();\n        //this._depthPass.textureSize = depthMapSize;\n        //this._depthPass.polyOffset = depthMapOffset;\n        //this._passes.push(this._depthPass);\n        this._scattering = 0.2;\n        this._translucency = 1;\n    }\n    /**\n     * @inheritDoc\n     */\n    DiffuseSubSurfaceMethod.prototype.iInitConstants = function (shader, methodVO) {\n        _super.prototype.iInitConstants.call(this, shader, methodVO);\n        var data = shader.vertexConstantData;\n        var index = methodVO.secondaryVertexConstantsIndex;\n        data[index] = .5;\n        data[index + 1] = -.5;\n        data[index + 2] = 0;\n        data[index + 3] = 1;\n        data = shader.fragmentConstantData;\n        index = methodVO.secondaryFragmentConstantsIndex;\n        data[index + 3] = 1.0;\n        data[index + 4] = 1.0;\n        data[index + 5] = 1 / 255;\n        data[index + 6] = 1 / 65025;\n        data[index + 7] = 1 / 16581375;\n        data[index + 10] = .5;\n        data[index + 11] = -.1;\n    };\n    DiffuseSubSurfaceMethod.prototype.iCleanCompilationData = function () {\n        _super.prototype.iCleanCompilationData.call(this);\n        this._lightProjVarying = null;\n        this._propReg = null;\n        this._lightColorReg = null;\n        this._colorReg = null;\n        this._decReg = null;\n        this._targetReg = null;\n    };\n    Object.defineProperty(DiffuseSubSurfaceMethod.prototype, \"scattering\", {\n        /**\n         * The amount by which the light scatters. It can be used to set the translucent surface's thickness. Use low\n         * values for skin.\n         */\n        get: function () {\n            return this._scattering;\n        },\n        set: function (value) {\n            this._scattering = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(DiffuseSubSurfaceMethod.prototype, \"translucency\", {\n        /**\n         * The translucency of the object.\n         */\n        get: function () {\n            return this._translucency;\n        },\n        set: function (value) {\n            this._translucency = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(DiffuseSubSurfaceMethod.prototype, \"scatterColor\", {\n        /**\n         * The colour of the \"insides\" of the object, ie: the colour the light becomes after leaving the object.\n         */\n        get: function () {\n            return this._scatterColor;\n        },\n        set: function (scatterColor /*uint*/) {\n            this._scatterColor = scatterColor;\n            this._scatterR = ((scatterColor >> 16) & 0xff) / 0xff;\n            this._scatterG = ((scatterColor >> 8) & 0xff) / 0xff;\n            this._scatterB = (scatterColor & 0xff) / 0xff;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * @inheritDoc\n     */\n    DiffuseSubSurfaceMethod.prototype.iGetVertexCode = function (shader, methodVO, registerCache, sharedRegisters) {\n        var code = _super.prototype.iGetVertexCode.call(this, shader, methodVO, registerCache, sharedRegisters);\n        var lightProjection;\n        var toTexRegister;\n        var temp = registerCache.getFreeVertexVectorTemp();\n        toTexRegister = registerCache.getFreeVertexConstant();\n        methodVO.secondaryVertexConstantsIndex = toTexRegister.index * 4;\n        this._lightProjVarying = registerCache.getFreeVarying();\n        lightProjection = registerCache.getFreeVertexConstant();\n        registerCache.getFreeVertexConstant();\n        registerCache.getFreeVertexConstant();\n        registerCache.getFreeVertexConstant();\n        code += \"m44 \" + temp + \", vt0, \" + lightProjection + \"\\n\" +\n            \"div \" + temp + \".xyz, \" + temp + \".xyz, \" + temp + \".w\\n\" +\n            \"mul \" + temp + \".xy, \" + temp + \".xy, \" + toTexRegister + \".xy\\n\" +\n            \"add \" + temp + \".xy, \" + temp + \".xy, \" + toTexRegister + \".xx\\n\" +\n            \"mov \" + this._lightProjVarying + \".xyz, \" + temp + \".xyz\\n\" +\n            \"mov \" + this._lightProjVarying + \".w, va0.w\\n\";\n        return code;\n    };\n    /**\n     * @inheritDoc\n     */\n    DiffuseSubSurfaceMethod.prototype.iGetFragmentPreLightingCode = function (shader, methodVO, registerCache, sharedRegisters) {\n        this._colorReg = registerCache.getFreeFragmentConstant();\n        this._decReg = registerCache.getFreeFragmentConstant();\n        this._propReg = registerCache.getFreeFragmentConstant();\n        methodVO.secondaryFragmentConstantsIndex = this._colorReg.index * 4;\n        return _super.prototype.iGetFragmentPreLightingCode.call(this, shader, methodVO, registerCache, sharedRegisters);\n    };\n    /**\n     * @inheritDoc\n     */\n    DiffuseSubSurfaceMethod.prototype.iGetFragmentCodePerLight = function (shader, methodVO, lightDirReg, lightColReg, registerCache, sharedRegisters) {\n        this._pIsFirstLight = true;\n        this._lightColorReg = lightColReg;\n        return _super.prototype.iGetFragmentCodePerLight.call(this, shader, methodVO, lightDirReg, lightColReg, registerCache, sharedRegisters);\n    };\n    /**\n     * @inheritDoc\n     */\n    DiffuseSubSurfaceMethod.prototype.iGetFragmentPostLightingCode = function (shader, methodVO, targetReg, registerCache, sharedRegisters) {\n        var code = _super.prototype.iGetFragmentPostLightingCode.call(this, shader, methodVO, targetReg, registerCache, sharedRegisters);\n        var temp = registerCache.getFreeFragmentVectorTemp();\n        code += \"mul \" + temp + \".xyz, \" + this._lightColorReg + \".xyz, \" + this._targetReg + \".w\\n\" +\n            \"mul \" + temp + \".xyz, \" + temp + \".xyz, \" + this._colorReg + \".xyz\\n\" +\n            \"add \" + targetReg + \".xyz, \" + targetReg + \".xyz, \" + temp + \".xyz\\n\";\n        if (this._targetReg != sharedRegisters.viewDirFragment)\n            registerCache.removeFragmentTempUsage(targetReg);\n        return code;\n    };\n    /**\n     * @inheritDoc\n     */\n    DiffuseSubSurfaceMethod.prototype.iActivate = function (shader, methodVO, stage) {\n        _super.prototype.iActivate.call(this, shader, methodVO, stage);\n        var index = methodVO.secondaryFragmentConstantsIndex;\n        var data = shader.fragmentConstantData;\n        data[index] = this._scatterR;\n        data[index + 1] = this._scatterG;\n        data[index + 2] = this._scatterB;\n        data[index + 8] = this._scattering;\n        data[index + 9] = this._translucency;\n    };\n    /**\n     * @inheritDoc\n     */\n    DiffuseSubSurfaceMethod.prototype.iSetRenderState = function (shader, methodVO, renderable, stage, camera) {\n        methodVO.secondaryTextureGL = shader.getAbstraction(this._depthPass._iGetDepthMap(renderable));\n        methodVO.secondaryTextureGL._setRenderState(renderable);\n        this._depthPass._iGetProjection(renderable).copyRawDataTo(shader.vertexConstantData, methodVO.secondaryVertexConstantsIndex + 4, true);\n    };\n    /**\n     * Generates the code for this method\n     */\n    DiffuseSubSurfaceMethod.prototype.scatterLight = function (shader, methodVO, targetReg, registerCache, sharedRegisters) {\n        // only scatter first light\n        if (!this._pIsFirstLight)\n            return \"\";\n        this._pIsFirstLight = false;\n        var code = \"\";\n        if (sharedRegisters.viewDirFragment)\n            this._targetReg = sharedRegisters.viewDirFragment;\n        else\n            registerCache.addFragmentTempUsages(this._targetReg = registerCache.getFreeFragmentVectorTemp(), 1);\n        var temp = registerCache.getFreeFragmentVectorTemp();\n        code += methodVO.secondaryTextureGL._iGetFragmentCode(temp, registerCache, sharedRegisters, this._lightProjVarying) +\n            // reencode RGBA\n            \"dp4 \" + targetReg + \".z, \" + temp + \", \" + this._decReg + \"\\n\";\n        // currentDistanceToLight - closestDistanceToLight\n        code += \"sub \" + targetReg + \".z, \" + this._lightProjVarying + \".z, \" + targetReg + \".z\\n\" +\n            \"sub \" + targetReg + \".z, \" + this._propReg + \".x, \" + targetReg + \".z\\n\" +\n            \"mul \" + targetReg + \".z, \" + this._propReg + \".y, \" + targetReg + \".z\\n\" +\n            \"sat \" + targetReg + \".z, \" + targetReg + \".z\\n\" +\n            // targetReg.x contains dot(lightDir, normal)\n            // modulate according to incident light angle (scatter = scatter*(-.5*dot(light, normal) + .5)\n            \"neg \" + targetReg + \".y, \" + targetReg + \".x\\n\" +\n            \"mul \" + targetReg + \".y, \" + targetReg + \".y, \" + this._propReg + \".z\\n\" +\n            \"add \" + targetReg + \".y, \" + targetReg + \".y, \" + this._propReg + \".z\\n\" +\n            \"mul \" + this._targetReg + \".w, \" + targetReg + \".z, \" + targetReg + \".y\\n\" +\n            // blend diffuse: d' = (1-s)*d + s*1\n            \"sub \" + targetReg + \".y, \" + this._colorReg + \".w, \" + this._targetReg + \".w\\n\" +\n            \"mul \" + targetReg + \".w, \" + targetReg + \".w, \" + targetReg + \".y\\n\";\n        return code;\n    };\n    return DiffuseSubSurfaceMethod;\n}(DiffuseCompositeMethod_1.default));\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = DiffuseSubSurfaceMethod;\n\n},{\"../methods/DiffuseCompositeMethod\":\"awayjs-methodmaterials/lib/methods/DiffuseCompositeMethod\"}],\"awayjs-methodmaterials/lib/methods/DiffuseWrapMethod\":[function(require,module,exports){\n\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar DiffuseBasicMethod_1 = require(\"../methods/DiffuseBasicMethod\");\n/**\n * DiffuseWrapMethod is an alternative to DiffuseBasicMethod in which the light is allowed to be \"wrapped around\" the normally dark area, to some extent.\n * It can be used as a crude approximation to Oren-Nayar or simple subsurface scattering.\n */\nvar DiffuseWrapMethod = (function (_super) {\n    __extends(DiffuseWrapMethod, _super);\n    /**\n     * Creates a new DiffuseWrapMethod object.\n     * @param wrapFactor A factor to indicate the amount by which the light is allowed to wrap\n     */\n    function DiffuseWrapMethod(wrapFactor) {\n        if (wrapFactor === void 0) { wrapFactor = .5; }\n        _super.call(this);\n        this.wrapFactor = wrapFactor;\n    }\n    /**\n     * @inheritDoc\n     */\n    DiffuseWrapMethod.prototype.iCleanCompilationData = function () {\n        _super.prototype.iCleanCompilationData.call(this);\n        this._wrapDataRegister = null;\n    };\n    Object.defineProperty(DiffuseWrapMethod.prototype, \"wrapFactor\", {\n        /**\n         * A factor to indicate the amount by which the light is allowed to wrap.\n         */\n        get: function () {\n            return this._wrapFactor;\n        },\n        set: function (value) {\n            this._wrapFactor = value;\n            this._wrapFactor = 1 / (value + 1);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * @inheritDoc\n     */\n    DiffuseWrapMethod.prototype.iGetFragmentPreLightingCode = function (shader, methodVO, registerCache, sharedRegisters) {\n        var code = _super.prototype.iGetFragmentPreLightingCode.call(this, shader, methodVO, registerCache, sharedRegisters);\n        this._pIsFirstLight = true;\n        this._wrapDataRegister = registerCache.getFreeFragmentConstant();\n        methodVO.secondaryFragmentConstantsIndex = this._wrapDataRegister.index * 4;\n        return code;\n    };\n    /**\n     * @inheritDoc\n     */\n    DiffuseWrapMethod.prototype.iGetFragmentCodePerLight = function (shader, methodVO, lightDirReg, lightColReg, registerCache, sharedRegisters) {\n        var code = \"\";\n        var t;\n        // write in temporary if not first light, so we can add to total diffuse colour\n        if (this._pIsFirstLight) {\n            t = this._pTotalLightColorReg;\n        }\n        else {\n            t = registerCache.getFreeFragmentVectorTemp();\n            registerCache.addFragmentTempUsages(t, 1);\n        }\n        code += \"dp3 \" + t + \".x, \" + lightDirReg + \".xyz, \" + sharedRegisters.normalFragment + \".xyz\\n\" +\n            \"add \" + t + \".y, \" + t + \".x, \" + this._wrapDataRegister + \".x\\n\" +\n            \"mul \" + t + \".y, \" + t + \".y, \" + this._wrapDataRegister + \".y\\n\" +\n            \"sat \" + t + \".w, \" + t + \".y\\n\" +\n            \"mul \" + t + \".xz, \" + t + \".w, \" + lightDirReg + \".wz\\n\";\n        if (this._iModulateMethod != null)\n            code += this._iModulateMethod(shader, methodVO, lightDirReg, registerCache, sharedRegisters);\n        code += \"mul \" + t + \", \" + t + \".x, \" + lightColReg + \"\\n\";\n        if (!this._pIsFirstLight) {\n            code += \"add \" + this._pTotalLightColorReg + \".xyz, \" + this._pTotalLightColorReg + \".xyz, \" + t + \".xyz\\n\";\n            registerCache.removeFragmentTempUsage(t);\n        }\n        this._pIsFirstLight = false;\n        return code;\n    };\n    /**\n     * @inheritDoc\n     */\n    DiffuseWrapMethod.prototype.iActivate = function (shader, methodVO, stage) {\n        _super.prototype.iActivate.call(this, shader, methodVO, stage);\n        var index = methodVO.secondaryFragmentConstantsIndex;\n        var data = shader.fragmentConstantData;\n        data[index] = this._wrapFactor;\n        data[index + 1] = 1 / (this._wrapFactor + 1);\n    };\n    return DiffuseWrapMethod;\n}(DiffuseBasicMethod_1.default));\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = DiffuseWrapMethod;\n\n},{\"../methods/DiffuseBasicMethod\":\"awayjs-methodmaterials/lib/methods/DiffuseBasicMethod\"}],\"awayjs-methodmaterials/lib/methods/EffectAlphaMaskMethod\":[function(require,module,exports){\n\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar EffectMethodBase_1 = require(\"../methods/EffectMethodBase\");\n/**\n * EffectAlphaMaskMethod allows the use of an additional texture to specify the alpha value of the material. When used\n * with the secondary uv set, it allows for a tiled main texture with independently varying alpha (useful for water\n * etc).\n */\nvar EffectAlphaMaskMethod = (function (_super) {\n    __extends(EffectAlphaMaskMethod, _super);\n    /**\n     * Creates a new EffectAlphaMaskMethod object.\n     *\n     * @param texture The texture to use as the alpha mask.\n     * @param useSecondaryUV Indicated whether or not the secondary uv set for the mask. This allows mapping alpha independently.\n     */\n    function EffectAlphaMaskMethod(texture, useSecondaryUV) {\n        if (useSecondaryUV === void 0) { useSecondaryUV = false; }\n        _super.call(this);\n        this._texture = texture;\n        this._useSecondaryUV = useSecondaryUV;\n        if (this._texture)\n            this.iAddTexture(this._texture);\n    }\n    /**\n     * @inheritDoc\n     */\n    EffectAlphaMaskMethod.prototype.iInitVO = function (shader, methodVO) {\n        methodVO.textureGL = shader.getAbstraction(this._texture);\n        if (this._useSecondaryUV)\n            shader.secondaryUVDependencies++;\n        else\n            shader.uvDependencies++;\n    };\n    Object.defineProperty(EffectAlphaMaskMethod.prototype, \"useSecondaryUV\", {\n        /**\n         * Indicated whether or not the secondary uv set for the mask. This allows mapping alpha independently, for\n         * instance to tile the main texture and normal map while providing untiled alpha, for example to define the\n         * transparency over a tiled water surface.\n         */\n        get: function () {\n            return this._useSecondaryUV;\n        },\n        set: function (value) {\n            if (this._useSecondaryUV == value)\n                return;\n            this._useSecondaryUV = value;\n            this.iInvalidateShaderProgram();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(EffectAlphaMaskMethod.prototype, \"texture\", {\n        /**\n         * The texture to use as the alpha mask.\n         */\n        get: function () {\n            return this._texture;\n        },\n        set: function (value) {\n            if (this._texture == value)\n                return;\n            if (this._texture)\n                this.iRemoveTexture(this._texture);\n            this._texture = value;\n            if (this._texture)\n                this.iAddTexture(this._texture);\n            this.iInvalidateShaderProgram();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * @inheritDoc\n     */\n    EffectAlphaMaskMethod.prototype.iGetFragmentCode = function (shader, methodVO, targetReg, registerCache, sharedRegisters) {\n        var temp = registerCache.getFreeFragmentVectorTemp();\n        return methodVO.textureGL._iGetFragmentCode(temp, registerCache, sharedRegisters, this._useSecondaryUV ? sharedRegisters.secondaryUVVarying : sharedRegisters.uvVarying) +\n            \"mul \" + targetReg + \", \" + targetReg + \", \" + temp + \".x\\n\";\n    };\n    /**\n     * @inheritDoc\n     */\n    EffectAlphaMaskMethod.prototype.iActivate = function (shader, methodVO, stage) {\n        _super.prototype.iActivate.call(this, shader, methodVO, stage);\n        methodVO.textureGL.activate(methodVO.pass._render);\n    };\n    EffectAlphaMaskMethod.prototype.iSetRenderState = function (shader, methodVO, renderable, stage, camera) {\n        methodVO.textureGL._setRenderState(renderable);\n    };\n    return EffectAlphaMaskMethod;\n}(EffectMethodBase_1.default));\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = EffectAlphaMaskMethod;\n\n},{\"../methods/EffectMethodBase\":\"awayjs-methodmaterials/lib/methods/EffectMethodBase\"}],\"awayjs-methodmaterials/lib/methods/EffectColorMatrixMethod\":[function(require,module,exports){\n\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar EffectMethodBase_1 = require(\"../methods/EffectMethodBase\");\n/**\n * EffectColorMatrixMethod provides a shading method that changes the colour of a material analogous to a ColorMatrixFilter.\n */\nvar EffectColorMatrixMethod = (function (_super) {\n    __extends(EffectColorMatrixMethod, _super);\n    /**\n     * Creates a new EffectColorTransformMethod.\n     *\n     * @param matrix An array of 20 items for 4 x 5 color transform.\n     */\n    function EffectColorMatrixMethod(matrix) {\n        _super.call(this);\n        if (matrix.length != 20)\n            throw new Error(\"Matrix length must be 20!\");\n        this._matrix = matrix;\n    }\n    Object.defineProperty(EffectColorMatrixMethod.prototype, \"colorMatrix\", {\n        /**\n         * The 4 x 5 matrix to transform the color of the material.\n         */\n        get: function () {\n            return this._matrix;\n        },\n        set: function (value) {\n            this._matrix = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * @inheritDoc\n     */\n    EffectColorMatrixMethod.prototype.iGetFragmentCode = function (shader, methodVO, targetReg, registerCache, sharedRegisters) {\n        var code = \"\";\n        var colorMultReg = registerCache.getFreeFragmentConstant();\n        registerCache.getFreeFragmentConstant();\n        registerCache.getFreeFragmentConstant();\n        registerCache.getFreeFragmentConstant();\n        var colorOffsetReg = registerCache.getFreeFragmentConstant();\n        methodVO.fragmentConstantsIndex = colorMultReg.index * 4;\n        var temp = registerCache.getFreeFragmentVectorTemp();\n        code += \"m44 \" + temp + \", \" + targetReg + \", \" + colorMultReg + \"\\n\" +\n            \"add \" + targetReg + \", \" + temp + \", \" + colorOffsetReg + \"\\n\";\n        return code;\n    };\n    /**\n     * @inheritDoc\n     */\n    EffectColorMatrixMethod.prototype.iActivate = function (shader, methodVO, stage) {\n        var matrix = this._matrix;\n        var index = methodVO.fragmentConstantsIndex;\n        var data = shader.fragmentConstantData;\n        // r\n        data[index] = matrix[0];\n        data[index + 1] = matrix[1];\n        data[index + 2] = matrix[2];\n        data[index + 3] = matrix[3];\n        // g\n        data[index + 4] = matrix[5];\n        data[index + 5] = matrix[6];\n        data[index + 6] = matrix[7];\n        data[index + 7] = matrix[8];\n        // b\n        data[index + 8] = matrix[10];\n        data[index + 9] = matrix[11];\n        data[index + 10] = matrix[12];\n        data[index + 11] = matrix[13];\n        // a\n        data[index + 12] = matrix[15];\n        data[index + 13] = matrix[16];\n        data[index + 14] = matrix[17];\n        data[index + 15] = matrix[18];\n        // rgba offset\n        data[index + 16] = matrix[4];\n        data[index + 17] = matrix[9];\n        data[index + 18] = matrix[14];\n        data[index + 19] = matrix[19];\n    };\n    return EffectColorMatrixMethod;\n}(EffectMethodBase_1.default));\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = EffectColorMatrixMethod;\n\n},{\"../methods/EffectMethodBase\":\"awayjs-methodmaterials/lib/methods/EffectMethodBase\"}],\"awayjs-methodmaterials/lib/methods/EffectColorTransformMethod\":[function(require,module,exports){\n\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar EffectMethodBase_1 = require(\"../methods/EffectMethodBase\");\n/**\n * EffectColorTransformMethod provides a shading method that changes the colour of a material analogous to a\n * ColorTransform object.\n */\nvar EffectColorTransformMethod = (function (_super) {\n    __extends(EffectColorTransformMethod, _super);\n    /**\n     * Creates a new EffectColorTransformMethod.\n     */\n    function EffectColorTransformMethod() {\n        _super.call(this);\n    }\n    Object.defineProperty(EffectColorTransformMethod.prototype, \"colorTransform\", {\n        /**\n         * The ColorTransform object to transform the colour of the material with.\n         */\n        get: function () {\n            return this._colorTransform;\n        },\n        set: function (value) {\n            this._colorTransform = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * @inheritDoc\n     */\n    EffectColorTransformMethod.prototype.iGetFragmentCode = function (shader, methodVO, targetReg, registerCache, sharedRegisters) {\n        var code = \"\";\n        var colorMultReg = registerCache.getFreeFragmentConstant();\n        var colorOffsReg = registerCache.getFreeFragmentConstant();\n        methodVO.fragmentConstantsIndex = colorMultReg.index * 4;\n        //TODO: AGAL <> GLSL\n        code += \"mul \" + targetReg + \", \" + targetReg + \", \" + colorMultReg + \"\\n\" + \"add \" + targetReg + \", \" + targetReg + \", \" + colorOffsReg + \"\\n\";\n        return code;\n    };\n    /**\n     * @inheritDoc\n     */\n    EffectColorTransformMethod.prototype.iActivate = function (shader, methodVO, stage) {\n        var inv = 1 / 0xff;\n        var index = methodVO.fragmentConstantsIndex;\n        var data = shader.fragmentConstantData;\n        data[index] = this._colorTransform.redMultiplier;\n        data[index + 1] = this._colorTransform.greenMultiplier;\n        data[index + 2] = this._colorTransform.blueMultiplier;\n        data[index + 3] = this._colorTransform.alphaMultiplier;\n        data[index + 4] = this._colorTransform.redOffset * inv;\n        data[index + 5] = this._colorTransform.greenOffset * inv;\n        data[index + 6] = this._colorTransform.blueOffset * inv;\n        data[index + 7] = this._colorTransform.alphaOffset * inv;\n    };\n    return EffectColorTransformMethod;\n}(EffectMethodBase_1.default));\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = EffectColorTransformMethod;\n\n},{\"../methods/EffectMethodBase\":\"awayjs-methodmaterials/lib/methods/EffectMethodBase\"}],\"awayjs-methodmaterials/lib/methods/EffectEnvMapMethod\":[function(require,module,exports){\n\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar EffectMethodBase_1 = require(\"../methods/EffectMethodBase\");\n/**\n * EffectEnvMapMethod provides a material method to perform reflection mapping using cube maps.\n */\nvar EffectEnvMapMethod = (function (_super) {\n    __extends(EffectEnvMapMethod, _super);\n    /**\n     * Creates an EffectEnvMapMethod object.\n     * @param envMap The environment map containing the reflected scene.\n     * @param alpha The reflectivity of the surface.\n     */\n    function EffectEnvMapMethod(envMap, alpha) {\n        if (alpha === void 0) { alpha = 1; }\n        _super.call(this);\n        this._envMap = envMap;\n        this._alpha = alpha;\n        if (this._envMap)\n            this.iAddTexture(this._envMap);\n    }\n    Object.defineProperty(EffectEnvMapMethod.prototype, \"mask\", {\n        /**\n         * An optional texture to modulate the reflectivity of the surface.\n         */\n        get: function () {\n            return this._mask;\n        },\n        set: function (value) {\n            if (value == this._mask)\n                return;\n            if (this._mask)\n                this.iRemoveTexture(this._mask);\n            this._mask = value;\n            if (this._mask)\n                this.iAddTexture(this._mask);\n            this.iInvalidateShaderProgram();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * @inheritDoc\n     */\n    EffectEnvMapMethod.prototype.iInitVO = function (shader, methodVO) {\n        methodVO.needsNormals = true;\n        methodVO.needsView = true;\n        if (this._envMap)\n            methodVO.textureGL = shader.getAbstraction(this._envMap);\n        if (this._mask) {\n            methodVO.secondaryTextureGL = shader.getAbstraction(this._mask);\n            shader.uvDependencies++;\n        }\n    };\n    Object.defineProperty(EffectEnvMapMethod.prototype, \"envMap\", {\n        /**\n         * The cubic environment map containing the reflected scene.\n         */\n        get: function () {\n            return this._envMap;\n        },\n        set: function (value) {\n            if (this._envMap == value)\n                return;\n            if (this._envMap)\n                this.iRemoveTexture(this._envMap);\n            this._envMap = value;\n            if (this._envMap)\n                this.iAddTexture(this._envMap);\n            this.iInvalidateShaderProgram();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * @inheritDoc\n     */\n    EffectEnvMapMethod.prototype.dispose = function () {\n    };\n    Object.defineProperty(EffectEnvMapMethod.prototype, \"alpha\", {\n        /**\n         * The reflectivity of the surface.\n         */\n        get: function () {\n            return this._alpha;\n        },\n        set: function (value) {\n            this._alpha = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * @inheritDoc\n     */\n    EffectEnvMapMethod.prototype.iActivate = function (shader, methodVO, stage) {\n        shader.fragmentConstantData[methodVO.fragmentConstantsIndex] = this._alpha;\n        methodVO.textureGL.activate(methodVO.pass._render);\n        if (this._mask)\n            methodVO.secondaryTextureGL.activate(methodVO.pass._render);\n    };\n    EffectEnvMapMethod.prototype.iSetRenderState = function (shader, methodVO, renderable, stage, camera) {\n        methodVO.textureGL._setRenderState(renderable);\n        if (this._mask)\n            methodVO.secondaryTextureGL._setRenderState(renderable);\n    };\n    /**\n     * @inheritDoc\n     */\n    EffectEnvMapMethod.prototype.iGetFragmentCode = function (shader, methodVO, targetReg, registerCache, sharedRegisters) {\n        var dataRegister = registerCache.getFreeFragmentConstant();\n        var code = \"\";\n        methodVO.fragmentConstantsIndex = dataRegister.index * 4;\n        var temp = registerCache.getFreeFragmentVectorTemp();\n        registerCache.addFragmentTempUsages(temp, 1);\n        var temp2 = registerCache.getFreeFragmentVectorTemp();\n        registerCache.addFragmentTempUsages(temp2, 1);\n        // r = I - 2(I.N)*N\n        code += \"dp3 \" + temp + \".w, \" + sharedRegisters.viewDirFragment + \".xyz, \" + sharedRegisters.normalFragment + \".xyz\\n\" +\n            \"add \" + temp + \".w, \" + temp + \".w, \" + temp + \".w\\n\" +\n            \"mul \" + temp + \".xyz, \" + sharedRegisters.normalFragment + \".xyz, \" + temp + \".w\\n\" +\n            \"sub \" + temp + \".xyz, \" + temp + \".xyz, \" + sharedRegisters.viewDirFragment + \".xyz\\n\" +\n            methodVO.textureGL._iGetFragmentCode(temp, registerCache, sharedRegisters, temp) +\n            \"sub \" + temp2 + \".w, \" + temp + \".w, fc0.x\\n\" +\n            \"kil \" + temp2 + \".w\\n\" +\n            \"sub \" + temp + \", \" + temp + \", \" + targetReg + \"\\n\";\n        if (this._mask) {\n            code += methodVO.secondaryTextureGL._iGetFragmentCode(temp2, registerCache, sharedRegisters, sharedRegisters.uvVarying) +\n                \"mul \" + temp + \", \" + temp2 + \", \" + temp + \"\\n\";\n        }\n        code += \"mul \" + temp + \", \" + temp + \", \" + dataRegister + \".x\\n\" +\n            \"add \" + targetReg + \", \" + targetReg + \", \" + temp + \"\\n\";\n        registerCache.removeFragmentTempUsage(temp);\n        registerCache.removeFragmentTempUsage(temp2);\n        return code;\n    };\n    return EffectEnvMapMethod;\n}(EffectMethodBase_1.default));\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = EffectEnvMapMethod;\n\n},{\"../methods/EffectMethodBase\":\"awayjs-methodmaterials/lib/methods/EffectMethodBase\"}],\"awayjs-methodmaterials/lib/methods/EffectFogMethod\":[function(require,module,exports){\n\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar EffectMethodBase_1 = require(\"../methods/EffectMethodBase\");\n/**\n * EffectFogMethod provides a method to add distance-based fog to a material.\n */\nvar EffectFogMethod = (function (_super) {\n    __extends(EffectFogMethod, _super);\n    /**\n     * Creates a new EffectFogMethod object.\n     * @param minDistance The distance from which the fog starts appearing.\n     * @param maxDistance The distance at which the fog is densest.\n     * @param fogColor The colour of the fog.\n     */\n    function EffectFogMethod(minDistance, maxDistance, fogColor) {\n        if (fogColor === void 0) { fogColor = 0x808080; }\n        _super.call(this);\n        this._minDistance = 0;\n        this._maxDistance = 1000;\n        this.minDistance = minDistance;\n        this.maxDistance = maxDistance;\n        this.fogColor = fogColor;\n    }\n    /**\n     * @inheritDoc\n     */\n    EffectFogMethod.prototype.iInitVO = function (shader, methodVO) {\n        methodVO.needsProjection = true;\n    };\n    /**\n     * @inheritDoc\n     */\n    EffectFogMethod.prototype.iInitConstants = function (shader, methodVO) {\n        var data = shader.fragmentConstantData;\n        var index = methodVO.fragmentConstantsIndex;\n        data[index + 3] = 1;\n        data[index + 6] = 0;\n        data[index + 7] = 0;\n    };\n    Object.defineProperty(EffectFogMethod.prototype, \"minDistance\", {\n        /**\n         * The distance from which the fog starts appearing.\n         */\n        get: function () {\n            return this._minDistance;\n        },\n        set: function (value) {\n            this._minDistance = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(EffectFogMethod.prototype, \"maxDistance\", {\n        /**\n         * The distance at which the fog is densest.\n         */\n        get: function () {\n            return this._maxDistance;\n        },\n        set: function (value) {\n            this._maxDistance = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(EffectFogMethod.prototype, \"fogColor\", {\n        /**\n         * The colour of the fog.\n         */\n        get: function () {\n            return this._fogColor;\n        },\n        set: function (value /*uint*/) {\n            this._fogColor = value;\n            this._fogR = ((value >> 16) & 0xff) / 0xff;\n            this._fogG = ((value >> 8) & 0xff) / 0xff;\n            this._fogB = (value & 0xff) / 0xff;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * @inheritDoc\n     */\n    EffectFogMethod.prototype.iActivate = function (shader, methodVO, stage) {\n        var data = shader.fragmentConstantData;\n        var index = methodVO.fragmentConstantsIndex;\n        data[index] = this._fogR;\n        data[index + 1] = this._fogG;\n        data[index + 2] = this._fogB;\n        data[index + 4] = this._minDistance;\n        data[index + 5] = 1 / (this._maxDistance - this._minDistance);\n    };\n    /**\n     * @inheritDoc\n     */\n    EffectFogMethod.prototype.iGetFragmentCode = function (shader, methodVO, targetReg, registerCache, sharedRegisters) {\n        var fogColor = registerCache.getFreeFragmentConstant();\n        var fogData = registerCache.getFreeFragmentConstant();\n        var temp = registerCache.getFreeFragmentVectorTemp();\n        registerCache.addFragmentTempUsages(temp, 1);\n        var temp2 = registerCache.getFreeFragmentVectorTemp();\n        var code = \"\";\n        methodVO.fragmentConstantsIndex = fogColor.index * 4;\n        code += \"sub \" + temp2 + \".w, \" + sharedRegisters.projectionFragment + \".z, \" + fogData + \".x\\n\" +\n            \"mul \" + temp2 + \".w, \" + temp2 + \".w, \" + fogData + \".y\\n\" +\n            \"sat \" + temp2 + \".w, \" + temp2 + \".w\\n\" +\n            \"sub \" + temp + \", \" + fogColor + \", \" + targetReg + \"\\n\" +\n            \"mul \" + temp + \", \" + temp + \", \" + temp2 + \".w\\n\" +\n            \"add \" + targetReg + \", \" + targetReg + \", \" + temp + \"\\n\"; // fogRatio*(fogColor- col) + col\n        registerCache.removeFragmentTempUsage(temp);\n        return code;\n    };\n    return EffectFogMethod;\n}(EffectMethodBase_1.default));\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = EffectFogMethod;\n\n},{\"../methods/EffectMethodBase\":\"awayjs-methodmaterials/lib/methods/EffectMethodBase\"}],\"awayjs-methodmaterials/lib/methods/EffectFresnelEnvMapMethod\":[function(require,module,exports){\n\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar EffectMethodBase_1 = require(\"../methods/EffectMethodBase\");\n/**\n * EffectFresnelEnvMapMethod provides a method to add fresnel-based reflectivity to an object using cube maps, which gets\n * stronger as the viewing angle becomes more grazing.\n */\nvar EffectFresnelEnvMapMethod = (function (_super) {\n    __extends(EffectFresnelEnvMapMethod, _super);\n    /**\n     * Creates a new <code>EffectFresnelEnvMapMethod</code> object.\n     *\n     * @param envMap The environment map containing the reflected scene.\n     * @param alpha The reflectivity of the material.\n     */\n    function EffectFresnelEnvMapMethod(envMap, alpha) {\n        if (alpha === void 0) { alpha = 1; }\n        _super.call(this);\n        this._fresnelPower = 5;\n        this._normalReflectance = 0;\n        this._envMap = envMap;\n        this._alpha = alpha;\n        if (this._envMap)\n            this.iAddTexture(this._envMap);\n    }\n    /**\n     * @inheritDoc\n     */\n    EffectFresnelEnvMapMethod.prototype.iInitVO = function (shader, methodVO) {\n        methodVO.needsNormals = true;\n        methodVO.needsView = true;\n        methodVO.textureGL = shader.getAbstraction(this._envMap);\n        if (this._mask != null) {\n            methodVO.secondaryTextureGL = shader.getAbstraction(this._mask);\n            shader.uvDependencies++;\n        }\n    };\n    /**\n     * @inheritDoc\n     */\n    EffectFresnelEnvMapMethod.prototype.iInitConstants = function (shader, methodVO) {\n        shader.fragmentConstantData[methodVO.fragmentConstantsIndex + 3] = 1;\n    };\n    Object.defineProperty(EffectFresnelEnvMapMethod.prototype, \"mask\", {\n        /**\n         * An optional texture to modulate the reflectivity of the surface.\n         */\n        get: function () {\n            return this._mask;\n        },\n        set: function (value) {\n            if (this._mask == value)\n                return;\n            if (this._mask)\n                this.iRemoveTexture(this._mask);\n            this._mask = value;\n            if (this._mask)\n                this.iAddTexture(this._mask);\n            this.iInvalidateShaderProgram();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(EffectFresnelEnvMapMethod.prototype, \"fresnelPower\", {\n        /**\n         * The power used in the Fresnel equation. Higher values make the fresnel effect more pronounced. Defaults to 5.\n         */\n        get: function () {\n            return this._fresnelPower;\n        },\n        set: function (value) {\n            this._fresnelPower = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(EffectFresnelEnvMapMethod.prototype, \"envMap\", {\n        /**\n         * The cubic environment map containing the reflected scene.\n         */\n        get: function () {\n            return this._envMap;\n        },\n        set: function (value) {\n            if (this._envMap == value)\n                return;\n            if (this._envMap)\n                this.iRemoveTexture(this._envMap);\n            this._envMap = value;\n            if (this._envMap)\n                this.iAddTexture(this._envMap);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(EffectFresnelEnvMapMethod.prototype, \"alpha\", {\n        /**\n         * The reflectivity of the surface.\n         */\n        get: function () {\n            return this._alpha;\n        },\n        set: function (value) {\n            this._alpha = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(EffectFresnelEnvMapMethod.prototype, \"normalReflectance\", {\n        /**\n         * The minimum amount of reflectance, ie the reflectance when the view direction is normal to the surface or light direction.\n         */\n        get: function () {\n            return this._normalReflectance;\n        },\n        set: function (value) {\n            this._normalReflectance = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * @inheritDoc\n     */\n    EffectFresnelEnvMapMethod.prototype.iActivate = function (shader, methodVO, stage) {\n        var data = shader.fragmentConstantData;\n        var index = methodVO.fragmentConstantsIndex;\n        data[index] = this._alpha;\n        data[index + 1] = this._normalReflectance;\n        data[index + 2] = this._fresnelPower;\n        methodVO.textureGL.activate(methodVO.pass._render);\n        if (this._mask)\n            methodVO.secondaryTextureGL.activate(methodVO.pass._render);\n    };\n    EffectFresnelEnvMapMethod.prototype.iSetRenderState = function (shader, methodVO, renderable, stage, camera) {\n        methodVO.textureGL._setRenderState(renderable);\n        if (this._mask)\n            methodVO.secondaryTextureGL._setRenderState(renderable);\n    };\n    /**\n     * @inheritDoc\n     */\n    EffectFresnelEnvMapMethod.prototype.iGetFragmentCode = function (shader, methodVO, targetReg, registerCache, sharedRegisters) {\n        var dataRegister = registerCache.getFreeFragmentConstant();\n        var code = \"\";\n        var viewDirReg = sharedRegisters.viewDirFragment;\n        var normalReg = sharedRegisters.normalFragment;\n        methodVO.fragmentConstantsIndex = dataRegister.index * 4;\n        var temp = registerCache.getFreeFragmentVectorTemp();\n        registerCache.addFragmentTempUsages(temp, 1);\n        var temp2 = registerCache.getFreeFragmentVectorTemp();\n        registerCache.addFragmentTempUsages(temp2, 1);\n        // r = V - 2(V.N)*N\n        code += \"dp3 \" + temp + \".w, \" + viewDirReg + \".xyz, \" + normalReg + \".xyz\\n\" +\n            \"add \" + temp + \".w, \" + temp + \".w, \" + temp + \".w\\n\" +\n            \"mul \" + temp + \".xyz, \" + normalReg + \".xyz, \" + temp + \".w\\n\" +\n            \"sub \" + temp + \".xyz, \" + temp + \".xyz, \" + viewDirReg + \".xyz\\n\" +\n            methodVO.textureGL._iGetFragmentCode(temp, registerCache, sharedRegisters, temp) +\n            \"sub \" + temp2 + \".w, \" + temp + \".w, fc0.x\\n\" +\n            \"kil \" + temp2 + \".w\\n\" +\n            \"sub \" + temp + \", \" + temp + \", \" + targetReg + \"\\n\";\n        // calculate fresnel term\n        code += \"dp3 \" + viewDirReg + \".w, \" + viewDirReg + \".xyz, \" + normalReg + \".xyz\\n\" +\n            \"sub \" + viewDirReg + \".w, \" + dataRegister + \".w, \" + viewDirReg + \".w\\n\" +\n            \"pow \" + viewDirReg + \".w, \" + viewDirReg + \".w, \" + dataRegister + \".z\\n\" +\n            \"sub \" + normalReg + \".w, \" + dataRegister + \".w, \" + viewDirReg + \".w\\n\" +\n            \"mul \" + normalReg + \".w, \" + dataRegister + \".y, \" + normalReg + \".w\\n\" +\n            \"add \" + viewDirReg + \".w, \" + viewDirReg + \".w, \" + normalReg + \".w\\n\" +\n            // total alpha\n            \"mul \" + viewDirReg + \".w, \" + dataRegister + \".x, \" + viewDirReg + \".w\\n\";\n        if (this._mask) {\n            code += methodVO.secondaryTextureGL._iGetFragmentCode(temp2, registerCache, sharedRegisters, sharedRegisters.uvVarying) +\n                \"mul \" + viewDirReg + \".w, \" + temp2 + \".x, \" + viewDirReg + \".w\\n\";\n        }\n        // blend\n        code += \"mul \" + temp + \", \" + temp + \", \" + viewDirReg + \".w\\n\" +\n            \"add \" + targetReg + \", \" + targetReg + \", \" + temp + \"\\n\";\n        registerCache.removeFragmentTempUsage(temp);\n        registerCache.removeFragmentTempUsage(temp2);\n        return code;\n    };\n    return EffectFresnelEnvMapMethod;\n}(EffectMethodBase_1.default));\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = EffectFresnelEnvMapMethod;\n\n},{\"../methods/EffectMethodBase\":\"awayjs-methodmaterials/lib/methods/EffectMethodBase\"}],\"awayjs-methodmaterials/lib/methods/EffectLightMapMethod\":[function(require,module,exports){\n\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar EffectMethodBase_1 = require(\"../methods/EffectMethodBase\");\n/**\n * EffectLightMapMethod provides a method that allows applying a light map texture to the calculated pixel colour.\n * It is different from DiffuseLightMapMethod in that the latter only modulates the diffuse shading value rather\n * than the whole pixel colour.\n */\nvar EffectLightMapMethod = (function (_super) {\n    __extends(EffectLightMapMethod, _super);\n    /**\n     * Creates a new EffectLightMapMethod object.\n     *\n     * @param lightMap The texture containing the light map.\n     * @param blendMode The blend mode with which the light map should be applied to the lighting result.\n     * @param useSecondaryUV Indicates whether the secondary UV set should be used to map the light map.\n     */\n    function EffectLightMapMethod(lightMap, blendMode, useSecondaryUV) {\n        if (blendMode === void 0) { blendMode = \"multiply\"; }\n        if (useSecondaryUV === void 0) { useSecondaryUV = false; }\n        _super.call(this);\n        if (blendMode != EffectLightMapMethod.ADD && blendMode != EffectLightMapMethod.MULTIPLY)\n            throw new Error(\"Unknown blendmode!\");\n        this._lightMap = lightMap;\n        this._blendMode = blendMode;\n        this._useSecondaryUV = useSecondaryUV;\n        if (this._lightMap)\n            this.iAddTexture(this._lightMap);\n    }\n    /**\n     * @inheritDoc\n     */\n    EffectLightMapMethod.prototype.iInitVO = function (shader, methodVO) {\n        methodVO.textureGL = shader.getAbstraction(this._lightMap);\n        if (this._useSecondaryUV)\n            shader.secondaryUVDependencies++;\n        else\n            shader.uvDependencies++;\n    };\n    Object.defineProperty(EffectLightMapMethod.prototype, \"blendMode\", {\n        /**\n         * The blend mode with which the light map should be applied to the lighting result.\n         *\n         * @see EffectLightMapMethod.ADD\n         * @see EffectLightMapMethod.MULTIPLY\n         */\n        get: function () {\n            return this._blendMode;\n        },\n        set: function (value) {\n            if (this._blendMode == value)\n                return;\n            if (value != EffectLightMapMethod.ADD && value != EffectLightMapMethod.MULTIPLY)\n                throw new Error(\"Unknown blendmode!\");\n            this._blendMode = value;\n            this.iInvalidateShaderProgram();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(EffectLightMapMethod.prototype, \"lightMap\", {\n        /**\n         * The lightMap containing the light map.\n         */\n        get: function () {\n            return this._lightMap;\n        },\n        set: function (value) {\n            if (this._lightMap == value)\n                return;\n            if (this._lightMap)\n                this.iRemoveTexture(this._lightMap);\n            this._lightMap = value;\n            if (this._lightMap)\n                this.iAddTexture(this._lightMap);\n            this.iInvalidateShaderProgram();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(EffectLightMapMethod.prototype, \"useSecondaryUV\", {\n        /**\n         * Indicates whether the secondary UV set should be used to map the light map.\n         */\n        get: function () {\n            return this._useSecondaryUV;\n        },\n        set: function (value) {\n            if (this._useSecondaryUV == value)\n                return;\n            this._useSecondaryUV = value;\n            this.iInvalidateShaderProgram();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * @inheritDoc\n     */\n    EffectLightMapMethod.prototype.iGetFragmentCode = function (shader, methodVO, targetReg, registerCache, sharedRegisters) {\n        var code;\n        var temp = registerCache.getFreeFragmentVectorTemp();\n        code = methodVO.secondaryTextureGL._iGetFragmentCode(temp, registerCache, sharedRegisters, this._useSecondaryUV ? sharedRegisters.secondaryUVVarying : sharedRegisters.uvVarying);\n        switch (this._blendMode) {\n            case EffectLightMapMethod.MULTIPLY:\n                code += \"mul \" + targetReg + \", \" + targetReg + \", \" + temp + \"\\n\";\n                break;\n            case EffectLightMapMethod.ADD:\n                code += \"add \" + targetReg + \", \" + targetReg + \", \" + temp + \"\\n\";\n                break;\n        }\n        return code;\n    };\n    /**\n     * @inheritDoc\n     */\n    EffectLightMapMethod.prototype.iActivate = function (shader, methodVO, stage) {\n        methodVO.textureGL.activate(methodVO.pass._render);\n    };\n    EffectLightMapMethod.prototype.iSetRenderState = function (shader, methodVO, renderable, stage, camera) {\n        methodVO.textureGL._setRenderState(renderable);\n    };\n    /**\n     * Indicates the light map should be multiplied with the calculated shading result.\n     */\n    EffectLightMapMethod.MULTIPLY = \"multiply\";\n    /**\n     * Indicates the light map should be added into the calculated shading result.\n     */\n    EffectLightMapMethod.ADD = \"add\";\n    return EffectLightMapMethod;\n}(EffectMethodBase_1.default));\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = EffectLightMapMethod;\n\n},{\"../methods/EffectMethodBase\":\"awayjs-methodmaterials/lib/methods/EffectMethodBase\"}],\"awayjs-methodmaterials/lib/methods/EffectMethodBase\":[function(require,module,exports){\n\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar AbstractMethodError_1 = require(\"awayjs-core/lib/errors/AbstractMethodError\");\nvar ShadingMethodBase_1 = require(\"../methods/ShadingMethodBase\");\n/**\n * EffectMethodBase forms an abstract base class for shader methods that are not dependent on light sources,\n * and are in essence post-process effects on the materials.\n */\nvar EffectMethodBase = (function (_super) {\n    __extends(EffectMethodBase, _super);\n    function EffectMethodBase() {\n        _super.call(this);\n    }\n    Object.defineProperty(EffectMethodBase.prototype, \"assetType\", {\n        /**\n         * @inheritDoc\n         */\n        get: function () {\n            return EffectMethodBase.assetType;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Get the fragment shader code that should be added after all per-light code. Usually composits everything to the target register.\n     * @param methodVO The MethodVO object containing the method data for the currently compiled material pass.\n     * @param regCache The register cache used during the compilation.\n     * @param targetReg The register that will be containing the method's output.\n     * @private\n     */\n    EffectMethodBase.prototype.iGetFragmentCode = function (shader, methodVO, targetReg, registerCache, sharedRegisters) {\n        throw new AbstractMethodError_1.default();\n    };\n    EffectMethodBase.assetType = \"[asset EffectMethod]\";\n    return EffectMethodBase;\n}(ShadingMethodBase_1.default));\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = EffectMethodBase;\n\n},{\"../methods/ShadingMethodBase\":\"awayjs-methodmaterials/lib/methods/ShadingMethodBase\",\"awayjs-core/lib/errors/AbstractMethodError\":undefined}],\"awayjs-methodmaterials/lib/methods/EffectRefractionEnvMapMethod\":[function(require,module,exports){\n\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar EffectMethodBase_1 = require(\"../methods/EffectMethodBase\");\n/**\n * EffectRefractionEnvMapMethod provides a method to add refracted transparency based on cube maps.\n */\nvar EffectRefractionEnvMapMethod = (function (_super) {\n    __extends(EffectRefractionEnvMapMethod, _super);\n    /**\n     * Creates a new EffectRefractionEnvMapMethod object. Example values for dispersion are: dispersionR: -0.03, dispersionG: -0.01, dispersionB: = .0015\n     *\n     * @param envMap The environment map containing the refracted scene.\n     * @param refractionIndex The refractive index of the material.\n     * @param dispersionR The amount of chromatic dispersion of the red channel. Defaults to 0 (none).\n     * @param dispersionG The amount of chromatic dispersion of the green channel. Defaults to 0 (none).\n     * @param dispersionB The amount of chromatic dispersion of the blue channel. Defaults to 0 (none).\n     */\n    function EffectRefractionEnvMapMethod(envMap, refractionIndex, dispersionR, dispersionG, dispersionB) {\n        if (refractionIndex === void 0) { refractionIndex = .1; }\n        if (dispersionR === void 0) { dispersionR = 0; }\n        if (dispersionG === void 0) { dispersionG = 0; }\n        if (dispersionB === void 0) { dispersionB = 0; }\n        _super.call(this);\n        this._dispersionR = 0;\n        this._dispersionG = 0;\n        this._dispersionB = 0;\n        this._alpha = 1;\n        this._envMap = envMap;\n        this._dispersionR = dispersionR;\n        this._dispersionG = dispersionG;\n        this._dispersionB = dispersionB;\n        this._useDispersion = !(this._dispersionR == this._dispersionB && this._dispersionR == this._dispersionG);\n        this._refractionIndex = refractionIndex;\n        if (this._envMap)\n            this.iAddTexture(this._envMap);\n    }\n    /**\n     * @inheritDoc\n     */\n    EffectRefractionEnvMapMethod.prototype.iInitConstants = function (shader, methodVO) {\n        var index = methodVO.fragmentConstantsIndex;\n        var data = shader.fragmentConstantData;\n        data[index + 4] = 1;\n        data[index + 5] = 0;\n        data[index + 7] = 1;\n    };\n    /**\n     * @inheritDoc\n     */\n    EffectRefractionEnvMapMethod.prototype.iInitVO = function (shader, methodVO) {\n        methodVO.needsNormals = true;\n        methodVO.needsView = true;\n        methodVO.textureGL = shader.getAbstraction(this._envMap);\n    };\n    Object.defineProperty(EffectRefractionEnvMapMethod.prototype, \"envMap\", {\n        /**\n         * The cube environment map to use for the refraction.\n         */\n        get: function () {\n            return this._envMap;\n        },\n        set: function (value) {\n            if (this._envMap == value)\n                return;\n            if (this._envMap)\n                this.iRemoveTexture(this._envMap);\n            this._envMap = value;\n            if (this._envMap)\n                this.iAddTexture(this._envMap);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(EffectRefractionEnvMapMethod.prototype, \"refractionIndex\", {\n        /**\n         * The refractive index of the material.\n         */\n        get: function () {\n            return this._refractionIndex;\n        },\n        set: function (value) {\n            this._refractionIndex = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(EffectRefractionEnvMapMethod.prototype, \"dispersionR\", {\n        /**\n         * The amount of chromatic dispersion of the red channel. Defaults to 0 (none).\n         */\n        get: function () {\n            return this._dispersionR;\n        },\n        set: function (value) {\n            this._dispersionR = value;\n            var useDispersion = !(this._dispersionR == this._dispersionB && this._dispersionR == this._dispersionG);\n            if (this._useDispersion != useDispersion) {\n                this.iInvalidateShaderProgram();\n                this._useDispersion = useDispersion;\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(EffectRefractionEnvMapMethod.prototype, \"dispersionG\", {\n        /**\n         * The amount of chromatic dispersion of the green channel. Defaults to 0 (none).\n         */\n        get: function () {\n            return this._dispersionG;\n        },\n        set: function (value) {\n            this._dispersionG = value;\n            var useDispersion = !(this._dispersionR == this._dispersionB && this._dispersionR == this._dispersionG);\n            if (this._useDispersion != useDispersion) {\n                this.iInvalidateShaderProgram();\n                this._useDispersion = useDispersion;\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(EffectRefractionEnvMapMethod.prototype, \"dispersionB\", {\n        /**\n         * The amount of chromatic dispersion of the blue channel. Defaults to 0 (none).\n         */\n        get: function () {\n            return this._dispersionB;\n        },\n        set: function (value) {\n            this._dispersionB = value;\n            var useDispersion = !(this._dispersionR == this._dispersionB && this._dispersionR == this._dispersionG);\n            if (this._useDispersion != useDispersion) {\n                this.iInvalidateShaderProgram();\n                this._useDispersion = useDispersion;\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(EffectRefractionEnvMapMethod.prototype, \"alpha\", {\n        /**\n         * The amount of transparency of the object. Warning: the alpha applies to the refracted color, not the actual\n         * material. A value of 1 will make it appear fully transparent.\n         */\n        get: function () {\n            return this._alpha;\n        },\n        set: function (value) {\n            this._alpha = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * @inheritDoc\n     */\n    EffectRefractionEnvMapMethod.prototype.iActivate = function (shader, methodVO, stage) {\n        var index = methodVO.fragmentConstantsIndex;\n        var data = shader.fragmentConstantData;\n        data[index] = this._dispersionR + this._refractionIndex;\n        if (this._useDispersion) {\n            data[index + 1] = this._dispersionG + this._refractionIndex;\n            data[index + 2] = this._dispersionB + this._refractionIndex;\n        }\n        data[index + 3] = this._alpha;\n        methodVO.textureGL.activate(methodVO.pass._render);\n    };\n    EffectRefractionEnvMapMethod.prototype.iSetRenderState = function (shader, methodVO, renderable, stage, camera) {\n        methodVO.textureGL._setRenderState(renderable);\n    };\n    /**\n     * @inheritDoc\n     */\n    EffectRefractionEnvMapMethod.prototype.iGetFragmentCode = function (shader, methodVO, targetReg, registerCache, sharedRegisters) {\n        // todo: data2.x could use common reg, so only 1 reg is used\n        var data = registerCache.getFreeFragmentConstant();\n        var data2 = registerCache.getFreeFragmentConstant();\n        var code = \"\";\n        var refractionDir;\n        var refractionColor;\n        var temp;\n        methodVO.fragmentConstantsIndex = data.index * 4;\n        refractionDir = registerCache.getFreeFragmentVectorTemp();\n        registerCache.addFragmentTempUsages(refractionDir, 1);\n        refractionColor = registerCache.getFreeFragmentVectorTemp();\n        registerCache.addFragmentTempUsages(refractionColor, 1);\n        temp = registerCache.getFreeFragmentVectorTemp();\n        registerCache.addFragmentTempUsages(temp, 1);\n        var viewDirReg = sharedRegisters.viewDirFragment;\n        var normalReg = sharedRegisters.normalFragment;\n        code += \"neg \" + viewDirReg + \".xyz, \" + viewDirReg + \".xyz\\n\";\n        code += \"dp3 \" + temp + \".x, \" + viewDirReg + \".xyz, \" + normalReg + \".xyz\\n\" +\n            \"mul \" + temp + \".w, \" + temp + \".x, \" + temp + \".x\\n\" +\n            \"sub \" + temp + \".w, \" + data2 + \".x, \" + temp + \".w\\n\" +\n            \"mul \" + temp + \".w, \" + data + \".x, \" + temp + \".w\\n\" +\n            \"mul \" + temp + \".w, \" + data + \".x, \" + temp + \".w\\n\" +\n            \"sub \" + temp + \".w, \" + data2 + \".x, \" + temp + \".w\\n\" +\n            \"sqt \" + temp + \".y, \" + temp + \".w\\n\" +\n            \"mul \" + temp + \".x, \" + data + \".x, \" + temp + \".x\\n\" +\n            \"add \" + temp + \".x, \" + temp + \".x, \" + temp + \".y\\n\" +\n            \"mul \" + temp + \".xyz, \" + temp + \".x, \" + normalReg + \".xyz\\n\" +\n            \"mul \" + refractionDir + \", \" + data + \".x, \" + viewDirReg + \"\\n\" +\n            \"sub \" + refractionDir + \".xyz, \" + refractionDir + \".xyz, \" + temp + \".xyz\\n\" +\n            \"nrm \" + refractionDir + \".xyz, \" + refractionDir + \".xyz\\n\" +\n            methodVO.textureGL._iGetFragmentCode(refractionColor, registerCache, sharedRegisters, refractionDir) +\n            \"sub \" + refractionColor + \".w, \" + refractionColor + \".w, fc0.x\t\\n\" +\n            \"kil \" + refractionColor + \".w\\n\";\n        if (this._useDispersion) {\n            // GREEN\n            code += \"dp3 \" + temp + \".x, \" + viewDirReg + \".xyz, \" + normalReg + \".xyz\\n\" +\n                \"mul \" + temp + \".w, \" + temp + \".x, \" + temp + \".x\\n\" +\n                \"sub \" + temp + \".w, \" + data2 + \".x, \" + temp + \".w\\n\" +\n                \"mul \" + temp + \".w, \" + data + \".y, \" + temp + \".w\\n\" +\n                \"mul \" + temp + \".w, \" + data + \".y, \" + temp + \".w\\n\" +\n                \"sub \" + temp + \".w, \" + data2 + \".x, \" + temp + \".w\\n\" +\n                \"sqt \" + temp + \".y, \" + temp + \".w\\n\" +\n                \"mul \" + temp + \".x, \" + data + \".y, \" + temp + \".x\\n\" +\n                \"add \" + temp + \".x, \" + temp + \".x, \" + temp + \".y\\n\" +\n                \"mul \" + temp + \".xyz, \" + temp + \".x, \" + normalReg + \".xyz\\n\" +\n                \"mul \" + refractionDir + \", \" + data + \".y, \" + viewDirReg + \"\\n\" +\n                \"sub \" + refractionDir + \".xyz, \" + refractionDir + \".xyz, \" + temp + \".xyz\\n\" +\n                \"nrm \" + refractionDir + \".xyz, \" + refractionDir + \".xyz\\n\" +\n                methodVO.textureGL._iGetFragmentCode(temp, registerCache, sharedRegisters, refractionDir) +\n                \"mov \" + refractionColor + \".y, \" + temp + \".y\\n\";\n            // BLUE\n            code += \"dp3 \" + temp + \".x, \" + viewDirReg + \".xyz, \" + normalReg + \".xyz\\n\" +\n                \"mul \" + temp + \".w, \" + temp + \".x, \" + temp + \".x\\n\" +\n                \"sub \" + temp + \".w, \" + data2 + \".x, \" + temp + \".w\\n\" +\n                \"mul \" + temp + \".w, \" + data + \".z, \" + temp + \".w\\n\" +\n                \"mul \" + temp + \".w, \" + data + \".z, \" + temp + \".w\\n\" +\n                \"sub \" + temp + \".w, \" + data2 + \".x, \" + temp + \".w\\n\" +\n                \"sqt \" + temp + \".y, \" + temp + \".w\\n\" +\n                \"mul \" + temp + \".x, \" + data + \".z, \" + temp + \".x\\n\" +\n                \"add \" + temp + \".x, \" + temp + \".x, \" + temp + \".y\\n\" +\n                \"mul \" + temp + \".xyz, \" + temp + \".x, \" + normalReg + \".xyz\\n\" +\n                \"mul \" + refractionDir + \", \" + data + \".z, \" + viewDirReg + \"\\n\" +\n                \"sub \" + refractionDir + \".xyz, \" + refractionDir + \".xyz, \" + temp + \".xyz\\n\" +\n                \"nrm \" + refractionDir + \".xyz, \" + refractionDir + \".xyz\\n\" +\n                methodVO.textureGL._iGetFragmentCode(temp, registerCache, sharedRegisters, refractionDir) +\n                \"mov \" + refractionColor + \".z, \" + temp + \".z\\n\";\n        }\n        code += \"sub \" + refractionColor + \".xyz, \" + refractionColor + \".xyz, \" + targetReg + \".xyz\\n\" +\n            \"mul \" + refractionColor + \".xyz, \" + refractionColor + \".xyz, \" + data + \".w\\n\" +\n            \"add \" + targetReg + \".xyz, \" + targetReg + \".xyz, \" + refractionColor + \".xyz\\n\";\n        registerCache.removeFragmentTempUsage(temp);\n        registerCache.removeFragmentTempUsage(refractionDir);\n        registerCache.removeFragmentTempUsage(refractionColor);\n        // restore\n        code += \"neg \" + viewDirReg + \".xyz, \" + viewDirReg + \".xyz\\n\";\n        return code;\n    };\n    return EffectRefractionEnvMapMethod;\n}(EffectMethodBase_1.default));\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = EffectRefractionEnvMapMethod;\n\n},{\"../methods/EffectMethodBase\":\"awayjs-methodmaterials/lib/methods/EffectMethodBase\"}],\"awayjs-methodmaterials/lib/methods/EffectRimLightMethod\":[function(require,module,exports){\n\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar EffectMethodBase_1 = require(\"../methods/EffectMethodBase\");\n/**\n * EffectRimLightMethod provides a method to add rim lighting to a material. This adds a glow-like effect to edges of objects.\n */\nvar EffectRimLightMethod = (function (_super) {\n    __extends(EffectRimLightMethod, _super);\n    /**\n     * Creates a new <code>EffectRimLightMethod</code> object.\n     *\n     * @param color The colour of the rim light.\n     * @param strength The strength of the rim light.\n     * @param power The power of the rim light. Higher values will result in a higher edge fall-off.\n     * @param blend The blend mode with which to add the light to the object.\n     */\n    function EffectRimLightMethod(color, strength, power, blend) {\n        if (color === void 0) { color = 0xffffff; }\n        if (strength === void 0) { strength = .4; }\n        if (power === void 0) { power = 2; }\n        if (blend === void 0) { blend = \"mix\"; }\n        _super.call(this);\n        this._blendMode = blend;\n        this._strength = strength;\n        this._power = power;\n        this.color = color;\n    }\n    /**\n     * @inheritDoc\n     */\n    EffectRimLightMethod.prototype.iInitConstants = function (shader, methodVO) {\n        shader.fragmentConstantData[methodVO.fragmentConstantsIndex + 3] = 1;\n    };\n    /**\n     * @inheritDoc\n     */\n    EffectRimLightMethod.prototype.iInitVO = function (shader, methodVO) {\n        methodVO.needsNormals = true;\n        methodVO.needsView = true;\n    };\n    Object.defineProperty(EffectRimLightMethod.prototype, \"blendMode\", {\n        /**\n         * The blend mode with which to add the light to the object.\n         *\n         * EffectRimLightMethod.MULTIPLY multiplies the rim light with the material's colour.\n         * EffectRimLightMethod.ADD adds the rim light with the material's colour.\n         * EffectRimLightMethod.MIX provides normal alpha blending.\n         */\n        get: function () {\n            return this._blendMode;\n        },\n        set: function (value) {\n            if (this._blendMode == value)\n                return;\n            this._blendMode = value;\n            this.iInvalidateShaderProgram();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(EffectRimLightMethod.prototype, \"color\", {\n        /**\n         * The color of the rim light.\n         */\n        get: function () {\n            return this._color;\n        },\n        set: function (value /*uint*/) {\n            this._color = value;\n            this._colorR = ((value >> 16) & 0xff) / 0xff;\n            this._colorG = ((value >> 8) & 0xff) / 0xff;\n            this._colorB = (value & 0xff) / 0xff;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(EffectRimLightMethod.prototype, \"strength\", {\n        /**\n         * The strength of the rim light.\n         */\n        get: function () {\n            return this._strength;\n        },\n        set: function (value) {\n            this._strength = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(EffectRimLightMethod.prototype, \"power\", {\n        /**\n         * The power of the rim light. Higher values will result in a higher edge fall-off.\n         */\n        get: function () {\n            return this._power;\n        },\n        set: function (value) {\n            this._power = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * @inheritDoc\n     */\n    EffectRimLightMethod.prototype.iActivate = function (shader, methodVO, stage) {\n        var index = methodVO.fragmentConstantsIndex;\n        var data = shader.fragmentConstantData;\n        data[index] = this._colorR;\n        data[index + 1] = this._colorG;\n        data[index + 2] = this._colorB;\n        data[index + 4] = this._strength;\n        data[index + 5] = this._power;\n    };\n    /**\n     * @inheritDoc\n     */\n    EffectRimLightMethod.prototype.iGetFragmentCode = function (shader, methodVO, targetReg, registerCache, sharedRegisters) {\n        var dataRegister = registerCache.getFreeFragmentConstant();\n        var dataRegister2 = registerCache.getFreeFragmentConstant();\n        var temp = registerCache.getFreeFragmentVectorTemp();\n        var code = \"\";\n        methodVO.fragmentConstantsIndex = dataRegister.index * 4;\n        code += \"dp3 \" + temp + \".x, \" + sharedRegisters.viewDirFragment + \".xyz, \" + sharedRegisters.normalFragment + \".xyz\\n\" +\n            \"sat \" + temp + \".x, \" + temp + \".x\\n\" +\n            \"sub \" + temp + \".x, \" + dataRegister + \".w, \" + temp + \".x\\n\" +\n            \"pow \" + temp + \".x, \" + temp + \".x, \" + dataRegister2 + \".y\\n\" +\n            \"mul \" + temp + \".x, \" + temp + \".x, \" + dataRegister2 + \".x\\n\" +\n            \"sub \" + temp + \".x, \" + dataRegister + \".w, \" + temp + \".x\\n\" +\n            \"mul \" + targetReg + \".xyz, \" + targetReg + \".xyz, \" + temp + \".x\\n\" +\n            \"sub \" + temp + \".w, \" + dataRegister + \".w, \" + temp + \".x\\n\";\n        if (this._blendMode == EffectRimLightMethod.ADD) {\n            code += \"mul \" + temp + \".xyz, \" + temp + \".w, \" + dataRegister + \".xyz\\n\" +\n                \"add \" + targetReg + \".xyz, \" + targetReg + \".xyz, \" + temp + \".xyz\\n\";\n        }\n        else if (this._blendMode == EffectRimLightMethod.MULTIPLY) {\n            code += \"mul \" + temp + \".xyz, \" + temp + \".w, \" + dataRegister + \".xyz\\n\" +\n                \"mul \" + targetReg + \".xyz, \" + targetReg + \".xyz, \" + temp + \".xyz\\n\";\n        }\n        else {\n            code += \"sub \" + temp + \".xyz, \" + dataRegister + \".xyz, \" + targetReg + \".xyz\\n\" +\n                \"mul \" + temp + \".xyz, \" + temp + \".xyz, \" + temp + \".w\\n\" +\n                \"add \" + targetReg + \".xyz, \" + targetReg + \".xyz, \" + temp + \".xyz\\n\";\n        }\n        return code;\n    };\n    EffectRimLightMethod.ADD = \"add\";\n    EffectRimLightMethod.MULTIPLY = \"multiply\";\n    EffectRimLightMethod.MIX = \"mix\";\n    return EffectRimLightMethod;\n}(EffectMethodBase_1.default));\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = EffectRimLightMethod;\n\n},{\"../methods/EffectMethodBase\":\"awayjs-methodmaterials/lib/methods/EffectMethodBase\"}],\"awayjs-methodmaterials/lib/methods/LightingMethodBase\":[function(require,module,exports){\n\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar ShadingMethodBase_1 = require(\"../methods/ShadingMethodBase\");\n/**\n * LightingMethodBase provides an abstract base method for shading methods that uses lights.\n * Used for diffuse and specular shaders only.\n */\nvar LightingMethodBase = (function (_super) {\n    __extends(LightingMethodBase, _super);\n    /**\n     * Creates a new LightingMethodBase.\n     */\n    function LightingMethodBase() {\n        _super.call(this);\n    }\n    /**\n     * Get the fragment shader code that will be needed before any per-light code is added.\n     * @param methodVO The MethodVO object containing the method data for the currently compiled material pass.\n     * @param regCache The register cache used during the compilation.\n     * @private\n     */\n    LightingMethodBase.prototype.iGetFragmentPreLightingCode = function (shader, methodVO, registerCache, sharedRegisters) {\n        return \"\";\n    };\n    /**\n     * Get the fragment shader code that will generate the code relevant to a single light.\n     *\n     * @param methodVO The MethodVO object containing the method data for the currently compiled material pass.\n     * @param lightDirReg The register containing the light direction vector.\n     * @param lightColReg The register containing the light colour.\n     * @param regCache The register cache used during the compilation.\n     */\n    LightingMethodBase.prototype.iGetFragmentCodePerLight = function (shader, methodVO, lightDirReg, lightColReg, registerCache, sharedRegisters) {\n        return \"\";\n    };\n    /**\n     * Get the fragment shader code that will generate the code relevant to a single light probe object.\n     *\n     * @param methodVO The MethodVO object containing the method data for the currently compiled material pass.\n     * @param cubeMapReg The register containing the cube map for the current probe\n     * @param weightRegister A string representation of the register + component containing the current weight\n     * @param regCache The register cache providing any necessary registers to the shader\n     */\n    LightingMethodBase.prototype.iGetFragmentCodePerProbe = function (shader, methodVO, cubeMapReg, weightRegister, registerCache, sharedRegisters) {\n        return \"\";\n    };\n    /**\n     * Get the fragment shader code that should be added after all per-light code. Usually composits everything to the target register.\n     *\n     * @param methodVO The MethodVO object containing the method data for the currently compiled material pass.\n     * @param regCache The register cache used during the compilation.\n     * @param targetReg The register containing the final shading output.\n     * @private\n     */\n    LightingMethodBase.prototype.iGetFragmentPostLightingCode = function (shader, methodVO, targetReg, registerCache, sharedRegisters) {\n        return \"\";\n    };\n    return LightingMethodBase;\n}(ShadingMethodBase_1.default));\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = LightingMethodBase;\n\n},{\"../methods/ShadingMethodBase\":\"awayjs-methodmaterials/lib/methods/ShadingMethodBase\"}],\"awayjs-methodmaterials/lib/methods/NormalBasicMethod\":[function(require,module,exports){\n\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar ShadingMethodBase_1 = require(\"../methods/ShadingMethodBase\");\n/**\n * NormalBasicMethod is the default method for standard tangent-space normal mapping.\n */\nvar NormalBasicMethod = (function (_super) {\n    __extends(NormalBasicMethod, _super);\n    /**\n     * Creates a new NormalBasicMethod object.\n     */\n    function NormalBasicMethod(texture) {\n        if (texture === void 0) { texture = null; }\n        _super.call(this);\n        this._texture = texture;\n        if (this._texture)\n            this.iAddTexture(this._texture);\n    }\n    NormalBasicMethod.prototype.iIsUsed = function (shader) {\n        if (this._texture && shader.normalDependencies)\n            return true;\n        return false;\n    };\n    /**\n     * @inheritDoc\n     */\n    NormalBasicMethod.prototype.iInitVO = function (shader, methodVO) {\n        if (this._texture) {\n            methodVO.textureGL = shader.getAbstraction(this._texture);\n            shader.uvDependencies++;\n        }\n    };\n    /**\n     * Indicates whether or not this method outputs normals in tangent space. Override for object-space normals.\n     */\n    NormalBasicMethod.prototype.iOutputsTangentNormals = function () {\n        return true;\n    };\n    /**\n     * @inheritDoc\n     */\n    NormalBasicMethod.prototype.copyFrom = function (method) {\n        var s = method;\n        var bnm = method;\n        if (bnm.texture != null)\n            this.texture = bnm.texture;\n    };\n    Object.defineProperty(NormalBasicMethod.prototype, \"texture\", {\n        /**\n         * A texture to modulate the direction of the surface for each texel (normal map). The default normal method expects\n         * tangent-space normal maps, but others could expect object-space maps.\n         */\n        get: function () {\n            return this._texture;\n        },\n        set: function (value) {\n            if (this._texture == value)\n                return;\n            if (this._texture)\n                this.iRemoveTexture(this._texture);\n            this._texture = value;\n            if (this._texture)\n                this.iAddTexture(this._texture);\n            this.iInvalidateShaderProgram();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * @inheritDoc\n     */\n    NormalBasicMethod.prototype.dispose = function () {\n        if (this._texture)\n            this._texture = null;\n    };\n    /**\n     * @inheritDoc\n     */\n    NormalBasicMethod.prototype.iActivate = function (shader, methodVO, stage) {\n        if (this._texture)\n            methodVO.textureGL.activate(methodVO.pass._render);\n    };\n    NormalBasicMethod.prototype.iSetRenderState = function (shader, methodVO, renderable, stage, camera) {\n        if (this._texture)\n            methodVO.textureGL._setRenderState(renderable);\n    };\n    /**\n     * @inheritDoc\n     */\n    NormalBasicMethod.prototype.iGetFragmentCode = function (shader, methodVO, targetReg, registerCache, sharedRegisters) {\n        var code = \"\";\n        if (this._texture)\n            code += methodVO.textureGL._iGetFragmentCode(targetReg, registerCache, sharedRegisters, sharedRegisters.uvVarying);\n        code += \"sub \" + targetReg + \".xyz, \" + targetReg + \".xyz, \" + sharedRegisters.commons + \".xxx\\n\" +\n            \"nrm \" + targetReg + \".xyz, \" + targetReg + \"\\n\";\n        return code;\n    };\n    return NormalBasicMethod;\n}(ShadingMethodBase_1.default));\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = NormalBasicMethod;\n\n},{\"../methods/ShadingMethodBase\":\"awayjs-methodmaterials/lib/methods/ShadingMethodBase\"}],\"awayjs-methodmaterials/lib/methods/NormalHeightMapMethod\":[function(require,module,exports){\n\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar NormalBasicMethod_1 = require(\"../methods/NormalBasicMethod\");\n/**\n * NormalHeightMapMethod provides a normal map method that uses a height map to calculate the normals.\n */\nvar NormalHeightMapMethod = (function (_super) {\n    __extends(NormalHeightMapMethod, _super);\n    /**\n     * Creates a new NormalHeightMapMethod method.\n     *\n     * @param heightMap The texture containing the height data. 0 means low, 1 means high.\n     * @param worldWidth The width of the 'world'. This is used to map uv coordinates' u component to scene dimensions.\n     * @param worldHeight The height of the 'world'. This is used to map the height map values to scene dimensions.\n     * @param worldDepth The depth of the 'world'. This is used to map uv coordinates' v component to scene dimensions.\n     */\n    function NormalHeightMapMethod(heightMap, worldWidth, worldHeight, worldDepth) {\n        _super.call(this);\n        this.texture = heightMap;\n        this._worldXYRatio = worldWidth / worldHeight;\n        this._worldXZRatio = worldDepth / worldHeight;\n    }\n    /**\n     * @inheritDoc\n     */\n    NormalHeightMapMethod.prototype.iInitConstants = function (shader, methodVO) {\n        var index = methodVO.fragmentConstantsIndex;\n        var data = shader.fragmentConstantData;\n        data[index] = 1 / this.texture.image2D.width;\n        data[index + 1] = 1 / this.texture.image2D.height;\n        data[index + 2] = 0;\n        data[index + 3] = 1;\n        data[index + 4] = this._worldXYRatio;\n        data[index + 5] = this._worldXZRatio;\n    };\n    Object.defineProperty(NormalHeightMapMethod.prototype, \"tangentSpace\", {\n        /**\n         * @inheritDoc\n         */\n        get: function () {\n            return false;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * @inheritDoc\n     */\n    NormalHeightMapMethod.prototype.copyFrom = function (method) {\n        _super.prototype.copyFrom.call(this, method);\n        this._worldXYRatio = method._worldXYRatio;\n        this._worldXZRatio = method._worldXZRatio;\n    };\n    /**\n     * @inheritDoc\n     */\n    NormalHeightMapMethod.prototype.iGetFragmentCode = function (shader, methodVO, targetReg, registerCache, sharedRegisters) {\n        var code = \"\";\n        var temp = registerCache.getFreeFragmentVectorTemp();\n        registerCache.addFragmentTempUsages(temp, 1);\n        var dataReg = registerCache.getFreeFragmentConstant();\n        var dataReg2 = registerCache.getFreeFragmentConstant();\n        methodVO.fragmentConstantsIndex = dataReg.index * 4;\n        code += methodVO.textureGL._iGetFragmentCode(targetReg, registerCache, sharedRegisters, sharedRegisters.uvVarying) +\n            \"add \" + temp + \", \" + sharedRegisters.uvVarying + \", \" + dataReg + \".xzzz\\n\" +\n            methodVO.textureGL._iGetFragmentCode(temp, registerCache, sharedRegisters, temp) +\n            \"sub \" + targetReg + \".x, \" + targetReg + \".x, \" + temp + \".x\\n\" +\n            \"add \" + temp + \", \" + sharedRegisters.uvVarying + \", \" + dataReg + \".zyzz\\n\" +\n            methodVO.textureGL._iGetFragmentCode(temp, registerCache, sharedRegisters, temp) +\n            \"sub \" + targetReg + \".z, \" + targetReg + \".z, \" + temp + \".x\\n\" +\n            \"mov \" + targetReg + \".y, \" + dataReg + \".w\\n\" +\n            \"mul \" + targetReg + \".xz, \" + targetReg + \".xz, \" + dataReg2 + \".xy\\n\" +\n            \"nrm \" + targetReg + \".xyz, \" + targetReg + \".xyz\\n\";\n        registerCache.removeFragmentTempUsage(temp);\n        return code;\n    };\n    return NormalHeightMapMethod;\n}(NormalBasicMethod_1.default));\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = NormalHeightMapMethod;\n\n},{\"../methods/NormalBasicMethod\":\"awayjs-methodmaterials/lib/methods/NormalBasicMethod\"}],\"awayjs-methodmaterials/lib/methods/NormalSimpleWaterMethod\":[function(require,module,exports){\n\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar NormalBasicMethod_1 = require(\"../methods/NormalBasicMethod\");\n/**\n * NormalSimpleWaterMethod provides a basic normal map method to create water ripples by translating two wave normal maps.\n */\nvar NormalSimpleWaterMethod = (function (_super) {\n    __extends(NormalSimpleWaterMethod, _super);\n    /**\n     * Creates a new NormalSimpleWaterMethod object.\n     * @param waveMap1 A normal map containing one layer of a wave structure.\n     * @param waveMap2 A normal map containing a second layer of a wave structure.\n     */\n    function NormalSimpleWaterMethod(normalMap, secondaryNormalMap) {\n        if (normalMap === void 0) { normalMap = null; }\n        if (secondaryNormalMap === void 0) { secondaryNormalMap = null; }\n        _super.call(this, normalMap);\n        this._water1OffsetX = 0;\n        this._water1OffsetY = 0;\n        this._water2OffsetX = 0;\n        this._water2OffsetY = 0;\n        this._secondaryNormalMap = secondaryNormalMap;\n        if (this._secondaryNormalMap)\n            this.iAddTexture(this._secondaryNormalMap);\n    }\n    /**\n     * @inheritDoc\n     */\n    NormalSimpleWaterMethod.prototype.iInitConstants = function (shader, methodVO) {\n        var index = methodVO.fragmentConstantsIndex;\n        var data = shader.fragmentConstantData;\n        data[index] = .5;\n        data[index + 1] = 0;\n        data[index + 2] = 0;\n        data[index + 3] = 1;\n    };\n    /**\n     * @inheritDoc\n     */\n    NormalSimpleWaterMethod.prototype.iInitVO = function (shader, methodVO) {\n        _super.prototype.iInitVO.call(this, shader, methodVO);\n        if (this._secondaryNormalMap) {\n            methodVO.secondaryTextureGL = shader.getAbstraction(this._secondaryNormalMap);\n            shader.uvDependencies++;\n        }\n    };\n    Object.defineProperty(NormalSimpleWaterMethod.prototype, \"water1OffsetX\", {\n        /**\n         * The translation of the first wave layer along the X-axis.\n         */\n        get: function () {\n            return this._water1OffsetX;\n        },\n        set: function (value) {\n            this._water1OffsetX = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(NormalSimpleWaterMethod.prototype, \"water1OffsetY\", {\n        /**\n         * The translation of the first wave layer along the Y-axis.\n         */\n        get: function () {\n            return this._water1OffsetY;\n        },\n        set: function (value) {\n            this._water1OffsetY = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(NormalSimpleWaterMethod.prototype, \"water2OffsetX\", {\n        /**\n         * The translation of the second wave layer along the X-axis.\n         */\n        get: function () {\n            return this._water2OffsetX;\n        },\n        set: function (value) {\n            this._water2OffsetX = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(NormalSimpleWaterMethod.prototype, \"water2OffsetY\", {\n        /**\n         * The translation of the second wave layer along the Y-axis.\n         */\n        get: function () {\n            return this._water2OffsetY;\n        },\n        set: function (value) {\n            this._water2OffsetY = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(NormalSimpleWaterMethod.prototype, \"secondaryNormalMap\", {\n        /**\n         * A second normal map that will be combined with the first to create a wave-like animation pattern.\n         */\n        get: function () {\n            return this._secondaryNormalMap;\n        },\n        set: function (value) {\n            if (this._secondaryNormalMap == value)\n                return;\n            if (this._secondaryNormalMap)\n                this.iRemoveTexture(this._secondaryNormalMap);\n            this._secondaryNormalMap = value;\n            if (this._secondaryNormalMap)\n                this.iAddTexture(this._secondaryNormalMap);\n            this.iInvalidateShaderProgram();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * @inheritDoc\n     */\n    NormalSimpleWaterMethod.prototype.dispose = function () {\n        _super.prototype.dispose.call(this);\n        this._secondaryNormalMap = null;\n    };\n    /**\n     * @inheritDoc\n     */\n    NormalSimpleWaterMethod.prototype.iActivate = function (shader, methodVO, stage) {\n        _super.prototype.iActivate.call(this, shader, methodVO, stage);\n        var data = shader.fragmentConstantData;\n        var index = methodVO.fragmentConstantsIndex;\n        data[index + 4] = this._water1OffsetX;\n        data[index + 5] = this._water1OffsetY;\n        data[index + 6] = this._water2OffsetX;\n        data[index + 7] = this._water2OffsetY;\n        if (this._secondaryNormalMap)\n            methodVO.secondaryTextureGL.activate(methodVO.pass._render);\n    };\n    /**\n     * @inheritDoc\n     */\n    NormalSimpleWaterMethod.prototype.iSetRenderState = function (shader, methodVO, renderable, stage, camera) {\n        _super.prototype.iSetRenderState.call(this, shader, methodVO, renderable, stage, camera);\n        if (this._secondaryNormalMap)\n            methodVO.secondaryTextureGL._setRenderState(renderable);\n    };\n    /**\n     * @inheritDoc\n     */\n    NormalSimpleWaterMethod.prototype.iGetFragmentCode = function (shader, methodVO, targetReg, registerCache, sharedRegisters) {\n        var code = \"\";\n        var temp = registerCache.getFreeFragmentVectorTemp();\n        registerCache.addFragmentTempUsages(temp, 1);\n        var dataReg = registerCache.getFreeFragmentConstant();\n        var dataReg2 = registerCache.getFreeFragmentConstant();\n        methodVO.fragmentConstantsIndex = dataReg.index * 4;\n        code += \"add \" + temp + \", \" + sharedRegisters.uvVarying + \", \" + dataReg2 + \".xyxy\\n\";\n        if (this.texture)\n            code += methodVO.textureGL._iGetFragmentCode(targetReg, registerCache, sharedRegisters, temp);\n        code += \"add \" + temp + \", \" + sharedRegisters.uvVarying + \", \" + dataReg2 + \".zwzw\\n\";\n        if (this._secondaryNormalMap)\n            code += methodVO.secondaryTextureGL._iGetFragmentCode(temp, registerCache, sharedRegisters, temp);\n        code += \"add \" + targetReg + \", \" + targetReg + \", \" + temp + \"\t\t\\n\" +\n            \"mul \" + targetReg + \", \" + targetReg + \", \" + dataReg + \".x\t\\n\" +\n            \"sub \" + targetReg + \".xyz, \" + targetReg + \".xyz, \" + sharedRegisters.commons + \".xxx\t\\n\" +\n            \"nrm \" + targetReg + \".xyz, \" + targetReg + \".xyz\t\t\t\t\t\t\t\\n\";\n        return code;\n    };\n    return NormalSimpleWaterMethod;\n}(NormalBasicMethod_1.default));\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = NormalSimpleWaterMethod;\n\n},{\"../methods/NormalBasicMethod\":\"awayjs-methodmaterials/lib/methods/NormalBasicMethod\"}],\"awayjs-methodmaterials/lib/methods/ShadingMethodBase\":[function(require,module,exports){\n\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar AssetBase_1 = require(\"awayjs-core/lib/library/AssetBase\");\nvar ShadingMethodEvent_1 = require(\"awayjs-renderergl/lib/events/ShadingMethodEvent\");\n/**\n * ShadingMethodBase provides an abstract base method for shading methods, used by compiled passes to compile\n * the final shading program.\n */\nvar ShadingMethodBase = (function (_super) {\n    __extends(ShadingMethodBase, _super);\n    /**\n     * Create a new ShadingMethodBase object.\n     */\n    function ShadingMethodBase() {\n        _super.call(this);\n        this._textures = new Array();\n        this._owners = new Array();\n        this._counts = new Array();\n    }\n    Object.defineProperty(ShadingMethodBase.prototype, \"assetType\", {\n        /**\n         * @inheritDoc\n         */\n        get: function () {\n            return ShadingMethodBase.assetType;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    ShadingMethodBase.prototype.iIsUsed = function (shader) {\n        return true;\n    };\n    /**\n     * Initializes the properties for a MethodVO, including register and texture indices.\n     *\n     * @param methodVO The MethodVO object linking this method with the pass currently being compiled.\n     *\n     * @internal\n     */\n    ShadingMethodBase.prototype.iInitVO = function (shader, methodVO) {\n    };\n    /**\n     * Initializes unchanging shader constants using the data from a MethodVO.\n     *\n     * @param methodVO The MethodVO object linking this method with the pass currently being compiled.\n     *\n     * @internal\n     */\n    ShadingMethodBase.prototype.iInitConstants = function (shader, methodVO) {\n    };\n    /**\n     * Indicates whether or not this method expects normals in tangent space. Override for object-space normals.\n     */\n    ShadingMethodBase.prototype.iUsesTangentSpace = function () {\n        return true;\n    };\n    /**\n     * Cleans up any resources used by the current object.\n     */\n    ShadingMethodBase.prototype.dispose = function () {\n    };\n    ShadingMethodBase.prototype.iAddOwner = function (owner) {\n        //a method can be used more than once in the same material, so we check for this\n        var index = this._owners.indexOf(owner);\n        if (index != -1) {\n            this._counts[index]++;\n        }\n        else {\n            this._owners.push(owner);\n            this._counts.push(1);\n            //add textures\n            var len = this._textures.length;\n            for (var i = 0; i < len; i++)\n                owner.addTexture(this._textures[i]);\n        }\n    };\n    ShadingMethodBase.prototype.iRemoveOwner = function (owner) {\n        var index = this._owners.indexOf(owner);\n        if (this._counts[index] != 1) {\n            this._counts[index]--;\n        }\n        else {\n            this._owners.splice(index, 1);\n            this._counts.splice(index, 1);\n            //remove textures\n            var len = this._textures.length;\n            for (var i = 0; i < len; i++)\n                owner.removeTexture(this._textures[i]);\n        }\n    };\n    /**\n     *\n     */\n    ShadingMethodBase.prototype.iAddTexture = function (texture) {\n        this._textures.push(texture);\n        var len = this._owners.length;\n        for (var i = 0; i < len; i++)\n            this._owners[i].addTexture(texture);\n    };\n    /**\n     *\n     */\n    ShadingMethodBase.prototype.iRemoveTexture = function (texture) {\n        this._textures.splice(this._textures.indexOf(texture), 1);\n        var len = this._owners.length;\n        for (var i = 0; i < len; i++)\n            this._owners[i].removeTexture(texture);\n    };\n    /**\n     * Resets the compilation state of the method.\n     *\n     * @internal\n     */\n    ShadingMethodBase.prototype.iReset = function () {\n        this.iCleanCompilationData();\n    };\n    /**\n     * Resets the method's state for compilation.\n     *\n     * @internal\n     */\n    ShadingMethodBase.prototype.iCleanCompilationData = function () {\n    };\n    /**\n     * Get the vertex shader code for this method.\n     * @param vo The MethodVO object linking this method with the pass currently being compiled.\n     * @param regCache The register cache used during the compilation.\n     *\n     * @internal\n     */\n    ShadingMethodBase.prototype.iGetVertexCode = function (shader, methodVO, registerCache, sharedRegisters) {\n        return \"\";\n    };\n    /**\n     * @inheritDoc\n     */\n    ShadingMethodBase.prototype.iGetFragmentCode = function (shader, methodVO, targetReg, registerCache, sharedRegisters) {\n        return null;\n    };\n    /**\n     * Sets the render state for this method.\n     *\n     * @param methodVO The MethodVO object linking this method with the pass currently being compiled.\n     * @param stage The Stage object currently used for rendering.\n     *\n     * @internal\n     */\n    ShadingMethodBase.prototype.iActivate = function (shader, methodVO, stage) {\n    };\n    /**\n     * Sets the render state for a single renderable.\n     *\n     * @param vo The MethodVO object linking this method with the pass currently being compiled.\n     * @param renderable The renderable currently being rendered.\n     * @param stage The Stage object currently used for rendering.\n     * @param camera The camera from which the scene is currently rendered.\n     *\n     * @internal\n     */\n    ShadingMethodBase.prototype.iSetRenderState = function (shader, methodVO, renderable, stage, camera) {\n    };\n    /**\n     * Clears the render state for this method.\n     * @param vo The MethodVO object linking this method with the pass currently being compiled.\n     * @param stage The Stage object currently used for rendering.\n     *\n     * @internal\n     */\n    ShadingMethodBase.prototype.iDeactivate = function (shader, methodVO, stage) {\n    };\n    /**\n     * Marks the shader program as invalid, so it will be recompiled before the next render.\n     *\n     * @internal\n     */\n    ShadingMethodBase.prototype.iInvalidateShaderProgram = function () {\n        this.dispatchEvent(new ShadingMethodEvent_1.default(ShadingMethodEvent_1.default.SHADER_INVALIDATED));\n    };\n    /**\n     * Copies the state from a ShadingMethodBase object into the current object.\n     */\n    ShadingMethodBase.prototype.copyFrom = function (method) {\n    };\n    ShadingMethodBase.assetType = \"[asset ShadingMethod]\";\n    return ShadingMethodBase;\n}(AssetBase_1.default));\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = ShadingMethodBase;\n\n},{\"awayjs-core/lib/library/AssetBase\":undefined,\"awayjs-renderergl/lib/events/ShadingMethodEvent\":undefined}],\"awayjs-methodmaterials/lib/methods/ShadowCascadeMethod\":[function(require,module,exports){\n\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar AssetEvent_1 = require(\"awayjs-core/lib/events/AssetEvent\");\nvar DirectionalLight_1 = require(\"awayjs-display/lib/display/DirectionalLight\");\nvar ShadingMethodEvent_1 = require(\"awayjs-renderergl/lib/events/ShadingMethodEvent\");\nvar MethodVO_1 = require(\"../data/MethodVO\");\nvar ShadowMapMethodBase_1 = require(\"../methods/ShadowMapMethodBase\");\n/**\n * ShadowCascadeMethod is a shadow map method to apply cascade shadow mapping on materials.\n * Must be used with a DirectionalLight with a CascadeShadowMapper assigned to its shadowMapper property.\n *\n * @see away.lights.CascadeShadowMapper\n */\nvar ShadowCascadeMethod = (function (_super) {\n    __extends(ShadowCascadeMethod, _super);\n    /**\n     * Creates a new ShadowCascadeMethod object.\n     *\n     * @param shadowMethodBase The shadow map sampling method used to sample individual cascades (fe: ShadowHardMethod, ShadowSoftMethod)\n     */\n    function ShadowCascadeMethod(shadowMethodBase) {\n        var _this = this;\n        _super.call(this, shadowMethodBase.castingLight);\n        this._baseMethod = shadowMethodBase;\n        if (!(this._pCastingLight instanceof DirectionalLight_1.default))\n            throw new Error(\"ShadowCascadeMethod is only compatible with DirectionalLight\");\n        this._cascadeShadowMapper = this._pCastingLight.shadowMapper;\n        if (!this._cascadeShadowMapper)\n            throw new Error(\"ShadowCascadeMethod requires a light that has a CascadeShadowMapper instance assigned to shadowMapper.\");\n        this._cascadeShadowMapper.addEventListener(AssetEvent_1.default.INVALIDATE, function (event) { return _this.onCascadeChange(event); });\n        this._baseMethod.addEventListener(ShadingMethodEvent_1.default.SHADER_INVALIDATED, function (event) { return _this.onShaderInvalidated(event); });\n    }\n    Object.defineProperty(ShadowCascadeMethod.prototype, \"baseMethod\", {\n        /**\n         * The shadow map sampling method used to sample individual cascades. These are typically those used in conjunction\n         * with a DirectionalShadowMapper.\n         *\n         * @see ShadowHardMethod\n         * @see ShadowSoftMethod\n         */\n        get: function () {\n            return this._baseMethod;\n        },\n        set: function (value) {\n            var _this = this;\n            if (this._baseMethod == value)\n                return;\n            this._baseMethod.removeEventListener(ShadingMethodEvent_1.default.SHADER_INVALIDATED, function (event) { return _this.onShaderInvalidated(event); });\n            this._baseMethod = value;\n            this._baseMethod.addEventListener(ShadingMethodEvent_1.default.SHADER_INVALIDATED, function (event) { return _this.onShaderInvalidated(event); });\n            this.iInvalidateShaderProgram();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * @inheritDoc\n     */\n    ShadowCascadeMethod.prototype.iInitVO = function (shader, methodVO) {\n        var tempVO = new MethodVO_1.default(this._baseMethod, methodVO.pass);\n        this._baseMethod.iInitVO(shader, tempVO);\n        methodVO.needsGlobalVertexPos = true;\n        methodVO.needsProjection = true;\n        methodVO.textureGL = shader.getAbstraction(this._pCastingLight.shadowMapper.depthMap);\n    };\n    /**\n     * @inheritDoc\n     */\n    ShadowCascadeMethod.prototype.iInitConstants = function (shader, methodVO) {\n        var fragmentData = shader.fragmentConstantData;\n        var vertexData = shader.vertexConstantData;\n        var index = methodVO.fragmentConstantsIndex;\n        fragmentData[index] = 1.0;\n        fragmentData[index + 1] = 1 / 255.0;\n        fragmentData[index + 2] = 1 / 65025.0;\n        fragmentData[index + 3] = 1 / 16581375.0;\n        fragmentData[index + 6] = .5;\n        fragmentData[index + 7] = -.5;\n        index = methodVO.vertexConstantsIndex;\n        vertexData[index] = .5;\n        vertexData[index + 1] = -.5;\n        vertexData[index + 2] = 0;\n    };\n    /**\n     * @inheritDoc\n     */\n    ShadowCascadeMethod.prototype.iCleanCompilationData = function () {\n        _super.prototype.iCleanCompilationData.call(this);\n        this._cascadeProjections = null;\n        this._depthMapCoordVaryings = null;\n    };\n    /**\n     * @inheritDoc\n     */\n    ShadowCascadeMethod.prototype.iGetVertexCode = function (shader, methodVO, registerCache, sharedRegisters) {\n        var code = \"\";\n        var dataReg = registerCache.getFreeVertexConstant();\n        this.initProjectionsRegs(registerCache);\n        methodVO.vertexConstantsIndex = dataReg.index * 4;\n        var temp = registerCache.getFreeVertexVectorTemp();\n        for (var i = 0; i < this._cascadeShadowMapper.numCascades; ++i) {\n            code += \"m44 \" + temp + \", \" + sharedRegisters.globalPositionVertex + \", \" + this._cascadeProjections[i] + \"\\n\" +\n                \"add \" + this._depthMapCoordVaryings[i] + \", \" + temp + \", \" + dataReg + \".zzwz\\n\";\n        }\n        return code;\n    };\n    /**\n     * Creates the registers for the cascades' projection coordinates.\n     */\n    ShadowCascadeMethod.prototype.initProjectionsRegs = function (registerCache) {\n        this._cascadeProjections = new Array(this._cascadeShadowMapper.numCascades);\n        this._depthMapCoordVaryings = new Array(this._cascadeShadowMapper.numCascades);\n        for (var i = 0; i < this._cascadeShadowMapper.numCascades; ++i) {\n            this._depthMapCoordVaryings[i] = registerCache.getFreeVarying();\n            this._cascadeProjections[i] = registerCache.getFreeVertexConstant();\n            registerCache.getFreeVertexConstant();\n            registerCache.getFreeVertexConstant();\n            registerCache.getFreeVertexConstant();\n        }\n    };\n    /**\n     * @inheritDoc\n     */\n    ShadowCascadeMethod.prototype.iGetFragmentCode = function (shader, methodVO, targetReg, registerCache, sharedRegisters) {\n        var numCascades = this._cascadeShadowMapper.numCascades;\n        var decReg = registerCache.getFreeFragmentConstant();\n        var dataReg = registerCache.getFreeFragmentConstant();\n        var planeDistanceReg = registerCache.getFreeFragmentConstant();\n        var planeDistances = Array(planeDistanceReg + \".x\", planeDistanceReg + \".y\", planeDistanceReg + \".z\", planeDistanceReg + \".w\");\n        var code;\n        methodVO.fragmentConstantsIndex = decReg.index * 4;\n        var inQuad = registerCache.getFreeFragmentVectorTemp();\n        registerCache.addFragmentTempUsages(inQuad, 1);\n        var uvCoord = registerCache.getFreeFragmentVectorTemp();\n        registerCache.addFragmentTempUsages(uvCoord, 1);\n        // assume lowest partition is selected, will be overwritten later otherwise\n        code = \"mov \" + uvCoord + \", \" + this._depthMapCoordVaryings[numCascades - 1] + \"\\n\";\n        for (var i = numCascades - 2; i >= 0; --i) {\n            var uvProjection = this._depthMapCoordVaryings[i];\n            // calculate if in texturemap (result == 0 or 1, only 1 for a single partition)\n            code += \"slt \" + inQuad + \".z, \" + sharedRegisters.projectionFragment + \".z, \" + planeDistances[i] + \"\\n\"; // z = x > minX, w = y > minY\n            var temp = registerCache.getFreeFragmentVectorTemp();\n            // linearly interpolate between old and new uv coords using predicate value == conditional toggle to new value if predicate == 1 (true)\n            code += \"sub \" + temp + \", \" + uvProjection + \", \" + uvCoord + \"\\n\" +\n                \"mul \" + temp + \", \" + temp + \", \" + inQuad + \".z\\n\" +\n                \"add \" + uvCoord + \", \" + uvCoord + \", \" + temp + \"\\n\";\n        }\n        registerCache.removeFragmentTempUsage(inQuad);\n        code += \"div \" + uvCoord + \", \" + uvCoord + \", \" + uvCoord + \".w\\n\" +\n            \"mul \" + uvCoord + \".xy, \" + uvCoord + \".xy, \" + dataReg + \".zw\\n\" +\n            \"add \" + uvCoord + \".xy, \" + uvCoord + \".xy, \" + dataReg + \".zz\\n\";\n        code += this._baseMethod._iGetCascadeFragmentCode(shader, methodVO, decReg, uvCoord, targetReg, registerCache, sharedRegisters) +\n            \"add \" + targetReg + \".w, \" + targetReg + \".w, \" + dataReg + \".y\\n\";\n        registerCache.removeFragmentTempUsage(uvCoord);\n        return code;\n    };\n    /**\n     * @inheritDoc\n     */\n    ShadowCascadeMethod.prototype.iActivate = function (shader, methodVO, stage) {\n        methodVO.textureGL.activate(methodVO.pass._render);\n        var vertexData = shader.vertexConstantData;\n        var vertexIndex = methodVO.vertexConstantsIndex;\n        shader.vertexConstantData[methodVO.vertexConstantsIndex + 3] = -1 / (this._cascadeShadowMapper.depth * this._pEpsilon);\n        var numCascades = this._cascadeShadowMapper.numCascades;\n        vertexIndex += 4;\n        for (var k = 0; k < numCascades; ++k) {\n            this._cascadeShadowMapper.getDepthProjections(k).copyRawDataTo(vertexData, vertexIndex, true);\n            vertexIndex += 16;\n        }\n        var fragmentData = shader.fragmentConstantData;\n        var fragmentIndex = methodVO.fragmentConstantsIndex;\n        fragmentData[fragmentIndex + 5] = 1 - this._pAlpha;\n        var nearPlaneDistances = this._cascadeShadowMapper._iNearPlaneDistances;\n        fragmentIndex += 8;\n        for (var i = 0; i < numCascades; ++i)\n            fragmentData[fragmentIndex + i] = nearPlaneDistances[i];\n        this._baseMethod.iActivateForCascade(shader, methodVO, stage);\n    };\n    /**\n     * @inheritDoc\n     */\n    ShadowCascadeMethod.prototype.iSetRenderState = function (shader, methodVO, renderable, stage, camera) {\n    };\n    /**\n     * Called when the shadow mappers cascade configuration changes.\n     */\n    ShadowCascadeMethod.prototype.onCascadeChange = function (event) {\n        this.iInvalidateShaderProgram();\n    };\n    /**\n     * Called when the base method's shader code is invalidated.\n     */\n    ShadowCascadeMethod.prototype.onShaderInvalidated = function (event) {\n        this.iInvalidateShaderProgram();\n    };\n    return ShadowCascadeMethod;\n}(ShadowMapMethodBase_1.default));\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = ShadowCascadeMethod;\n\n},{\"../data/MethodVO\":\"awayjs-methodmaterials/lib/data/MethodVO\",\"../methods/ShadowMapMethodBase\":\"awayjs-methodmaterials/lib/methods/ShadowMapMethodBase\",\"awayjs-core/lib/events/AssetEvent\":undefined,\"awayjs-display/lib/display/DirectionalLight\":undefined,\"awayjs-renderergl/lib/events/ShadingMethodEvent\":undefined}],\"awayjs-methodmaterials/lib/methods/ShadowDitheredMethod\":[function(require,module,exports){\n\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar BitmapImage2D_1 = require(\"awayjs-core/lib/image/BitmapImage2D\");\nvar Single2DTexture_1 = require(\"awayjs-display/lib/textures/Single2DTexture\");\nvar ShadowMethodBase_1 = require(\"../methods/ShadowMethodBase\");\n/**\n * ShadowDitheredMethod provides a soft shadowing technique by randomly distributing sample points differently for each fragment.\n */\nvar ShadowDitheredMethod = (function (_super) {\n    __extends(ShadowDitheredMethod, _super);\n    /**\n     * Creates a new ShadowDitheredMethod object.\n     * @param castingLight The light casting the shadows\n     * @param numSamples The amount of samples to take for dithering. Minimum 1, maximum 24.\n     */\n    function ShadowDitheredMethod(castingLight, numSamples, range) {\n        if (numSamples === void 0) { numSamples = 4; }\n        if (range === void 0) { range = 1; }\n        _super.call(this, castingLight);\n        this._depthMapSize = this._pCastingLight.shadowMapper.depthMapSize;\n        this.numSamples = numSamples;\n        this.range = range;\n        ++ShadowDitheredMethod._grainUsages;\n        if (!ShadowDitheredMethod._grainTexture)\n            this.initGrainTexture();\n    }\n    Object.defineProperty(ShadowDitheredMethod.prototype, \"numSamples\", {\n        /**\n         * The amount of samples to take for dithering. Minimum 1, maximum 24. The actual maximum may depend on the\n         * complexity of the shader.\n         */\n        get: function () {\n            return this._numSamples;\n        },\n        set: function (value /*int*/) {\n            if (value < 1)\n                value = 1;\n            else if (value > 24)\n                value = 24;\n            if (this._numSamples == value)\n                return;\n            this._numSamples = value;\n            this.iInvalidateShaderProgram();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * @inheritDoc\n     */\n    ShadowDitheredMethod.prototype.iInitVO = function (shader, methodVO) {\n        _super.prototype.iInitVO.call(this, shader, methodVO);\n        methodVO.needsProjection = true;\n        methodVO.secondaryTextureGL = shader.getAbstraction(ShadowDitheredMethod._grainTexture);\n    };\n    /**\n     * @inheritDoc\n     */\n    ShadowDitheredMethod.prototype.iInitConstants = function (shader, methodVO) {\n        _super.prototype.iInitConstants.call(this, shader, methodVO);\n        var fragmentData = shader.fragmentConstantData;\n        var index = methodVO.fragmentConstantsIndex;\n        fragmentData[index + 8] = 1 / this._numSamples;\n    };\n    Object.defineProperty(ShadowDitheredMethod.prototype, \"range\", {\n        /**\n         * The range in the shadow map in which to distribute the samples.\n         */\n        get: function () {\n            return this._range * 2;\n        },\n        set: function (value) {\n            this._range = value / 2;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Creates a texture containing the dithering noise texture.\n     */\n    ShadowDitheredMethod.prototype.initGrainTexture = function () {\n        ShadowDitheredMethod._grainBitmapImage2D = new BitmapImage2D_1.default(64, 64, false);\n        var vec = new Array();\n        var len = 4096;\n        var step = 1 / (this._depthMapSize * this._range);\n        var r, g;\n        for (var i = 0; i < len; ++i) {\n            r = 2 * (Math.random() - .5);\n            g = 2 * (Math.random() - .5);\n            if (r < 0)\n                r -= step;\n            else\n                r += step;\n            if (g < 0)\n                g -= step;\n            else\n                g += step;\n            if (r > 1)\n                r = 1;\n            else if (r < -1)\n                r = -1;\n            if (g > 1)\n                g = 1;\n            else if (g < -1)\n                g = -1;\n            vec[i] = (Math.floor((r * .5 + .5) * 0xff) << 16) | (Math.floor((g * .5 + .5) * 0xff) << 8);\n        }\n        ShadowDitheredMethod._grainBitmapImage2D.setArray(ShadowDitheredMethod._grainBitmapImage2D.rect, vec);\n        ShadowDitheredMethod._grainTexture = new Single2DTexture_1.default(ShadowDitheredMethod._grainBitmapImage2D);\n    };\n    /**\n     * @inheritDoc\n     */\n    ShadowDitheredMethod.prototype.dispose = function () {\n        if (--ShadowDitheredMethod._grainUsages == 0) {\n            ShadowDitheredMethod._grainTexture.dispose();\n            ShadowDitheredMethod._grainBitmapImage2D.dispose();\n            ShadowDitheredMethod._grainTexture = null;\n        }\n    };\n    /**\n     * @inheritDoc\n     */\n    ShadowDitheredMethod.prototype.iActivate = function (shader, methodVO, stage) {\n        _super.prototype.iActivate.call(this, shader, methodVO, stage);\n        var data = shader.fragmentConstantData;\n        var index = methodVO.fragmentConstantsIndex;\n        data[index + 9] = (stage.width - 1) / 63;\n        data[index + 10] = (stage.height - 1) / 63;\n        data[index + 11] = 2 * this._range / this._depthMapSize;\n        methodVO.secondaryTextureGL.activate(methodVO.pass._render);\n    };\n    /**\n     * @inheritDoc\n     */\n    ShadowDitheredMethod.prototype.iSetRenderState = function (shader, methodVO, renderable, stage, camera) {\n        _super.prototype.iSetRenderState.call(this, shader, methodVO, renderable, stage, camera);\n        methodVO.secondaryTextureGL._setRenderState(renderable);\n    };\n    /**\n     * @inheritDoc\n     */\n    ShadowDitheredMethod.prototype._pGetPlanarFragmentCode = function (shader, methodVO, targetReg, regCache, sharedRegisters) {\n        var decReg = regCache.getFreeFragmentConstant();\n        var dataReg = regCache.getFreeFragmentConstant();\n        var customDataReg = regCache.getFreeFragmentConstant();\n        methodVO.fragmentConstantsIndex = decReg.index * 4;\n        return this.getSampleCode(shader, methodVO, customDataReg, decReg, targetReg, regCache, sharedRegisters);\n    };\n    /**\n     * Get the actual shader code for shadow mapping\n     * @param regCache The register cache managing the registers.\n     * @param depthMapRegister The texture register containing the depth map.\n     * @param decReg The register containing the depth map decoding data.\n     * @param targetReg The target register to add the shadow coverage.\n     */\n    ShadowDitheredMethod.prototype.getSampleCode = function (shader, methodVO, customDataReg, decReg, targetReg, regCache, sharedRegisters) {\n        var code = \"\";\n        var numSamples = this._numSamples;\n        var uvReg = regCache.getFreeFragmentVectorTemp();\n        regCache.addFragmentTempUsages(uvReg, 1);\n        var temp = regCache.getFreeFragmentVectorTemp();\n        regCache.addFragmentTempUsages(temp, 1);\n        var projectionReg = sharedRegisters.projectionFragment;\n        code += \"div \" + uvReg + \", \" + projectionReg + \", \" + projectionReg + \".w\\n\" +\n            \"mul \" + uvReg + \".xy, \" + uvReg + \".xy, \" + customDataReg + \".yz\\n\";\n        while (numSamples > 0) {\n            if (numSamples == this._numSamples) {\n                code += methodVO.secondaryTextureGL._iGetFragmentCode(uvReg, regCache, sharedRegisters, uvReg);\n            }\n            else {\n                code += \"mov \" + temp + \", \" + uvReg + \".zwxy \\n\" +\n                    methodVO.secondaryTextureGL._iGetFragmentCode(uvReg, regCache, sharedRegisters, temp);\n            }\n            // keep grain in uvReg.zw\n            code += \"sub \" + uvReg + \".zw, \" + uvReg + \".xy, fc0.xx\\n\" +\n                \"mul \" + uvReg + \".zw, \" + uvReg + \".zw, \" + customDataReg + \".w\\n\"; // (tex unpack scale and tex scale in one)\n            if (numSamples == this._numSamples) {\n                // first sample\n                code += \"add \" + uvReg + \".xy, \" + uvReg + \".zw, \" + this._pDepthMapCoordReg + \".xy\\n\" +\n                    methodVO.textureGL._iGetFragmentCode(temp, regCache, sharedRegisters, uvReg) +\n                    \"dp4 \" + temp + \".z, \" + temp + \", \" + decReg + \"\\n\" +\n                    \"slt \" + targetReg + \".w, \" + this._pDepthMapCoordReg + \".z, \" + temp + \".z\\n\"; // 0 if in shadow\n            }\n            else {\n                code += this.addSample(shader, methodVO, uvReg, decReg, targetReg, regCache, sharedRegisters);\n            }\n            if (numSamples > 4)\n                code += \"add \" + uvReg + \".xy, \" + uvReg + \".xy, \" + uvReg + \".zw\\n\" + this.addSample(shader, methodVO, uvReg, decReg, targetReg, regCache, sharedRegisters);\n            if (numSamples > 1)\n                code += \"sub \" + uvReg + \".xy, \" + this._pDepthMapCoordReg + \".xy, \" + uvReg + \".zw\\n\" + this.addSample(shader, methodVO, uvReg, decReg, targetReg, regCache, sharedRegisters);\n            if (numSamples > 5)\n                code += \"sub \" + uvReg + \".xy, \" + uvReg + \".xy, \" + uvReg + \".zw\\n\" + this.addSample(shader, methodVO, uvReg, decReg, targetReg, regCache, sharedRegisters);\n            if (numSamples > 2) {\n                code += \"neg \" + uvReg + \".w, \" + uvReg + \".w\\n\"; // will be rotated 90 degrees when being accessed as wz\n                code += \"add \" + uvReg + \".xy, \" + uvReg + \".wz, \" + this._pDepthMapCoordReg + \".xy\\n\" + this.addSample(shader, methodVO, uvReg, decReg, targetReg, regCache, sharedRegisters);\n            }\n            if (numSamples > 6)\n                code += \"add \" + uvReg + \".xy, \" + uvReg + \".xy, \" + uvReg + \".wz\\n\" + this.addSample(shader, methodVO, uvReg, decReg, targetReg, regCache, sharedRegisters);\n            if (numSamples > 3)\n                code += \"sub \" + uvReg + \".xy, \" + this._pDepthMapCoordReg + \".xy, \" + uvReg + \".wz\\n\" + this.addSample(shader, methodVO, uvReg, decReg, targetReg, regCache, sharedRegisters);\n            if (numSamples > 7)\n                code += \"sub \" + uvReg + \".xy, \" + uvReg + \".xy, \" + uvReg + \".wz\\n\" + this.addSample(shader, methodVO, uvReg, decReg, targetReg, regCache, sharedRegisters);\n            numSamples -= 8;\n        }\n        regCache.removeFragmentTempUsage(temp);\n        regCache.removeFragmentTempUsage(uvReg);\n        code += \"mul \" + targetReg + \".w, \" + targetReg + \".w, \" + customDataReg + \".x\\n\"; // average\n        return code;\n    };\n    /**\n     * Adds the code for another tap to the shader code.\n     * @param uvReg The uv register for the tap.\n     * @param depthMapRegister The texture register containing the depth map.\n     * @param decReg The register containing the depth map decoding data.\n     * @param targetReg The target register to add the tap comparison result.\n     * @param regCache The register cache managing the registers.\n     * @return\n     */\n    ShadowDitheredMethod.prototype.addSample = function (shader, methodVO, uvReg, decReg, targetReg, regCache, sharedRegisters) {\n        var temp = regCache.getFreeFragmentVectorTemp();\n        return methodVO.textureGL._iGetFragmentCode(temp, regCache, sharedRegisters, uvReg) +\n            \"dp4 \" + temp + \".z, \" + temp + \", \" + decReg + \"\\n\" +\n            \"slt \" + temp + \".z, \" + this._pDepthMapCoordReg + \".z, \" + temp + \".z\\n\" +\n            \"add \" + targetReg + \".w, \" + targetReg + \".w, \" + temp + \".z\\n\";\n    };\n    /**\n     * @inheritDoc\n     */\n    ShadowDitheredMethod.prototype.iActivateForCascade = function (shader, methodVO, stage) {\n        var data = shader.fragmentConstantData;\n        var index = methodVO.secondaryFragmentConstantsIndex;\n        data[index] = 1 / this._numSamples;\n        data[index + 1] = (stage.width - 1) / 63;\n        data[index + 2] = (stage.height - 1) / 63;\n        data[index + 3] = 2 * this._range / this._depthMapSize;\n        methodVO.secondaryTextureGL.activate(methodVO.pass._render);\n    };\n    /**\n     * @inheritDoc\n     */\n    ShadowDitheredMethod.prototype._iGetCascadeFragmentCode = function (shader, methodVO, decodeRegister, depthProjection, targetRegister, registerCache, sharedRegisters) {\n        this._pDepthMapCoordReg = depthProjection;\n        var dataReg = registerCache.getFreeFragmentConstant();\n        methodVO.secondaryFragmentConstantsIndex = dataReg.index * 4;\n        return this.getSampleCode(shader, methodVO, dataReg, decodeRegister, targetRegister, registerCache, sharedRegisters);\n    };\n    return ShadowDitheredMethod;\n}(ShadowMethodBase_1.default));\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = ShadowDitheredMethod;\n\n},{\"../methods/ShadowMethodBase\":\"awayjs-methodmaterials/lib/methods/ShadowMethodBase\",\"awayjs-core/lib/image/BitmapImage2D\":undefined,\"awayjs-display/lib/textures/Single2DTexture\":undefined}],\"awayjs-methodmaterials/lib/methods/ShadowFilteredMethod\":[function(require,module,exports){\n\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar ShadowMethodBase_1 = require(\"../methods/ShadowMethodBase\");\n/**\n * ShadowFilteredMethod provides a softened shadowing technique by bilinearly interpolating shadow comparison\n * results of neighbouring pixels.\n */\nvar ShadowFilteredMethod = (function (_super) {\n    __extends(ShadowFilteredMethod, _super);\n    /**\n     * Creates a new DiffuseBasicMethod object.\n     *\n     * @param castingLight The light casting the shadow\n     */\n    function ShadowFilteredMethod(castingLight) {\n        _super.call(this, castingLight);\n    }\n    /**\n     * @inheritDoc\n     */\n    ShadowFilteredMethod.prototype.iInitConstants = function (shader, methodVO) {\n        _super.prototype.iInitConstants.call(this, shader, methodVO);\n        var fragmentData = shader.fragmentConstantData;\n        var index = methodVO.fragmentConstantsIndex;\n        fragmentData[index + 8] = .5;\n        var size = this.castingLight.shadowMapper.depthMapSize;\n        fragmentData[index + 9] = size;\n        fragmentData[index + 10] = 1 / size;\n    };\n    /**\n     * @inheritDoc\n     */\n    ShadowFilteredMethod.prototype._pGetPlanarFragmentCode = function (shader, methodVO, targetReg, regCache, sharedRegisters) {\n        var code = \"\";\n        var decReg = regCache.getFreeFragmentConstant();\n        regCache.getFreeFragmentConstant();\n        var customDataReg = regCache.getFreeFragmentConstant();\n        methodVO.fragmentConstantsIndex = decReg.index * 4;\n        var depthCol = regCache.getFreeFragmentVectorTemp();\n        regCache.addFragmentTempUsages(depthCol, 1);\n        var uvReg = regCache.getFreeFragmentVectorTemp();\n        regCache.addFragmentTempUsages(uvReg, 1);\n        code += \"mov \" + uvReg + \", \" + this._pDepthMapCoordReg + \"\\n\" +\n            methodVO.textureGL._iGetFragmentCode(depthCol, regCache, sharedRegisters, this._pDepthMapCoordReg) +\n            \"dp4 \" + depthCol + \".z, \" + depthCol + \", \" + decReg + \"\\n\" +\n            \"slt \" + uvReg + \".z, \" + this._pDepthMapCoordReg + \".z, \" + depthCol + \".z\\n\" +\n            \"add \" + uvReg + \".x, \" + this._pDepthMapCoordReg + \".x, \" + customDataReg + \".z\\n\" +\n            methodVO.textureGL._iGetFragmentCode(depthCol, regCache, sharedRegisters, uvReg) +\n            \"dp4 \" + depthCol + \".z, \" + depthCol + \", \" + decReg + \"\\n\" +\n            \"slt \" + uvReg + \".w, \" + this._pDepthMapCoordReg + \".z, \" + depthCol + \".z\\n\" +\n            \"mul \" + depthCol + \".x, \" + this._pDepthMapCoordReg + \".x, \" + customDataReg + \".y\\n\" +\n            \"frc \" + depthCol + \".x, \" + depthCol + \".x\\n\" +\n            \"sub \" + uvReg + \".w, \" + uvReg + \".w, \" + uvReg + \".z\\n\" +\n            \"mul \" + uvReg + \".w, \" + uvReg + \".w, \" + depthCol + \".x\\n\" +\n            \"add \" + targetReg + \".w, \" + uvReg + \".z, \" + uvReg + \".w\\n\" +\n            \"mov \" + uvReg + \".x, \" + this._pDepthMapCoordReg + \".x\\n\" +\n            \"add \" + uvReg + \".y, \" + this._pDepthMapCoordReg + \".y, \" + customDataReg + \".z\\n\" +\n            methodVO.textureGL._iGetFragmentCode(depthCol, regCache, sharedRegisters, uvReg) +\n            \"dp4 \" + depthCol + \".z, \" + depthCol + \", \" + decReg + \"\\n\" +\n            \"slt \" + uvReg + \".z, \" + this._pDepthMapCoordReg + \".z, \" + depthCol + \".z\\n\" +\n            \"add \" + uvReg + \".x, \" + this._pDepthMapCoordReg + \".x, \" + customDataReg + \".z\\n\" +\n            methodVO.textureGL._iGetFragmentCode(depthCol, regCache, sharedRegisters, uvReg) +\n            \"dp4 \" + depthCol + \".z, \" + depthCol + \", \" + decReg + \"\\n\" +\n            \"slt \" + uvReg + \".w, \" + this._pDepthMapCoordReg + \".z, \" + depthCol + \".z\\n\" +\n            // recalculate fraction, since we ran out of registers :(\n            \"mul \" + depthCol + \".x, \" + this._pDepthMapCoordReg + \".x, \" + customDataReg + \".y\\n\" +\n            \"frc \" + depthCol + \".x, \" + depthCol + \".x\\n\" + \"sub \" + uvReg + \".w, \" + uvReg + \".w, \" + uvReg + \".z\\n\" +\n            \"mul \" + uvReg + \".w, \" + uvReg + \".w, \" + depthCol + \".x\\n\" +\n            \"add \" + uvReg + \".w, \" + uvReg + \".z, \" + uvReg + \".w\\n\" +\n            \"mul \" + depthCol + \".x, \" + this._pDepthMapCoordReg + \".y, \" + customDataReg + \".y\\n\" +\n            \"frc \" + depthCol + \".x, \" + depthCol + \".x\\n\" +\n            \"sub \" + uvReg + \".w, \" + uvReg + \".w, \" + targetReg + \".w\\n\" +\n            \"mul \" + uvReg + \".w, \" + uvReg + \".w, \" + depthCol + \".x\\n\" +\n            \"add \" + targetReg + \".w, \" + targetReg + \".w, \" + uvReg + \".w\\n\";\n        regCache.removeFragmentTempUsage(depthCol);\n        regCache.removeFragmentTempUsage(uvReg);\n        return code;\n    };\n    /**\n     * @inheritDoc\n     */\n    ShadowFilteredMethod.prototype.iActivateForCascade = function (shader, methodVO, stage) {\n        var size = this.castingLight.shadowMapper.depthMapSize;\n        var index = methodVO.secondaryFragmentConstantsIndex;\n        var data = shader.fragmentConstantData;\n        data[index] = size;\n        data[index + 1] = 1 / size;\n    };\n    /**\n     * @inheritDoc\n     */\n    ShadowFilteredMethod.prototype._iGetCascadeFragmentCode = function (shader, methodVO, decodeRegister, depthProjection, targetRegister, registerCache, sharedRegisters) {\n        var code;\n        var dataReg = registerCache.getFreeFragmentConstant();\n        methodVO.secondaryFragmentConstantsIndex = dataReg.index * 4;\n        var temp = registerCache.getFreeFragmentVectorTemp();\n        registerCache.addFragmentTempUsages(temp, 1);\n        var predicate = registerCache.getFreeFragmentVectorTemp();\n        registerCache.addFragmentTempUsages(predicate, 1);\n        code = methodVO.textureGL._iGetFragmentCode(temp, registerCache, sharedRegisters, depthProjection) +\n            \"dp4 \" + temp + \".z, \" + temp + \", \" + decodeRegister + \"\\n\" +\n            \"slt \" + predicate + \".x, \" + depthProjection + \".z, \" + temp + \".z\\n\" +\n            \"add \" + depthProjection + \".x, \" + depthProjection + \".x, \" + dataReg + \".y\\n\" +\n            methodVO.textureGL._iGetFragmentCode(temp, registerCache, sharedRegisters, depthProjection) +\n            \"dp4 \" + temp + \".z, \" + temp + \", \" + decodeRegister + \"\\n\" +\n            \"slt \" + predicate + \".z, \" + depthProjection + \".z, \" + temp + \".z\\n\" +\n            \"add \" + depthProjection + \".y, \" + depthProjection + \".y, \" + dataReg + \".y\\n\" +\n            methodVO.textureGL._iGetFragmentCode(temp, registerCache, sharedRegisters, depthProjection) +\n            \"dp4 \" + temp + \".z, \" + temp + \", \" + decodeRegister + \"\\n\" +\n            \"slt \" + predicate + \".w, \" + depthProjection + \".z, \" + temp + \".z\\n\" +\n            \"sub \" + depthProjection + \".x, \" + depthProjection + \".x, \" + dataReg + \".y\\n\" +\n            methodVO.textureGL._iGetFragmentCode(temp, registerCache, sharedRegisters, depthProjection) +\n            \"dp4 \" + temp + \".z, \" + temp + \", \" + decodeRegister + \"\\n\" +\n            \"slt \" + predicate + \".y, \" + depthProjection + \".z, \" + temp + \".z\\n\" +\n            \"mul \" + temp + \".xy, \" + depthProjection + \".xy, \" + dataReg + \".x\\n\" +\n            \"frc \" + temp + \".xy, \" + temp + \".xy\\n\" +\n            // some strange register juggling to prevent agal bugging out\n            \"sub \" + depthProjection + \", \" + predicate + \".xyzw, \" + predicate + \".zwxy\\n\" +\n            \"mul \" + depthProjection + \", \" + depthProjection + \", \" + temp + \".x\\n\" +\n            \"add \" + predicate + \".xy, \" + predicate + \".xy, \" + depthProjection + \".zw\\n\" +\n            \"sub \" + predicate + \".y, \" + predicate + \".y, \" + predicate + \".x\\n\" +\n            \"mul \" + predicate + \".y, \" + predicate + \".y, \" + temp + \".y\\n\" +\n            \"add \" + targetRegister + \".w, \" + predicate + \".x, \" + predicate + \".y\\n\";\n        registerCache.removeFragmentTempUsage(temp);\n        registerCache.removeFragmentTempUsage(predicate);\n        return code;\n    };\n    return ShadowFilteredMethod;\n}(ShadowMethodBase_1.default));\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = ShadowFilteredMethod;\n\n},{\"../methods/ShadowMethodBase\":\"awayjs-methodmaterials/lib/methods/ShadowMethodBase\"}],\"awayjs-methodmaterials/lib/methods/ShadowHardMethod\":[function(require,module,exports){\n\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar ShadowMethodBase_1 = require(\"../methods/ShadowMethodBase\");\n/**\n * ShadowHardMethod provides the cheapest shadow map method by using a single tap without any filtering.\n */\nvar ShadowHardMethod = (function (_super) {\n    __extends(ShadowHardMethod, _super);\n    /**\n     * Creates a new ShadowHardMethod object.\n     */\n    function ShadowHardMethod(castingLight) {\n        _super.call(this, castingLight);\n    }\n    /**\n     * @inheritDoc\n     */\n    ShadowHardMethod.prototype._pGetPlanarFragmentCode = function (shader, methodVO, targetReg, regCache, sharedRegisters) {\n        var code = \"\";\n        var decReg = regCache.getFreeFragmentConstant();\n        regCache.getFreeFragmentConstant();\n        var depthCol = regCache.getFreeFragmentVectorTemp();\n        methodVO.fragmentConstantsIndex = decReg.index * 4;\n        code += methodVO.textureGL._iGetFragmentCode(depthCol, regCache, sharedRegisters, this._pDepthMapCoordReg) +\n            \"dp4 \" + depthCol + \".z, \" + depthCol + \", \" + decReg + \"\\n\" +\n            \"slt \" + targetReg + \".w, \" + this._pDepthMapCoordReg + \".z, \" + depthCol + \".z\\n\"; // 0 if in shadow\n        return code;\n    };\n    /**\n     * @inheritDoc\n     */\n    ShadowHardMethod.prototype._pGetPointFragmentCode = function (shader, methodVO, targetReg, regCache, sharedRegisters) {\n        var code = \"\";\n        var decReg = regCache.getFreeFragmentConstant();\n        var epsReg = regCache.getFreeFragmentConstant();\n        var posReg = regCache.getFreeFragmentConstant();\n        var depthSampleCol = regCache.getFreeFragmentVectorTemp();\n        regCache.addFragmentTempUsages(depthSampleCol, 1);\n        var lightDir = regCache.getFreeFragmentVectorTemp();\n        regCache.addFragmentTempUsages(lightDir, 1);\n        methodVO.fragmentConstantsIndex = decReg.index * 4;\n        code += \"sub \" + lightDir + \", \" + sharedRegisters.globalPositionVarying + \", \" + posReg + \"\\n\" +\n            \"dp3 \" + lightDir + \".w, \" + lightDir + \".xyz, \" + lightDir + \".xyz\\n\" +\n            \"mul \" + lightDir + \".w, \" + lightDir + \".w, \" + posReg + \".w\\n\" +\n            \"nrm \" + lightDir + \".xyz, \" + lightDir + \".xyz\\n\" +\n            methodVO.textureGL._iGetFragmentCode(depthSampleCol, regCache, sharedRegisters, lightDir) +\n            \"dp4 \" + depthSampleCol + \".z, \" + depthSampleCol + \", \" + decReg + \"\\n\" +\n            \"add \" + targetReg + \".w, \" + lightDir + \".w, \" + epsReg + \".x\\n\" +\n            \"slt \" + targetReg + \".w, \" + targetReg + \".w, \" + depthSampleCol + \".z\\n\"; // 0 if in shadow\n        regCache.removeFragmentTempUsage(lightDir);\n        regCache.removeFragmentTempUsage(depthSampleCol);\n        return code;\n    };\n    /**\n     * @inheritDoc\n     */\n    ShadowHardMethod.prototype._iGetCascadeFragmentCode = function (shader, methodVO, decodeRegister, depthProjection, targetRegister, registerCache, sharedRegisters) {\n        var temp = registerCache.getFreeFragmentVectorTemp();\n        return methodVO.textureGL._iGetFragmentCode(temp, registerCache, sharedRegisters, depthProjection) +\n            \"dp4 \" + temp + \".z, \" + temp + \", \" + decodeRegister + \"\\n\" +\n            \"slt \" + targetRegister + \".w, \" + depthProjection + \".z, \" + temp + \".z\\n\"; // 0 if in shadow\n    };\n    /**\n     * @inheritDoc\n     */\n    ShadowHardMethod.prototype.iActivateForCascade = function (shader, methodVO, stage) {\n    };\n    return ShadowHardMethod;\n}(ShadowMethodBase_1.default));\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = ShadowHardMethod;\n\n},{\"../methods/ShadowMethodBase\":\"awayjs-methodmaterials/lib/methods/ShadowMethodBase\"}],\"awayjs-methodmaterials/lib/methods/ShadowMapMethodBase\":[function(require,module,exports){\n\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar ShadingMethodBase_1 = require(\"../methods/ShadingMethodBase\");\n/**\n * ShadowMapMethodBase provides an abstract base method for shadow map methods.\n */\nvar ShadowMapMethodBase = (function (_super) {\n    __extends(ShadowMapMethodBase, _super);\n    /**\n     * Creates a new ShadowMapMethodBase object.\n     * @param castingLight The light used to cast shadows.\n     */\n    function ShadowMapMethodBase(castingLight) {\n        _super.call(this);\n        this._pEpsilon = .02;\n        this._pAlpha = 1;\n        this._pCastingLight = castingLight;\n        castingLight.shadowsEnabled = true;\n        this._pShadowMapper = castingLight.shadowMapper;\n        this.iAddTexture(castingLight.shadowMapper.depthMap);\n    }\n    Object.defineProperty(ShadowMapMethodBase.prototype, \"assetType\", {\n        /**\n         * @inheritDoc\n         */\n        get: function () {\n            return ShadowMapMethodBase.assetType;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ShadowMapMethodBase.prototype, \"alpha\", {\n        /**\n         * The \"transparency\" of the shadows. This allows making shadows less strong.\n         */\n        get: function () {\n            return this._pAlpha;\n        },\n        set: function (value) {\n            this._pAlpha = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ShadowMapMethodBase.prototype, \"castingLight\", {\n        /**\n         * The light casting the shadows.\n         */\n        get: function () {\n            return this._pCastingLight;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ShadowMapMethodBase.prototype, \"epsilon\", {\n        /**\n         * A small value to counter floating point precision errors when comparing values in the shadow map with the\n         * calculated depth value. Increase this if shadow banding occurs, decrease it if the shadow seems to be too detached.\n         */\n        get: function () {\n            return this._pEpsilon;\n        },\n        set: function (value) {\n            this._pEpsilon = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    ShadowMapMethodBase.assetType = \"[asset ShadowMapMethod]\";\n    return ShadowMapMethodBase;\n}(ShadingMethodBase_1.default));\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = ShadowMapMethodBase;\n\n},{\"../methods/ShadingMethodBase\":\"awayjs-methodmaterials/lib/methods/ShadingMethodBase\"}],\"awayjs-methodmaterials/lib/methods/ShadowMethodBase\":[function(require,module,exports){\n\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar AbstractMethodError_1 = require(\"awayjs-core/lib/errors/AbstractMethodError\");\nvar PointLight_1 = require(\"awayjs-display/lib/display/PointLight\");\nvar ShadowMapMethodBase_1 = require(\"../methods/ShadowMapMethodBase\");\n/**\n * ShadowMethodBase provides an abstract method for simple (non-wrapping) shadow map methods.\n */\nvar ShadowMethodBase = (function (_super) {\n    __extends(ShadowMethodBase, _super);\n    /**\n     * Creates a new ShadowMethodBase object.\n     * @param castingLight The light used to cast shadows.\n     */\n    function ShadowMethodBase(castingLight) {\n        _super.call(this, castingLight);\n        this._pUsePoint = (castingLight instanceof PointLight_1.default);\n    }\n    /**\n     * @inheritDoc\n     */\n    ShadowMethodBase.prototype.iInitVO = function (shader, methodVO) {\n        methodVO.needsView = true;\n        methodVO.needsGlobalVertexPos = true;\n        methodVO.needsGlobalFragmentPos = this._pUsePoint;\n        methodVO.needsNormals = shader.numLights > 0;\n        methodVO.textureGL = shader.getAbstraction(this._pCastingLight.shadowMapper.depthMap);\n    };\n    /**\n     * @inheritDoc\n     */\n    ShadowMethodBase.prototype.iInitConstants = function (shader, methodVO) {\n        var fragmentData = shader.fragmentConstantData;\n        var vertexData = shader.vertexConstantData;\n        var index = methodVO.fragmentConstantsIndex;\n        fragmentData[index] = 1.0;\n        fragmentData[index + 1] = 1 / 255.0;\n        fragmentData[index + 2] = 1 / 65025.0;\n        fragmentData[index + 3] = 1 / 16581375.0;\n        fragmentData[index + 6] = 0;\n        fragmentData[index + 7] = 1;\n        if (this._pUsePoint) {\n            fragmentData[index + 8] = 0;\n            fragmentData[index + 9] = 0;\n            fragmentData[index + 10] = 0;\n            fragmentData[index + 11] = 1;\n        }\n        index = methodVO.vertexConstantsIndex;\n        if (index != -1) {\n            vertexData[index] = .5;\n            vertexData[index + 1] = .5;\n            vertexData[index + 2] = 0.0;\n            vertexData[index + 3] = 1.0;\n        }\n    };\n    Object.defineProperty(ShadowMethodBase.prototype, \"_iDepthMapCoordReg\", {\n        /**\n         * Wrappers that override the vertex shader need to set this explicitly\n         */\n        get: function () {\n            return this._pDepthMapCoordReg;\n        },\n        set: function (value) {\n            this._pDepthMapCoordReg = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * @inheritDoc\n     */\n    ShadowMethodBase.prototype.iCleanCompilationData = function () {\n        _super.prototype.iCleanCompilationData.call(this);\n        this._pDepthMapCoordReg = null;\n    };\n    /**\n     * @inheritDoc\n     */\n    ShadowMethodBase.prototype.iGetVertexCode = function (shader, methodVO, regCache, sharedRegisters) {\n        return this._pUsePoint ? this._pGetPointVertexCode(methodVO, regCache, sharedRegisters) : this.pGetPlanarVertexCode(methodVO, regCache, sharedRegisters);\n    };\n    /**\n     * Gets the vertex code for shadow mapping with a point light.\n     *\n     * @param methodVO The MethodVO object linking this method with the pass currently being compiled.\n     * @param regCache The register cache used during the compilation.\n     */\n    ShadowMethodBase.prototype._pGetPointVertexCode = function (methodVO, regCache, sharedRegisters) {\n        methodVO.vertexConstantsIndex = -1;\n        return \"\";\n    };\n    /**\n     * Gets the vertex code for shadow mapping with a planar shadow map (fe: directional lights).\n     *\n     * @param methodVO The MethodVO object linking this method with the pass currently being compiled.\n     * @param regCache The register cache used during the compilation.\n     */\n    ShadowMethodBase.prototype.pGetPlanarVertexCode = function (methodVO, regCache, sharedRegisters) {\n        var code = \"\";\n        var temp = regCache.getFreeVertexVectorTemp();\n        var dataReg = regCache.getFreeVertexConstant();\n        var depthMapProj = regCache.getFreeVertexConstant();\n        regCache.getFreeVertexConstant();\n        regCache.getFreeVertexConstant();\n        regCache.getFreeVertexConstant();\n        this._pDepthMapCoordReg = regCache.getFreeVarying();\n        methodVO.vertexConstantsIndex = dataReg.index * 4;\n        // todo: can epsilon be applied here instead of fragment shader?\n        code += \"m44 \" + temp + \", \" + sharedRegisters.globalPositionVertex + \", \" + depthMapProj + \"\\n\" +\n            \"div \" + temp + \", \" + temp + \", \" + temp + \".w\\n\" +\n            \"mul \" + temp + \".xy, \" + temp + \".xy, \" + dataReg + \".xy\\n\" +\n            \"add \" + this._pDepthMapCoordReg + \", \" + temp + \", \" + dataReg + \".xxwz\\n\";\n        //\"sub \" + this._pDepthMapCoordReg + \".z, \" + this._pDepthMapCoordReg + \".z, \" + this._pDepthMapCoordReg + \".w\\n\";\n        return code;\n    };\n    /**\n     * @inheritDoc\n     */\n    ShadowMethodBase.prototype.iGetFragmentCode = function (shader, methodVO, targetReg, registerCache, sharedRegisters) {\n        var code = this._pUsePoint ? this._pGetPointFragmentCode(shader, methodVO, targetReg, registerCache, sharedRegisters) : this._pGetPlanarFragmentCode(shader, methodVO, targetReg, registerCache, sharedRegisters);\n        code += \"add \" + targetReg + \".w, \" + targetReg + \".w, fc\" + (methodVO.fragmentConstantsIndex / 4 + 1) + \".y\\n\" +\n            \"sat \" + targetReg + \".w, \" + targetReg + \".w\\n\";\n        return code;\n    };\n    /**\n     * Gets the fragment code for shadow mapping with a planar shadow map.\n     * @param methodVO The MethodVO object linking this method with the pass currently being compiled.\n     * @param regCache The register cache used during the compilation.\n     * @param targetReg The register to contain the shadow coverage\n     * @return\n     */\n    ShadowMethodBase.prototype._pGetPlanarFragmentCode = function (shader, methodVO, targetReg, regCache, sharedRegisters) {\n        throw new AbstractMethodError_1.default();\n    };\n    /**\n     * Gets the fragment code for shadow mapping with a point light.\n     * @param methodVO The MethodVO object linking this method with the pass currently being compiled.\n     * @param regCache The register cache used during the compilation.\n     * @param targetReg The register to contain the shadow coverage\n     * @return\n     */\n    ShadowMethodBase.prototype._pGetPointFragmentCode = function (shader, methodVO, targetReg, regCache, sharedRegisters) {\n        throw new AbstractMethodError_1.default();\n    };\n    /**\n     * @inheritDoc\n     */\n    ShadowMethodBase.prototype.iSetRenderState = function (shader, methodVO, renderable, stage, camera) {\n        if (!this._pUsePoint)\n            this._pShadowMapper.iDepthProjection.copyRawDataTo(shader.vertexConstantData, methodVO.vertexConstantsIndex + 4, true);\n        methodVO.textureGL._setRenderState(renderable);\n    };\n    /**\n     * Gets the fragment code for combining this method with a cascaded shadow map method.\n     * @param methodVO The MethodVO object linking this method with the pass currently being compiled.\n     * @param regCache The register cache used during the compilation.\n     * @param decodeRegister The register containing the data to decode the shadow map depth value.\n     * @param depthTexture The texture containing the shadow map.\n     * @param depthProjection The projection of the fragment relative to the light.\n     * @param targetRegister The register to contain the shadow coverage\n     * @return\n     */\n    ShadowMethodBase.prototype._iGetCascadeFragmentCode = function (shader, methodVO, decodeRegister, depthProjection, targetRegister, registerCache, sharedRegisters) {\n        throw new Error(\"This shadow method is incompatible with cascade shadows\");\n    };\n    /**\n     * @inheritDoc\n     */\n    ShadowMethodBase.prototype.iActivate = function (shader, methodVO, stage) {\n        var fragmentData = shader.fragmentConstantData;\n        var index = methodVO.fragmentConstantsIndex;\n        if (this._pUsePoint)\n            fragmentData[index + 4] = -Math.pow(1 / (this._pCastingLight.fallOff * this._pEpsilon), 2);\n        else\n            shader.vertexConstantData[methodVO.vertexConstantsIndex + 3] = -1 / (this._pShadowMapper.depth * this._pEpsilon);\n        fragmentData[index + 5] = 1 - this._pAlpha;\n        if (this._pUsePoint) {\n            var pos = this._pCastingLight.scenePosition;\n            fragmentData[index + 8] = pos.x;\n            fragmentData[index + 9] = pos.y;\n            fragmentData[index + 10] = pos.z;\n            // used to decompress distance\n            var f = this._pCastingLight.fallOff;\n            fragmentData[index + 11] = 1 / (2 * f * f);\n        }\n        methodVO.textureGL.activate(methodVO.pass._render);\n    };\n    /**\n     * Sets the method state for cascade shadow mapping.\n     */\n    ShadowMethodBase.prototype.iActivateForCascade = function (shader, methodVO, stage) {\n        throw new Error(\"This shadow method is incompatible with cascade shadows\");\n    };\n    return ShadowMethodBase;\n}(ShadowMapMethodBase_1.default));\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = ShadowMethodBase;\n\n},{\"../methods/ShadowMapMethodBase\":\"awayjs-methodmaterials/lib/methods/ShadowMapMethodBase\",\"awayjs-core/lib/errors/AbstractMethodError\":undefined,\"awayjs-display/lib/display/PointLight\":undefined}],\"awayjs-methodmaterials/lib/methods/ShadowNearMethod\":[function(require,module,exports){\n\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar ShadingMethodEvent_1 = require(\"awayjs-renderergl/lib/events/ShadingMethodEvent\");\nvar ShadowMethodBase_1 = require(\"../methods/ShadowMethodBase\");\n// TODO: shadow mappers references in materials should be an interface so that this class should NOT extend ShadowMapMethodBase just for some delegation work\n/**\n * ShadowNearMethod provides a shadow map method that restricts the shadowed area near the camera to optimize\n * shadow map usage. This method needs to be used in conjunction with a NearDirectionalShadowMapper.\n *\n * @see away.lights.NearDirectionalShadowMapper\n */\nvar ShadowNearMethod = (function (_super) {\n    __extends(ShadowNearMethod, _super);\n    /**\n     * Creates a new ShadowNearMethod object.\n     * @param baseMethod The shadow map sampling method used to sample individual cascades (fe: ShadowHardMethod, ShadowSoftMethod)\n     * @param fadeRatio The amount of shadow fading to the outer shadow area. A value of 1 would mean the shadows start fading from the camera's near plane.\n     */\n    function ShadowNearMethod(baseMethod, fadeRatio) {\n        var _this = this;\n        if (fadeRatio === void 0) { fadeRatio = .1; }\n        _super.call(this, baseMethod.castingLight);\n        this._onShaderInvalidatedDelegate = function (event) { return _this.onShaderInvalidated(event); };\n        this._baseMethod = baseMethod;\n        this._fadeRatio = fadeRatio;\n        this._nearShadowMapper = this._pCastingLight.shadowMapper;\n        if (!this._nearShadowMapper)\n            throw new Error(\"ShadowNearMethod requires a light that has a NearDirectionalShadowMapper instance assigned to shadowMapper.\");\n        this._baseMethod.addEventListener(ShadingMethodEvent_1.default.SHADER_INVALIDATED, this._onShaderInvalidatedDelegate);\n    }\n    Object.defineProperty(ShadowNearMethod.prototype, \"baseMethod\", {\n        /**\n         * The base shadow map method on which this method's shading is based.\n         */\n        get: function () {\n            return this._baseMethod;\n        },\n        set: function (value) {\n            if (this._baseMethod == value)\n                return;\n            this._baseMethod.removeEventListener(ShadingMethodEvent_1.default.SHADER_INVALIDATED, this._onShaderInvalidatedDelegate);\n            this._baseMethod = value;\n            this._baseMethod.addEventListener(ShadingMethodEvent_1.default.SHADER_INVALIDATED, this._onShaderInvalidatedDelegate);\n            this.iInvalidateShaderProgram();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * @inheritDoc\n     */\n    ShadowNearMethod.prototype.iInitConstants = function (shader, methodVO) {\n        _super.prototype.iInitConstants.call(this, shader, methodVO);\n        this._baseMethod.iInitConstants(shader, methodVO);\n        var fragmentData = shader.fragmentConstantData;\n        var index = methodVO.secondaryFragmentConstantsIndex;\n        fragmentData[index + 2] = 0;\n        fragmentData[index + 3] = 1;\n    };\n    /**\n     * @inheritDoc\n     */\n    ShadowNearMethod.prototype.iInitVO = function (shader, methodVO) {\n        this._baseMethod.iInitVO(shader, methodVO);\n        methodVO.needsProjection = true;\n    };\n    /**\n     * @inheritDoc\n     */\n    ShadowNearMethod.prototype.dispose = function () {\n        this._baseMethod.removeEventListener(ShadingMethodEvent_1.default.SHADER_INVALIDATED, this._onShaderInvalidatedDelegate);\n    };\n    Object.defineProperty(ShadowNearMethod.prototype, \"alpha\", {\n        /**\n         * @inheritDoc\n         */\n        get: function () {\n            return this._baseMethod.alpha;\n        },\n        set: function (value) {\n            this._baseMethod.alpha = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ShadowNearMethod.prototype, \"epsilon\", {\n        /**\n         * @inheritDoc\n         */\n        get: function () {\n            return this._baseMethod.epsilon;\n        },\n        set: function (value) {\n            this._baseMethod.epsilon = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ShadowNearMethod.prototype, \"fadeRatio\", {\n        /**\n         * The amount of shadow fading to the outer shadow area. A value of 1 would mean the shadows start fading from the camera's near plane.\n         */\n        get: function () {\n            return this._fadeRatio;\n        },\n        set: function (value) {\n            this._fadeRatio = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * @inheritDoc\n     */\n    ShadowNearMethod.prototype.iGetFragmentCode = function (shader, methodVO, targetReg, registerCache, sharedRegisters) {\n        var code = this._baseMethod.iGetFragmentCode(shader, methodVO, targetReg, registerCache, sharedRegisters);\n        var dataReg = registerCache.getFreeFragmentConstant();\n        var temp = registerCache.getFreeFragmentSingleTemp();\n        methodVO.secondaryFragmentConstantsIndex = dataReg.index * 4;\n        code += \"abs \" + temp + \", \" + sharedRegisters.projectionFragment + \".w\\n\" +\n            \"sub \" + temp + \", \" + temp + \", \" + dataReg + \".x\\n\" +\n            \"mul \" + temp + \", \" + temp + \", \" + dataReg + \".y\\n\" +\n            \"sat \" + temp + \", \" + temp + \"\\n\" +\n            \"sub \" + temp + \", \" + dataReg + \".w,\" + temp + \"\\n\" +\n            \"sub \" + targetReg + \".w, \" + dataReg + \".w,\" + targetReg + \".w\\n\" +\n            \"mul \" + targetReg + \".w, \" + targetReg + \".w, \" + temp + \"\\n\" +\n            \"sub \" + targetReg + \".w, \" + dataReg + \".w,\" + targetReg + \".w\\n\";\n        return code;\n    };\n    /**\n     * @inheritDoc\n     */\n    ShadowNearMethod.prototype.iActivate = function (shader, methodVO, stage) {\n        this._baseMethod.iActivate(shader, methodVO, stage);\n    };\n    /**\n     * @inheritDoc\n     */\n    ShadowNearMethod.prototype.iDeactivate = function (shader, methodVO, stage) {\n        this._baseMethod.iDeactivate(shader, methodVO, stage);\n    };\n    /**\n     * @inheritDoc\n     */\n    ShadowNearMethod.prototype.iSetRenderState = function (shader, methodVO, renderable, stage, camera) {\n        // todo: move this to activate (needs camera)\n        var near = camera.projection.near;\n        var d = camera.projection.far - near;\n        var maxDistance = this._nearShadowMapper.coverageRatio;\n        var minDistance = maxDistance * (1 - this._fadeRatio);\n        maxDistance = near + maxDistance * d;\n        minDistance = near + minDistance * d;\n        var fragmentData = shader.fragmentConstantData;\n        var index = methodVO.secondaryFragmentConstantsIndex;\n        fragmentData[index] = minDistance;\n        fragmentData[index + 1] = 1 / (maxDistance - minDistance);\n        this._baseMethod.iSetRenderState(shader, methodVO, renderable, stage, camera);\n    };\n    /**\n     * @inheritDoc\n     */\n    ShadowNearMethod.prototype.iGetVertexCode = function (shader, methodVO, registerCache, sharedRegisters) {\n        return this._baseMethod.iGetVertexCode(shader, methodVO, registerCache, sharedRegisters);\n    };\n    /**\n     * @inheritDoc\n     */\n    ShadowNearMethod.prototype.iReset = function () {\n        this._baseMethod.iReset();\n    };\n    /**\n     * @inheritDoc\n     */\n    ShadowNearMethod.prototype.iCleanCompilationData = function () {\n        _super.prototype.iCleanCompilationData.call(this);\n        this._baseMethod.iCleanCompilationData();\n    };\n    /**\n     * Called when the base method's shader code is invalidated.\n     */\n    ShadowNearMethod.prototype.onShaderInvalidated = function (event) {\n        this.iInvalidateShaderProgram();\n    };\n    return ShadowNearMethod;\n}(ShadowMethodBase_1.default));\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = ShadowNearMethod;\n\n},{\"../methods/ShadowMethodBase\":\"awayjs-methodmaterials/lib/methods/ShadowMethodBase\",\"awayjs-renderergl/lib/events/ShadingMethodEvent\":undefined}],\"awayjs-methodmaterials/lib/methods/ShadowSoftMethod\":[function(require,module,exports){\n\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar PoissonLookup_1 = require(\"awayjs-core/lib/geom/PoissonLookup\");\nvar ShadowMethodBase_1 = require(\"../methods/ShadowMethodBase\");\n/**\n * ShadowSoftMethod provides a soft shadowing technique by randomly distributing sample points.\n */\nvar ShadowSoftMethod = (function (_super) {\n    __extends(ShadowSoftMethod, _super);\n    /**\n     * Creates a new DiffuseBasicMethod object.\n     *\n     * @param castingLight The light casting the shadows\n     * @param numSamples The amount of samples to take for dithering. Minimum 1, maximum 32.\n     */\n    function ShadowSoftMethod(castingLight, numSamples, range) {\n        if (numSamples === void 0) { numSamples = 5; }\n        if (range === void 0) { range = 1; }\n        _super.call(this, castingLight);\n        this._range = 1;\n        this.numSamples = numSamples;\n        this.range = range;\n    }\n    Object.defineProperty(ShadowSoftMethod.prototype, \"numSamples\", {\n        /**\n         * The amount of samples to take for dithering. Minimum 1, maximum 32. The actual maximum may depend on the\n         * complexity of the shader.\n         */\n        get: function () {\n            return this._numSamples;\n        },\n        set: function (value /*int*/) {\n            this._numSamples = value;\n            if (this._numSamples < 1)\n                this._numSamples = 1;\n            else if (this._numSamples > 32)\n                this._numSamples = 32;\n            this._offsets = PoissonLookup_1.default.getDistribution(this._numSamples);\n            this.iInvalidateShaderProgram();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ShadowSoftMethod.prototype, \"range\", {\n        /**\n         * The range in the shadow map in which to distribute the samples.\n         */\n        get: function () {\n            return this._range;\n        },\n        set: function (value) {\n            this._range = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * @inheritDoc\n     */\n    ShadowSoftMethod.prototype.iInitConstants = function (shader, methodVO) {\n        _super.prototype.iInitConstants.call(this, shader, methodVO);\n        shader.fragmentConstantData[methodVO.fragmentConstantsIndex + 8] = 1 / this._numSamples;\n        shader.fragmentConstantData[methodVO.fragmentConstantsIndex + 9] = 0;\n    };\n    /**\n     * @inheritDoc\n     */\n    ShadowSoftMethod.prototype.iActivate = function (shader, methodVO, stage) {\n        _super.prototype.iActivate.call(this, shader, methodVO, stage);\n        var texRange = .5 * this._range / this._pCastingLight.shadowMapper.depthMapSize;\n        var data = shader.fragmentConstantData;\n        var index = methodVO.fragmentConstantsIndex + 10;\n        var len = this._numSamples << 1;\n        for (var i = 0; i < len; ++i)\n            data[index + i] = this._offsets[i] * texRange;\n    };\n    /**\n     * @inheritDoc\n     */\n    ShadowSoftMethod.prototype._pGetPlanarFragmentCode = function (shader, methodVO, targetReg, regCache, sharedRegisters) {\n        // todo: move some things to super\n        var decReg = regCache.getFreeFragmentConstant();\n        regCache.getFreeFragmentConstant();\n        var dataReg = regCache.getFreeFragmentConstant();\n        methodVO.fragmentConstantsIndex = decReg.index * 4;\n        return this.getSampleCode(shader, methodVO, decReg, targetReg, regCache, sharedRegisters, dataReg);\n    };\n    /**\n     * Adds the code for another tap to the shader code.\n     * @param uv The uv register for the tap.\n     * @param texture The texture register containing the depth map.\n     * @param decode The register containing the depth map decoding data.\n     * @param target The target register to add the tap comparison result.\n     * @param regCache The register cache managing the registers.\n     * @return\n     */\n    ShadowSoftMethod.prototype.addSample = function (shader, methodVO, decodeRegister, targetRegister, registerCache, sharedRegisters, uvReg) {\n        var temp = registerCache.getFreeFragmentVectorTemp();\n        return methodVO.textureGL._iGetFragmentCode(temp, registerCache, sharedRegisters, uvReg) +\n            \"dp4 \" + temp + \".z, \" + temp + \", \" + decodeRegister + \"\\n\" +\n            \"slt \" + uvReg + \".w, \" + this._pDepthMapCoordReg + \".z, \" + temp + \".z\\n\" +\n            \"add \" + targetRegister + \".w, \" + targetRegister + \".w, \" + uvReg + \".w\\n\";\n    };\n    /**\n     * @inheritDoc\n     */\n    ShadowSoftMethod.prototype.iActivateForCascade = function (shader, methodVO, stage) {\n        _super.prototype.iActivate.call(this, shader, methodVO, stage);\n        var texRange = this._range / this._pCastingLight.shadowMapper.depthMapSize;\n        var data = shader.fragmentConstantData;\n        var index = methodVO.secondaryFragmentConstantsIndex;\n        var len = this._numSamples << 1;\n        data[index] = 1 / this._numSamples;\n        data[index + 1] = 0;\n        index += 2;\n        for (var i = 0; i < len; ++i)\n            data[index + i] = this._offsets[i] * texRange;\n        if (len % 4 == 0) {\n            data[index + len] = 0;\n            data[index + len + 1] = 0;\n        }\n    };\n    /**\n     * @inheritDoc\n     */\n    ShadowSoftMethod.prototype._iGetCascadeFragmentCode = function (shader, methodVO, decodeRegister, depthProjection, targetRegister, registerCache, sharedRegisters) {\n        this._pDepthMapCoordReg = depthProjection;\n        var dataReg = registerCache.getFreeFragmentConstant();\n        methodVO.secondaryFragmentConstantsIndex = dataReg.index * 4;\n        return this.getSampleCode(shader, methodVO, decodeRegister, targetRegister, registerCache, sharedRegisters, dataReg);\n    };\n    /**\n     * Get the actual shader code for shadow mapping\n     * @param regCache The register cache managing the registers.\n     * @param depthTexture The texture register containing the depth map.\n     * @param decodeRegister The register containing the depth map decoding data.\n     * @param targetReg The target register to add the shadow coverage.\n     * @param dataReg The register containing additional data.\n     */\n    ShadowSoftMethod.prototype.getSampleCode = function (shader, methodVO, decodeRegister, targetRegister, registerCache, sharedRegisters, dataReg) {\n        var code;\n        var uvReg = registerCache.getFreeFragmentVectorTemp();\n        registerCache.addFragmentTempUsages(uvReg, 1);\n        var offsets = new Array(dataReg + \".zw\");\n        var numRegs = this._numSamples >> 1;\n        for (var i = 0; i < numRegs; ++i) {\n            var reg = registerCache.getFreeFragmentConstant();\n            offsets.push(reg + \".xy\");\n            offsets.push(reg + \".zw\");\n        }\n        for (i = 0; i < this._numSamples; ++i) {\n            if (i == 0) {\n                var temp = registerCache.getFreeFragmentVectorTemp();\n                code = \"add \" + uvReg + \", \" + this._pDepthMapCoordReg + \", \" + dataReg + \".zwyy\\n\" +\n                    methodVO.textureGL._iGetFragmentCode(temp, registerCache, sharedRegisters, uvReg) +\n                    \"dp4 \" + temp + \".z, \" + temp + \", \" + decodeRegister + \"\\n\" +\n                    \"slt \" + targetRegister + \".w, \" + this._pDepthMapCoordReg + \".z, \" + temp + \".z\\n\"; // 0 if in shadow;\n            }\n            else {\n                code += \"add \" + uvReg + \".xy, \" + this._pDepthMapCoordReg + \".xy, \" + offsets[i] + \"\\n\" +\n                    this.addSample(shader, methodVO, decodeRegister, targetRegister, registerCache, sharedRegisters, uvReg);\n            }\n        }\n        registerCache.removeFragmentTempUsage(uvReg);\n        code += \"mul \" + targetRegister + \".w, \" + targetRegister + \".w, \" + dataReg + \".x\\n\"; // average\n        return code;\n    };\n    return ShadowSoftMethod;\n}(ShadowMethodBase_1.default));\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = ShadowSoftMethod;\n\n},{\"../methods/ShadowMethodBase\":\"awayjs-methodmaterials/lib/methods/ShadowMethodBase\",\"awayjs-core/lib/geom/PoissonLookup\":undefined}],\"awayjs-methodmaterials/lib/methods/SpecularAnisotropicMethod\":[function(require,module,exports){\n\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar SpecularBasicMethod_1 = require(\"../methods/SpecularBasicMethod\");\n/**\n * SpecularAnisotropicMethod provides a specular method resulting in anisotropic highlights. These are typical for\n * surfaces with microfacet details such as tiny grooves. In particular, this uses the Heidrich-Seidel distrubution.\n * The tangent vectors are used as the surface groove directions.\n */\nvar SpecularAnisotropicMethod = (function (_super) {\n    __extends(SpecularAnisotropicMethod, _super);\n    /**\n     * Creates a new SpecularAnisotropicMethod object.\n     */\n    function SpecularAnisotropicMethod() {\n        _super.call(this);\n    }\n    /**\n     * @inheritDoc\n     */\n    SpecularAnisotropicMethod.prototype.iInitVO = function (shader, methodVO) {\n        methodVO.needsTangents = true;\n        methodVO.needsView = true;\n    };\n    /**\n     * @inheritDoc\n     */\n    SpecularAnisotropicMethod.prototype.iGetFragmentCodePerLight = function (shader, methodVO, lightDirReg, lightColReg, registerCache, sharedRegisters) {\n        var code = \"\";\n        var t;\n        if (this._pIsFirstLight)\n            t = this._pTotalLightColorReg;\n        else {\n            t = registerCache.getFreeFragmentVectorTemp();\n            registerCache.addFragmentTempUsages(t, 1);\n        }\n        // (sin(l,t) * sin(v,t) - cos(l,t)*cos(v,t)) ^ k\n        code += \"nrm \" + t + \".xyz, \" + sharedRegisters.tangentVarying + \".xyz\\n\" +\n            \"dp3 \" + t + \".w, \" + t + \".xyz, \" + lightDirReg + \".xyz\\n\" +\n            \"dp3 \" + t + \".z, \" + t + \".xyz, \" + sharedRegisters.viewDirFragment + \".xyz\\n\";\n        // (sin(t.w) * sin(t.z) - cos(t.w)*cos(t.z)) ^ k\n        code += \"sin \" + t + \".x, \" + t + \".w\\n\" +\n            \"sin \" + t + \".y, \" + t + \".z\\n\" +\n            // (t.x * t.y - cos(t.w)*cos(t.z)) ^ k\n            \"mul \" + t + \".x, \" + t + \".x, \" + t + \".y\\n\" +\n            // (t.x - cos(t.w)*cos(t.z)) ^ k\n            \"cos \" + t + \".z, \" + t + \".z\\n\" +\n            \"cos \" + t + \".w, \" + t + \".w\\n\" +\n            // (t.x - t.w*t.z) ^ k\n            \"mul \" + t + \".w, \" + t + \".w, \" + t + \".z\\n\" +\n            // (t.x - t.w) ^ k\n            \"sub \" + t + \".w, \" + t + \".x, \" + t + \".w\\n\";\n        if (this.texture) {\n            // apply gloss modulation from texture\n            code += \"mul \" + this._pSpecularTexData + \".w, \" + this._pSpecularTexData + \".y, \" + this._pSpecularDataRegister + \".w\\n\" +\n                \"pow \" + t + \".w, \" + t + \".w, \" + this._pSpecularTexData + \".w\\n\";\n        }\n        else\n            code += \"pow \" + t + \".w, \" + t + \".w, \" + this._pSpecularDataRegister + \".w\\n\";\n        // attenuate\n        code += \"mul \" + t + \".w, \" + t + \".w, \" + lightDirReg + \".w\\n\";\n        if (this._iModulateMethod != null)\n            code += this._iModulateMethod(shader, methodVO, t, registerCache, sharedRegisters);\n        code += \"mul \" + t + \".xyz, \" + lightColReg + \".xyz, \" + t + \".w\\n\";\n        if (!this._pIsFirstLight) {\n            code += \"add \" + this._pTotalLightColorReg + \".xyz, \" + this._pTotalLightColorReg + \".xyz, \" + t + \".xyz\\n\";\n            registerCache.removeFragmentTempUsage(t);\n        }\n        this._pIsFirstLight = false;\n        return code;\n    };\n    return SpecularAnisotropicMethod;\n}(SpecularBasicMethod_1.default));\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = SpecularAnisotropicMethod;\n\n},{\"../methods/SpecularBasicMethod\":\"awayjs-methodmaterials/lib/methods/SpecularBasicMethod\"}],\"awayjs-methodmaterials/lib/methods/SpecularBasicMethod\":[function(require,module,exports){\n\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar AssetEvent_1 = require(\"awayjs-core/lib/events/AssetEvent\");\nvar LightingMethodBase_1 = require(\"../methods/LightingMethodBase\");\n/**\n * SpecularBasicMethod provides the default shading method for Blinn-Phong specular highlights (an optimized but approximated\n * version of Phong specularity).\n */\nvar SpecularBasicMethod = (function (_super) {\n    __extends(SpecularBasicMethod, _super);\n    /**\n     * Creates a new SpecularBasicMethod object.\n     */\n    function SpecularBasicMethod() {\n        _super.call(this);\n        this._gloss = 50;\n        this._strength = 1;\n        this._color = 0xffffff;\n        this._iSpecularR = 1;\n        this._iSpecularG = 1;\n        this._iSpecularB = 1;\n    }\n    SpecularBasicMethod.prototype.iIsUsed = function (shader) {\n        if (!shader.numLights)\n            return false;\n        return true;\n    };\n    /**\n     * @inheritDoc\n     */\n    SpecularBasicMethod.prototype.iInitVO = function (shader, methodVO) {\n        methodVO.needsNormals = shader.numLights > 0;\n        methodVO.needsView = shader.numLights > 0;\n        if (this._texture) {\n            methodVO.textureGL = shader.getAbstraction(this._texture);\n            shader.uvDependencies++;\n        }\n        else if (methodVO.textureGL) {\n            methodVO.textureGL.onClear(new AssetEvent_1.default(AssetEvent_1.default.CLEAR, null));\n            methodVO.textureGL = null;\n        }\n    };\n    Object.defineProperty(SpecularBasicMethod.prototype, \"gloss\", {\n        /**\n         * The glossiness of the material (sharpness of the specular highlight).\n         */\n        get: function () {\n            return this._gloss;\n        },\n        set: function (value) {\n            this._gloss = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(SpecularBasicMethod.prototype, \"strength\", {\n        /**\n         * The overall strength of the specular highlights.\n         */\n        get: function () {\n            return this._strength;\n        },\n        set: function (value) {\n            if (value == this._strength)\n                return;\n            this._strength = value;\n            this.updateSpecular();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(SpecularBasicMethod.prototype, \"color\", {\n        /**\n         * The colour of the specular reflection of the surface.\n         */\n        get: function () {\n            return this._color;\n        },\n        set: function (value) {\n            if (this._color == value)\n                return;\n            // specular is now either enabled or disabled\n            if (this._color == 0 || value == 0)\n                this.iInvalidateShaderProgram();\n            this._color = value;\n            this.updateSpecular();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(SpecularBasicMethod.prototype, \"texture\", {\n        /**\n         * A texture that defines the strength of specular reflections for each texel in the red channel,\n         * and the gloss factor (sharpness) in the green channel. You can use Specular2DTexture if you want to easily set\n         * specular and gloss maps from grayscale images, but correctly authored images are preferred.\n         */\n        get: function () {\n            return this._texture;\n        },\n        set: function (value) {\n            if (this._texture == value)\n                return;\n            if (this._texture)\n                this.iRemoveTexture(this._texture);\n            this._texture = value;\n            if (this._texture)\n                this.iAddTexture(this._texture);\n            this.iInvalidateShaderProgram();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * @inheritDoc\n     */\n    SpecularBasicMethod.prototype.copyFrom = function (method) {\n        var m = method;\n        var bsm = method;\n        var spec = bsm; //SpecularBasicMethod(method);\n        this.texture = spec.texture;\n        this.strength = spec.strength;\n        this.color = spec.color;\n        this.gloss = spec.gloss;\n    };\n    /**\n     * @inheritDoc\n     */\n    SpecularBasicMethod.prototype.iCleanCompilationData = function () {\n        _super.prototype.iCleanCompilationData.call(this);\n        this._pTotalLightColorReg = null;\n        this._pSpecularTexData = null;\n        this._pSpecularDataRegister = null;\n    };\n    /**\n     * @inheritDoc\n     */\n    SpecularBasicMethod.prototype.iGetFragmentPreLightingCode = function (shader, methodVO, registerCache, sharedRegisters) {\n        var code = \"\";\n        this._pIsFirstLight = true;\n        this._pSpecularDataRegister = registerCache.getFreeFragmentConstant();\n        methodVO.fragmentConstantsIndex = this._pSpecularDataRegister.index * 4;\n        if (this._texture) {\n            this._pSpecularTexData = registerCache.getFreeFragmentVectorTemp();\n            registerCache.addFragmentTempUsages(this._pSpecularTexData, 1);\n            code += methodVO.textureGL._iGetFragmentCode(this._pSpecularTexData, registerCache, sharedRegisters, sharedRegisters.uvVarying);\n        }\n        this._pTotalLightColorReg = registerCache.getFreeFragmentVectorTemp();\n        registerCache.addFragmentTempUsages(this._pTotalLightColorReg, 1);\n        return code;\n    };\n    /**\n     * @inheritDoc\n     */\n    SpecularBasicMethod.prototype.iGetFragmentCodePerLight = function (shader, methodVO, lightDirReg, lightColReg, registerCache, sharedRegisters) {\n        var code = \"\";\n        var t;\n        if (this._pIsFirstLight) {\n            t = this._pTotalLightColorReg;\n        }\n        else {\n            t = registerCache.getFreeFragmentVectorTemp();\n            registerCache.addFragmentTempUsages(t, 1);\n        }\n        var viewDirReg = sharedRegisters.viewDirFragment;\n        var normalReg = sharedRegisters.normalFragment;\n        // blinn-phong half vector model\n        code += \"add \" + t + \", \" + lightDirReg + \", \" + viewDirReg + \"\\n\" +\n            \"nrm \" + t + \".xyz, \" + t + \"\\n\" +\n            \"dp3 \" + t + \".w, \" + normalReg + \", \" + t + \"\\n\" +\n            \"sat \" + t + \".w, \" + t + \".w\\n\";\n        if (this._texture) {\n            // apply gloss modulation from texture\n            code += \"mul \" + this._pSpecularTexData + \".w, \" + this._pSpecularTexData + \".y, \" + this._pSpecularDataRegister + \".w\\n\" +\n                \"pow \" + t + \".w, \" + t + \".w, \" + this._pSpecularTexData + \".w\\n\";\n        }\n        else {\n            code += \"pow \" + t + \".w, \" + t + \".w, \" + this._pSpecularDataRegister + \".w\\n\";\n        }\n        // attenuate\n        if (shader.usesLightFallOff)\n            code += \"mul \" + t + \".w, \" + t + \".w, \" + lightDirReg + \".w\\n\";\n        if (this._iModulateMethod != null)\n            code += this._iModulateMethod(shader, methodVO, t, registerCache, sharedRegisters);\n        code += \"mul \" + t + \".xyz, \" + lightColReg + \", \" + t + \".w\\n\";\n        if (!this._pIsFirstLight) {\n            code += \"add \" + this._pTotalLightColorReg + \".xyz, \" + this._pTotalLightColorReg + \", \" + t + \"\\n\";\n            registerCache.removeFragmentTempUsage(t);\n        }\n        this._pIsFirstLight = false;\n        return code;\n    };\n    /**\n     * @inheritDoc\n     */\n    SpecularBasicMethod.prototype.iGetFragmentCodePerProbe = function (shader, methodVO, cubeMapReg, weightRegister, registerCache, sharedRegisters) {\n        var code = \"\";\n        var t;\n        // write in temporary if not first light, so we can add to total diffuse colour\n        if (this._pIsFirstLight) {\n            t = this._pTotalLightColorReg;\n        }\n        else {\n            t = registerCache.getFreeFragmentVectorTemp();\n            registerCache.addFragmentTempUsages(t, 1);\n        }\n        var normalReg = sharedRegisters.normalFragment;\n        var viewDirReg = sharedRegisters.viewDirFragment;\n        code += \"dp3 \" + t + \".w, \" + normalReg + \", \" + viewDirReg + \"\\n\" +\n            \"add \" + t + \".w, \" + t + \".w, \" + t + \".w\\n\" +\n            \"mul \" + t + \", \" + t + \".w, \" + normalReg + \"\\n\" +\n            \"sub \" + t + \", \" + t + \", \" + viewDirReg + \"\\n\" +\n            \"tex \" + t + \", \" + t + \", \" + cubeMapReg + \" <cube,\" + \"linear\" + \",miplinear>\\n\" +\n            \"mul \" + t + \".xyz, \" + t + \", \" + weightRegister + \"\\n\";\n        if (this._iModulateMethod != null)\n            code += this._iModulateMethod(shader, methodVO, t, registerCache, sharedRegisters);\n        if (!this._pIsFirstLight) {\n            code += \"add \" + this._pTotalLightColorReg + \".xyz, \" + this._pTotalLightColorReg + \", \" + t + \"\\n\";\n            registerCache.removeFragmentTempUsage(t);\n        }\n        this._pIsFirstLight = false;\n        return code;\n    };\n    /**\n     * @inheritDoc\n     */\n    SpecularBasicMethod.prototype.iGetFragmentPostLightingCode = function (shader, methodVO, targetReg, registerCache, sharedRegisters) {\n        var code = \"\";\n        if (sharedRegisters.shadowTarget)\n            code += \"mul \" + this._pTotalLightColorReg + \".xyz, \" + this._pTotalLightColorReg + \", \" + sharedRegisters.shadowTarget + \".w\\n\";\n        if (this._texture) {\n            // apply strength modulation from texture\n            code += \"mul \" + this._pTotalLightColorReg + \".xyz, \" + this._pTotalLightColorReg + \", \" + this._pSpecularTexData + \".x\\n\";\n            registerCache.removeFragmentTempUsage(this._pSpecularTexData);\n        }\n        // apply material's specular reflection\n        code += \"mul \" + this._pTotalLightColorReg + \".xyz, \" + this._pTotalLightColorReg + \", \" + this._pSpecularDataRegister + \"\\n\" +\n            \"add \" + targetReg + \".xyz, \" + targetReg + \", \" + this._pTotalLightColorReg + \"\\n\";\n        registerCache.removeFragmentTempUsage(this._pTotalLightColorReg);\n        return code;\n    };\n    /**\n     * @inheritDoc\n     */\n    SpecularBasicMethod.prototype.iActivate = function (shader, methodVO, stage) {\n        if (this._texture)\n            methodVO.textureGL.activate(methodVO.pass._render);\n        var index = methodVO.fragmentConstantsIndex;\n        var data = shader.fragmentConstantData;\n        data[index] = this._iSpecularR;\n        data[index + 1] = this._iSpecularG;\n        data[index + 2] = this._iSpecularB;\n        data[index + 3] = this._gloss;\n    };\n    SpecularBasicMethod.prototype.iSetRenderState = function (shader, methodVO, renderable, stage, camera) {\n        if (this._texture)\n            methodVO.textureGL._setRenderState(renderable);\n    };\n    /**\n     * Updates the specular color data used by the render state.\n     */\n    SpecularBasicMethod.prototype.updateSpecular = function () {\n        this._iSpecularR = ((this._color >> 16) & 0xff) / 0xff * this._strength;\n        this._iSpecularG = ((this._color >> 8) & 0xff) / 0xff * this._strength;\n        this._iSpecularB = (this._color & 0xff) / 0xff * this._strength;\n    };\n    return SpecularBasicMethod;\n}(LightingMethodBase_1.default));\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = SpecularBasicMethod;\n\n},{\"../methods/LightingMethodBase\":\"awayjs-methodmaterials/lib/methods/LightingMethodBase\",\"awayjs-core/lib/events/AssetEvent\":undefined}],\"awayjs-methodmaterials/lib/methods/SpecularCelMethod\":[function(require,module,exports){\n\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar SpecularCompositeMethod_1 = require(\"../methods/SpecularCompositeMethod\");\n/**\n * SpecularCelMethod provides a shading method to add specular cel (cartoon) shading.\n */\nvar SpecularCelMethod = (function (_super) {\n    __extends(SpecularCelMethod, _super);\n    /**\n     * Creates a new SpecularCelMethod object.\n     * @param specularCutOff The threshold at which the specular highlight should be shown.\n     * @param baseMethod An optional specular method on which the cartoon shading is based. If ommitted, SpecularBasicMethod is used.\n     */\n    function SpecularCelMethod(specularCutOff, baseMethod) {\n        var _this = this;\n        if (specularCutOff === void 0) { specularCutOff = .5; }\n        if (baseMethod === void 0) { baseMethod = null; }\n        _super.call(this, null, baseMethod);\n        this._smoothness = .1;\n        this._specularCutOff = .1;\n        this.baseMethod._iModulateMethod = function (shader, methodVO, targetReg, registerCache, sharedRegisters) { return _this.clampSpecular(shader, methodVO, targetReg, registerCache, sharedRegisters); };\n        this._specularCutOff = specularCutOff;\n    }\n    Object.defineProperty(SpecularCelMethod.prototype, \"smoothness\", {\n        /**\n         * The smoothness of the highlight edge.\n         */\n        get: function () {\n            return this._smoothness;\n        },\n        set: function (value) {\n            this._smoothness = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(SpecularCelMethod.prototype, \"specularCutOff\", {\n        /**\n         * The threshold at which the specular highlight should be shown.\n         */\n        get: function () {\n            return this._specularCutOff;\n        },\n        set: function (value) {\n            this._specularCutOff = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * @inheritDoc\n     */\n    SpecularCelMethod.prototype.iActivate = function (shader, methodVO, stage) {\n        _super.prototype.iActivate.call(this, shader, methodVO, stage);\n        var index = methodVO.secondaryFragmentConstantsIndex;\n        var data = shader.fragmentConstantData;\n        data[index] = this._smoothness;\n        data[index + 1] = this._specularCutOff;\n    };\n    /**\n     * @inheritDoc\n     */\n    SpecularCelMethod.prototype.iCleanCompilationData = function () {\n        _super.prototype.iCleanCompilationData.call(this);\n        this._dataReg = null;\n    };\n    /**\n     * Snaps the specular shading strength of the wrapped method to zero or one, depending on whether or not it exceeds the specularCutOff\n     * @param vo The MethodVO used to compile the current shader.\n     * @param t The register containing the specular strength in the \"w\" component, and either the half-vector or the reflection vector in \"xyz\".\n     * @param regCache The register cache used for the shader compilation.\n     * @param sharedRegisters The shared register data for this shader.\n     * @return The AGAL fragment code for the method.\n     */\n    SpecularCelMethod.prototype.clampSpecular = function (shader, methodVO, targetReg, registerCache, sharedRegisters) {\n        return \"sub \" + targetReg + \".y, \" + targetReg + \".w, \" + this._dataReg + \".y\\n\" +\n            \"div \" + targetReg + \".y, \" + targetReg + \".y, \" + this._dataReg + \".x\\n\" +\n            \"sat \" + targetReg + \".y, \" + targetReg + \".y\\n\" +\n            \"sge \" + targetReg + \".w, \" + targetReg + \".w, \" + this._dataReg + \".y\\n\" +\n            \"mul \" + targetReg + \".w, \" + targetReg + \".w, \" + targetReg + \".y\\n\";\n    };\n    /**\n     * @inheritDoc\n     */\n    SpecularCelMethod.prototype.iGetFragmentPreLightingCode = function (shader, methodVO, registerCache, sharedRegisters) {\n        this._dataReg = registerCache.getFreeFragmentConstant();\n        methodVO.secondaryFragmentConstantsIndex = this._dataReg.index * 4;\n        return _super.prototype.iGetFragmentPreLightingCode.call(this, shader, methodVO, registerCache, sharedRegisters);\n    };\n    return SpecularCelMethod;\n}(SpecularCompositeMethod_1.default));\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = SpecularCelMethod;\n\n},{\"../methods/SpecularCompositeMethod\":\"awayjs-methodmaterials/lib/methods/SpecularCompositeMethod\"}],\"awayjs-methodmaterials/lib/methods/SpecularCompositeMethod\":[function(require,module,exports){\n\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar ShadingMethodEvent_1 = require(\"awayjs-renderergl/lib/events/ShadingMethodEvent\");\nvar SpecularBasicMethod_1 = require(\"../methods/SpecularBasicMethod\");\n/**\n * SpecularCompositeMethod provides a base class for specular methods that wrap a specular method to alter the\n * calculated specular reflection strength.\n */\nvar SpecularCompositeMethod = (function (_super) {\n    __extends(SpecularCompositeMethod, _super);\n    /**\n     * Creates a new <code>SpecularCompositeMethod</code> object.\n     *\n     * @param modulateMethod The method which will add the code to alter the base method's strength. It needs to have the signature modSpecular(t:ShaderRegisterElement, regCache:ShaderRegisterCache):string, in which t.w will contain the specular strength and t.xyz will contain the half-vector or the reflection vector.\n     * @param baseMethod The base specular method on which this method's shading is based.\n     */\n    function SpecularCompositeMethod(modulateMethod, baseMethod) {\n        var _this = this;\n        if (baseMethod === void 0) { baseMethod = null; }\n        _super.call(this);\n        this._onShaderInvalidatedDelegate = function (event) { return _this.onShaderInvalidated(event); };\n        this._baseMethod = baseMethod || new SpecularBasicMethod_1.default();\n        this._baseMethod._iModulateMethod = modulateMethod;\n        this._baseMethod.addEventListener(ShadingMethodEvent_1.default.SHADER_INVALIDATED, this._onShaderInvalidatedDelegate);\n    }\n    /**\n     * @inheritDoc\n     */\n    SpecularCompositeMethod.prototype.iInitVO = function (shader, methodVO) {\n        this._baseMethod.iInitVO(shader, methodVO);\n    };\n    /**\n     * @inheritDoc\n     */\n    SpecularCompositeMethod.prototype.iInitConstants = function (shader, methodVO) {\n        this._baseMethod.iInitConstants(shader, methodVO);\n    };\n    SpecularCompositeMethod.prototype.iAddOwner = function (owner) {\n        _super.prototype.iAddOwner.call(this, owner);\n        this._baseMethod.iAddOwner(owner);\n    };\n    SpecularCompositeMethod.prototype.iRemoveOwner = function (owner) {\n        _super.prototype.iRemoveOwner.call(this, owner);\n        this._baseMethod.iRemoveOwner(owner);\n    };\n    Object.defineProperty(SpecularCompositeMethod.prototype, \"baseMethod\", {\n        /**\n         * The base specular method on which this method's shading is based.\n         */\n        get: function () {\n            return this._baseMethod;\n        },\n        set: function (value) {\n            if (this._baseMethod == value)\n                return;\n            this._baseMethod.removeEventListener(ShadingMethodEvent_1.default.SHADER_INVALIDATED, this._onShaderInvalidatedDelegate);\n            this._baseMethod = value;\n            this._baseMethod.addEventListener(ShadingMethodEvent_1.default.SHADER_INVALIDATED, this._onShaderInvalidatedDelegate);\n            this.iInvalidateShaderProgram();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(SpecularCompositeMethod.prototype, \"gloss\", {\n        /**\n         * @inheritDoc\n         */\n        get: function () {\n            return this._baseMethod.gloss;\n        },\n        set: function (value) {\n            this._baseMethod.gloss = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(SpecularCompositeMethod.prototype, \"strength\", {\n        /**\n         * @inheritDoc\n         */\n        get: function () {\n            return this._baseMethod.strength;\n        },\n        set: function (value) {\n            this._baseMethod.strength = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(SpecularCompositeMethod.prototype, \"color\", {\n        /**\n         * @inheritDoc\n         */\n        get: function () {\n            return this._baseMethod.color;\n        },\n        /**\n         * @inheritDoc\n         */\n        set: function (value) {\n            this._baseMethod.color = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * @inheritDoc\n     */\n    SpecularCompositeMethod.prototype.dispose = function () {\n        this._baseMethod.removeEventListener(ShadingMethodEvent_1.default.SHADER_INVALIDATED, this._onShaderInvalidatedDelegate);\n        this._baseMethod.dispose();\n    };\n    Object.defineProperty(SpecularCompositeMethod.prototype, \"texture\", {\n        /**\n         * @inheritDoc\n         */\n        get: function () {\n            return this._baseMethod.texture;\n        },\n        set: function (value) {\n            this._baseMethod.texture = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * @inheritDoc\n     */\n    SpecularCompositeMethod.prototype.iActivate = function (shader, methodVO, stage) {\n        this._baseMethod.iActivate(shader, methodVO, stage);\n    };\n    /**\n     * @inheritDoc\n     */\n    SpecularCompositeMethod.prototype.iSetRenderState = function (shader, methodVO, renderable, stage, camera) {\n        this._baseMethod.iSetRenderState(shader, methodVO, renderable, stage, camera);\n    };\n    /**\n     * @inheritDoc\n     */\n    SpecularCompositeMethod.prototype.iDeactivate = function (shader, methodVO, stage) {\n        this._baseMethod.iDeactivate(shader, methodVO, stage);\n    };\n    /**\n     * @inheritDoc\n     */\n    SpecularCompositeMethod.prototype.iGetVertexCode = function (shader, methodVO, registerCache, sharedRegisters) {\n        return this._baseMethod.iGetVertexCode(shader, methodVO, registerCache, sharedRegisters);\n    };\n    /**\n     * @inheritDoc\n     */\n    SpecularCompositeMethod.prototype.iGetFragmentPreLightingCode = function (shader, methodVO, registerCache, sharedRegisters) {\n        return this._baseMethod.iGetFragmentPreLightingCode(shader, methodVO, registerCache, sharedRegisters);\n    };\n    /**\n     * @inheritDoc\n     */\n    SpecularCompositeMethod.prototype.iGetFragmentCodePerLight = function (shader, methodVO, lightDirReg, lightColReg, registerCache, sharedRegisters) {\n        return this._baseMethod.iGetFragmentCodePerLight(shader, methodVO, lightDirReg, lightColReg, registerCache, sharedRegisters);\n    };\n    /**\n     * @inheritDoc\n     * @return\n     */\n    SpecularCompositeMethod.prototype.iGetFragmentCodePerProbe = function (shader, methodVO, cubeMapReg, weightRegister, registerCache, sharedRegisters) {\n        return this._baseMethod.iGetFragmentCodePerProbe(shader, methodVO, cubeMapReg, weightRegister, registerCache, sharedRegisters);\n    };\n    /**\n     * @inheritDoc\n     */\n    SpecularCompositeMethod.prototype.iGetFragmentPostLightingCode = function (shader, methodVO, targetReg, registerCache, sharedRegisters) {\n        return this._baseMethod.iGetFragmentPostLightingCode(shader, methodVO, targetReg, registerCache, sharedRegisters);\n    };\n    /**\n     * @inheritDoc\n     */\n    SpecularCompositeMethod.prototype.iReset = function () {\n        this._baseMethod.iReset();\n    };\n    /**\n     * @inheritDoc\n     */\n    SpecularCompositeMethod.prototype.iCleanCompilationData = function () {\n        _super.prototype.iCleanCompilationData.call(this);\n        this._baseMethod.iCleanCompilationData();\n    };\n    /**\n     * Called when the base method's shader code is invalidated.\n     */\n    SpecularCompositeMethod.prototype.onShaderInvalidated = function (event) {\n        this.iInvalidateShaderProgram();\n    };\n    return SpecularCompositeMethod;\n}(SpecularBasicMethod_1.default));\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = SpecularCompositeMethod;\n\n},{\"../methods/SpecularBasicMethod\":\"awayjs-methodmaterials/lib/methods/SpecularBasicMethod\",\"awayjs-renderergl/lib/events/ShadingMethodEvent\":undefined}],\"awayjs-methodmaterials/lib/methods/SpecularFresnelMethod\":[function(require,module,exports){\n\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar SpecularCompositeMethod_1 = require(\"../methods/SpecularCompositeMethod\");\n/**\n * SpecularFresnelMethod provides a specular shading method that causes stronger highlights on grazing view angles.\n */\nvar SpecularFresnelMethod = (function (_super) {\n    __extends(SpecularFresnelMethod, _super);\n    /**\n     * Creates a new SpecularFresnelMethod object.\n     * @param basedOnSurface Defines whether the fresnel effect should be based on the view angle on the surface (if true), or on the angle between the light and the view.\n     * @param baseMethod The specular method to which the fresnel equation. Defaults to SpecularBasicMethod.\n     */\n    function SpecularFresnelMethod(basedOnSurface, baseMethod) {\n        var _this = this;\n        if (basedOnSurface === void 0) { basedOnSurface = true; }\n        if (baseMethod === void 0) { baseMethod = null; }\n        // may want to offer diff speculars\n        _super.call(this, null, baseMethod);\n        this._fresnelPower = 5;\n        this._normalReflectance = .028; // default value for skin\n        this.baseMethod._iModulateMethod = function (shader, methodVO, targetReg, registerCache, sharedRegisters) { return _this.modulateSpecular(shader, methodVO, targetReg, registerCache, sharedRegisters); };\n        this._incidentLight = !basedOnSurface;\n    }\n    /**\n     * @inheritDoc\n     */\n    SpecularFresnelMethod.prototype.iInitConstants = function (shader, methodVO) {\n        var index = methodVO.secondaryFragmentConstantsIndex;\n        shader.fragmentConstantData[index + 2] = 1;\n        shader.fragmentConstantData[index + 3] = 0;\n    };\n    Object.defineProperty(SpecularFresnelMethod.prototype, \"basedOnSurface\", {\n        /**\n         * Defines whether the fresnel effect should be based on the view angle on the surface (if true), or on the angle between the light and the view.\n         */\n        get: function () {\n            return !this._incidentLight;\n        },\n        set: function (value) {\n            if (this._incidentLight != value)\n                return;\n            this._incidentLight = !value;\n            this.iInvalidateShaderProgram();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(SpecularFresnelMethod.prototype, \"fresnelPower\", {\n        /**\n         * The power used in the Fresnel equation. Higher values make the fresnel effect more pronounced. Defaults to 5.\n         */\n        get: function () {\n            return this._fresnelPower;\n        },\n        set: function (value) {\n            this._fresnelPower = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * @inheritDoc\n     */\n    SpecularFresnelMethod.prototype.iCleanCompilationData = function () {\n        _super.prototype.iCleanCompilationData.call(this);\n        this._dataReg = null;\n    };\n    Object.defineProperty(SpecularFresnelMethod.prototype, \"normalReflectance\", {\n        /**\n         * The minimum amount of reflectance, ie the reflectance when the view direction is normal to the surface or light direction.\n         */\n        get: function () {\n            return this._normalReflectance;\n        },\n        set: function (value) {\n            this._normalReflectance = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * @inheritDoc\n     */\n    SpecularFresnelMethod.prototype.iActivate = function (shader, methodVO, stage) {\n        _super.prototype.iActivate.call(this, shader, methodVO, stage);\n        var fragmentData = shader.fragmentConstantData;\n        var index = methodVO.secondaryFragmentConstantsIndex;\n        fragmentData[index] = this._normalReflectance;\n        fragmentData[index + 1] = this._fresnelPower;\n    };\n    /**\n     * @inheritDoc\n     */\n    SpecularFresnelMethod.prototype.iGetFragmentPreLightingCode = function (shader, methodVO, registerCache, sharedRegisters) {\n        this._dataReg = registerCache.getFreeFragmentConstant();\n        methodVO.secondaryFragmentConstantsIndex = this._dataReg.index * 4;\n        return _super.prototype.iGetFragmentPreLightingCode.call(this, shader, methodVO, registerCache, sharedRegisters);\n    };\n    /**\n     * Applies the fresnel effect to the specular strength.\n     *\n     * @param vo The MethodVO object containing the method data for the currently compiled material pass.\n     * @param target The register containing the specular strength in the \"w\" component, and the half-vector/reflection vector in \"xyz\".\n     * @param regCache The register cache used for the shader compilation.\n     * @param sharedRegisters The shared registers created by the compiler.\n     * @return The AGAL fragment code for the method.\n     */\n    SpecularFresnelMethod.prototype.modulateSpecular = function (shader, methodVO, targetReg, registerCache, sharedRegisters) {\n        var code;\n        code = \"dp3 \" + targetReg + \".y, \" + sharedRegisters.viewDirFragment + \".xyz, \" + (this._incidentLight ? targetReg : sharedRegisters.normalFragment) + \".xyz\\n\" +\n            \"sub \" + targetReg + \".y, \" + this._dataReg + \".z, \" + targetReg + \".y\\n\" +\n            \"pow \" + targetReg + \".x, \" + targetReg + \".y, \" + this._dataReg + \".y\\n\" +\n            \"sub \" + targetReg + \".y, \" + this._dataReg + \".z, \" + targetReg + \".y\\n\" +\n            \"mul \" + targetReg + \".y, \" + this._dataReg + \".x, \" + targetReg + \".y\\n\" +\n            \"add \" + targetReg + \".y, \" + targetReg + \".x, \" + targetReg + \".y\\n\" +\n            \"mul \" + targetReg + \".w, \" + targetReg + \".w, \" + targetReg + \".y\\n\";\n        return code;\n    };\n    return SpecularFresnelMethod;\n}(SpecularCompositeMethod_1.default));\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = SpecularFresnelMethod;\n\n},{\"../methods/SpecularCompositeMethod\":\"awayjs-methodmaterials/lib/methods/SpecularCompositeMethod\"}],\"awayjs-methodmaterials/lib/methods/SpecularPhongMethod\":[function(require,module,exports){\n\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar SpecularBasicMethod_1 = require(\"../methods/SpecularBasicMethod\");\n/**\n * SpecularPhongMethod provides a specular method that provides Phong highlights.\n */\nvar SpecularPhongMethod = (function (_super) {\n    __extends(SpecularPhongMethod, _super);\n    /**\n     * Creates a new SpecularPhongMethod object.\n     */\n    function SpecularPhongMethod() {\n        _super.call(this);\n    }\n    /**\n     * @inheritDoc\n     */\n    SpecularPhongMethod.prototype.iGetFragmentCodePerLight = function (shader, methodVO, lightDirReg, lightColReg, registerCache, sharedRegisters) {\n        var code = \"\";\n        var t;\n        if (this._pIsFirstLight) {\n            t = this._pTotalLightColorReg;\n        }\n        else {\n            t = registerCache.getFreeFragmentVectorTemp();\n            registerCache.addFragmentTempUsages(t, 1);\n        }\n        var viewDirReg = sharedRegisters.viewDirFragment;\n        var normalReg = sharedRegisters.normalFragment;\n        // phong model\n        code += \"dp3 \" + t + \".w, \" + lightDirReg + \", \" + normalReg + \"\\n\" +\n            //find the reflected light vector R\n            \"add \" + t + \".w, \" + t + \".w, \" + t + \".w\\n\" +\n            \"mul \" + t + \".xyz, \" + normalReg + \", \" + t + \".w\\n\" +\n            \"sub \" + t + \".xyz, \" + t + \", \" + lightDirReg + \"\\n\" +\n            //smooth the edge as incidence angle approaches 90\n            \"add \" + t + \".w, \" + t + \".w, \" + sharedRegisters.commons + \".w\\n\" +\n            \"sat \" + t + \".w, \" + t + \".w\\n\" +\n            \"mul \" + t + \".xyz, \" + t + \", \" + t + \".w\\n\" +\n            //find the dot product between R and V\n            \"dp3 \" + t + \".w, \" + t + \", \" + viewDirReg + \"\\n\" +\n            \"sat \" + t + \".w, \" + t + \".w\\n\";\n        if (this.texture) {\n            // apply gloss modulation from texture\n            code += \"mul \" + this._pSpecularTexData + \".w, \" + this._pSpecularTexData + \".y, \" + this._pSpecularDataRegister + \".w\\n\" +\n                \"pow \" + t + \".w, \" + t + \".w, \" + this._pSpecularTexData + \".w\\n\";\n        }\n        else\n            code += \"pow \" + t + \".w, \" + t + \".w, \" + this._pSpecularDataRegister + \".w\\n\";\n        // attenuate\n        if (shader.usesLightFallOff)\n            code += \"mul \" + t + \".w, \" + t + \".w, \" + lightDirReg + \".w\\n\";\n        if (this._iModulateMethod != null)\n            code += this._iModulateMethod(shader, methodVO, t, registerCache, sharedRegisters);\n        code += \"mul \" + t + \".xyz, \" + lightColReg + \".xyz, \" + t + \".w\\n\";\n        if (!this._pIsFirstLight) {\n            code += \"add \" + this._pTotalLightColorReg + \".xyz, \" + this._pTotalLightColorReg + \".xyz, \" + t + \".xyz\\n\";\n            registerCache.removeFragmentTempUsage(t);\n        }\n        this._pIsFirstLight = false;\n        return code;\n    };\n    return SpecularPhongMethod;\n}(SpecularBasicMethod_1.default));\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = SpecularPhongMethod;\n\n},{\"../methods/SpecularBasicMethod\":\"awayjs-methodmaterials/lib/methods/SpecularBasicMethod\"}],\"awayjs-methodmaterials/lib/methods\":[function(require,module,exports){\n\"use strict\";\nvar AmbientBasicMethod_1 = require(\"./methods/AmbientBasicMethod\");\nexports.AmbientBasicMethod = AmbientBasicMethod_1.default;\nvar AmbientEnvMapMethod_1 = require(\"./methods/AmbientEnvMapMethod\");\nexports.AmbientEnvMapMethod = AmbientEnvMapMethod_1.default;\nvar CurveBasicMethod_1 = require(\"./methods/CurveBasicMethod\");\nexports.CurveBasicMethod = CurveBasicMethod_1.default;\nvar DiffuseBasicMethod_1 = require(\"./methods/DiffuseBasicMethod\");\nexports.DiffuseBasicMethod = DiffuseBasicMethod_1.default;\nvar DiffuseCelMethod_1 = require(\"./methods/DiffuseCelMethod\");\nexports.DiffuseCelMethod = DiffuseCelMethod_1.default;\nvar DiffuseCompositeMethod_1 = require(\"./methods/DiffuseCompositeMethod\");\nexports.DiffuseCompositeMethod = DiffuseCompositeMethod_1.default;\nvar DiffuseDepthMethod_1 = require(\"./methods/DiffuseDepthMethod\");\nexports.DiffuseDepthMethod = DiffuseDepthMethod_1.default;\nvar DiffuseGradientMethod_1 = require(\"./methods/DiffuseGradientMethod\");\nexports.DiffuseGradientMethod = DiffuseGradientMethod_1.default;\nvar DiffuseLightMapMethod_1 = require(\"./methods/DiffuseLightMapMethod\");\nexports.DiffuseLightMapMethod = DiffuseLightMapMethod_1.default;\nvar DiffuseSubSurfaceMethod_1 = require(\"./methods/DiffuseSubSurfaceMethod\");\nexports.DiffuseSubSurfaceMethod = DiffuseSubSurfaceMethod_1.default;\nvar DiffuseWrapMethod_1 = require(\"./methods/DiffuseWrapMethod\");\nexports.DiffuseWrapMethod = DiffuseWrapMethod_1.default;\nvar EffectAlphaMaskMethod_1 = require(\"./methods/EffectAlphaMaskMethod\");\nexports.EffectAlphaMaskMethod = EffectAlphaMaskMethod_1.default;\nvar EffectColorMatrixMethod_1 = require(\"./methods/EffectColorMatrixMethod\");\nexports.EffectColorMatrixMethod = EffectColorMatrixMethod_1.default;\nvar EffectColorTransformMethod_1 = require(\"./methods/EffectColorTransformMethod\");\nexports.EffectColorTransformMethod = EffectColorTransformMethod_1.default;\nvar EffectEnvMapMethod_1 = require(\"./methods/EffectEnvMapMethod\");\nexports.EffectEnvMapMethod = EffectEnvMapMethod_1.default;\nvar EffectFogMethod_1 = require(\"./methods/EffectFogMethod\");\nexports.EffectFogMethod = EffectFogMethod_1.default;\nvar EffectFresnelEnvMapMethod_1 = require(\"./methods/EffectFresnelEnvMapMethod\");\nexports.EffectFresnelEnvMapMethod = EffectFresnelEnvMapMethod_1.default;\nvar EffectLightMapMethod_1 = require(\"./methods/EffectLightMapMethod\");\nexports.EffectLightMapMethod = EffectLightMapMethod_1.default;\nvar EffectMethodBase_1 = require(\"./methods/EffectMethodBase\");\nexports.EffectMethodBase = EffectMethodBase_1.default;\nvar EffectRefractionEnvMapMethod_1 = require(\"./methods/EffectRefractionEnvMapMethod\");\nexports.EffectRefractionEnvMapMethod = EffectRefractionEnvMapMethod_1.default;\nvar EffectRimLightMethod_1 = require(\"./methods/EffectRimLightMethod\");\nexports.EffectRimLightMethod = EffectRimLightMethod_1.default;\nvar LightingMethodBase_1 = require(\"./methods/LightingMethodBase\");\nexports.LightingMethodBase = LightingMethodBase_1.default;\nvar NormalBasicMethod_1 = require(\"./methods/NormalBasicMethod\");\nexports.NormalBasicMethod = NormalBasicMethod_1.default;\nvar NormalHeightMapMethod_1 = require(\"./methods/NormalHeightMapMethod\");\nexports.NormalHeightMapMethod = NormalHeightMapMethod_1.default;\nvar NormalSimpleWaterMethod_1 = require(\"./methods/NormalSimpleWaterMethod\");\nexports.NormalSimpleWaterMethod = NormalSimpleWaterMethod_1.default;\nvar ShadingMethodBase_1 = require(\"./methods/ShadingMethodBase\");\nexports.ShadingMethodBase = ShadingMethodBase_1.default;\nvar ShadowCascadeMethod_1 = require(\"./methods/ShadowCascadeMethod\");\nexports.ShadowCascadeMethod = ShadowCascadeMethod_1.default;\nvar ShadowDitheredMethod_1 = require(\"./methods/ShadowDitheredMethod\");\nexports.ShadowDitheredMethod = ShadowDitheredMethod_1.default;\nvar ShadowFilteredMethod_1 = require(\"./methods/ShadowFilteredMethod\");\nexports.ShadowFilteredMethod = ShadowFilteredMethod_1.default;\nvar ShadowHardMethod_1 = require(\"./methods/ShadowHardMethod\");\nexports.ShadowHardMethod = ShadowHardMethod_1.default;\nvar ShadowMapMethodBase_1 = require(\"./methods/ShadowMapMethodBase\");\nexports.ShadowMapMethodBase = ShadowMapMethodBase_1.default;\nvar ShadowMethodBase_1 = require(\"./methods/ShadowMethodBase\");\nexports.ShadowMethodBase = ShadowMethodBase_1.default;\nvar ShadowNearMethod_1 = require(\"./methods/ShadowNearMethod\");\nexports.ShadowNearMethod = ShadowNearMethod_1.default;\nvar ShadowSoftMethod_1 = require(\"./methods/ShadowSoftMethod\");\nexports.ShadowSoftMethod = ShadowSoftMethod_1.default;\nvar SpecularAnisotropicMethod_1 = require(\"./methods/SpecularAnisotropicMethod\");\nexports.SpecularAnisotropicMethod = SpecularAnisotropicMethod_1.default;\nvar SpecularBasicMethod_1 = require(\"./methods/SpecularBasicMethod\");\nexports.SpecularBasicMethod = SpecularBasicMethod_1.default;\nvar SpecularCelMethod_1 = require(\"./methods/SpecularCelMethod\");\nexports.SpecularCelMethod = SpecularCelMethod_1.default;\nvar SpecularCompositeMethod_1 = require(\"./methods/SpecularCompositeMethod\");\nexports.SpecularCompositeMethod = SpecularCompositeMethod_1.default;\nvar SpecularFresnelMethod_1 = require(\"./methods/SpecularFresnelMethod\");\nexports.SpecularFresnelMethod = SpecularFresnelMethod_1.default;\nvar SpecularPhongMethod_1 = require(\"./methods/SpecularPhongMethod\");\nexports.SpecularPhongMethod = SpecularPhongMethod_1.default;\n\n},{\"./methods/AmbientBasicMethod\":\"awayjs-methodmaterials/lib/methods/AmbientBasicMethod\",\"./methods/AmbientEnvMapMethod\":\"awayjs-methodmaterials/lib/methods/AmbientEnvMapMethod\",\"./methods/CurveBasicMethod\":\"awayjs-methodmaterials/lib/methods/CurveBasicMethod\",\"./methods/DiffuseBasicMethod\":\"awayjs-methodmaterials/lib/methods/DiffuseBasicMethod\",\"./methods/DiffuseCelMethod\":\"awayjs-methodmaterials/lib/methods/DiffuseCelMethod\",\"./methods/DiffuseCompositeMethod\":\"awayjs-methodmaterials/lib/methods/DiffuseCompositeMethod\",\"./methods/DiffuseDepthMethod\":\"awayjs-methodmaterials/lib/methods/DiffuseDepthMethod\",\"./methods/DiffuseGradientMethod\":\"awayjs-methodmaterials/lib/methods/DiffuseGradientMethod\",\"./methods/DiffuseLightMapMethod\":\"awayjs-methodmaterials/lib/methods/DiffuseLightMapMethod\",\"./methods/DiffuseSubSurfaceMethod\":\"awayjs-methodmaterials/lib/methods/DiffuseSubSurfaceMethod\",\"./methods/DiffuseWrapMethod\":\"awayjs-methodmaterials/lib/methods/DiffuseWrapMethod\",\"./methods/EffectAlphaMaskMethod\":\"awayjs-methodmaterials/lib/methods/EffectAlphaMaskMethod\",\"./methods/EffectColorMatrixMethod\":\"awayjs-methodmaterials/lib/methods/EffectColorMatrixMethod\",\"./methods/EffectColorTransformMethod\":\"awayjs-methodmaterials/lib/methods/EffectColorTransformMethod\",\"./methods/EffectEnvMapMethod\":\"awayjs-methodmaterials/lib/methods/EffectEnvMapMethod\",\"./methods/EffectFogMethod\":\"awayjs-methodmaterials/lib/methods/EffectFogMethod\",\"./methods/EffectFresnelEnvMapMethod\":\"awayjs-methodmaterials/lib/methods/EffectFresnelEnvMapMethod\",\"./methods/EffectLightMapMethod\":\"awayjs-methodmaterials/lib/methods/EffectLightMapMethod\",\"./methods/EffectMethodBase\":\"awayjs-methodmaterials/lib/methods/EffectMethodBase\",\"./methods/EffectRefractionEnvMapMethod\":\"awayjs-methodmaterials/lib/methods/EffectRefractionEnvMapMethod\",\"./methods/EffectRimLightMethod\":\"awayjs-methodmaterials/lib/methods/EffectRimLightMethod\",\"./methods/LightingMethodBase\":\"awayjs-methodmaterials/lib/methods/LightingMethodBase\",\"./methods/NormalBasicMethod\":\"awayjs-methodmaterials/lib/methods/NormalBasicMethod\",\"./methods/NormalHeightMapMethod\":\"awayjs-methodmaterials/lib/methods/NormalHeightMapMethod\",\"./methods/NormalSimpleWaterMethod\":\"awayjs-methodmaterials/lib/methods/NormalSimpleWaterMethod\",\"./methods/ShadingMethodBase\":\"awayjs-methodmaterials/lib/methods/ShadingMethodBase\",\"./methods/ShadowCascadeMethod\":\"awayjs-methodmaterials/lib/methods/ShadowCascadeMethod\",\"./methods/ShadowDitheredMethod\":\"awayjs-methodmaterials/lib/methods/ShadowDitheredMethod\",\"./methods/ShadowFilteredMethod\":\"awayjs-methodmaterials/lib/methods/ShadowFilteredMethod\",\"./methods/ShadowHardMethod\":\"awayjs-methodmaterials/lib/methods/ShadowHardMethod\",\"./methods/ShadowMapMethodBase\":\"awayjs-methodmaterials/lib/methods/ShadowMapMethodBase\",\"./methods/ShadowMethodBase\":\"awayjs-methodmaterials/lib/methods/ShadowMethodBase\",\"./methods/ShadowNearMethod\":\"awayjs-methodmaterials/lib/methods/ShadowNearMethod\",\"./methods/ShadowSoftMethod\":\"awayjs-methodmaterials/lib/methods/ShadowSoftMethod\",\"./methods/SpecularAnisotropicMethod\":\"awayjs-methodmaterials/lib/methods/SpecularAnisotropicMethod\",\"./methods/SpecularBasicMethod\":\"awayjs-methodmaterials/lib/methods/SpecularBasicMethod\",\"./methods/SpecularCelMethod\":\"awayjs-methodmaterials/lib/methods/SpecularCelMethod\",\"./methods/SpecularCompositeMethod\":\"awayjs-methodmaterials/lib/methods/SpecularCompositeMethod\",\"./methods/SpecularFresnelMethod\":\"awayjs-methodmaterials/lib/methods/SpecularFresnelMethod\",\"./methods/SpecularPhongMethod\":\"awayjs-methodmaterials/lib/methods/SpecularPhongMethod\"}],\"awayjs-methodmaterials/lib/surfaces/GL_MethodMaterialSurface\":[function(require,module,exports){\n\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar BlendMode_1 = require(\"awayjs-core/lib/image/BlendMode\");\nvar StaticLightPicker_1 = require(\"awayjs-display/lib/materials/lightpickers/StaticLightPicker\");\nvar ContextGLCompareMode_1 = require(\"awayjs-stagegl/lib/base/ContextGLCompareMode\");\nvar GL_SurfaceBase_1 = require(\"awayjs-renderergl/lib/surfaces/GL_SurfaceBase\");\nvar MethodMaterialMode_1 = require(\"../MethodMaterialMode\");\nvar MethodPassMode_1 = require(\"../surfaces/passes/MethodPassMode\");\nvar MethodPass_1 = require(\"../surfaces/passes/MethodPass\");\n/**\n * CompiledPass forms an abstract base class for the default compiled pass materials provided by Away3D,\n * using material methods to define their appearance.\n */\nvar GL_MethodMaterialSurface = (function (_super) {\n    __extends(GL_MethodMaterialSurface, _super);\n    /**\n     * Creates a new CompiledPass object.\n     *\n     * @param material The material to which this pass belongs.\n     */\n    function GL_MethodMaterialSurface(material, elementsClass, pool) {\n        _super.call(this, material, elementsClass, pool);\n        this._material = material;\n    }\n    Object.defineProperty(GL_MethodMaterialSurface.prototype, \"numLights\", {\n        /**\n         * The maximum total number of lights provided by the light picker.\n         */\n        get: function () {\n            return this._material.lightPicker ? this._material.lightPicker.numLightProbes + this._material.lightPicker.numDirectionalLights + this._material.lightPicker.numPointLights + this._material.lightPicker.numCastingDirectionalLights + this._material.lightPicker.numCastingPointLights : 0;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(GL_MethodMaterialSurface.prototype, \"numNonCasters\", {\n        /**\n         * The amount of lights that don't cast shadows.\n         */\n        get: function () {\n            return this._material.lightPicker ? this._material.lightPicker.numLightProbes + this._material.lightPicker.numDirectionalLights + this._material.lightPicker.numPointLights : 0;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * @inheritDoc\n     */\n    GL_MethodMaterialSurface.prototype._pUpdateRender = function () {\n        _super.prototype._pUpdateRender.call(this);\n        this.initPasses();\n        this.setBlendAndCompareModes();\n        this._pClearPasses();\n        if (this._material.mode == MethodMaterialMode_1.default.MULTI_PASS) {\n            if (this._casterLightPass)\n                this._pAddPass(this._casterLightPass);\n            if (this._nonCasterLightPasses)\n                for (var i = 0; i < this._nonCasterLightPasses.length; ++i)\n                    this._pAddPass(this._nonCasterLightPasses[i]);\n        }\n        if (this._pass)\n            this._pAddPass(this._pass);\n    };\n    /**\n     * Initializes all the passes and their dependent passes.\n     */\n    GL_MethodMaterialSurface.prototype.initPasses = function () {\n        // let the effects pass handle everything if there are no lights, when there are effect methods applied\n        // after shading, or when the material mode is single pass.\n        if (this.numLights == 0 || this._material.numEffectMethods > 0 || this._material.mode == MethodMaterialMode_1.default.SINGLE_PASS)\n            this.initEffectPass();\n        else if (this._pass)\n            this.removeEffectPass();\n        // only use a caster light pass if shadows need to be rendered\n        if (this._material.shadowMethod && this._material.mode == MethodMaterialMode_1.default.MULTI_PASS)\n            this.initCasterLightPass();\n        else if (this._casterLightPass)\n            this.removeCasterLightPass();\n        // only use non caster light passes if there are lights that don't cast\n        if (this.numNonCasters > 0 && this._material.mode == MethodMaterialMode_1.default.MULTI_PASS)\n            this.initNonCasterLightPasses();\n        else if (this._nonCasterLightPasses)\n            this.removeNonCasterLightPasses();\n    };\n    /**\n     * Sets up the various blending modes for all screen passes, based on whether or not there are previous passes.\n     */\n    GL_MethodMaterialSurface.prototype.setBlendAndCompareModes = function () {\n        var forceSeparateMVP = Boolean(this._casterLightPass || this._pass);\n        // caster light pass is always first if it exists, hence it uses normal blending\n        if (this._casterLightPass) {\n            this._casterLightPass.forceSeparateMVP = forceSeparateMVP;\n            this._casterLightPass.shader.setBlendMode(BlendMode_1.default.NORMAL);\n            this._casterLightPass.shader.depthCompareMode = this._material.depthCompareMode;\n        }\n        if (this._nonCasterLightPasses) {\n            var firstAdditiveIndex = 0;\n            // if there's no caster light pass, the first non caster light pass will be the first\n            // and should use normal blending\n            if (!this._casterLightPass) {\n                this._nonCasterLightPasses[0].forceSeparateMVP = forceSeparateMVP;\n                this._nonCasterLightPasses[0].shader.setBlendMode(BlendMode_1.default.NORMAL);\n                this._nonCasterLightPasses[0].shader.depthCompareMode = this._material.depthCompareMode;\n                firstAdditiveIndex = 1;\n            }\n            // all lighting passes following the first light pass should use additive blending\n            for (var i = firstAdditiveIndex; i < this._nonCasterLightPasses.length; ++i) {\n                this._nonCasterLightPasses[i].forceSeparateMVP = forceSeparateMVP;\n                this._nonCasterLightPasses[i].shader.setBlendMode(BlendMode_1.default.ADD);\n                this._nonCasterLightPasses[i].shader.depthCompareMode = ContextGLCompareMode_1.default.LESS_EQUAL;\n            }\n        }\n        if (this._casterLightPass || this._nonCasterLightPasses) {\n            //cannot be blended by blendmode property if multipass enabled\n            this._pRequiresBlending = false;\n            // there are light passes, so this should be blended in\n            if (this._pass) {\n                this._pass.mode = MethodPassMode_1.default.EFFECTS;\n                this._pass.forceSeparateMVP = forceSeparateMVP;\n                this._pass.shader.depthCompareMode = ContextGLCompareMode_1.default.LESS_EQUAL;\n                this._pass.shader.setBlendMode(BlendMode_1.default.LAYER);\n            }\n        }\n        else if (this._pass) {\n            this._pRequiresBlending = (this._material.blendMode != BlendMode_1.default.NORMAL || this._material.alphaBlending || (this._material.colorTransform && this._material.colorTransform.alphaMultiplier < 1));\n            // effects pass is the only pass, so it should just blend normally\n            this._pass.mode = MethodPassMode_1.default.SUPER_SHADER;\n            this._pass.preserveAlpha = this._pRequiresBlending;\n            this._pass.forceSeparateMVP = false;\n            this._pass.colorTransform = this._material.colorTransform;\n            this._pass.shader.setBlendMode((this._material.blendMode == BlendMode_1.default.NORMAL && this._pRequiresBlending) ? BlendMode_1.default.LAYER : this._material.blendMode);\n            this._pass.shader.depthCompareMode = this._material.depthCompareMode;\n        }\n    };\n    GL_MethodMaterialSurface.prototype.initCasterLightPass = function () {\n        if (this._casterLightPass == null)\n            this._casterLightPass = new MethodPass_1.default(MethodPassMode_1.default.LIGHTING, this, this._material, this._elementsClass, this._stage);\n        this._casterLightPass.lightPicker = new StaticLightPicker_1.default([this._material.shadowMethod.castingLight]);\n        this._casterLightPass.shadowMethod = this._material.shadowMethod;\n        this._casterLightPass.diffuseMethod = this._material.diffuseMethod;\n        this._casterLightPass.ambientMethod = this._material.ambientMethod;\n        this._casterLightPass.normalMethod = this._material.normalMethod;\n        this._casterLightPass.specularMethod = this._material.specularMethod;\n    };\n    GL_MethodMaterialSurface.prototype.removeCasterLightPass = function () {\n        this._casterLightPass.dispose();\n        this._pRemovePass(this._casterLightPass);\n        this._casterLightPass = null;\n    };\n    GL_MethodMaterialSurface.prototype.initNonCasterLightPasses = function () {\n        this.removeNonCasterLightPasses();\n        var pass;\n        var numDirLights = this._material.lightPicker.numDirectionalLights;\n        var numPointLights = this._material.lightPicker.numPointLights;\n        var numLightProbes = this._material.lightPicker.numLightProbes;\n        var dirLightOffset = 0;\n        var pointLightOffset = 0;\n        var probeOffset = 0;\n        if (!this._casterLightPass) {\n            numDirLights += this._material.lightPicker.numCastingDirectionalLights;\n            numPointLights += this._material.lightPicker.numCastingPointLights;\n        }\n        this._nonCasterLightPasses = new Array();\n        while (dirLightOffset < numDirLights || pointLightOffset < numPointLights || probeOffset < numLightProbes) {\n            pass = new MethodPass_1.default(MethodPassMode_1.default.LIGHTING, this, this._material, this._elementsClass, this._stage);\n            pass.includeCasters = this._material.shadowMethod == null;\n            pass.directionalLightsOffset = dirLightOffset;\n            pass.pointLightsOffset = pointLightOffset;\n            pass.lightProbesOffset = probeOffset;\n            pass.lightPicker = this._material.lightPicker;\n            pass.diffuseMethod = this._material.diffuseMethod;\n            pass.ambientMethod = this._material.ambientMethod;\n            pass.normalMethod = this._material.normalMethod;\n            pass.specularMethod = this._material.specularMethod;\n            this._nonCasterLightPasses.push(pass);\n            dirLightOffset += pass.numDirectionalLights;\n            pointLightOffset += pass.numPointLights;\n            probeOffset += pass.numLightProbes;\n        }\n    };\n    GL_MethodMaterialSurface.prototype.removeNonCasterLightPasses = function () {\n        if (!this._nonCasterLightPasses)\n            return;\n        for (var i = 0; i < this._nonCasterLightPasses.length; ++i)\n            this._pRemovePass(this._nonCasterLightPasses[i]);\n        this._nonCasterLightPasses = null;\n    };\n    GL_MethodMaterialSurface.prototype.removeEffectPass = function () {\n        if (this._pass.ambientMethod != this._material.ambientMethod)\n            this._pass.ambientMethod.dispose();\n        if (this._pass.diffuseMethod != this._material.diffuseMethod)\n            this._pass.diffuseMethod.dispose();\n        if (this._pass.specularMethod != this._material.specularMethod)\n            this._pass.specularMethod.dispose();\n        if (this._pass.normalMethod != this._material.normalMethod)\n            this._pass.normalMethod.dispose();\n        this._pRemovePass(this._pass);\n        this._pass = null;\n    };\n    GL_MethodMaterialSurface.prototype.initEffectPass = function () {\n        if (this._pass == null)\n            this._pass = new MethodPass_1.default(MethodPassMode_1.default.SUPER_SHADER, this, this._material, this._elementsClass, this._stage);\n        if (this._material.mode == MethodMaterialMode_1.default.SINGLE_PASS) {\n            this._pass.ambientMethod = this._material.ambientMethod;\n            this._pass.diffuseMethod = this._material.diffuseMethod;\n            this._pass.specularMethod = this._material.specularMethod;\n            this._pass.normalMethod = this._material.normalMethod;\n            this._pass.shadowMethod = this._material.shadowMethod;\n        }\n        else if (this._material.mode == MethodMaterialMode_1.default.MULTI_PASS) {\n            if (this.numLights == 0) {\n                this._pass.ambientMethod = this._material.ambientMethod;\n            }\n            else {\n                this._pass.ambientMethod = null;\n            }\n            this._pass.preserveAlpha = false;\n            this._pass.normalMethod = this._material.normalMethod;\n        }\n        //update effect methods\n        var i = 0;\n        var effectMethod;\n        var len = Math.max(this._material.numEffectMethods, this._pass.numEffectMethods);\n        while (i < len) {\n            effectMethod = this._material.getEffectMethodAt(i);\n            if (effectMethod != this._pass.getEffectMethodAt(i)) {\n                this._pass.removeEffectMethodAt(i);\n                if (effectMethod != null) {\n                    if (i < this._pass.numEffectMethods)\n                        this._pass.addEffectMethodAt(effectMethod, i);\n                    else\n                        this._pass.addEffectMethod(effectMethod);\n                }\n            }\n            i++;\n        }\n    };\n    /**\n     * @inheritDoc\n     */\n    GL_MethodMaterialSurface.prototype.onClear = function (event) {\n        _super.prototype.onClear.call(this, event);\n        //TODO\n    };\n    return GL_MethodMaterialSurface;\n}(GL_SurfaceBase_1.default));\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = GL_MethodMaterialSurface;\n\n},{\"../MethodMaterialMode\":\"awayjs-methodmaterials/lib/MethodMaterialMode\",\"../surfaces/passes/MethodPass\":\"awayjs-methodmaterials/lib/surfaces/passes/MethodPass\",\"../surfaces/passes/MethodPassMode\":\"awayjs-methodmaterials/lib/surfaces/passes/MethodPassMode\",\"awayjs-core/lib/image/BlendMode\":undefined,\"awayjs-display/lib/materials/lightpickers/StaticLightPicker\":undefined,\"awayjs-renderergl/lib/surfaces/GL_SurfaceBase\":undefined,\"awayjs-stagegl/lib/base/ContextGLCompareMode\":undefined}],\"awayjs-methodmaterials/lib/surfaces/passes/MethodPassMode\":[function(require,module,exports){\n\"use strict\";\nvar PassMode = (function () {\n    function PassMode() {\n    }\n    /**\n     *\n     */\n    PassMode.EFFECTS = 0x01;\n    /**\n     *\n     */\n    PassMode.LIGHTING = 0x02;\n    /**\n     *\n     */\n    PassMode.SUPER_SHADER = 0x03;\n    return PassMode;\n}());\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = PassMode;\n\n},{}],\"awayjs-methodmaterials/lib/surfaces/passes/MethodPass\":[function(require,module,exports){\n\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar AssetEvent_1 = require(\"awayjs-core/lib/events/AssetEvent\");\nvar LightSources_1 = require(\"awayjs-display/lib/materials/LightSources\");\nvar LightingShader_1 = require(\"awayjs-renderergl/lib/shaders/LightingShader\");\nvar ShadingMethodEvent_1 = require(\"awayjs-renderergl/lib/events/ShadingMethodEvent\");\nvar ShaderBase_1 = require(\"awayjs-renderergl/lib/shaders/ShaderBase\");\nvar PassBase_1 = require(\"awayjs-renderergl/lib/surfaces/passes/PassBase\");\nvar MethodVO_1 = require(\"../../data/MethodVO\");\nvar EffectColorTransformMethod_1 = require(\"../../methods/EffectColorTransformMethod\");\nvar MethodPassMode_1 = require(\"../../surfaces/passes/MethodPassMode\");\n/**\n * CompiledPass forms an abstract base class for the default compiled pass materials provided by Away3D,\n * using material methods to define their appearance.\n */\nvar MethodPass = (function (_super) {\n    __extends(MethodPass, _super);\n    /**\n     * Creates a new CompiledPass object.\n     *\n     * @param material The material to which this pass belongs.\n     */\n    function MethodPass(mode, render, renderOwner, elementsClass, stage) {\n        var _this = this;\n        _super.call(this, render, renderOwner, elementsClass, stage);\n        this._maxLights = 3;\n        this._mode = 0x03;\n        this._includeCasters = true;\n        this._iMethodVOs = new Array();\n        this._numEffectDependencies = 0;\n        this.numDirectionalLights = 0;\n        this.numPointLights = 0;\n        this.numLightProbes = 0;\n        this.pointLightsOffset = 0;\n        this.directionalLightsOffset = 0;\n        this.lightProbesOffset = 0;\n        this._mode = mode;\n        this._material = renderOwner;\n        this._onLightsChangeDelegate = function (event) { return _this.onLightsChange(event); };\n        this._onMethodInvalidatedDelegate = function (event) { return _this.onMethodInvalidated(event); };\n        this.lightPicker = renderOwner.lightPicker;\n        if (this._shader == null)\n            this._updateShader();\n    }\n    Object.defineProperty(MethodPass.prototype, \"mode\", {\n        /**\n         *\n         */\n        get: function () {\n            return this._mode;\n        },\n        set: function (value) {\n            if (this._mode == value)\n                return;\n            this._mode = value;\n            this._updateLights();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MethodPass.prototype, \"includeCasters\", {\n        /**\n         * Indicates whether or not shadow casting lights need to be included.\n         */\n        get: function () {\n            return this._includeCasters;\n        },\n        set: function (value) {\n            if (this._includeCasters == value)\n                return;\n            this._includeCasters = value;\n            this._updateLights();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MethodPass.prototype, \"lightPicker\", {\n        /**\n         *\n         * @returns {LightPickerBase}\n         */\n        get: function () {\n            return this._lightPicker;\n        },\n        set: function (value) {\n            //if (this._lightPicker == value)\n            //\treturn;\n            if (this._lightPicker)\n                this._lightPicker.removeEventListener(AssetEvent_1.default.INVALIDATE, this._onLightsChangeDelegate);\n            this._lightPicker = value;\n            if (this._lightPicker)\n                this._lightPicker.addEventListener(AssetEvent_1.default.INVALIDATE, this._onLightsChangeDelegate);\n            this._updateLights();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MethodPass.prototype, \"enableLightFallOff\", {\n        /**\n         * Whether or not to use fallOff and radius properties for lights. This can be used to improve performance and\n         * compatibility for constrained mode.\n         */\n        get: function () {\n            return this._material.enableLightFallOff;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MethodPass.prototype, \"diffuseLightSources\", {\n        /**\n         * Define which light source types to use for diffuse reflections. This allows choosing between regular lights\n         * and/or light probes for diffuse reflections.\n         *\n         * @see away3d.materials.LightSources\n         */\n        get: function () {\n            return this._material.diffuseLightSources;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MethodPass.prototype, \"specularLightSources\", {\n        /**\n         * Define which light source types to use for specular reflections. This allows choosing between regular lights\n         * and/or light probes for specular reflections.\n         *\n         * @see away3d.materials.LightSources\n         */\n        get: function () {\n            return this._material.specularLightSources;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    MethodPass.prototype._updateShader = function () {\n        if ((this.numDirectionalLights || this.numPointLights || this.numLightProbes) && !(this._shader instanceof LightingShader_1.default)) {\n            if (this._shader != null)\n                this._shader.dispose();\n            this._shader = new LightingShader_1.default(this._elementsClass, this, this._stage);\n        }\n        else if (!(this._shader instanceof ShaderBase_1.default)) {\n            if (this._shader != null)\n                this._shader.dispose();\n            this._shader = new ShaderBase_1.default(this._elementsClass, this, this._stage);\n        }\n    };\n    /**\n     * Initializes the unchanging constant data for this material.\n     */\n    MethodPass.prototype._iInitConstantData = function (shader) {\n        _super.prototype._iInitConstantData.call(this, shader);\n        //Updates method constants if they have changed.\n        var len = this._iMethodVOs.length;\n        for (var i = 0; i < len; ++i)\n            this._iMethodVOs[i].method.iInitConstants(shader, this._iMethodVOs[i]);\n    };\n    Object.defineProperty(MethodPass.prototype, \"colorTransform\", {\n        /**\n         * The ColorTransform object to transform the colour of the material with. Defaults to null.\n         */\n        get: function () {\n            return this.colorTransformMethod ? this.colorTransformMethod.colorTransform : null;\n        },\n        set: function (value) {\n            if (value) {\n                if (this.colorTransformMethod == null)\n                    this.colorTransformMethod = new EffectColorTransformMethod_1.default();\n                this.colorTransformMethod.colorTransform = value;\n            }\n            else if (!value) {\n                if (this.colorTransformMethod)\n                    this.colorTransformMethod = null;\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MethodPass.prototype, \"colorTransformMethod\", {\n        /**\n         * The EffectColorTransformMethod object to transform the colour of the material with. Defaults to null.\n         */\n        get: function () {\n            return this._iColorTransformMethodVO ? this._iColorTransformMethodVO.method : null;\n        },\n        set: function (value) {\n            if (this._iColorTransformMethodVO && this._iColorTransformMethodVO.method == value)\n                return;\n            if (this._iColorTransformMethodVO) {\n                this._removeDependency(this._iColorTransformMethodVO);\n                this._iColorTransformMethodVO = null;\n            }\n            if (value) {\n                this._iColorTransformMethodVO = new MethodVO_1.default(value, this);\n                this._addDependency(this._iColorTransformMethodVO);\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    MethodPass.prototype._removeDependency = function (methodVO, effectsDependency) {\n        if (effectsDependency === void 0) { effectsDependency = false; }\n        var index = this._iMethodVOs.indexOf(methodVO);\n        if (!effectsDependency)\n            this._numEffectDependencies--;\n        methodVO.method.removeEventListener(ShadingMethodEvent_1.default.SHADER_INVALIDATED, this._onMethodInvalidatedDelegate);\n        this._iMethodVOs.splice(index, 1);\n        this.invalidate();\n    };\n    MethodPass.prototype._addDependency = function (methodVO, effectsDependency, index) {\n        if (effectsDependency === void 0) { effectsDependency = false; }\n        if (index === void 0) { index = -1; }\n        methodVO.method.addEventListener(ShadingMethodEvent_1.default.SHADER_INVALIDATED, this._onMethodInvalidatedDelegate);\n        if (effectsDependency) {\n            if (index != -1)\n                this._iMethodVOs.splice(index + this._iMethodVOs.length - this._numEffectDependencies, 0, methodVO);\n            else\n                this._iMethodVOs.push(methodVO);\n            this._numEffectDependencies++;\n        }\n        else {\n            this._iMethodVOs.splice(this._iMethodVOs.length - this._numEffectDependencies, 0, methodVO);\n        }\n        this.invalidate();\n    };\n    /**\n     * Appends an \"effect\" shading method to the shader. Effect methods are those that do not influence the lighting\n     * but modulate the shaded colour, used for fog, outlines, etc. The method will be applied to the result of the\n     * methods added prior.\n     */\n    MethodPass.prototype.addEffectMethod = function (method) {\n        this._addDependency(new MethodVO_1.default(method, this), true);\n    };\n    Object.defineProperty(MethodPass.prototype, \"numEffectMethods\", {\n        /**\n         * The number of \"effect\" methods added to the material.\n         */\n        get: function () {\n            return this._numEffectDependencies;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Queries whether a given effects method was added to the material.\n     *\n     * @param method The method to be queried.\n     * @return true if the method was added to the material, false otherwise.\n     */\n    MethodPass.prototype.hasEffectMethod = function (method) {\n        return this.getDependencyForMethod(method) != null;\n    };\n    /**\n     * Returns the method added at the given index.\n     * @param index The index of the method to retrieve.\n     * @return The method at the given index.\n     */\n    MethodPass.prototype.getEffectMethodAt = function (index) {\n        if (index < 0 || index > this._numEffectDependencies - 1)\n            return null;\n        return this._iMethodVOs[index + this._iMethodVOs.length - this._numEffectDependencies].method;\n    };\n    /**\n     * Adds an effect method at the specified index amongst the methods already added to the material. Effect\n     * methods are those that do not influence the lighting but modulate the shaded colour, used for fog, outlines,\n     * etc. The method will be applied to the result of the methods with a lower index.\n     */\n    MethodPass.prototype.addEffectMethodAt = function (method, index) {\n        this._addDependency(new MethodVO_1.default(method, this), true, index);\n    };\n    /**\n     * Removes an effect method from the material.\n     * @param method The method to be removed.\n     */\n    MethodPass.prototype.removeEffectMethod = function (method) {\n        var methodVO = this.getDependencyForMethod(method);\n        if (methodVO != null)\n            this._removeDependency(methodVO, true);\n    };\n    /**\n     * remove an effect method at the specified index from the material.\n     */\n    MethodPass.prototype.removeEffectMethodAt = function (index) {\n        if (index < 0 || index > this._numEffectDependencies - 1)\n            return;\n        var methodVO = this._iMethodVOs[index + this._iMethodVOs.length - this._numEffectDependencies];\n        if (methodVO != null)\n            this._removeDependency(methodVO, true);\n    };\n    MethodPass.prototype.getDependencyForMethod = function (method) {\n        var len = this._iMethodVOs.length;\n        for (var i = 0; i < len; ++i)\n            if (this._iMethodVOs[i].method == method)\n                return this._iMethodVOs[i];\n        return null;\n    };\n    Object.defineProperty(MethodPass.prototype, \"normalMethod\", {\n        /**\n         * The method used to generate the per-pixel normals. Defaults to NormalBasicMethod.\n         */\n        get: function () {\n            return this._iNormalMethodVO ? this._iNormalMethodVO.method : null;\n        },\n        set: function (value) {\n            if (this._iNormalMethodVO && this._iNormalMethodVO.method == value)\n                return;\n            if (this._iNormalMethodVO) {\n                this._removeDependency(this._iNormalMethodVO);\n                this._iNormalMethodVO = null;\n            }\n            if (value) {\n                this._iNormalMethodVO = new MethodVO_1.default(value, this);\n                this._addDependency(this._iNormalMethodVO);\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MethodPass.prototype, \"ambientMethod\", {\n        /**\n         * The method that provides the ambient lighting contribution. Defaults to AmbientBasicMethod.\n         */\n        get: function () {\n            return this._iAmbientMethodVO ? this._iAmbientMethodVO.method : null;\n        },\n        set: function (value) {\n            if (this._iAmbientMethodVO && this._iAmbientMethodVO.method == value)\n                return;\n            if (this._iAmbientMethodVO) {\n                this._removeDependency(this._iAmbientMethodVO);\n                this._iAmbientMethodVO = null;\n            }\n            if (value) {\n                this._iAmbientMethodVO = new MethodVO_1.default(value, this);\n                this._addDependency(this._iAmbientMethodVO);\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MethodPass.prototype, \"shadowMethod\", {\n        /**\n         * The method used to render shadows cast on this surface, or null if no shadows are to be rendered. Defaults to null.\n         */\n        get: function () {\n            return this._iShadowMethodVO ? this._iShadowMethodVO.method : null;\n        },\n        set: function (value) {\n            if (this._iShadowMethodVO && this._iShadowMethodVO.method == value)\n                return;\n            if (this._iShadowMethodVO) {\n                this._removeDependency(this._iShadowMethodVO);\n                this._iShadowMethodVO = null;\n            }\n            if (value) {\n                this._iShadowMethodVO = new MethodVO_1.default(value, this);\n                this._addDependency(this._iShadowMethodVO);\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MethodPass.prototype, \"diffuseMethod\", {\n        /**\n         * The method that provides the diffuse lighting contribution. Defaults to DiffuseBasicMethod.\n         */\n        get: function () {\n            return this._iDiffuseMethodVO ? this._iDiffuseMethodVO.method : null;\n        },\n        set: function (value) {\n            if (this._iDiffuseMethodVO && this._iDiffuseMethodVO.method == value)\n                return;\n            if (this._iDiffuseMethodVO) {\n                this._removeDependency(this._iDiffuseMethodVO);\n                this._iDiffuseMethodVO = null;\n            }\n            if (value) {\n                this._iDiffuseMethodVO = new MethodVO_1.default(value, this);\n                this._addDependency(this._iDiffuseMethodVO);\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MethodPass.prototype, \"specularMethod\", {\n        /**\n         * The method that provides the specular lighting contribution. Defaults to SpecularBasicMethod.\n         */\n        get: function () {\n            return this._iSpecularMethodVO ? this._iSpecularMethodVO.method : null;\n        },\n        set: function (value) {\n            if (this._iSpecularMethodVO && this._iSpecularMethodVO.method == value)\n                return;\n            if (this._iSpecularMethodVO) {\n                this._removeDependency(this._iSpecularMethodVO);\n                this._iSpecularMethodVO = null;\n            }\n            if (value) {\n                this._iSpecularMethodVO = new MethodVO_1.default(value, this);\n                this._addDependency(this._iSpecularMethodVO);\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * @inheritDoc\n     */\n    MethodPass.prototype.dispose = function () {\n        if (this._lightPicker)\n            this._lightPicker.removeEventListener(AssetEvent_1.default.INVALIDATE, this._onLightsChangeDelegate);\n        while (this._iMethodVOs.length)\n            this._removeDependency(this._iMethodVOs[0]);\n        _super.prototype.dispose.call(this);\n        this._iMethodVOs = null;\n    };\n    /**\n     * Called when any method's shader code is invalidated.\n     */\n    MethodPass.prototype.onMethodInvalidated = function (event) {\n        this.invalidate();\n    };\n    // RENDER LOOP\n    /**\n     * @inheritDoc\n     */\n    MethodPass.prototype._iActivate = function (camera) {\n        _super.prototype._iActivate.call(this, camera);\n        var methodVO;\n        var len = this._iMethodVOs.length;\n        for (var i = 0; i < len; ++i) {\n            methodVO = this._iMethodVOs[i];\n            if (methodVO.useMethod)\n                methodVO.method.iActivate(this._shader, methodVO, this._stage);\n        }\n    };\n    /**\n     *\n     *\n     * @param renderable\n     * @param stage\n     * @param camera\n     */\n    MethodPass.prototype._iRender = function (renderable, camera, viewProjection) {\n        _super.prototype._iRender.call(this, renderable, camera, viewProjection);\n        var methodVO;\n        var len = this._iMethodVOs.length;\n        for (var i = 0; i < len; ++i) {\n            methodVO = this._iMethodVOs[i];\n            if (methodVO.useMethod)\n                methodVO.method.iSetRenderState(this._shader, methodVO, renderable, this._stage, camera);\n        }\n    };\n    /**\n     * @inheritDoc\n     */\n    MethodPass.prototype._iDeactivate = function () {\n        _super.prototype._iDeactivate.call(this);\n        var methodVO;\n        var len = this._iMethodVOs.length;\n        for (var i = 0; i < len; ++i) {\n            methodVO = this._iMethodVOs[i];\n            if (methodVO.useMethod)\n                methodVO.method.iDeactivate(this._shader, methodVO, this._stage);\n        }\n    };\n    MethodPass.prototype._iIncludeDependencies = function (shader) {\n        _super.prototype._iIncludeDependencies.call(this, shader);\n        //TODO: fragment animtion should be compatible with lighting pass\n        shader.usesFragmentAnimation = Boolean(this._mode == MethodPassMode_1.default.SUPER_SHADER);\n        if (shader.useAlphaPremultiplied && shader.usesBlending)\n            shader.usesCommonData = true;\n        var i;\n        var len = this._iMethodVOs.length;\n        for (i = 0; i < len; ++i)\n            this.setupAndCountDependencies(shader, this._iMethodVOs[i]);\n        var usesTangentSpace = true;\n        var methodVO;\n        for (i = 0; i < len; ++i) {\n            methodVO = this._iMethodVOs[i];\n            if ((methodVO.useMethod = methodVO.method.iIsUsed(shader)) && !methodVO.method.iUsesTangentSpace())\n                usesTangentSpace = false;\n        }\n        shader.outputsNormals = this._iNormalMethodVO && this._iNormalMethodVO.useMethod;\n        shader.outputsTangentNormals = shader.outputsNormals && this._iNormalMethodVO.method.iOutputsTangentNormals();\n        shader.usesTangentSpace = shader.outputsTangentNormals && !shader.usesProbes && usesTangentSpace;\n        if (!shader.usesTangentSpace) {\n            if (shader.viewDirDependencies > 0) {\n                shader.globalPosDependencies++;\n            }\n            else if (this.numPointLights > 0 && shader.usesLights) {\n                shader.globalPosDependencies++;\n                if (Boolean(this._mode & MethodPassMode_1.default.EFFECTS))\n                    shader.usesGlobalPosFragment = true;\n            }\n        }\n    };\n    /**\n     * Counts the dependencies for a given method.\n     * @param method The method to count the dependencies for.\n     * @param methodVO The method's data for this material.\n     */\n    MethodPass.prototype.setupAndCountDependencies = function (shader, methodVO) {\n        methodVO.reset();\n        methodVO.method.iInitVO(shader, methodVO);\n        if (methodVO.needsProjection)\n            shader.projectionDependencies++;\n        if (methodVO.needsGlobalVertexPos || methodVO.needsGlobalFragmentPos) {\n            shader.globalPosDependencies++;\n            if (methodVO.needsGlobalFragmentPos)\n                shader.usesGlobalPosFragment = true;\n        }\n        if (methodVO.needsNormals)\n            shader.normalDependencies++;\n        if (methodVO.needsTangents)\n            shader.tangentDependencies++;\n        if (methodVO.needsView)\n            shader.viewDirDependencies++;\n    };\n    MethodPass.prototype._iGetPreLightingVertexCode = function (shader, registerCache, sharedRegisters) {\n        var code = \"\";\n        if (this._iAmbientMethodVO && this._iAmbientMethodVO.useMethod)\n            code += this._iAmbientMethodVO.method.iGetVertexCode(shader, this._iAmbientMethodVO, registerCache, sharedRegisters);\n        if (this._iDiffuseMethodVO && this._iDiffuseMethodVO.useMethod)\n            code += this._iDiffuseMethodVO.method.iGetVertexCode(shader, this._iDiffuseMethodVO, registerCache, sharedRegisters);\n        if (this._iSpecularMethodVO && this._iSpecularMethodVO.useMethod)\n            code += this._iSpecularMethodVO.method.iGetVertexCode(shader, this._iSpecularMethodVO, registerCache, sharedRegisters);\n        return code;\n    };\n    MethodPass.prototype._iGetPreLightingFragmentCode = function (shader, registerCache, sharedRegisters) {\n        var code = \"\";\n        if (this._iAmbientMethodVO && this._iAmbientMethodVO.useMethod) {\n            code += this._iAmbientMethodVO.method.iGetFragmentCode(shader, this._iAmbientMethodVO, sharedRegisters.shadedTarget, registerCache, sharedRegisters);\n            if (this._iAmbientMethodVO.needsNormals)\n                registerCache.removeFragmentTempUsage(sharedRegisters.normalFragment);\n            if (this._iAmbientMethodVO.needsView)\n                registerCache.removeFragmentTempUsage(sharedRegisters.viewDirFragment);\n        }\n        if (this._iDiffuseMethodVO && this._iDiffuseMethodVO.useMethod)\n            code += this._iDiffuseMethodVO.method.iGetFragmentPreLightingCode(shader, this._iDiffuseMethodVO, registerCache, sharedRegisters);\n        if (this._iSpecularMethodVO && this._iSpecularMethodVO.useMethod)\n            code += this._iSpecularMethodVO.method.iGetFragmentPreLightingCode(shader, this._iSpecularMethodVO, registerCache, sharedRegisters);\n        return code;\n    };\n    MethodPass.prototype._iGetPerLightDiffuseFragmentCode = function (shader, lightDirReg, diffuseColorReg, registerCache, sharedRegisters) {\n        return this._iDiffuseMethodVO.method.iGetFragmentCodePerLight(shader, this._iDiffuseMethodVO, lightDirReg, diffuseColorReg, registerCache, sharedRegisters);\n    };\n    MethodPass.prototype._iGetPerLightSpecularFragmentCode = function (shader, lightDirReg, specularColorReg, registerCache, sharedRegisters) {\n        return this._iSpecularMethodVO.method.iGetFragmentCodePerLight(shader, this._iSpecularMethodVO, lightDirReg, specularColorReg, registerCache, sharedRegisters);\n    };\n    MethodPass.prototype._iGetPerProbeDiffuseFragmentCode = function (shader, texReg, weightReg, registerCache, sharedRegisters) {\n        return this._iDiffuseMethodVO.method.iGetFragmentCodePerProbe(shader, this._iDiffuseMethodVO, texReg, weightReg, registerCache, sharedRegisters);\n    };\n    MethodPass.prototype._iGetPerProbeSpecularFragmentCode = function (shader, texReg, weightReg, registerCache, sharedRegisters) {\n        return this._iSpecularMethodVO.method.iGetFragmentCodePerProbe(shader, this._iSpecularMethodVO, texReg, weightReg, registerCache, sharedRegisters);\n    };\n    MethodPass.prototype._iGetPostLightingVertexCode = function (shader, registerCache, sharedRegisters) {\n        var code = \"\";\n        if (this._iShadowMethodVO)\n            code += this._iShadowMethodVO.method.iGetVertexCode(shader, this._iShadowMethodVO, registerCache, sharedRegisters);\n        return code;\n    };\n    MethodPass.prototype._iGetPostLightingFragmentCode = function (shader, registerCache, sharedRegisters) {\n        var code = \"\";\n        if (shader.useAlphaPremultiplied && shader.usesBlending) {\n            code += \"add \" + sharedRegisters.shadedTarget + \".w, \" + sharedRegisters.shadedTarget + \".w, \" + sharedRegisters.commons + \".z\\n\" +\n                \"div \" + sharedRegisters.shadedTarget + \".xyz, \" + sharedRegisters.shadedTarget + \", \" + sharedRegisters.shadedTarget + \".w\\n\" +\n                \"sub \" + sharedRegisters.shadedTarget + \".w, \" + sharedRegisters.shadedTarget + \".w, \" + sharedRegisters.commons + \".z\\n\" +\n                \"sat \" + sharedRegisters.shadedTarget + \".xyz, \" + sharedRegisters.shadedTarget + \"\\n\";\n        }\n        if (this._iShadowMethodVO)\n            code += this._iShadowMethodVO.method.iGetFragmentCode(shader, this._iShadowMethodVO, sharedRegisters.shadowTarget, registerCache, sharedRegisters);\n        if (this._iDiffuseMethodVO && this._iDiffuseMethodVO.useMethod) {\n            code += this._iDiffuseMethodVO.method.iGetFragmentPostLightingCode(shader, this._iDiffuseMethodVO, sharedRegisters.shadedTarget, registerCache, sharedRegisters);\n            // resolve other dependencies as well?\n            if (this._iDiffuseMethodVO.needsNormals)\n                registerCache.removeFragmentTempUsage(sharedRegisters.normalFragment);\n            if (this._iDiffuseMethodVO.needsView)\n                registerCache.removeFragmentTempUsage(sharedRegisters.viewDirFragment);\n        }\n        if (this._iSpecularMethodVO && this._iSpecularMethodVO.useMethod) {\n            code += this._iSpecularMethodVO.method.iGetFragmentPostLightingCode(shader, this._iSpecularMethodVO, sharedRegisters.shadedTarget, registerCache, sharedRegisters);\n            if (this._iSpecularMethodVO.needsNormals)\n                registerCache.removeFragmentTempUsage(sharedRegisters.normalFragment);\n            if (this._iSpecularMethodVO.needsView)\n                registerCache.removeFragmentTempUsage(sharedRegisters.viewDirFragment);\n        }\n        if (this._iShadowMethodVO)\n            registerCache.removeFragmentTempUsage(sharedRegisters.shadowTarget);\n        return code;\n    };\n    MethodPass.prototype._iGetNormalVertexCode = function (shader, registerCache, sharedRegisters) {\n        return this._iNormalMethodVO.method.iGetVertexCode(shader, this._iNormalMethodVO, registerCache, sharedRegisters);\n    };\n    MethodPass.prototype._iGetNormalFragmentCode = function (shader, registerCache, sharedRegisters) {\n        var code = this._iNormalMethodVO.method.iGetFragmentCode(shader, this._iNormalMethodVO, sharedRegisters.normalFragment, registerCache, sharedRegisters);\n        if (this._iNormalMethodVO.needsView)\n            registerCache.removeFragmentTempUsage(sharedRegisters.viewDirFragment);\n        if (this._iNormalMethodVO.needsGlobalFragmentPos || this._iNormalMethodVO.needsGlobalVertexPos)\n            registerCache.removeVertexTempUsage(sharedRegisters.globalPositionVertex);\n        return code;\n    };\n    /**\n     * @inheritDoc\n     */\n    MethodPass.prototype._iGetVertexCode = function (shader, regCache, sharedReg) {\n        var code = \"\";\n        var methodVO;\n        var len = this._iMethodVOs.length;\n        for (var i = len - this._numEffectDependencies; i < len; i++) {\n            methodVO = this._iMethodVOs[i];\n            if (methodVO.useMethod) {\n                code += methodVO.method.iGetVertexCode(shader, methodVO, regCache, sharedReg);\n                if (methodVO.needsGlobalVertexPos || methodVO.needsGlobalFragmentPos)\n                    regCache.removeVertexTempUsage(sharedReg.globalPositionVertex);\n            }\n        }\n        if (this._iColorTransformMethodVO && this._iColorTransformMethodVO.useMethod)\n            code += this._iColorTransformMethodVO.method.iGetVertexCode(shader, this._iColorTransformMethodVO, regCache, sharedReg);\n        return code;\n    };\n    /**\n     * @inheritDoc\n     */\n    MethodPass.prototype._iGetFragmentCode = function (shader, regCache, sharedReg) {\n        var code = \"\";\n        var alphaReg;\n        if (this.preserveAlpha && this._numEffectDependencies > 0) {\n            alphaReg = regCache.getFreeFragmentSingleTemp();\n            regCache.addFragmentTempUsages(alphaReg, 1);\n            code += \"mov \" + alphaReg + \", \" + sharedReg.shadedTarget + \".w\\n\";\n        }\n        var methodVO;\n        var len = this._iMethodVOs.length;\n        for (var i = len - this._numEffectDependencies; i < len; i++) {\n            methodVO = this._iMethodVOs[i];\n            if (methodVO.useMethod) {\n                code += methodVO.method.iGetFragmentCode(shader, methodVO, sharedReg.shadedTarget, regCache, sharedReg);\n                if (methodVO.needsNormals)\n                    regCache.removeFragmentTempUsage(sharedReg.normalFragment);\n                if (methodVO.needsView)\n                    regCache.removeFragmentTempUsage(sharedReg.viewDirFragment);\n            }\n        }\n        if (this.preserveAlpha && this._numEffectDependencies > 0) {\n            code += \"mov \" + sharedReg.shadedTarget + \".w, \" + alphaReg + \"\\n\";\n            regCache.removeFragmentTempUsage(alphaReg);\n        }\n        if (this._iColorTransformMethodVO && this._iColorTransformMethodVO.useMethod)\n            code += this._iColorTransformMethodVO.method.iGetFragmentCode(shader, this._iColorTransformMethodVO, sharedReg.shadedTarget, regCache, sharedReg);\n        return code;\n    };\n    /**\n     * Indicates whether the shader uses any shadows.\n     */\n    MethodPass.prototype._iUsesShadows = function (shader) {\n        return Boolean(this._iShadowMethodVO && (this._lightPicker.castingDirectionalLights.length > 0 || this._lightPicker.castingPointLights.length > 0));\n    };\n    /**\n     * Indicates whether the shader uses any specular component.\n     */\n    MethodPass.prototype._iUsesSpecular = function (shader) {\n        return Boolean(this._iSpecularMethodVO);\n    };\n    /**\n     * Indicates whether the shader uses any specular component.\n     */\n    MethodPass.prototype._iUsesDiffuse = function (shader) {\n        return Boolean(this._iDiffuseMethodVO);\n    };\n    MethodPass.prototype.onLightsChange = function (event) {\n        this._updateLights();\n    };\n    MethodPass.prototype._updateLights = function () {\n        var numDirectionalLightsOld = this.numDirectionalLights;\n        var numPointLightsOld = this.numPointLights;\n        var numLightProbesOld = this.numLightProbes;\n        if (this._lightPicker && (this._mode & MethodPassMode_1.default.LIGHTING)) {\n            this.numDirectionalLights = this.calculateNumDirectionalLights(this._lightPicker.numDirectionalLights);\n            this.numPointLights = this.calculateNumPointLights(this._lightPicker.numPointLights);\n            this.numLightProbes = this.calculateNumProbes(this._lightPicker.numLightProbes);\n            if (this._includeCasters) {\n                this.numDirectionalLights += this._lightPicker.numCastingDirectionalLights;\n                this.numPointLights += this._lightPicker.numCastingPointLights;\n            }\n        }\n        else {\n            this.numDirectionalLights = 0;\n            this.numPointLights = 0;\n            this.numLightProbes = 0;\n        }\n        if (numDirectionalLightsOld != this.numDirectionalLights || numPointLightsOld != this.numPointLights || numLightProbesOld != this.numLightProbes) {\n            this._updateShader();\n            this.invalidate();\n        }\n    };\n    /**\n     * Calculates the amount of directional lights this material will support.\n     * @param numDirectionalLights The maximum amount of directional lights to support.\n     * @return The amount of directional lights this material will support, bounded by the amount necessary.\n     */\n    MethodPass.prototype.calculateNumDirectionalLights = function (numDirectionalLights) {\n        return Math.min(numDirectionalLights - this.directionalLightsOffset, this._maxLights);\n    };\n    /**\n     * Calculates the amount of point lights this material will support.\n     * @param numDirectionalLights The maximum amount of point lights to support.\n     * @return The amount of point lights this material will support, bounded by the amount necessary.\n     */\n    MethodPass.prototype.calculateNumPointLights = function (numPointLights) {\n        var numFree = this._maxLights - this.numDirectionalLights;\n        return Math.min(numPointLights - this.pointLightsOffset, numFree);\n    };\n    /**\n     * Calculates the amount of light probes this material will support.\n     * @param numDirectionalLights The maximum amount of light probes to support.\n     * @return The amount of light probes this material will support, bounded by the amount necessary.\n     */\n    MethodPass.prototype.calculateNumProbes = function (numLightProbes) {\n        var numChannels = 0;\n        if ((this.specularLightSources & LightSources_1.default.PROBES) != 0)\n            ++numChannels;\n        if ((this.diffuseLightSources & LightSources_1.default.PROBES) != 0)\n            ++numChannels;\n        // 4 channels available\n        return Math.min(numLightProbes - this.lightProbesOffset, (4 / numChannels) | 0);\n    };\n    return MethodPass;\n}(PassBase_1.default));\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = MethodPass;\n\n},{\"../../data/MethodVO\":\"awayjs-methodmaterials/lib/data/MethodVO\",\"../../methods/EffectColorTransformMethod\":\"awayjs-methodmaterials/lib/methods/EffectColorTransformMethod\",\"../../surfaces/passes/MethodPassMode\":\"awayjs-methodmaterials/lib/surfaces/passes/MethodPassMode\",\"awayjs-core/lib/events/AssetEvent\":undefined,\"awayjs-display/lib/materials/LightSources\":undefined,\"awayjs-renderergl/lib/events/ShadingMethodEvent\":undefined,\"awayjs-renderergl/lib/shaders/LightingShader\":undefined,\"awayjs-renderergl/lib/shaders/ShaderBase\":undefined,\"awayjs-renderergl/lib/surfaces/passes/PassBase\":undefined}],\"awayjs-methodmaterials/lib/surfaces/passes/SingleObjectDepthPass\":[function(require,module,exports){\n\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Image2D_1 = require(\"awayjs-core/lib/image/Image2D\");\nvar Matrix3D_1 = require(\"awayjs-core/lib/geom/Matrix3D\");\nvar Single2DTexture_1 = require(\"awayjs-display/lib/textures/Single2DTexture\");\nvar ContextGLDrawMode_1 = require(\"awayjs-stagegl/lib/base/ContextGLDrawMode\");\nvar PassBase_1 = require(\"awayjs-renderergl/lib/surfaces/passes/PassBase\");\n/**\n * The SingleObjectDepthPass provides a material pass that renders a single object to a depth map from the point\n * of view from a light.\n */\nvar SingleObjectDepthPass = (function (_super) {\n    __extends(SingleObjectDepthPass, _super);\n    /**\n     * Creates a new SingleObjectDepthPass object.\n     */\n    function SingleObjectDepthPass(render, renderOwner, elementsClass, stage) {\n        _super.call(this, render, renderOwner, elementsClass, stage);\n        this._textureSize = 512;\n        this._polyOffset = new Float32Array([15, 0, 0, 0]);\n        this._projectionTexturesInvalid = true;\n        //this._pNumUsedStreams = 2;\n        //this._pNumUsedVertexConstants = 7;\n        //this._enc = Array<number>(1.0, 255.0, 65025.0, 16581375.0, 1.0/255.0, 1.0/255.0, 1.0/255.0, 0.0);\n        //\n        //this._pAnimatableAttributes = Array<string>(\"va0\", \"va1\";\n        //this._pAnimationTargetRegisters = Array<string>(\"vt0\", \"vt1\";\n    }\n    Object.defineProperty(SingleObjectDepthPass.prototype, \"textureSize\", {\n        /**\n         * The size of the depth map texture to render to.\n         */\n        get: function () {\n            return this._textureSize;\n        },\n        set: function (value) {\n            this._textureSize = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(SingleObjectDepthPass.prototype, \"polyOffset\", {\n        /**\n         * The amount by which the rendered object will be inflated, to prevent depth map rounding errors.\n         */\n        get: function () {\n            return this._polyOffset[0];\n        },\n        set: function (value) {\n            this._polyOffset[0] = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * @inheritDoc\n     */\n    SingleObjectDepthPass.prototype.dispose = function () {\n        if (this._textures) {\n            for (var key in this._textures) {\n                var texture = this._textures[key];\n                texture.dispose();\n            }\n            this._textures = null;\n        }\n    };\n    /**\n     * Updates the projection textures used to contain the depth renders.\n     */\n    SingleObjectDepthPass.prototype.updateProjectionTextures = function () {\n        if (this._textures) {\n            for (var key in this._textures) {\n                var texture = this._textures[key];\n                texture.dispose();\n            }\n        }\n        this._textures = new Object();\n        this._projections = new Object();\n        this._projectionTexturesInvalid = false;\n    };\n    /**\n     * @inheritDoc\n     */\n    SingleObjectDepthPass.prototype._iGetVertexCode = function () {\n        var code;\n        // offset\n        code = \"mul vt7, vt1, vc4.x\t\\n\" +\n            \"add vt7, vt7, vt0\\n\" +\n            \"mov vt7.w, vt0.w\\n\";\n        // project\n        code += \"m44 vt2, vt7, vc0\\n\" +\n            \"mov op, vt2\\n\";\n        // perspective divide\n        code += \"div v0, vt2, vt2.w\\n\";\n        return code;\n    };\n    /**\n     * @inheritDoc\n     */\n    SingleObjectDepthPass.prototype._iGetFragmentCode = function (shader, registerCache, sharedRegisters) {\n        var code = \"\";\n        // encode float -> rgba\n        code += \"mul ft0, fc0, v0.z\\n\" +\n            \"frc ft0, ft0\\n\" +\n            \"mul ft1, ft0.yzww, fc1\\n\" +\n            \"sub ft0, ft0, ft1\\n\" +\n            \"mov oc, ft0\\n\";\n        return code;\n    };\n    /**\n     * Gets the depth maps rendered for this object from all lights.\n     * @param renderableGL The renderableGL for which to retrieve the depth maps.\n     * @param stage3DProxy The Stage3DProxy object currently used for rendering.\n     * @return A list of depth map textures for all supported lights.\n     */\n    SingleObjectDepthPass.prototype._iGetDepthMap = function (renderableGL) {\n        return this._textures[renderableGL.renderable.id];\n    };\n    /**\n     * Retrieves the depth map projection maps for all lights.\n     * @param renderableGL The renderableGL for which to retrieve the projection maps.\n     * @return A list of projection maps for all supported lights.\n     */\n    SingleObjectDepthPass.prototype._iGetProjection = function (renderableGL) {\n        return this._projections[renderableGL.renderable.id];\n    };\n    /**\n     * @inheritDoc\n     */\n    SingleObjectDepthPass.prototype._iRender = function (renderableGL, camera, viewProjection) {\n        var matrix;\n        var context = this._stage.context;\n        var len;\n        var light;\n        var lights = this._surface.lightPicker.allPickedLights;\n        var rId = renderableGL.renderable.id;\n        if (!this._textures[rId])\n            this._textures[rId] = new Single2DTexture_1.default(new Image2D_1.default(this._textureSize, this._textureSize));\n        if (!this._projections[rId])\n            this._projections[rId] = new Matrix3D_1.default();\n        len = lights.length;\n        // local position = enough\n        light = lights[0];\n        matrix = light.iGetObjectProjectionMatrix(renderableGL.sourceEntity, camera.sceneTransform, this._projections[rId]);\n        this._stage.setRenderTarget(this._textures[rId], true);\n        context.clear(1.0, 1.0, 1.0);\n        //context.setProgramConstantsFromMatrix(ContextGLProgramType.VERTEX, 0, matrix, true);\n        //context.setProgramConstantsFromArray(ContextGLProgramType.FRAGMENT, 0, this._enc, 2);\n        var elements = renderableGL.elements;\n        var elementsGL = this._shader._elementsPool.getAbstraction(elements);\n        elementsGL.activateVertexBufferVO(0, elements.positions);\n        elementsGL.activateVertexBufferVO(1, elements.normals);\n        elementsGL.getIndexBufferGL().draw(ContextGLDrawMode_1.default.TRIANGLES, 0, elements.numElements);\n    };\n    /**\n     * @inheritDoc\n     */\n    SingleObjectDepthPass.prototype._iActivate = function (camera) {\n        if (this._projectionTexturesInvalid)\n            this.updateProjectionTextures();\n        // never scale\n        _super.prototype._iActivate.call(this, camera);\n        //this._stage.context.setProgramConstantsFromArray(ContextGLProgramType.VERTEX, 4, this._polyOffset, 1);\n    };\n    return SingleObjectDepthPass;\n}(PassBase_1.default));\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = SingleObjectDepthPass;\n\n},{\"awayjs-core/lib/geom/Matrix3D\":undefined,\"awayjs-core/lib/image/Image2D\":undefined,\"awayjs-display/lib/textures/Single2DTexture\":undefined,\"awayjs-renderergl/lib/surfaces/passes/PassBase\":undefined,\"awayjs-stagegl/lib/base/ContextGLDrawMode\":undefined}],\"awayjs-methodmaterials/lib/surfaces\":[function(require,module,exports){\n\"use strict\";\nvar MethodPass_1 = require(\"./surfaces/passes/MethodPass\");\nexports.MethodPass = MethodPass_1.default;\nvar MethodPassMode_1 = require(\"./surfaces/passes/MethodPassMode\");\nexports.MethodPassMode = MethodPassMode_1.default;\nvar SingleObjectDepthPass_1 = require(\"./surfaces/passes/SingleObjectDepthPass\");\nexports.SingleObjectDepthPass = SingleObjectDepthPass_1.default;\nvar GL_MethodMaterialSurface_1 = require(\"./surfaces/GL_MethodMaterialSurface\");\nexports.GL_MethodMaterialSurface = GL_MethodMaterialSurface_1.default;\n\n},{\"./surfaces/GL_MethodMaterialSurface\":\"awayjs-methodmaterials/lib/surfaces/GL_MethodMaterialSurface\",\"./surfaces/passes/MethodPass\":\"awayjs-methodmaterials/lib/surfaces/passes/MethodPass\",\"./surfaces/passes/MethodPassMode\":\"awayjs-methodmaterials/lib/surfaces/passes/MethodPassMode\",\"./surfaces/passes/SingleObjectDepthPass\":\"awayjs-methodmaterials/lib/surfaces/passes/SingleObjectDepthPass\"}]},{},[1])\n\n",
    "import * as data\t\t\t\t\tfrom \"./lib/data\";\nimport * as methods\t\t\t\t\tfrom \"./lib/methods\";\nimport * as surfaces\t\t\t\tfrom \"./lib/surfaces\";\nimport MethodMaterial\t\t\t\tfrom \"./lib/MethodMaterial\";\nimport MethodMaterialMode\t\t\tfrom \"./lib/MethodMaterialMode\";\n\nimport SurfacePool\t\t\t\t\tfrom \"awayjs-renderergl/lib/surfaces/SurfacePool\";\n\nSurfacePool.registerAbstraction(surfaces.GL_MethodMaterialSurface, MethodMaterial);\n\nexport {\n\tdata,\n\tmethods,\n\tsurfaces,\n\tMethodMaterial,\n\tMethodMaterialMode\n}",
    "class MethodMaterialMode\n{\n\t/**\n\t *\n\t */\n\tpublic static SINGLE_PASS:string = \"singlePass\";\n\n\t/**\n\t *\n\t */\n\tpublic static MULTI_PASS:string = \"multiPass\";\n}\n\nexport default MethodMaterialMode;",
    "import Image2D\t\t\t\t\t\tfrom \"awayjs-core/lib/image/Image2D\";\n\nimport MaterialBase\t\t\t\t\tfrom \"awayjs-display/lib/materials/MaterialBase\";\nimport Single2DTexture\t\t\t\tfrom \"awayjs-display/lib/textures/Single2DTexture\";\nimport TextureBase\t\t\t\t\tfrom \"awayjs-display/lib/textures/TextureBase\";\n\nimport ContextGLCompareMode\t\t\tfrom \"awayjs-stagegl/lib/base/ContextGLCompareMode\";\n\nimport MethodMaterialMode\t\t\tfrom \"./MethodMaterialMode\";\nimport AmbientBasicMethod\t\t\tfrom \"./methods/AmbientBasicMethod\";\nimport DiffuseBasicMethod\t\t\tfrom \"./methods/DiffuseBasicMethod\";\nimport EffectMethodBase\t\t\t\tfrom \"./methods/EffectMethodBase\";\nimport NormalBasicMethod\t\t\tfrom \"./methods/NormalBasicMethod\";\nimport ShadowMapMethodBase\t\t\tfrom \"./methods/ShadowMapMethodBase\";\nimport SpecularBasicMethod\t\t\tfrom \"./methods/SpecularBasicMethod\";\n\n/**\n * MethodMaterial forms an abstract base class for the default shaded materials provided by Stage,\n * using material methods to define their appearance.\n */\nclass MethodMaterial extends MaterialBase\n{\n\tpublic static assetType:string = \"[materials MethodMaterial]\";\n\n\tprivate _effectMethods:Array<EffectMethodBase> = new Array<EffectMethodBase>();\n\tprivate _mode:string;\n\n\tprivate _ambientMethod:AmbientBasicMethod = new AmbientBasicMethod();\n\tprivate _shadowMethod:ShadowMapMethodBase;\n\tprivate _diffuseMethod:DiffuseBasicMethod = new DiffuseBasicMethod();\n\tprivate _normalMethod:NormalBasicMethod = new NormalBasicMethod();\n\tprivate _specularMethod:SpecularBasicMethod = new SpecularBasicMethod();\n\n\n\tprivate _depthCompareMode:string = ContextGLCompareMode.LESS_EQUAL;\n\n\t/**\n\t *\n\t */\n\tpublic get assetType():string\n\t{\n\t\treturn MethodMaterial.assetType;\n\t}\n\n\t/**\n\t * Creates a new MethodMaterial object.\n\t *\n\t * @param texture The texture used for the material's albedo color.\n\t * @param smooth Indicates whether the texture should be filtered when sampled. Defaults to true.\n\t * @param repeat Indicates whether the texture should be tiled when sampled. Defaults to false.\n\t * @param mipmap Indicates whether or not any used textures should use mipmapping. Defaults to false.\n\t */\n\tconstructor(image?:Image2D, alpha?:number);\n\tconstructor(color?:number, alpha?:number);\n\tconstructor(imageColor:any = null, alpha:number = 1)\n\t{\n\t\tsuper(imageColor, alpha);\n\n\t\tthis._mode = MethodMaterialMode.SINGLE_PASS;\n\n\t\t//add default methods owners\n\t\tthis._ambientMethod.iAddOwner(this);\n\t\tthis._diffuseMethod.iAddOwner(this);\n\t\tthis._normalMethod.iAddOwner(this);\n\t\tthis._specularMethod.iAddOwner(this);\n\n\t\t//set a texture if an image is present\n\t\tif (imageColor instanceof Image2D)\n\t\t\tthis._ambientMethod.texture = new Single2DTexture();\n\t}\n\n\n\tpublic get mode():string\n\t{\n\t\treturn this._mode;\n\t}\n\n\tpublic set mode(value:string)\n\t{\n\t\tif (this._mode == value)\n\t\t\treturn;\n\n\t\tthis._mode = value;\n\n\t\tthis.invalidate();\n\t}\n\n\t/**\n\t * The depth compare mode used to render the renderables using this material.\n\t *\n\t * @see away.stagegl.ContextGLCompareMode\n\t */\n\n\tpublic get depthCompareMode():string\n\t{\n\t\treturn this._depthCompareMode;\n\t}\n\n\tpublic set depthCompareMode(value:string)\n\t{\n\t\tif (this._depthCompareMode == value)\n\t\t\treturn;\n\n\t\tthis._depthCompareMode = value;\n\n\t\tthis.invalidate();\n\t}\n\n\t/**\n\t * The texture object to use for the ambient colour.\n\t */\n\tpublic get diffuseTexture():TextureBase\n\t{\n\t\treturn this._diffuseMethod.texture;\n\t}\n\n\tpublic set diffuseTexture(value:TextureBase)\n\t{\n\t\tthis._diffuseMethod.texture = value;\n\t}\n\n\t/**\n\t * The method that provides the ambient lighting contribution. Defaults to AmbientBasicMethod.\n\t */\n\tpublic get ambientMethod():AmbientBasicMethod\n\t{\n\t\treturn this._ambientMethod;\n\t}\n\n\tpublic set ambientMethod(value:AmbientBasicMethod)\n\t{\n\t\tif (this._ambientMethod == value)\n\t\t\treturn;\n\n\t\tif (this._ambientMethod)\n\t\t\tthis._ambientMethod.iRemoveOwner(this);\n\n\t\tthis._ambientMethod = value;\n\n\t\tif (this._ambientMethod)\n\t\t\tthis._ambientMethod.iAddOwner(this);\n\n\t\tthis.invalidate();\n\t}\n\n\t/**\n\t * The method used to render shadows cast on this surface, or null if no shadows are to be rendered. Defaults to null.\n\t */\n\tpublic get shadowMethod():ShadowMapMethodBase\n\t{\n\t\treturn this._shadowMethod;\n\t}\n\n\tpublic set shadowMethod(value:ShadowMapMethodBase)\n\t{\n\t\tif (this._shadowMethod == value)\n\t\t\treturn;\n\n\t\tif (this._shadowMethod)\n\t\t\tthis._shadowMethod.iRemoveOwner(this);\n\n\t\tthis._shadowMethod = value;\n\n\t\tif (this._shadowMethod)\n\t\t\tthis._shadowMethod.iAddOwner(this);\n\n\t\tthis.invalidate();\n\t}\n\n\t/**\n\t * The method that provides the diffuse lighting contribution. Defaults to DiffuseBasicMethod.\n\t */\n\tpublic get diffuseMethod():DiffuseBasicMethod\n\t{\n\t\treturn this._diffuseMethod;\n\t}\n\n\tpublic set diffuseMethod(value:DiffuseBasicMethod)\n\t{\n\t\tif (this._diffuseMethod == value)\n\t\t\treturn;\n\n\t\tif (this._diffuseMethod)\n\t\t\tthis._diffuseMethod.iRemoveOwner(this);\n\n\t\tthis._diffuseMethod = value;\n\n\t\tif (this._diffuseMethod)\n\t\t\tthis._diffuseMethod.iAddOwner(this);\n\n\t\tthis.invalidate();\n\t}\n\n\t/**\n\t * The method that provides the specular lighting contribution. Defaults to SpecularBasicMethod.\n\t */\n\tpublic get specularMethod():SpecularBasicMethod\n\t{\n\t\treturn this._specularMethod;\n\t}\n\n\tpublic set specularMethod(value:SpecularBasicMethod)\n\t{\n\t\tif (this._specularMethod == value)\n\t\t\treturn;\n\n\t\tif (this._specularMethod)\n\t\t\tthis._specularMethod.iRemoveOwner(this);\n\n\t\tthis._specularMethod = value;\n\n\t\tif (this._specularMethod)\n\t\t\tthis._specularMethod.iAddOwner(this);\n\n\t\tthis.invalidate();\n\t}\n\n\t/**\n\t * The method used to generate the per-pixel normals. Defaults to NormalBasicMethod.\n\t */\n\tpublic get normalMethod():NormalBasicMethod\n\t{\n\t\treturn this._normalMethod;\n\t}\n\n\tpublic set normalMethod(value:NormalBasicMethod)\n\t{\n\t\tif (this._normalMethod == value)\n\t\t\treturn;\n\n\t\tif (this._normalMethod)\n\t\t\tthis._normalMethod.iRemoveOwner(this);\n\n\t\tthis._normalMethod = value;\n\n\t\tif (this._normalMethod)\n\t\t\tthis._normalMethod.iAddOwner(this);\n\n\t\tthis.invalidate();\n\t}\n\n\tpublic get numEffectMethods():number\n\t{\n\t\treturn this._effectMethods.length;\n\t}\n\n\t/**\n\t * Appends an \"effect\" shading method to the shader. Effect methods are those that do not influence the lighting\n\t * but modulate the shaded colour, used for fog, outlines, etc. The method will be applied to the result of the\n\t * methods added prior.\n\t */\n\tpublic addEffectMethod(method:EffectMethodBase)\n\t{\n\t\tmethod.iAddOwner(this);\n\n\t\tthis._effectMethods.push(method);\n\n\t\tthis.invalidate();\n\t}\n\n\t/**\n\t * Returns the method added at the given index.\n\t * @param index The index of the method to retrieve.\n\t * @return The method at the given index.\n\t */\n\tpublic getEffectMethodAt(index:number):EffectMethodBase\n\t{\n\t\treturn this._effectMethods[index];\n\t}\n\n\t/**\n\t * Adds an effect method at the specified index amongst the methods already added to the material. Effect\n\t * methods are those that do not influence the lighting but modulate the shaded colour, used for fog, outlines,\n\t * etc. The method will be applied to the result of the methods with a lower index.\n\t */\n\tpublic addEffectMethodAt(method:EffectMethodBase, index:number)\n\t{\n\t\tmethod.iAddOwner(this);\n\n\t\tthis._effectMethods.splice(index, 0, method);\n\n\t\tthis.invalidate();\n\t}\n\n\t/**\n\t * Removes an effect method from the material.\n\t * @param method The method to be removed.\n\t */\n\tpublic removeEffectMethod(method:EffectMethodBase)\n\t{\n\t\tmethod.iRemoveOwner(this);\n\n\t\tthis._effectMethods.splice(this._effectMethods.indexOf(method), 1);\n\n\t\tthis.invalidate();\n\t}\n}\n\nexport default MethodMaterial;",
    "import GL_TextureBase\t\t\t\tfrom \"awayjs-renderergl/lib/textures/GL_TextureBase\";\n\nimport MethodPass\t\t\t\t\tfrom \"../surfaces/passes/MethodPass\";\nimport ShadingMethodBase\t\t\tfrom \"../methods/ShadingMethodBase\";\n\n/**\n * MethodVO contains data for a given shader object for the use within a single material.\n * This allows shader methods to be shared across materials while their non-public state differs.\n */\nclass MethodVO\n{\n\tpublic useMethod:boolean = true;\n\n\tpublic method:ShadingMethodBase;\n\tpublic pass:MethodPass;\n\n\t// public register indices\n\tpublic textureGL:GL_TextureBase;\n\tpublic secondaryTextureGL:GL_TextureBase; // sometimes needed for composites\n\tpublic vertexConstantsIndex:number;\n\tpublic secondaryVertexConstantsIndex:number; // sometimes needed for composites\n\tpublic fragmentConstantsIndex:number;\n\tpublic secondaryFragmentConstantsIndex:number; // sometimes needed for composites\n\n\t// internal stuff for the material to know before assembling code\n\tpublic needsProjection:boolean;\n\tpublic needsView:boolean;\n\tpublic needsNormals:boolean;\n\tpublic needsTangents:boolean;\n\tpublic needsGlobalVertexPos:boolean;\n\tpublic needsGlobalFragmentPos:boolean;\n\t/**\n\t * Creates a new MethodVO object.\n\t */\n\tconstructor(method:ShadingMethodBase, pass:MethodPass)\n\t{\n\t\tthis.method = method;\n\t\tthis.pass = pass;\n\t}\n\n\t/**\n\t * Resets the values of the value object to their \"unused\" state.\n\t */\n\tpublic reset()\n\t{\n\t\tthis.method.iReset();\n\n\t\tthis.vertexConstantsIndex = -1;\n\t\tthis.secondaryVertexConstantsIndex = -1;\n\t\tthis.fragmentConstantsIndex = -1;\n\t\tthis.secondaryFragmentConstantsIndex = -1;\n\n\t\tthis.needsProjection = false;\n\t\tthis.needsView = false;\n\t\tthis.needsNormals = false;\n\t\tthis.needsTangents = false;\n\t\tthis.needsGlobalVertexPos = false;\n\t\tthis.needsGlobalFragmentPos = false;\n\t}\n}\n\nexport default MethodVO;\n",
    "export {default as MethodVO}\t\t\t\t\t\tfrom \"./data/MethodVO\";",
    "import AssetEvent\t\t\t\t\t\tfrom \"awayjs-core/lib/events/AssetEvent\";\nimport Camera\t\t\t\t\t\t\tfrom \"awayjs-display/lib/display/Camera\";\nimport TextureBase\t\t\t\t\t\tfrom \"awayjs-display/lib/textures/TextureBase\";\n\nimport Stage\t\t\t\t\t\t\tfrom \"awayjs-stagegl/lib/base/Stage\";\n\nimport GL_RenderableBase\t\t\t\tfrom \"awayjs-renderergl/lib/renderables/GL_RenderableBase\";\nimport ShaderBase\t\t\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderBase\";\nimport ShaderRegisterCache\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterCache\";\nimport ShaderRegisterData\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterData\";\nimport ShaderRegisterElement\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterElement\";\n\nimport MethodVO\t\t\t\t\t\t\tfrom \"../data/MethodVO\";\nimport ShadingMethodBase\t\t\t\tfrom \"../methods/ShadingMethodBase\";\n\n/**\n * AmbientBasicMethod provides the default shading method for uniform ambient lighting.\n */\nclass AmbientBasicMethod extends ShadingMethodBase\n{\n\tprivate _color:number;\n\tprivate _alpha:number = 1;\n\n\tpublic _texture:TextureBase;\n\tprivate _colorR:number = 1;\n\tprivate _colorG:number = 1;\n\tprivate _colorB:number = 1;\n\n\tprivate _strength:number = 1;\n\n\t/**\n\t * Creates a new AmbientBasicMethod object.\n\t */\n\tconstructor()\n\t{\n\t\tsuper();\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitVO(shader:ShaderBase, methodVO:MethodVO)\n\t{\n\t\tif (this._texture) {\n\t\t\tmethodVO.textureGL = shader.getAbstraction(this._texture);\n\t\t\tshader.uvDependencies++;\n\t\t} else if (methodVO.textureGL) {\n\t\t\tmethodVO.textureGL.onClear(new AssetEvent(AssetEvent.CLEAR, this._texture));\n\t\t\tmethodVO.textureGL = null;\n\t\t}\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitConstants(shader:ShaderBase, methodVO:MethodVO)\n\t{\n\t\tif (!methodVO.textureGL) {\n\t\t\tthis._color = shader.numLights? 0xFFFFFF : methodVO.pass._surface.style.color;\n\t\t\tthis.updateColor();\n\t\t}\n\t}\n\n\t/**\n\t * The strength of the ambient reflection of the surface.\n\t */\n\tpublic get strength():number\n\t{\n\t\treturn this._strength;\n\t}\n\n\tpublic set strength(value:number)\n\t{\n\t\tif (this._strength == value)\n\t\t\treturn;\n\n\t\tthis._strength = value;\n\n\t\tthis.updateColor();\n\t}\n\n\t/**\n\t * The alpha component of the surface.\n\t */\n\tpublic get alpha():number\n\t{\n\t\treturn this._alpha;\n\t}\n\n\tpublic set alpha(value:number)\n\t{\n\t\tif (this._alpha == value)\n\t\t\treturn;\n\n\t\tthis._alpha = value;\n\n\t\tthis.updateColor();\n\t}\n\n\t/**\n\t * The texture to use to define the diffuse reflection color per texel.\n\t */\n\tpublic get texture():TextureBase\n\t{\n\t\treturn this._texture;\n\t}\n\n\tpublic set texture(value:TextureBase)\n\t{\n\t\tif (this._texture == value)\n\t\t\treturn;\n\n\t\tif (this._texture)\n\t\t\tthis.iRemoveTexture(this._texture);\n\n\t\tthis._texture = value;\n\n\t\tif (this._texture)\n\t\t\tthis.iAddTexture(this._texture);\n\n\t\tthis.iInvalidateShaderProgram();\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic copyFrom(method:ShadingMethodBase)\n\t{\n\t\tvar m:any = method;\n\t\tvar b:AmbientBasicMethod = <AmbientBasicMethod> m;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentCode(shader:ShaderBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = \"\";\n\n\t\tif (methodVO.textureGL) {\n\t\t\tcode += methodVO.textureGL._iGetFragmentCode(targetReg, registerCache, sharedRegisters, sharedRegisters.uvVarying);\n\n\t\t\tif (shader.alphaThreshold > 0) {\n\t\t\t\tvar cutOffReg:ShaderRegisterElement = registerCache.getFreeFragmentConstant();\n\t\t\t\tmethodVO.fragmentConstantsIndex = cutOffReg.index*4;\n\n\t\t\t\tcode += \"sub \" + targetReg + \".w, \" + targetReg + \".w, \" + cutOffReg + \".x\\n\" +\n\t\t\t\t\t\"kil \" + targetReg + \".w\\n\" +\n\t\t\t\t\t\"add \" + targetReg + \".w, \" + targetReg + \".w, \" + cutOffReg + \".x\\n\";\n\t\t\t}\n\n\t\t} else {\n\t\t\tvar ambientInputRegister:ShaderRegisterElement = registerCache.getFreeFragmentConstant();\n\t\t\tmethodVO.fragmentConstantsIndex = ambientInputRegister.index*4;\n\n\t\t\tcode += \"mov \" + targetReg + \", \" + ambientInputRegister + \"\\n\";\n\t\t}\n\n\t\treturn code;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iActivate(shader:ShaderBase, methodVO:MethodVO, stage:Stage)\n\t{\n\t\tif (methodVO.textureGL) {\n\t\t\tmethodVO.textureGL.activate(methodVO.pass._render);\n\n\t\t\tif (shader.alphaThreshold > 0)\n\t\t\t\tshader.fragmentConstantData[methodVO.fragmentConstantsIndex] = shader.alphaThreshold;\n\t\t} else {\n\t\t\tvar index:number = methodVO.fragmentConstantsIndex;\n\t\t\tvar data:Float32Array = shader.fragmentConstantData;\n\t\t\tdata[index] = this._colorR;\n\t\t\tdata[index + 1] = this._colorG;\n\t\t\tdata[index + 2] = this._colorB;\n\t\t\tdata[index + 3] = this._alpha;\n\t\t}\n\t}\n\n\tpublic iSetRenderState(shader:ShaderBase, methodVO:MethodVO, renderable:GL_RenderableBase, stage:Stage, camera:Camera)\n\t{\n\t\tif (methodVO.textureGL)\n\t\t\tmethodVO.textureGL._setRenderState(renderable);\n\t}\n\n\t/**\n\t * Updates the ambient color data used by the render state.\n\t */\n\tprivate updateColor()\n\t{\n\t\tthis._colorR = ((this._color >> 16) & 0xff)/0xff*this._strength;\n\t\tthis._colorG = ((this._color >> 8) & 0xff)/0xff*this._strength;\n\t\tthis._colorB = (this._color & 0xff)/0xff*this._strength;\n\t}\n}\n\nexport default AmbientBasicMethod;",
    "import AssetEvent\t\t\t\t\t\tfrom \"awayjs-core/lib/events/AssetEvent\";\nimport ShaderBase\t\t\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderBase\";\nimport ShaderRegisterCache\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterCache\";\nimport ShaderRegisterData\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterData\";\nimport ShaderRegisterElement\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterElement\";\n\nimport MethodVO\t\t\t\t\t\t\tfrom \"../data/MethodVO\";\nimport AmbientBasicMethod\t\t\t\tfrom \"../methods/AmbientBasicMethod\";\n\n/**\n * AmbientEnvMapMethod provides a diffuse shading method that uses a diffuse irradiance environment map to\n * approximate global lighting rather than lights.\n */\nclass AmbientEnvMapMethod extends AmbientBasicMethod\n{\n\t/**\n\t * Creates a new <code>AmbientEnvMapMethod</code> object.\n\t *\n\t * @param envMap The cube environment map to use for the ambient lighting.\n\t */\n\tconstructor()\n\t{\n\t\tsuper();\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitVO(shader:ShaderBase, methodVO:MethodVO)\n\t{\n\t\tmethodVO.needsNormals = true;\n\n\t\tif (this._texture) {\n\t\t\tmethodVO.textureGL = shader.getAbstraction(this._texture);\n\t\t\tshader.uvDependencies++;\n\t\t} else if (methodVO.textureGL) {\n\t\t\tmethodVO.textureGL.onClear(new AssetEvent(AssetEvent.CLEAR, this._texture));\n\t\t\tmethodVO.textureGL = null;\n\t\t}\n\t}\n\t\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentCode(shader:ShaderBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, regCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\treturn (this._texture)? methodVO.textureGL._iGetFragmentCode(targetReg, regCache, sharedRegisters, sharedRegisters.normalFragment) : \"\";\n\t}\n}\n\nexport default AmbientEnvMapMethod;",
    "import AssetEvent\t\t\t\t\t\tfrom \"awayjs-core/lib/events/AssetEvent\";\nimport Camera\t\t\t\t\t\t\tfrom \"awayjs-display/lib/display/Camera\";\nimport TextureBase\t\t\t\t\t\tfrom \"awayjs-display/lib/textures/TextureBase\";\n\nimport Stage\t\t\t\t\t\t\tfrom \"awayjs-stagegl/lib/base/Stage\";\n\nimport GL_RenderableBase\t\t\t\tfrom \"awayjs-renderergl/lib/renderables/GL_RenderableBase\";\nimport ShaderBase\t\t\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderBase\";\nimport ShaderRegisterCache\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterCache\";\nimport ShaderRegisterData\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterData\";\nimport ShaderRegisterElement\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterElement\";\n\nimport MethodVO\t\t\t\t\t\t\tfrom \"../data/MethodVO\";\nimport ShadingMethodBase\t\t\t\tfrom \"../methods/ShadingMethodBase\";\n\n/**\n * AmbientBasicMethod provides the default shading method for uniform ambient lighting.\n */\nclass CurveBasicMethod extends ShadingMethodBase\n{\n\tprivate _color:number = 0xffffff;\n\tprivate _alpha:number = 1;\n\n\tpublic _texture:TextureBase;\n\tprivate _colorR:number = 1;\n\tprivate _colorG:number = 1;\n\tprivate _colorB:number = 1;\n\n\tprivate _ambient:number = 1;\n\n\t/**\n\t * Creates a new AmbientBasicMethod object.\n\t */\n\tconstructor()\n\t{\n\t\tsuper();\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitVO(shader:ShaderBase, methodVO:MethodVO)\n\t{\n\t\tif (this._texture) {\n\t\t\tmethodVO.textureGL = shader.getAbstraction(this._texture);\n\t\t\tshader.uvDependencies++;\n\t\t} else if (methodVO.textureGL) {\n\t\t\tmethodVO.textureGL.onClear(new AssetEvent(AssetEvent.CLEAR, this._texture));\n\t\t\tmethodVO.textureGL = null;\n\t\t}\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitConstants(shader:ShaderBase, methodVO:MethodVO)\n\t{\n\t\tif (!methodVO.textureGL) {\n\t\t\tthis._color = methodVO.pass._surface.style.color;\n\t\t\tthis.updateColor();\n\t\t}\n\t}\n\n\t/**\n\t * The strength of the ambient reflection of the surface.\n\t */\n\tpublic get ambient():number\n\t{\n\t\treturn this._ambient;\n\t}\n\n\tpublic set ambient(value:number)\n\t{\n\t\tif (this._ambient == value)\n\t\t\treturn;\n\n\t\tthis._ambient = value;\n\n\t\tthis.updateColor();\n\t}\n\n\t/**\n\t * The alpha component of the surface.\n\t */\n\tpublic get alpha():number\n\t{\n\t\treturn this._alpha;\n\t}\n\n\tpublic set alpha(value:number)\n\t{\n\t\tif (this._alpha == value)\n\t\t\treturn;\n\n\t\tthis._alpha = value;\n\n\t\tthis.updateColor();\n\t}\n\n\t/**\n\t * The texture to use to define the diffuse reflection color per texel.\n\t */\n\tpublic get texture():TextureBase\n\t{\n\t\treturn this._texture;\n\t}\n\n\tpublic set texture(value:TextureBase)\n\t{\n\t\tif (this._texture == value)\n\t\t\treturn;\n\n\t\tif (this._texture)\n\t\t\tthis.iRemoveTexture(this._texture);\n\n\t\tthis._texture = value;\n\n\t\tif (this._texture)\n\t\t\tthis.iAddTexture(this._texture);\n\n\t\tthis.iInvalidateShaderProgram();\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic copyFrom(method:ShadingMethodBase)\n\t{\n\t\tvar m:any = method;\n\t\tvar b:CurveBasicMethod = <CurveBasicMethod> m;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n    /*\n    public iGeVertexCode(shader:ShaderBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string {\n        var code:string = \"\";\n        code = \"mov \" + sharedRegisters.uvVarying + \" \" + registerCache.uv +  \" \\n\";\n    }*/\n    public iGetFragmentCode(shader:ShaderBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = \"\";\n\t\tvar ambientInputRegister:ShaderRegisterElement;\n\n\t\tif (methodVO.textureGL) {\n\t\t\tcode += methodVO.textureGL._iGetFragmentCode(targetReg, registerCache, sharedRegisters, sharedRegisters.uvVarying);\n\n\t\t\tif (shader.alphaThreshold > 0) {\n\t\t\t\tvar cutOffReg:ShaderRegisterElement = registerCache.getFreeFragmentConstant();\n\t\t\t\tmethodVO.fragmentConstantsIndex = cutOffReg.index*4;\n\n\t\t\t\tcode += \"sub \" + targetReg + \".w, \" + targetReg + \".w, \" + cutOffReg + \".x\\n\" +\n\t\t\t\t\t\"kil \" + targetReg + \".w\\n\" +\n\t\t\t\t\t\"add \" + targetReg + \".w, \" + targetReg + \".w, \" + cutOffReg + \".x\\n\";\n\t\t\t}\n\n\t\t} else {\n\t\t\tambientInputRegister = registerCache.getFreeFragmentConstant();\n\t\t\tmethodVO.fragmentConstantsIndex = ambientInputRegister.index*4;\n\n\t\t\tcode += \"mov \" + targetReg + \", \" + ambientInputRegister + \"\\n\";\n\t\t}\n        code = \"mov \" + targetReg + \", \" + sharedRegisters.uvVarying + \"\\n\";\n\t\treturn code;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iActivate(shader:ShaderBase, methodVO:MethodVO, stage:Stage)\n\t{\n\t\tif (methodVO.textureGL) {\n\t\t\tmethodVO.textureGL.activate(methodVO.pass._render);\n\n\t\t\tif (shader.alphaThreshold > 0)\n\t\t\t\tshader.fragmentConstantData[methodVO.fragmentConstantsIndex] = shader.alphaThreshold;\n\t\t} else {\n\t\t\tvar index:number = methodVO.fragmentConstantsIndex;\n\t\t\tvar data:Float32Array = shader.fragmentConstantData;\n\t\t\tdata[index] = this._colorR;\n\t\t\tdata[index + 1] = this._colorG;\n\t\t\tdata[index + 2] = this._colorB;\n\t\t\tdata[index + 3] = this._alpha;\n\t\t}\n\t}\n\n\tpublic iSetRenderState(shader:ShaderBase, methodVO:MethodVO, renderable:GL_RenderableBase, stage:Stage, camera:Camera)\n\t{\n\t\tif (methodVO.textureGL)\n\t\t\tmethodVO.textureGL._setRenderState(renderable);\n\t}\n\n\t/**\n\t * Updates the ambient color data used by the render state.\n\t */\n\tprivate updateColor()\n\t{\n\t\tthis._colorR = ((this._color >> 16) & 0xff)/0xff*this._ambient;\n\t\tthis._colorG = ((this._color >> 8) & 0xff)/0xff*this._ambient;\n\t\tthis._colorB = (this._color & 0xff)/0xff*this._ambient;\n\t}\n}\nexport default CurveBasicMethod;",
    "import AssetEvent\t\t\t\t\t\tfrom \"awayjs-core/lib/events/AssetEvent\";\n\nimport Camera\t\t\t\t\t\t\tfrom \"awayjs-display/lib/display/Camera\";\nimport TextureBase\t\t\t\t\t\tfrom \"awayjs-display/lib/textures/TextureBase\";\n\nimport Stage\t\t\t\t\t\t\tfrom \"awayjs-stagegl/lib/base/Stage\";\n\nimport GL_RenderableBase\t\t\t\tfrom \"awayjs-renderergl/lib/renderables/GL_RenderableBase\";\nimport LightingShader\t\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/LightingShader\";\nimport ShaderRegisterCache\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterCache\";\nimport ShaderRegisterData\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterData\";\nimport ShaderRegisterElement\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterElement\";\n\nimport MethodVO\t\t\t\t\t\t\tfrom \"../data/MethodVO\";\nimport ShadingMethodBase\t\t\t\tfrom \"../methods/ShadingMethodBase\";\nimport LightingMethodBase\t\t\t\tfrom \"../methods/LightingMethodBase\";\n\n/**\n * DiffuseBasicMethod provides the default shading method for Lambert (dot3) diffuse lighting.\n */\nclass DiffuseBasicMethod extends LightingMethodBase\n{\n\tprivate _multiply:boolean = true;\n\n\tpublic _pTotalLightColorReg:ShaderRegisterElement;\n\n\tpublic _texture:TextureBase;\n\tprivate _ambientColor:number;\n\tprivate _ambientColorR:number = 1;\n\tprivate _ambientColorG:number = 1;\n\tprivate _ambientColorB:number = 1;\n\tprivate _color:number = 0xffffff;\n\tprivate _colorR:number = 1;\n\tprivate _colorG:number = 1;\n\tprivate _colorB:number = 1;\n\n\tpublic _pIsFirstLight:boolean;\n\n\t/**\n\t * Creates a new DiffuseBasicMethod object.\n\t */\n\tconstructor()\n\t{\n\t\tsuper();\n\t}\n\n\tpublic iIsUsed(shader:LightingShader):boolean\n\t{\n\t\tif (!shader.numLights)\n\t\t\treturn false;\n\n\t\treturn true;\n\t}\n\n\t/**\n\t * Set internally if diffuse color component multiplies or replaces the ambient color\n\t */\n\tpublic get multiply():boolean\n\t{\n\t\treturn this._multiply;\n\t}\n\n\tpublic set multiply(value:boolean)\n\t{\n\t\tif (this._multiply == value)\n\t\t\treturn;\n\n\t\tthis._multiply = value;\n\n\t\tthis.iInvalidateShaderProgram();\n\t}\n\n\tpublic iInitVO(shader:LightingShader, methodVO:MethodVO)\n\t{\n\t\tif (this._texture) {\n\t\t\tmethodVO.textureGL = shader.getAbstraction(this._texture);\n\t\t\tshader.uvDependencies++;\n\t\t} else if (methodVO.textureGL) {\n\t\t\tmethodVO.textureGL.onClear(new AssetEvent(AssetEvent.CLEAR, null));\n\t\t\tmethodVO.textureGL = null;\n\t\t}\n\n\t\tif (shader.numLights > 0) {\n\t\t\tshader.usesCommonData = true;\n\t\t\tmethodVO.needsNormals = true;\n\t\t}\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitConstants(shader:LightingShader, methodVO:MethodVO)\n\t{\n\t\tif (shader.numLights > 0) {\n\t\t\tthis._ambientColor = methodVO.pass._surface.style.color;\n\t\t\tthis.updateAmbientColor();\n\t\t} else {\n\t\t\tthis._ambientColor = null;\n\t\t}\n\t}\n\n\t/**\n\t * The color of the diffuse reflection when not using a texture.\n\t */\n\tpublic get color():number\n\t{\n\t\treturn this._color;\n\t}\n\n\tpublic set color(value:number)\n\t{\n\t\tif (this._color == value)\n\t\t\treturn;\n\n\t\tthis._color = value;\n\n\t\tthis.updateColor();\n\t}\n\n\t/**\n\t * The texture to use to define the diffuse reflection color per texel.\n\t */\n\tpublic get texture():TextureBase\n\t{\n\t\treturn this._texture;\n\t}\n\n\tpublic set texture(value:TextureBase)\n\t{\n\t\tif (this._texture == value)\n\t\t\treturn;\n\n\t\tif (this._texture)\n\t\t\tthis.iRemoveTexture(this._texture);\n\n\t\tthis._texture = value;\n\n\t\tif (this._texture)\n\t\t\tthis.iAddTexture(this._texture);\n\n\t\tthis.iInvalidateShaderProgram();\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic dispose()\n\t{\n\t\tthis._texture = null;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic copyFrom(method:ShadingMethodBase)\n\t{\n\t\tvar diff:DiffuseBasicMethod = <DiffuseBasicMethod> method;\n\n\t\tthis.texture = diff.texture;\n\t\tthis.multiply = diff.multiply;\n\t\tthis.color = diff.color;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iCleanCompilationData()\n\t{\n\t\tsuper.iCleanCompilationData();\n\n\t\tthis._pTotalLightColorReg = null;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentPreLightingCode(shader:LightingShader, methodVO:MethodVO, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = \"\";\n\n\t\tthis._pIsFirstLight = true;\n\n\t\tregisterCache.addFragmentTempUsages(this._pTotalLightColorReg = registerCache.getFreeFragmentVectorTemp(), 1);\n\n\t\treturn code;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentCodePerLight(shader:LightingShader, methodVO:MethodVO, lightDirReg:ShaderRegisterElement, lightColReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = \"\";\n\t\tvar t:ShaderRegisterElement;\n\n\t\t// write in temporary if not first light, so we can add to total diffuse colour\n\t\tif (this._pIsFirstLight) {\n\t\t\tt = this._pTotalLightColorReg;\n\t\t} else {\n\t\t\tt = registerCache.getFreeFragmentVectorTemp();\n\t\t\tregisterCache.addFragmentTempUsages(t, 1);\n\t\t}\n\n\t\tcode += \"dp3 \" + t + \".x, \" + lightDirReg + \", \" + sharedRegisters.normalFragment + \"\\n\" +\n\t\t\t\t\"max \" + t + \".w, \" + t + \".x, \" + sharedRegisters.commons + \".y\\n\";\n\n\t\tif (shader.usesLightFallOff)\n\t\t\tcode += \"mul \" + t + \".w, \" + t + \".w, \" + lightDirReg + \".w\\n\";\n\n\t\tif (this._iModulateMethod != null)\n\t\t\tcode += this._iModulateMethod(shader, methodVO, t, registerCache, sharedRegisters);\n\n\t\tcode += \"mul \" + t + \", \" + t + \".w, \" + lightColReg + \"\\n\";\n\n\t\tif (!this._pIsFirstLight) {\n\t\t\tcode += \"add \" + this._pTotalLightColorReg + \".xyz, \" + this._pTotalLightColorReg + \", \" + t + \"\\n\";\n\t\t\tregisterCache.removeFragmentTempUsage(t);\n\t\t}\n\n\t\tthis._pIsFirstLight = false;\n\n\t\treturn code;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentCodePerProbe(shader:LightingShader, methodVO:MethodVO, cubeMapReg:ShaderRegisterElement, weightRegister:string, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = \"\";\n\t\tvar t:ShaderRegisterElement;\n\n\t\t// write in temporary if not first light, so we can add to total diffuse colour\n\t\tif (this._pIsFirstLight) {\n\t\t\tt = this._pTotalLightColorReg;\n\t\t} else {\n\t\t\tt = registerCache.getFreeFragmentVectorTemp();\n\t\t\tregisterCache.addFragmentTempUsages(t, 1);\n\t\t}\n\n\t\tcode += \"tex \" + t + \", \" + sharedRegisters.normalFragment + \", \" + cubeMapReg + \" <cube,linear,miplinear>\\n\" +\n\t\t\t\t\"mul \" + t + \".xyz, \" + t + \".xyz, \" + weightRegister + \"\\n\";\n\n\t\tif (this._iModulateMethod != null)\n\t\t\tcode += this._iModulateMethod(shader, methodVO, t, registerCache, sharedRegisters);\n\n\t\tif (!this._pIsFirstLight) {\n\t\t\tcode += \"add \" + this._pTotalLightColorReg + \".xyz, \" + this._pTotalLightColorReg + \", \" + t + \"\\n\";\n\t\t\tregisterCache.removeFragmentTempUsage(t);\n\t\t}\n\n\t\tthis._pIsFirstLight = false;\n\n\t\treturn code;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentPostLightingCode(shader:LightingShader, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = \"\";\n\n\t\tvar diffuseColor:ShaderRegisterElement;\n\t\tvar cutOffReg:ShaderRegisterElement;\n\n\t\t// incorporate input from ambient\n\t\tif (sharedRegisters.shadowTarget)\n\t\t\tcode += this.pApplyShadow(shader, methodVO, registerCache, sharedRegisters);\n\n\t\tregisterCache.addFragmentTempUsages(diffuseColor = registerCache.getFreeFragmentVectorTemp(), 1);\n\n\t\tvar ambientColorRegister:ShaderRegisterElement = registerCache.getFreeFragmentConstant();\n\t\tmethodVO.fragmentConstantsIndex = ambientColorRegister.index*4;\n\n\t\tif (this._texture) {\n\t\t\tcode += methodVO.textureGL._iGetFragmentCode(diffuseColor, registerCache, sharedRegisters, sharedRegisters.uvVarying);\n\t\t} else {\n\t\t\tvar diffuseInputRegister:ShaderRegisterElement = registerCache.getFreeFragmentConstant();\n\n\t\t\tcode += \"mov \" + diffuseColor + \", \" + diffuseInputRegister + \"\\n\";\n\t\t}\n\n\t\tcode += \"sat \" + this._pTotalLightColorReg + \", \" + this._pTotalLightColorReg + \"\\n\" +\n\t\t\t\"mul \" + diffuseColor + \".xyz, \" + diffuseColor + \", \" + this._pTotalLightColorReg + \"\\n\";\n\n\t\tif (this._multiply) {\n\t\t\tcode += \"add \" + diffuseColor + \".xyz, \" + diffuseColor + \", \" + ambientColorRegister + \"\\n\" +\n\t\t\t\t\"mul \" + targetReg + \".xyz, \" + targetReg + \", \" + diffuseColor + \"\\n\";\n\t\t} else if (this._texture) {\n\t\t\tcode += \"mul \" + targetReg + \".xyz, \" + targetReg + \", \" + ambientColorRegister + \"\\n\" + // multiply target by ambient for total ambient\n\t\t\t\t\"mul \" + this._pTotalLightColorReg + \".xyz, \" + targetReg + \", \" + this._pTotalLightColorReg + \"\\n\" +\n\t\t\t\t\"sub \" + targetReg + \".xyz, \" + targetReg + \", \" + this._pTotalLightColorReg + \"\\n\" + // ambient * (1 - totalLightColor)\n\t\t\t\t\"add \" + targetReg + \".xyz, \" + targetReg + \", \" + diffuseColor + \"\\n\"; //add diffuse color and ambient color\n\t\t} else {\n\t\t\tcode += \"mul \" + this._pTotalLightColorReg + \".xyz, \" + ambientColorRegister + \", \" + this._pTotalLightColorReg + \"\\n\" +\n\t\t\t\t\"sub \" + this._pTotalLightColorReg + \".xyz, \" + ambientColorRegister + \", \" + this._pTotalLightColorReg + \"\\n\" + // ambient * (1 - totalLightColor)\n\t\t\t\t\"add \" + diffuseColor + \".xyz, \" + diffuseColor + \", \" + this._pTotalLightColorReg + \"\\n\" + // add diffuse color and  ambient color\n\t\t\t\t\"mul \" + targetReg + \".xyz, \" + targetReg + \", \" + diffuseColor + \"\\n\"; // multiply by target which could be texture or white\n\t\t}\n\n\t\tregisterCache.removeFragmentTempUsage(this._pTotalLightColorReg);\n\t\tregisterCache.removeFragmentTempUsage(diffuseColor);\n\n\t\treturn code;\n\t}\n\n\t/**\n\t * Generate the code that applies the calculated shadow to the diffuse light\n\t * @param methodVO The MethodVO object for which the compilation is currently happening.\n\t * @param regCache The register cache the compiler is currently using for the register management.\n\t */\n\tpublic pApplyShadow(shader:LightingShader, methodVO:MethodVO, regCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\treturn \"mul \" + this._pTotalLightColorReg + \".xyz, \" + this._pTotalLightColorReg + \", \" + sharedRegisters.shadowTarget + \".w\\n\";\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iActivate(shader:LightingShader, methodVO:MethodVO, stage:Stage)\n\t{\n\t\tif (this._texture) {\n\t\t\tmethodVO.textureGL.activate(methodVO.pass._render);\n\t\t} else {\n\t\t\tvar index:number = methodVO.fragmentConstantsIndex;\n\t\t\tvar data:Float32Array = shader.fragmentConstantData;\n\t\t\tif (this._multiply) {\n\t\t\t\tdata[index + 4] = this._colorR*this._ambientColorR;\n\t\t\t\tdata[index + 5] = this._colorG*this._ambientColorG;\n\t\t\t\tdata[index + 6] = this._colorB*this._ambientColorB;\n\t\t\t} else {\n\t\t\t\tdata[index + 4] = this._colorR;\n\t\t\t\tdata[index + 5] = this._colorG;\n\t\t\t\tdata[index + 6] = this._colorB;\n\t\t\t}\n\t\t\tdata[index + 7] = 1;\n\t\t}\n\t}\n\n\t/**\n\t * Updates the diffuse color data used by the render state.\n\t */\n\tprivate updateColor()\n\t{\n\t\tthis._colorR = ((this._color >> 16) & 0xff)/0xff;\n\t\tthis._colorG = ((this._color >> 8) & 0xff)/0xff;\n\t\tthis._colorB = (this._color & 0xff)/0xff;\n\t}\n\n\n\t/**\n\t * Updates the ambient color data used by the render state.\n\t */\n\tprivate updateAmbientColor()\n\t{\n\t\tthis._ambientColorR = ((this._ambientColor >> 16) & 0xff)/0xff;\n\t\tthis._ambientColorG = ((this._ambientColor >> 8) & 0xff)/0xff;\n\t\tthis._ambientColorB = (this._ambientColor & 0xff)/0xff;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iSetRenderState(shader:LightingShader, methodVO:MethodVO, renderable:GL_RenderableBase, stage:Stage, camera:Camera)\n\t{\n\t\tif (this._texture)\n\t\t\tmethodVO.textureGL._setRenderState(renderable);\n\n\t\t//TODO move this to Activate (ambientR/G/B currently calc'd in render state)\n\t\tvar index:number = methodVO.fragmentConstantsIndex;\n\t\tvar data:Float32Array = shader.fragmentConstantData;\n\t\tdata[index] = shader.ambientR*this._ambientColorR;\n\t\tdata[index + 1] = shader.ambientG*this._ambientColorG;\n\t\tdata[index + 2] = shader.ambientB*this._ambientColorB;\n\t\tdata[index + 3] = 1;\n\t}\n}\n\nexport default DiffuseBasicMethod;",
    "import Stage\t\t\t\t\t\t\tfrom \"awayjs-stagegl/lib/base/Stage\";\n\nimport LightingShader\t\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/LightingShader\";\nimport ShaderBase\t\t\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderBase\";\nimport ShaderRegisterCache\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterCache\";\nimport ShaderRegisterData\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterData\";\nimport ShaderRegisterElement\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterElement\";\n\nimport MethodVO\t\t\t\t\t\t\tfrom \"../data/MethodVO\";\nimport DiffuseBasicMethod\t\t\t\tfrom \"../methods/DiffuseBasicMethod\";\nimport DiffuseCompositeMethod\t\t\tfrom \"../methods/DiffuseCompositeMethod\";\n\n/**\n * DiffuseCelMethod provides a shading method to add diffuse cel (cartoon) shading.\n */\nclass DiffuseCelMethod extends DiffuseCompositeMethod\n{\n\tprivate _levels:number /*uint*/;\n\tprivate _dataReg:ShaderRegisterElement;\n\tprivate _smoothness:number = .1;\n\n\t/**\n\t * Creates a new DiffuseCelMethod object.\n\t * @param levels The amount of shadow gradations.\n\t * @param baseMethod An optional diffuse method on which the cartoon shading is based. If omitted, DiffuseBasicMethod is used.\n\t */\n\tconstructor(levels:number /*uint*/ = 3, baseMethod:DiffuseBasicMethod = null)\n\t{\n\t\tsuper(null, baseMethod);\n\n\t\tthis.baseMethod._iModulateMethod = (shader:ShaderBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData) => this.clampDiffuse(shader, methodVO, targetReg, registerCache, sharedRegisters);\n\n\t\tthis._levels = levels;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitConstants(shader:LightingShader, methodVO:MethodVO)\n\t{\n\t\tvar data:Float32Array = shader.fragmentConstantData;\n\t\tvar index:number /*int*/ = methodVO.secondaryFragmentConstantsIndex;\n\t\tsuper.iInitConstants(shader, methodVO);\n\t\tdata[index + 1] = 1;\n\t\tdata[index + 2] = 0;\n\t}\n\n\t/**\n\t * The amount of shadow gradations.\n\t */\n\tpublic get levels():number /*uint*/\n\t{\n\t\treturn this._levels;\n\t}\n\n\tpublic set levels(value:number /*uint*/)\n\t{\n\t\tthis._levels = value;\n\t}\n\n\t/**\n\t * The smoothness of the edge between 2 shading levels.\n\t */\n\tpublic get smoothness():number\n\t{\n\t\treturn this._smoothness;\n\t}\n\n\tpublic set smoothness(value:number)\n\t{\n\t\tthis._smoothness = value;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iCleanCompilationData()\n\t{\n\t\tsuper.iCleanCompilationData();\n\t\tthis._dataReg = null;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentPreLightingCode(shader:LightingShader, methodVO:MethodVO, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tthis._dataReg = registerCache.getFreeFragmentConstant();\n\t\tmethodVO.secondaryFragmentConstantsIndex = this._dataReg.index*4;\n\n\t\treturn super.iGetFragmentPreLightingCode(shader, methodVO, registerCache, sharedRegisters);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iActivate(shader:LightingShader, methodVO:MethodVO, stage:Stage)\n\t{\n\t\tsuper.iActivate(shader, methodVO, stage);\n\t\tvar data:Float32Array = shader.fragmentConstantData;\n\t\tvar index:number /*int*/ = methodVO.secondaryFragmentConstantsIndex;\n\t\tdata[index] = this._levels;\n\t\tdata[index + 3] = this._smoothness;\n\t}\n\n\t/**\n\t * Snaps the diffuse shading of the wrapped method to one of the levels.\n\t * @param vo The MethodVO used to compile the current shader.\n\t * @param t The register containing the diffuse strength in the \"w\" component.\n\t * @param regCache The register cache used for the shader compilation.\n\t * @param sharedRegisters The shared register data for this shader.\n\t * @return The AGAL fragment code for the method.\n\t */\n\tprivate clampDiffuse(shader:ShaderBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\treturn \"mul \" + targetReg + \".w, \" + targetReg + \".w, \" + this._dataReg + \".x\\n\" +\n\t\t\t\"frc \" + targetReg + \".z, \" + targetReg + \".w\\n\" +\n\t\t\t\"sub \" + targetReg + \".y, \" + targetReg + \".w, \" + targetReg + \".z\\n\" +\n\t\t\t\"mov \" + targetReg + \".x, \" + this._dataReg + \".x\\n\" +\n\t\t\t\"sub \" + targetReg + \".x, \" + targetReg + \".x, \" + this._dataReg + \".y\\n\" +\n\t\t\t\"rcp \" + targetReg + \".x,\" + targetReg + \".x\\n\" +\n\t\t\t\"mul \" + targetReg + \".w, \" + targetReg + \".y, \" + targetReg + \".x\\n\" +\n\n\t\t\t// previous clamped strength\n\t\t\t\"sub \" + targetReg + \".y, \" + targetReg + \".w, \" + targetReg + \".x\\n\" +\n\n\t\t\t// fract/epsilon (so 0 - epsilon will become 0 - 1)\n\t\t\t\"div \" + targetReg + \".z, \" + targetReg + \".z, \" + this._dataReg + \".w\\n\" +\n\t\t\t\"sat \" + targetReg + \".z, \" + targetReg + \".z\\n\" +\n\n\t\t\t\"mul \" + targetReg + \".w, \" + targetReg + \".w, \" + targetReg + \".z\\n\" +\n\t\t\t// 1-z\n\t\t\t\"sub \" + targetReg + \".z, \" + this._dataReg + \".y, \" + targetReg + \".z\\n\" +\n\t\t\t\"mul \" + targetReg + \".y, \" + targetReg + \".y, \" + targetReg + \".z\\n\" +\n\t\t\t\"add \" + targetReg + \".w, \" + targetReg + \".w, \" + targetReg + \".y\\n\" +\n\t\t\t\"sat \" + targetReg + \".w, \" + targetReg + \".w\\n\";\n\t}\n}\n\nexport default DiffuseCelMethod;",
    "import Camera\t\t\t\t\t\t\tfrom \"awayjs-display/lib/display/Camera\";\nimport TextureBase\t\t\t\t\t\tfrom \"awayjs-display/lib/textures/TextureBase\";\nimport ISurface\t\t\t\t\t\t\tfrom \"awayjs-display/lib/base/ISurface\";\n\nimport Stage\t\t\t\t\t\t\tfrom \"awayjs-stagegl/lib/base/Stage\";\n\nimport LightingShader\t\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/LightingShader\";\nimport ShaderBase\t\t\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderBase\";\nimport ShaderRegisterCache\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterCache\";\nimport ShaderRegisterData\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterData\";\nimport ShaderRegisterElement\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterElement\";\nimport ShadingMethodEvent\t\t\t\tfrom \"awayjs-renderergl/lib/events/ShadingMethodEvent\";\nimport GL_RenderableBase\t\t\t\tfrom \"awayjs-renderergl/lib/renderables/GL_RenderableBase\";\n\nimport MethodVO\t\t\t\t\t\t\tfrom \"../data/MethodVO\";\nimport DiffuseBasicMethod\t\t\t\tfrom \"../methods/DiffuseBasicMethod\";\n\n/**\n * DiffuseCompositeMethod provides a base class for diffuse methods that wrap a diffuse method to alter the\n * calculated diffuse reflection strength.\n */\nclass DiffuseCompositeMethod extends DiffuseBasicMethod\n{\n\tpublic pBaseMethod:DiffuseBasicMethod;\n\n\tprivate _onShaderInvalidatedDelegate:(event:ShadingMethodEvent) => void;\n\n\t/**\n\t * Creates a new <code>DiffuseCompositeMethod</code> object.\n\t *\n\t * @param modulateMethod The method which will add the code to alter the base method's strength. It needs to have the signature clampDiffuse(t:ShaderRegisterElement, regCache:ShaderRegisterCache):string, in which t.w will contain the diffuse strength.\n\t * @param baseMethod The base diffuse method on which this method's shading is based.\n\t */\n\tconstructor(modulateMethod:(shader:ShaderBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData) => string, baseMethod:DiffuseBasicMethod = null)\n\t{\n\t\tsuper();\n\n\t\tthis._onShaderInvalidatedDelegate = (event:ShadingMethodEvent) => this.onShaderInvalidated(event);\n\n\t\tthis.pBaseMethod = baseMethod || new DiffuseBasicMethod();\n\t\tthis.pBaseMethod._iModulateMethod = modulateMethod;\n\t\tthis.pBaseMethod.addEventListener(ShadingMethodEvent.SHADER_INVALIDATED, this._onShaderInvalidatedDelegate);\n\t}\n\n\t/**\n\t * The base diffuse method on which this method's shading is based.\n\t */\n\tpublic get baseMethod():DiffuseBasicMethod\n\t{\n\t\treturn this.pBaseMethod;\n\t}\n\n\tpublic set baseMethod(value:DiffuseBasicMethod)\n\t{\n\t\tif (this.pBaseMethod == value)\n\t\t\treturn;\n\n\t\tthis.pBaseMethod.removeEventListener(ShadingMethodEvent.SHADER_INVALIDATED, this._onShaderInvalidatedDelegate);\n\t\tthis.pBaseMethod = value;\n\t\tthis.pBaseMethod.addEventListener(ShadingMethodEvent.SHADER_INVALIDATED, this._onShaderInvalidatedDelegate);\n\t\tthis.iInvalidateShaderProgram();\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitVO(shader:LightingShader, methodVO:MethodVO)\n\t{\n\t\tthis.pBaseMethod.iInitVO(shader, methodVO);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitConstants(shader:LightingShader, methodVO:MethodVO)\n\t{\n\t\tthis.pBaseMethod.iInitConstants(shader, methodVO);\n\t}\n\n\tpublic iAddOwner(owner:ISurface)\n\t{\n\t\tsuper.iAddOwner(owner);\n\n\t\tthis.pBaseMethod.iAddOwner(owner);\n\t}\n\n\tpublic iRemoveOwner(owner:ISurface)\n\t{\n\t\tsuper.iRemoveOwner(owner);\n\n\t\tthis.pBaseMethod.iRemoveOwner(owner);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic dispose()\n\t{\n\t\tthis.pBaseMethod.removeEventListener(ShadingMethodEvent.SHADER_INVALIDATED, this._onShaderInvalidatedDelegate);\n\t\tthis.pBaseMethod.dispose();\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic get texture():TextureBase\n\t{\n\t\treturn this.pBaseMethod.texture;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic set texture(value:TextureBase)\n\t{\n\t\tthis.pBaseMethod.texture = value;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic get color():number\n\t{\n\t\treturn this.pBaseMethod.color;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic set color(value:number)\n\t{\n\t\tthis.pBaseMethod.color = value;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic get multiply():boolean\n\t{\n\t\treturn this.pBaseMethod.multiply;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic set multiply(value:boolean)\n\t{\n\t\tthis.pBaseMethod.multiply = value;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentPreLightingCode(shader:LightingShader, methodVO:MethodVO, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\treturn this.pBaseMethod.iGetFragmentPreLightingCode(shader, methodVO, registerCache, sharedRegisters);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentCodePerLight(shader:LightingShader, methodVO:MethodVO, lightDirReg:ShaderRegisterElement, lightColReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = this.pBaseMethod.iGetFragmentCodePerLight(shader, methodVO, lightDirReg, lightColReg, registerCache, sharedRegisters);\n\t\tthis._pTotalLightColorReg = this.pBaseMethod._pTotalLightColorReg;\n\t\treturn code;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentCodePerProbe(shader:LightingShader, methodVO:MethodVO, cubeMapReg:ShaderRegisterElement, weightRegister:string, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = this.pBaseMethod.iGetFragmentCodePerProbe(shader, methodVO, cubeMapReg, weightRegister, registerCache, sharedRegisters);\n\t\tthis._pTotalLightColorReg = this.pBaseMethod._pTotalLightColorReg;\n\t\treturn code;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iActivate(shader:LightingShader, methodVO:MethodVO, stage:Stage)\n\t{\n\t\tthis.pBaseMethod.iActivate(shader, methodVO, stage);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iSetRenderState(shader:LightingShader, methodVO:MethodVO, renderable:GL_RenderableBase, stage:Stage, camera:Camera)\n\t{\n\t\tthis.pBaseMethod.iSetRenderState(shader, methodVO, renderable, stage, camera);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iDeactivate(shader:LightingShader, methodVO:MethodVO, stage:Stage)\n\t{\n\t\tthis.pBaseMethod.iDeactivate(shader, methodVO, stage);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetVertexCode(shader:ShaderBase, methodVO:MethodVO, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\treturn this.pBaseMethod.iGetVertexCode(shader, methodVO, registerCache, sharedRegisters);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentPostLightingCode(shader:LightingShader, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\treturn this.pBaseMethod.iGetFragmentPostLightingCode(shader, methodVO, targetReg, registerCache, sharedRegisters);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iReset()\n\t{\n\t\tthis.pBaseMethod.iReset();\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iCleanCompilationData()\n\t{\n\t\tsuper.iCleanCompilationData();\n\t\tthis.pBaseMethod.iCleanCompilationData();\n\t}\n\n\t/**\n\t * Called when the base method's shader code is invalidated.\n\t */\n\tprivate onShaderInvalidated(event:ShadingMethodEvent)\n\t{\n\t\tthis.iInvalidateShaderProgram();\n\t}\n}\n\nexport default DiffuseCompositeMethod;",
    "import GL_RenderableBase\t\t\t\tfrom \"awayjs-renderergl/lib/renderables/GL_RenderableBase\";\nimport LightingShader\t\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/LightingShader\";\nimport ShaderBase\t\t\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderBase\";\nimport ShaderRegisterCache\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterCache\";\nimport ShaderRegisterData\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterData\";\nimport ShaderRegisterElement\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterElement\";\n\nimport MethodVO\t\t\t\t\t\t\tfrom \"../data/MethodVO\";\nimport DiffuseBasicMethod\t\t\t\tfrom \"../methods/DiffuseBasicMethod\";\n\n/**\n * DiffuseDepthMethod provides a debug method to visualise depth maps\n */\nclass DiffuseDepthMethod extends DiffuseBasicMethod\n{\n\t/**\n\t * Creates a new DiffuseBasicMethod object.\n\t */\n\tconstructor()\n\t{\n\t\tsuper();\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitConstants(shader:ShaderBase, methodVO:MethodVO)\n\t{\n\t\tvar data:Float32Array = shader.fragmentConstantData;\n\t\tvar index:number /*int*/ = methodVO.fragmentConstantsIndex;\n\t\tdata[index] = 1.0;\n\t\tdata[index + 1] = 1/255.0;\n\t\tdata[index + 2] = 1/65025.0;\n\t\tdata[index + 3] = 1/16581375.0;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentPostLightingCode(shader:LightingShader, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = \"\";\n\t\tvar temp:ShaderRegisterElement;\n\t\tvar decReg:ShaderRegisterElement;\n\n\t\tif (!this._texture)\n\t\t\tthrow new Error(\"DiffuseDepthMethod requires texture!\");\n\n\t\t// incorporate input from ambient\n\t\tif (shader.numLights > 0) {\n\t\t\tif (sharedRegisters.shadowTarget)\n\t\t\t\tcode += \"mul \" + this._pTotalLightColorReg + \".xyz, \" + this._pTotalLightColorReg + \".xyz, \" + sharedRegisters.shadowTarget + \".w\\n\";\n\t\t\tcode += \"add \" + targetReg + \".xyz, \" + this._pTotalLightColorReg + \".xyz, \" + targetReg + \".xyz\\n\" +\n\t\t\t\t\"sat \" + targetReg + \".xyz, \" + targetReg + \".xyz\\n\";\n\t\t\tregisterCache.removeFragmentTempUsage(this._pTotalLightColorReg);\n\t\t\tregisterCache.addFragmentTempUsages(temp = registerCache.getFreeFragmentVectorTemp(), 1);\n\t\t} else {\n\t\t\ttemp = targetReg;\n\t\t}\n\n\t\tdecReg = registerCache.getFreeFragmentConstant();\n\t\tmethodVO.fragmentConstantsIndex = decReg.index*4;\n\n\t\tcode += methodVO.textureGL._iGetFragmentCode(temp, registerCache, sharedRegisters, sharedRegisters.uvVarying) +\n\t\t\t\"dp4 \" + temp + \".x, \" + temp + \", \" + decReg + \"\\n\" +\n\t\t\t\"mov \" + temp + \".yz, \" + temp + \".xx\t\t\t\\n\" +\n\t\t\t\"mov \" + temp + \".w, \" + decReg + \".x\\n\" +\n\t\t\t\"sub \" + temp + \".xyz, \" + decReg + \".xxx, \" + temp + \".xyz\\n\";\n\n\t\tif (shader.numLights == 0)\n\t\t\treturn code;\n\n\t\tcode += \"mul \" + targetReg + \".xyz, \" + temp + \".xyz, \" + targetReg + \".xyz\\n\" +\n\t\t\t\"mov \" + targetReg + \".w, \" + temp + \".w\\n\";\n\n\t\tif (shader.numLights > 0)\n\t\t\tregisterCache.removeFragmentTempUsage(temp);\n\n\t\treturn code;\n\t}\n}\n\nexport default DiffuseDepthMethod;",
    "import Camera\t\t\t\t\t\t\tfrom \"awayjs-display/lib/display/Camera\";\nimport TextureBase\t\t\t\t\t\tfrom \"awayjs-display/lib/textures/TextureBase\";\n\nimport Stage\t\t\t\t\t\t\tfrom \"awayjs-stagegl/lib/base/Stage\";\n\nimport GL_RenderableBase\t\t\t\tfrom \"awayjs-renderergl/lib/renderables/GL_RenderableBase\";\nimport LightingShader\t\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/LightingShader\";\nimport ShaderRegisterCache\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterCache\";\nimport ShaderRegisterData\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterData\";\nimport ShaderRegisterElement\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterElement\";\n\nimport MethodVO\t\t\t\t\t\t\tfrom \"../data/MethodVO\";\nimport DiffuseBasicMethod\t\t\t\tfrom \"../methods/DiffuseBasicMethod\";\n\n/**\n * DiffuseGradientMethod is an alternative to DiffuseBasicMethod in which the shading can be modulated with a gradient\n * to introduce color-tinted shading as opposed to the single-channel diffuse strength. This can be used as a crude\n * approximation to subsurface scattering (for instance, the mid-range shading for skin can be tinted red to similate\n * scattered light within the skin attributing to the final colour)\n */\nclass DiffuseGradientMethod extends DiffuseBasicMethod\n{\n\tprivate _gradient:TextureBase;\n\n\t/**\n\t * Creates a new DiffuseGradientMethod object.\n\t * @param gradient A texture that contains the light colour based on the angle. This can be used to change\n\t * the light colour due to subsurface scattering when the surface faces away from the light.\n\t */\n\tconstructor(gradient:TextureBase)\n\t{\n\t\tsuper();\n\n\t\tthis._gradient = gradient;\n\n\t\tif (this._gradient)\n\t\t\tthis.iAddTexture(this._gradient);\n\t}\n\n\tpublic iInitVO(shader:LightingShader, methodVO:MethodVO)\n\t{\n\t\tsuper.iInitVO(shader, methodVO);\n\n\t\tmethodVO.secondaryTextureGL = shader.getAbstraction(this._gradient);\n\t}\n\n\t/**\n\t * A texture that contains the light colour based on the angle. This can be used to change the light colour\n\t * due to subsurface scattering when the surface faces away from the light.\n\t */\n\tpublic get gradient():TextureBase\n\t{\n\t\treturn this._gradient;\n\t}\n\n\tpublic set gradient(value:TextureBase)\n\t{\n\t\tif (this._gradient == value)\n\t\t\treturn;\n\n\t\tif (this._gradient)\n\t\t\tthis.iRemoveTexture(this._gradient);\n\n\t\tthis._gradient = value;\n\n\t\tif (this._gradient)\n\t\t\tthis.iAddTexture(this._gradient);\n\n\t\tthis.iInvalidateShaderProgram();\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iCleanCompilationData()\n\t{\n\t\tsuper.iCleanCompilationData();\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentPreLightingCode(shader:LightingShader, methodVO:MethodVO, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = super.iGetFragmentPreLightingCode(shader, methodVO, registerCache, sharedRegisters);\n\t\tthis._pIsFirstLight = true;\n\n\t\treturn code;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentCodePerLight(shader:LightingShader, methodVO:MethodVO, lightDirReg:ShaderRegisterElement, lightColReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = \"\";\n\t\tvar t:ShaderRegisterElement;\n\n\t\t// write in temporary if not first light, so we can add to total diffuse colour\n\t\tif (this._pIsFirstLight)\n\t\t\tt = this._pTotalLightColorReg;\n\t\telse {\n\t\t\tt = registerCache.getFreeFragmentVectorTemp();\n\t\t\tregisterCache.addFragmentTempUsages(t, 1);\n\t\t}\n\n\t\tcode += \"dp3 \" + t + \".w, \" + lightDirReg + \".xyz, \" + sharedRegisters.normalFragment + \".xyz\\n\" +\n\t\t\t\"mul \" + t + \".w, \" + t + \".w, \" + sharedRegisters.commons + \".x\\n\" +\n\t\t\t\"add \" + t + \".w, \" + t + \".w, \" + sharedRegisters.commons + \".x\\n\" +\n\t\t\t\"mul \" + t + \".xyz, \" + t + \".w, \" + lightDirReg + \".w\\n\";\n\n\t\tif (this._iModulateMethod != null)\n\t\t\tcode += this._iModulateMethod(shader, methodVO, t, registerCache, sharedRegisters);\n\n\t\tcode += methodVO.secondaryTextureGL._iGetFragmentCode(t, registerCache, sharedRegisters, t) +\n\t\t\t//\t\t\t\t\t\"mul \" + t + \".xyz, \" + t + \".xyz, \" + t + \".w\\n\" +\n\t\t\t\"mul \" + t + \".xyz, \" + t + \".xyz, \" + lightColReg + \".xyz\\n\";\n\n\t\tif (!this._pIsFirstLight) {\n\t\t\tcode += \"add \" + this._pTotalLightColorReg + \".xyz, \" + this._pTotalLightColorReg + \".xyz, \" + t + \".xyz\\n\";\n\t\t\tregisterCache.removeFragmentTempUsage(t);\n\t\t}\n\n\t\tthis._pIsFirstLight = false;\n\n\t\treturn code;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic pApplyShadow(shader:LightingShader, methodVO:MethodVO, regCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar t:ShaderRegisterElement = regCache.getFreeFragmentVectorTemp();\n\n\t\treturn \"mov \" + t + \", \" + sharedRegisters.shadowTarget + \".wwww\\n\" +\n\t\t\tmethodVO.secondaryTextureGL._iGetFragmentCode(t, regCache, sharedRegisters, sharedRegisters.uvVarying) +\n\t\t\t\"mul \" + this._pTotalLightColorReg + \".xyz, \" + this._pTotalLightColorReg + \", \" + t + \"\\n\";\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iActivate(shader:LightingShader, methodVO:MethodVO, stage:Stage)\n\t{\n\t\tsuper.iActivate(shader, methodVO, stage);\n\n\t\tmethodVO.secondaryTextureGL.activate(methodVO.pass._render);\n\t}\n\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iSetRenderState(shader:LightingShader, methodVO:MethodVO, renderable:GL_RenderableBase, stage:Stage, camera:Camera)\n\t{\n\t\tsuper.iSetRenderState(shader, methodVO, renderable, stage, camera);\n\n\t\tif (shader.numLights > 0)\n\t\t\tmethodVO.secondaryTextureGL._setRenderState(renderable);\n\t}\n}\n\nexport default DiffuseGradientMethod;",
    "import Camera\t\t\t\t\t\t\tfrom \"awayjs-display/lib/display/Camera\";\nimport TextureBase\t\t\t\t\t\tfrom \"awayjs-display/lib/textures/TextureBase\";\n\nimport Stage\t\t\t\t\t\t\tfrom \"awayjs-stagegl/lib/base/Stage\";\n\nimport GL_RenderableBase\t\t\t\tfrom \"awayjs-renderergl/lib/renderables/GL_RenderableBase\";\nimport LightingShader\t\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/LightingShader\";\nimport ShaderRegisterCache\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterCache\";\nimport ShaderRegisterData\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterData\";\nimport ShaderRegisterElement\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterElement\";\n\nimport MethodVO\t\t\t\t\t\t\tfrom \"../data/MethodVO\";\nimport DiffuseBasicMethod\t\t\t\tfrom \"../methods/DiffuseBasicMethod\";\nimport DiffuseCompositeMethod\t\t\tfrom \"../methods/DiffuseCompositeMethod\";\n\n/**\n * DiffuseLightMapMethod provides a diffuse shading method that uses a light map to modulate the calculated diffuse\n * lighting. It is different from EffectLightMapMethod in that the latter modulates the entire calculated pixel color, rather\n * than only the diffuse lighting value.\n */\nclass DiffuseLightMapMethod extends DiffuseCompositeMethod\n{\n\t/**\n\t * Indicates the light map should be multiplied with the calculated shading result.\n\t * This can be used to add pre-calculated shadows or occlusion.\n\t */\n\tpublic static MULTIPLY:string = \"multiply\";\n\n\t/**\n\t * Indicates the light map should be added into the calculated shading result.\n\t * This can be used to add pre-calculated lighting or global illumination.\n\t */\n\tpublic static ADD:string = \"add\";\n\n\tprivate _lightMap:TextureBase;\n\tprivate _blendMode:string;\n\tprivate _useSecondaryUV:boolean;\n\n\t/**\n\t * Creates a new DiffuseLightMapMethod method.\n\t *\n\t * @param lightMap The texture containing the light map.\n\t * @param blendMode The blend mode with which the light map should be applied to the lighting result.\n\t * @param useSecondaryUV Indicates whether the secondary UV set should be used to map the light map.\n\t * @param baseMethod The diffuse method used to calculate the regular diffuse-based lighting.\n\t */\n\tconstructor(lightMap:TextureBase, blendMode:string = \"multiply\", useSecondaryUV:boolean = false, baseMethod:DiffuseBasicMethod = null)\n\t{\n\t\tsuper(null, baseMethod);\n\n\t\tthis._useSecondaryUV = useSecondaryUV;\n\t\tthis._lightMap = lightMap;\n\t\tthis.blendMode = blendMode;\n\n\t\tif (this._lightMap)\n\t\t\tthis.iAddTexture(this._lightMap);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitVO(shader:LightingShader, methodVO:MethodVO)\n\t{\n\t\tmethodVO.secondaryTextureGL = shader.getAbstraction(this._lightMap);\n\n\t\tif (this._useSecondaryUV)\n\t\t\tshader.secondaryUVDependencies++;\n\t\telse\n\t\t\tshader.uvDependencies++;\n\t}\n\n\t/**\n\t * The blend mode with which the light map should be applied to the lighting result.\n\t *\n\t * @see DiffuseLightMapMethod.ADD\n\t * @see DiffuseLightMapMethod.MULTIPLY\n\t */\n\tpublic get blendMode():string\n\t{\n\t\treturn this._blendMode;\n\t}\n\n\tpublic set blendMode(value:string)\n\t{\n\t\tif (value != DiffuseLightMapMethod.ADD && value != DiffuseLightMapMethod.MULTIPLY)\n\t\t\tthrow new Error(\"Unknown blendmode!\");\n\n\t\tif (this._blendMode == value)\n\t\t\treturn;\n\n\t\tthis._blendMode = value;\n\n\t\tthis.iInvalidateShaderProgram();\n\t}\n\n\t/**\n\t * The texture containing the light map data.\n\t */\n\tpublic get lightMap():TextureBase\n\t{\n\t\treturn this._lightMap;\n\t}\n\n\tpublic set lightMap(value:TextureBase)\n\t{\n\t\tif (this._lightMap == value)\n\t\t\treturn;\n\n\t\tif (this._lightMap)\n\t\t\tthis.iRemoveTexture(this._lightMap);\n\n\t\tthis._lightMap = value;\n\n\t\tif (this._lightMap)\n\t\t\tthis.iAddTexture(this._lightMap);\n\n\t\tthis.iInvalidateShaderProgram();\n\t}\n\n\t/**\n\t * Indicates whether the secondary UV set should be used to map the light map.\n\t */\n\tpublic get useSecondaryUV():boolean\n\t{\n\t\treturn this._useSecondaryUV;\n\t}\n\n\tpublic set useSecondaryUV(value:boolean)\n\t{\n\t\tif (this._useSecondaryUV == value)\n\t\t\treturn;\n\n\t\tthis._useSecondaryUV = value;\n\n\t\tthis.iInvalidateShaderProgram();\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentPostLightingCode(shader:LightingShader, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string;\n\t\tvar temp:ShaderRegisterElement = registerCache.getFreeFragmentVectorTemp();\n\n\t\tcode = methodVO.secondaryTextureGL._iGetFragmentCode(temp, registerCache, sharedRegisters, this._useSecondaryUV? sharedRegisters.secondaryUVVarying : sharedRegisters.uvVarying);\n\n\t\tswitch (this._blendMode) {\n\t\t\tcase DiffuseLightMapMethod.MULTIPLY:\n\t\t\t\tcode += \"mul \" + this._pTotalLightColorReg + \", \" + this._pTotalLightColorReg + \", \" + temp + \"\\n\";\n\t\t\t\tbreak;\n\t\t\tcase DiffuseLightMapMethod.ADD:\n\t\t\t\tcode += \"add \" + this._pTotalLightColorReg + \", \" + this._pTotalLightColorReg + \", \" + temp + \"\\n\";\n\t\t\t\tbreak;\n\t\t}\n\n\t\tcode += super.iGetFragmentPostLightingCode(shader, methodVO, targetReg, registerCache, sharedRegisters);\n\n\t\treturn code;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iActivate(shader:LightingShader, methodVO:MethodVO, stage:Stage)\n\t{\n\t\tsuper.iActivate(shader, methodVO, stage);\n\n\t\tmethodVO.secondaryTextureGL.activate(methodVO.pass._render);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iSetRenderState(shader:LightingShader, methodVO:MethodVO, renderable:GL_RenderableBase, stage:Stage, camera:Camera)\n\t{\n\t\tsuper.iSetRenderState(shader, methodVO, renderable, stage, camera);\n\n\t\tmethodVO.secondaryTextureGL._setRenderState(renderable);\n\t}\n}\n\nexport default DiffuseLightMapMethod;",
    "import Camera\t\t\t\t\t\t\tfrom \"awayjs-display/lib/display/Camera\";\n\nimport Stage\t\t\t\t\t\t\tfrom \"awayjs-stagegl/lib/base/Stage\";\n\nimport GL_RenderableBase\t\t\t\tfrom \"awayjs-renderergl/lib/renderables/GL_RenderableBase\";\nimport LightingShader\t\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/LightingShader\";\nimport ShaderBase\t\t\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderBase\";\nimport ShaderRegisterCache\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterCache\";\nimport ShaderRegisterData\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterData\";\nimport ShaderRegisterElement\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterElement\";\n\nimport MethodVO\t\t\t\t\t\t\tfrom \"../data/MethodVO\";\nimport DiffuseBasicMethod\t\t\t\tfrom \"../methods/DiffuseBasicMethod\";\nimport DiffuseCompositeMethod\t\t\tfrom \"../methods/DiffuseCompositeMethod\";\nimport SingleObjectDepthPass\t\t\tfrom \"../surfaces/passes/SingleObjectDepthPass\";\n\n/**\n * DiffuseSubSurfaceMethod provides a depth map-based diffuse shading method that mimics the scattering of\n * light inside translucent surfaces. It allows light to shine through an object and to soften the diffuse shading.\n * It can be used for candle wax, ice, skin, ...\n */\nclass DiffuseSubSurfaceMethod extends DiffuseCompositeMethod\n{\n\tprivate _depthPass:SingleObjectDepthPass;\n\tprivate _lightProjVarying:ShaderRegisterElement;\n\tprivate _propReg:ShaderRegisterElement;\n\tprivate _scattering:number;\n\tprivate _translucency:number = 1;\n\tprivate _lightColorReg:ShaderRegisterElement;\n\tprivate _scatterColor:number /*uint*/ = 0xffffff;\n\tprivate _colorReg:ShaderRegisterElement;\n\tprivate _decReg:ShaderRegisterElement;\n\tprivate _scatterR:number = 1.0;\n\tprivate _scatterG:number = 1.0;\n\tprivate _scatterB:number = 1.0;\n\tprivate _targetReg:ShaderRegisterElement;\n\t\n\t/**\n\t * Creates a new <code>DiffuseSubSurfaceMethod</code> object.\n\t *\n\t * @param depthMapSize The size of the depth map used.\n\t * @param depthMapOffset The amount by which the rendered object will be inflated, to prevent depth map rounding errors.\n\t * @param baseMethod The diffuse method used to calculate the regular diffuse-based lighting.\n\t */\n\tconstructor(depthMapSize:number /*int*/ = 512, depthMapOffset:number = 15, baseMethod:DiffuseBasicMethod = null)\n\t{\n\t\tsuper(null, baseMethod);\n\n\t\tthis.pBaseMethod._iModulateMethod = (shader:ShaderBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData) => this.scatterLight(shader, methodVO, targetReg, registerCache, sharedRegisters);\n\n\t\t//this._passes = new Array<MaterialPassGLBase>();\n\t\t//this._depthPass = new SingleObjectDepthPass();\n\t\t//this._depthPass.textureSize = depthMapSize;\n\t\t//this._depthPass.polyOffset = depthMapOffset;\n\t\t//this._passes.push(this._depthPass);\n\t\tthis._scattering = 0.2;\n\t\tthis._translucency = 1;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitConstants(shader:LightingShader, methodVO:MethodVO)\n\t{\n\t\tsuper.iInitConstants(shader, methodVO);\n\n\t\tvar data:Float32Array = shader.vertexConstantData;\n\t\tvar index:number /*int*/ = methodVO.secondaryVertexConstantsIndex;\n\t\tdata[index] = .5;\n\t\tdata[index + 1] = -.5;\n\t\tdata[index + 2] = 0;\n\t\tdata[index + 3] = 1;\n\t\t\n\t\tdata = shader.fragmentConstantData;\n\t\tindex = methodVO.secondaryFragmentConstantsIndex;\n\t\tdata[index + 3] = 1.0;\n\t\tdata[index + 4] = 1.0;\n\t\tdata[index + 5] = 1/255;\n\t\tdata[index + 6] = 1/65025;\n\t\tdata[index + 7] = 1/16581375;\n\t\tdata[index + 10] = .5;\n\t\tdata[index + 11] = -.1;\n\t}\n\t\n\tpublic iCleanCompilationData()\n\t{\n\t\tsuper.iCleanCompilationData();\n\n\t\tthis._lightProjVarying = null;\n\t\tthis._propReg = null;\n\t\tthis._lightColorReg = null;\n\t\tthis._colorReg = null;\n\t\tthis._decReg = null;\n\t\tthis._targetReg = null;\n\t}\n\t\n\t/**\n\t * The amount by which the light scatters. It can be used to set the translucent surface's thickness. Use low\n\t * values for skin.\n\t */\n\tpublic get scattering():number\n\t{\n\t\treturn this._scattering;\n\t}\n\t\n\tpublic set scattering(value:number)\n\t{\n\t\tthis._scattering = value;\n\t}\n\t\n\t/**\n\t * The translucency of the object.\n\t */\n\tpublic get translucency():number\n\t{\n\t\treturn this._translucency;\n\t}\n\t\n\tpublic set translucency(value:number)\n\t{\n\t\tthis._translucency = value;\n\t}\n\t\n\t/**\n\t * The colour of the \"insides\" of the object, ie: the colour the light becomes after leaving the object.\n\t */\n\tpublic get scatterColor():number /*uint*/\n\t{\n\t\treturn this._scatterColor;\n\t}\n\t\n\tpublic set scatterColor(scatterColor:number /*uint*/)\n\t{\n\t\tthis._scatterColor = scatterColor;\n\t\tthis._scatterR = ((scatterColor >> 16) & 0xff)/0xff;\n\t\tthis._scatterG = ((scatterColor >> 8) & 0xff)/0xff;\n\t\tthis._scatterB = (scatterColor & 0xff)/0xff;\n\t}\n\t\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetVertexCode(shader:ShaderBase, methodVO:MethodVO, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = super.iGetVertexCode(shader, methodVO, registerCache, sharedRegisters);\n\t\tvar lightProjection:ShaderRegisterElement;\n\t\tvar toTexRegister:ShaderRegisterElement;\n\t\tvar temp:ShaderRegisterElement = registerCache.getFreeVertexVectorTemp();\n\t\t\n\t\ttoTexRegister = registerCache.getFreeVertexConstant();\n\t\tmethodVO.secondaryVertexConstantsIndex = toTexRegister.index*4;\n\n\t\tthis._lightProjVarying = registerCache.getFreeVarying();\n\t\tlightProjection = registerCache.getFreeVertexConstant();\n\t\tregisterCache.getFreeVertexConstant();\n\t\tregisterCache.getFreeVertexConstant();\n\t\tregisterCache.getFreeVertexConstant();\n\t\t\n\t\tcode += \"m44 \" + temp + \", vt0, \" + lightProjection + \"\\n\" +\n\t\t\t\"div \" + temp + \".xyz, \" + temp + \".xyz, \" + temp + \".w\\n\" +\n\t\t\t\"mul \" + temp + \".xy, \" + temp + \".xy, \" + toTexRegister + \".xy\\n\" +\n\t\t\t\"add \" + temp + \".xy, \" + temp + \".xy, \" + toTexRegister + \".xx\\n\" +\n\t\t\t\"mov \" + this._lightProjVarying + \".xyz, \" + temp + \".xyz\\n\" +\n\t\t\t\"mov \" + this._lightProjVarying + \".w, va0.w\\n\";\n\t\t\n\t\treturn code;\n\t}\n\t\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentPreLightingCode(shader:LightingShader, methodVO:MethodVO, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tthis._colorReg = registerCache.getFreeFragmentConstant();\n\t\tthis._decReg = registerCache.getFreeFragmentConstant();\n\t\tthis._propReg = registerCache.getFreeFragmentConstant();\n\t\tmethodVO.secondaryFragmentConstantsIndex = this._colorReg.index*4;\n\t\t\n\t\treturn super.iGetFragmentPreLightingCode(shader, methodVO, registerCache, sharedRegisters);\n\t}\n\t\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentCodePerLight(shader:LightingShader, methodVO:MethodVO, lightDirReg:ShaderRegisterElement, lightColReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tthis._pIsFirstLight = true;\n\t\tthis._lightColorReg = lightColReg;\n\t\treturn super.iGetFragmentCodePerLight(shader, methodVO, lightDirReg, lightColReg, registerCache, sharedRegisters);\n\t}\n\t\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentPostLightingCode(shader:LightingShader, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = super.iGetFragmentPostLightingCode(shader, methodVO, targetReg, registerCache, sharedRegisters);\n\t\tvar temp:ShaderRegisterElement = registerCache.getFreeFragmentVectorTemp();\n\t\t\n\t\tcode += \"mul \" + temp + \".xyz, \" + this._lightColorReg + \".xyz, \" + this._targetReg + \".w\\n\" +\n\t\t\t\"mul \" + temp + \".xyz, \" + temp + \".xyz, \" + this._colorReg + \".xyz\\n\" +\n\t\t\t\"add \" + targetReg + \".xyz, \" + targetReg + \".xyz, \" + temp + \".xyz\\n\";\n\t\t\n\t\tif (this._targetReg != sharedRegisters.viewDirFragment)\n\t\t\tregisterCache.removeFragmentTempUsage(targetReg);\n\t\t\n\t\treturn code;\n\t}\n\t\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iActivate(shader:LightingShader, methodVO:MethodVO, stage:Stage)\n\t{\n\t\tsuper.iActivate(shader, methodVO, stage);\n\n\t\tvar index:number /*int*/ = methodVO.secondaryFragmentConstantsIndex;\n\t\tvar data:Float32Array = shader.fragmentConstantData;\n\t\tdata[index] = this._scatterR;\n\t\tdata[index + 1] = this._scatterG;\n\t\tdata[index + 2] = this._scatterB;\n\t\tdata[index + 8] = this._scattering;\n\t\tdata[index + 9] = this._translucency;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iSetRenderState(shader:ShaderBase, methodVO:MethodVO, renderable:GL_RenderableBase, stage:Stage, camera:Camera)\n\t{\n\t\tmethodVO.secondaryTextureGL = shader.getAbstraction(this._depthPass._iGetDepthMap(renderable));\n\t\tmethodVO.secondaryTextureGL._setRenderState(renderable);\n\n\t\tthis._depthPass._iGetProjection(renderable).copyRawDataTo(shader.vertexConstantData, methodVO.secondaryVertexConstantsIndex + 4, true);\n\t}\n\t\n\t/**\n\t * Generates the code for this method\n\t */\n\tprivate scatterLight(shader:ShaderBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\t// only scatter first light\n\t\tif (!this._pIsFirstLight)\n\t\t\treturn \"\";\n\n\t\tthis._pIsFirstLight = false;\n\n\t\tvar code:string = \"\";\n\n\t\tif (sharedRegisters.viewDirFragment)\n\t\t\tthis._targetReg = sharedRegisters.viewDirFragment;\n\t\telse\n\t\t\tregisterCache.addFragmentTempUsages(this._targetReg = registerCache.getFreeFragmentVectorTemp(), 1);\n\n\t\tvar temp:ShaderRegisterElement = registerCache.getFreeFragmentVectorTemp();\n\n\t\tcode += methodVO.secondaryTextureGL._iGetFragmentCode(temp, registerCache, sharedRegisters, this._lightProjVarying) +\n\t\t\t// reencode RGBA\n\t\t\t\"dp4 \" + targetReg + \".z, \" + temp + \", \" + this._decReg + \"\\n\";\n\t\t// currentDistanceToLight - closestDistanceToLight\n\t\tcode += \"sub \" + targetReg + \".z, \" + this._lightProjVarying + \".z, \" + targetReg + \".z\\n\" +\n\t\t\t\n\t\t\t\"sub \" + targetReg + \".z, \" + this._propReg + \".x, \" + targetReg + \".z\\n\" +\n\t\t\t\"mul \" + targetReg + \".z, \" + this._propReg + \".y, \" + targetReg + \".z\\n\" +\n\t\t\t\"sat \" + targetReg + \".z, \" + targetReg + \".z\\n\" +\n\t\t\t\n\t\t\t// targetReg.x contains dot(lightDir, normal)\n\t\t\t// modulate according to incident light angle (scatter = scatter*(-.5*dot(light, normal) + .5)\n\t\t\t\"neg \" + targetReg + \".y, \" + targetReg + \".x\\n\" +\n\t\t\t\"mul \" + targetReg + \".y, \" + targetReg + \".y, \" + this._propReg + \".z\\n\" +\n\t\t\t\"add \" + targetReg + \".y, \" + targetReg + \".y, \" + this._propReg + \".z\\n\" +\n\t\t\t\"mul \" + this._targetReg + \".w, \" + targetReg + \".z, \" + targetReg + \".y\\n\" +\n\t\t\t\n\t\t\t// blend diffuse: d' = (1-s)*d + s*1\n\t\t\t\"sub \" + targetReg + \".y, \" + this._colorReg + \".w, \" + this._targetReg + \".w\\n\" +\n\t\t\t\"mul \" + targetReg + \".w, \" + targetReg + \".w, \" + targetReg + \".y\\n\";\n\t\t\n\t\treturn code;\n\t}\n}\n\nexport default DiffuseSubSurfaceMethod;",
    "import Stage\t\t\t\t\t\t\tfrom \"awayjs-stagegl/lib/base/Stage\";\n\nimport LightingShader\t\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/LightingShader\";\nimport ShaderRegisterCache\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterCache\";\nimport ShaderRegisterData\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterData\";\nimport ShaderRegisterElement\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterElement\";\n\nimport MethodVO\t\t\t\t\t\t\tfrom \"../data/MethodVO\";\nimport DiffuseBasicMethod\t\t\t\tfrom \"../methods/DiffuseBasicMethod\";\n\n/**\n * DiffuseWrapMethod is an alternative to DiffuseBasicMethod in which the light is allowed to be \"wrapped around\" the normally dark area, to some extent.\n * It can be used as a crude approximation to Oren-Nayar or simple subsurface scattering.\n */\nclass DiffuseWrapMethod extends DiffuseBasicMethod\n{\n\tprivate _wrapDataRegister:ShaderRegisterElement;\n\tprivate _wrapFactor:number;\n\n\t/**\n\t * Creates a new DiffuseWrapMethod object.\n\t * @param wrapFactor A factor to indicate the amount by which the light is allowed to wrap\n\t */\n\tconstructor(wrapFactor:number = .5)\n\t{\n\t\tsuper();\n\n\t\tthis.wrapFactor = wrapFactor;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iCleanCompilationData()\n\t{\n\t\tsuper.iCleanCompilationData();\n\n\t\tthis._wrapDataRegister = null;\n\t}\n\n\t/**\n\t * A factor to indicate the amount by which the light is allowed to wrap.\n\t */\n\tpublic get wrapFactor():number\n\t{\n\t\treturn this._wrapFactor;\n\t}\n\n\tpublic set wrapFactor(value:number)\n\t{\n\t\tthis._wrapFactor = value;\n\t\tthis._wrapFactor = 1/(value + 1);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentPreLightingCode(shader:LightingShader, methodVO:MethodVO, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = super.iGetFragmentPreLightingCode(shader, methodVO, registerCache, sharedRegisters);\n\t\tthis._pIsFirstLight = true;\n\t\tthis._wrapDataRegister = registerCache.getFreeFragmentConstant();\n\t\tmethodVO.secondaryFragmentConstantsIndex = this._wrapDataRegister.index*4;\n\n\t\treturn code;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentCodePerLight(shader:LightingShader, methodVO:MethodVO, lightDirReg:ShaderRegisterElement, lightColReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = \"\";\n\t\tvar t:ShaderRegisterElement;\n\n\t\t// write in temporary if not first light, so we can add to total diffuse colour\n\t\tif (this._pIsFirstLight) {\n\t\t\tt = this._pTotalLightColorReg;\n\t\t} else {\n\t\t\tt = registerCache.getFreeFragmentVectorTemp();\n\t\t\tregisterCache.addFragmentTempUsages(t, 1);\n\t\t}\n\n\t\tcode += \"dp3 \" + t + \".x, \" + lightDirReg + \".xyz, \" + sharedRegisters.normalFragment + \".xyz\\n\" +\n\t\t\t\"add \" + t + \".y, \" + t + \".x, \" + this._wrapDataRegister + \".x\\n\" +\n\t\t\t\"mul \" + t + \".y, \" + t + \".y, \" + this._wrapDataRegister + \".y\\n\" +\n\t\t\t\"sat \" + t + \".w, \" + t + \".y\\n\" +\n\t\t\t\"mul \" + t + \".xz, \" + t + \".w, \" + lightDirReg + \".wz\\n\";\n\n\t\tif (this._iModulateMethod != null)\n\t\t\tcode += this._iModulateMethod(shader, methodVO, lightDirReg, registerCache, sharedRegisters);\n\n\t\tcode += \"mul \" + t + \", \" + t + \".x, \" + lightColReg + \"\\n\";\n\n\t\tif (!this._pIsFirstLight) {\n\t\t\tcode += \"add \" + this._pTotalLightColorReg + \".xyz, \" + this._pTotalLightColorReg + \".xyz, \" + t + \".xyz\\n\";\n\t\t\tregisterCache.removeFragmentTempUsage(t);\n\t\t}\n\n\t\tthis._pIsFirstLight = false;\n\n\t\treturn code;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iActivate(shader:LightingShader, methodVO:MethodVO, stage:Stage)\n\t{\n\t\tsuper.iActivate(shader, methodVO, stage);\n\n\t\tvar index:number /*int*/ = methodVO.secondaryFragmentConstantsIndex;\n\t\tvar data:Float32Array = shader.fragmentConstantData;\n\t\tdata[index] = this._wrapFactor;\n\t\tdata[index + 1] = 1/(this._wrapFactor + 1);\n\t}\n}\n\nexport default DiffuseWrapMethod;",
    "import Camera\t\t\t\t\t\t\tfrom \"awayjs-display/lib/display/Camera\";\nimport TextureBase\t\t\t\t\t\tfrom \"awayjs-display/lib/textures/TextureBase\";\n\nimport Stage\t\t\t\t\t\t\tfrom \"awayjs-stagegl/lib/base/Stage\";\n\nimport GL_RenderableBase\t\t\t\tfrom \"awayjs-renderergl/lib/renderables/GL_RenderableBase\";\nimport LightingShader\t\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/LightingShader\";\nimport ShaderBase\t\t\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderBase\";\nimport ShaderRegisterCache\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterCache\";\nimport ShaderRegisterData\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterData\";\nimport ShaderRegisterElement\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterElement\";\n\nimport MethodVO\t\t\t\t\t\t\tfrom \"../data/MethodVO\";\nimport EffectMethodBase\t\t\t\t\tfrom \"../methods/EffectMethodBase\";\n\n/**\n * EffectAlphaMaskMethod allows the use of an additional texture to specify the alpha value of the material. When used\n * with the secondary uv set, it allows for a tiled main texture with independently varying alpha (useful for water\n * etc).\n */\nclass EffectAlphaMaskMethod extends EffectMethodBase\n{\n\tprivate _texture:TextureBase;\n\tprivate _useSecondaryUV:boolean;\n\n\t/**\n\t * Creates a new EffectAlphaMaskMethod object.\n\t *\n\t * @param texture The texture to use as the alpha mask.\n\t * @param useSecondaryUV Indicated whether or not the secondary uv set for the mask. This allows mapping alpha independently.\n\t */\n\tconstructor(texture:TextureBase, useSecondaryUV:boolean = false)\n\t{\n\t\tsuper();\n\n\t\tthis._texture = texture;\n\t\tthis._useSecondaryUV = useSecondaryUV;\n\n\t\tif (this._texture)\n\t\t\tthis.iAddTexture(this._texture);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitVO(shader:ShaderBase, methodVO:MethodVO)\n\t{\n\t\tmethodVO.textureGL = shader.getAbstraction(this._texture);\n\n\t\tif (this._useSecondaryUV)\n\t\t\tshader.secondaryUVDependencies++;\n\t\telse\n\t\t\tshader.uvDependencies++;\n\t}\n\n\t/**\n\t * Indicated whether or not the secondary uv set for the mask. This allows mapping alpha independently, for\n\t * instance to tile the main texture and normal map while providing untiled alpha, for example to define the\n\t * transparency over a tiled water surface.\n\t */\n\tpublic get useSecondaryUV():boolean\n\t{\n\t\treturn this._useSecondaryUV;\n\t}\n\n\tpublic set useSecondaryUV(value:boolean)\n\t{\n\t\tif (this._useSecondaryUV == value)\n\t\t\treturn;\n\n\t\tthis._useSecondaryUV = value;\n\n\t\tthis.iInvalidateShaderProgram();\n\t}\n\n\t/**\n\t * The texture to use as the alpha mask.\n\t */\n\tpublic get texture():TextureBase\n\t{\n\t\treturn this._texture;\n\t}\n\n\tpublic set texture(value:TextureBase)\n\t{\n\t\tif (this._texture == value)\n\t\t\treturn;\n\n\t\tif (this._texture)\n\t\t\tthis.iRemoveTexture(this._texture);\n\n\t\tthis._texture = value;\n\n\t\tif (this._texture)\n\t\t\tthis.iAddTexture(this._texture);\n\n\t\tthis.iInvalidateShaderProgram();\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentCode(shader:ShaderBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar temp:ShaderRegisterElement = registerCache.getFreeFragmentVectorTemp();\n\n\t\treturn methodVO.textureGL._iGetFragmentCode(temp, registerCache, sharedRegisters, this._useSecondaryUV? sharedRegisters.secondaryUVVarying : sharedRegisters.uvVarying) +\n\t\t\t\"mul \" + targetReg + \", \" + targetReg + \", \" + temp + \".x\\n\";\n\t}\n\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iActivate(shader:LightingShader, methodVO:MethodVO, stage:Stage)\n\t{\n\t\tsuper.iActivate(shader, methodVO, stage);\n\n\t\tmethodVO.textureGL.activate(methodVO.pass._render);\n\t}\n\n\n\tpublic iSetRenderState(shader:ShaderBase, methodVO:MethodVO, renderable:GL_RenderableBase, stage:Stage, camera:Camera)\n\t{\n\t\tmethodVO.textureGL._setRenderState(renderable);\n\t}\n}\n\nexport default EffectAlphaMaskMethod;",
    "import Stage\t\t\t\t\t\t\tfrom \"awayjs-stagegl/lib/base/Stage\";\n\nimport ShaderBase\t\t\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderBase\";\nimport ShaderRegisterCache\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterCache\";\nimport ShaderRegisterData\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterData\";\nimport ShaderRegisterElement\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterElement\";\n\nimport MethodVO\t\t\t\t\t\t\tfrom \"../data/MethodVO\";\nimport EffectMethodBase\t\t\t\t\tfrom \"../methods/EffectMethodBase\";\n\n/**\n * EffectColorMatrixMethod provides a shading method that changes the colour of a material analogous to a ColorMatrixFilter.\n */\nclass EffectColorMatrixMethod extends EffectMethodBase\n{\n\tprivate _matrix:Array<number>;\n\n\t/**\n\t * Creates a new EffectColorTransformMethod.\n\t *\n\t * @param matrix An array of 20 items for 4 x 5 color transform.\n\t */\n\tconstructor(matrix:Array<number>)\n\t{\n\t\tsuper();\n\n\t\tif (matrix.length != 20)\n\t\t\tthrow new Error(\"Matrix length must be 20!\");\n\n\t\tthis._matrix = matrix;\n\t}\n\n\t/**\n\t * The 4 x 5 matrix to transform the color of the material.\n\t */\n\tpublic get colorMatrix():Array<number>\n\t{\n\t\treturn this._matrix;\n\t}\n\n\tpublic set colorMatrix(value:Array<number>)\n\t{\n\t\tthis._matrix = value;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentCode(shader:ShaderBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = \"\";\n\t\tvar colorMultReg:ShaderRegisterElement = registerCache.getFreeFragmentConstant();\n\t\tregisterCache.getFreeFragmentConstant();\n\t\tregisterCache.getFreeFragmentConstant();\n\t\tregisterCache.getFreeFragmentConstant();\n\n\t\tvar colorOffsetReg:ShaderRegisterElement = registerCache.getFreeFragmentConstant();\n\n\t\tmethodVO.fragmentConstantsIndex = colorMultReg.index*4;\n\n\t\tvar temp:ShaderRegisterElement = registerCache.getFreeFragmentVectorTemp();\n\n\t\tcode += \"m44 \" + temp + \", \" + targetReg + \", \" + colorMultReg + \"\\n\" +\n\t\t\t\t\"add \" + targetReg + \", \" + temp + \", \" + colorOffsetReg + \"\\n\";\n\n\t\treturn code;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iActivate(shader:ShaderBase, methodVO:MethodVO, stage:Stage)\n\t{\n\t\tvar matrix:Array<number> = this._matrix;\n\t\tvar index:number /*int*/ = methodVO.fragmentConstantsIndex;\n\t\tvar data:Float32Array = shader.fragmentConstantData;\n\n\t\t// r\n\t\tdata[index] = matrix[0];\n\t\tdata[index + 1] = matrix[1];\n\t\tdata[index + 2] = matrix[2];\n\t\tdata[index + 3] = matrix[3];\n\n\t\t// g\n\t\tdata[index + 4] = matrix[5];\n\t\tdata[index + 5] = matrix[6];\n\t\tdata[index + 6] = matrix[7];\n\t\tdata[index + 7] = matrix[8];\n\n\t\t// b\n\t\tdata[index + 8] = matrix[10];\n\t\tdata[index + 9] = matrix[11];\n\t\tdata[index + 10] = matrix[12];\n\t\tdata[index + 11] = matrix[13];\n\n\t\t// a\n\t\tdata[index + 12] = matrix[15];\n\t\tdata[index + 13] = matrix[16];\n\t\tdata[index + 14] = matrix[17];\n\t\tdata[index + 15] = matrix[18];\n\n\t\t// rgba offset\n\t\tdata[index + 16] = matrix[4];\n\t\tdata[index + 17] = matrix[9];\n\t\tdata[index + 18] = matrix[14];\n\t\tdata[index + 19] = matrix[19];\n\t}\n}\n\nexport default EffectColorMatrixMethod;",
    "import ColorTransform\t\t\t\tfrom \"awayjs-core/lib/geom/ColorTransform\";\n\nimport Stage\t\t\t\t\t\tfrom \"awayjs-stagegl/lib/base/Stage\";\n\nimport ShaderBase\t\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderBase\";\nimport ShaderRegisterCache\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterCache\";\nimport ShaderRegisterData\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterData\";\nimport ShaderRegisterElement\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterElement\";\n\nimport MethodVO\t\t\t\t\t\tfrom \"../data/MethodVO\";\nimport EffectMethodBase\t\t\t\tfrom \"../methods/EffectMethodBase\";\n\n/**\n * EffectColorTransformMethod provides a shading method that changes the colour of a material analogous to a\n * ColorTransform object.\n */\nclass EffectColorTransformMethod extends EffectMethodBase\n{\n\tprivate _colorTransform:ColorTransform;\n\n\t/**\n\t * Creates a new EffectColorTransformMethod.\n\t */\n\tconstructor()\n\t{\n\t\tsuper();\n\t}\n\n\t/**\n\t * The ColorTransform object to transform the colour of the material with.\n\t */\n\tpublic get colorTransform():ColorTransform\n\t{\n\t\treturn this._colorTransform;\n\t}\n\n\tpublic set colorTransform(value:ColorTransform)\n\t{\n\t\tthis._colorTransform = value;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentCode(shader:ShaderBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = \"\";\n\t\tvar colorMultReg:ShaderRegisterElement = registerCache.getFreeFragmentConstant();\n\t\tvar colorOffsReg:ShaderRegisterElement = registerCache.getFreeFragmentConstant();\n\n\t\tmethodVO.fragmentConstantsIndex = colorMultReg.index*4;\n\n\t\t//TODO: AGAL <> GLSL\n\n\t\tcode += \"mul \" + targetReg + \", \" + targetReg + \", \" + colorMultReg + \"\\n\" + \"add \" + targetReg + \", \" + targetReg + \", \" + colorOffsReg + \"\\n\";\n\n\t\treturn code;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iActivate(shader:ShaderBase, methodVO:MethodVO, stage:Stage)\n\t{\n\t\tvar inv:number = 1/0xff;\n\t\tvar index:number = methodVO.fragmentConstantsIndex;\n\t\tvar data:Float32Array = shader.fragmentConstantData;\n\n\t\tdata[index] = this._colorTransform.redMultiplier;\n\t\tdata[index + 1] = this._colorTransform.greenMultiplier;\n\t\tdata[index + 2] = this._colorTransform.blueMultiplier;\n\t\tdata[index + 3] = this._colorTransform.alphaMultiplier;\n\t\tdata[index + 4] = this._colorTransform.redOffset*inv;\n\t\tdata[index + 5] = this._colorTransform.greenOffset*inv;\n\t\tdata[index + 6] = this._colorTransform.blueOffset*inv;\n\t\tdata[index + 7] = this._colorTransform.alphaOffset*inv;\n\n\t}\n}\n\nexport default EffectColorTransformMethod;",
    "import Camera\t\t\t\t\t\t\tfrom \"awayjs-display/lib/display/Camera\";\nimport TextureBase\t\t\t\t\t\tfrom \"awayjs-display/lib/textures/TextureBase\";\n\nimport Stage\t\t\t\t\t\t\tfrom \"awayjs-stagegl/lib/base/Stage\";\n\nimport GL_RenderableBase\t\t\t\tfrom \"awayjs-renderergl/lib/renderables/GL_RenderableBase\";\nimport ShaderBase\t\t\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderBase\";\nimport ShaderRegisterCache\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterCache\";\nimport ShaderRegisterData\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterData\";\nimport ShaderRegisterElement\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterElement\";\n\nimport MethodVO\t\t\t\t\t\t\tfrom \"../data/MethodVO\";\nimport EffectMethodBase\t\t\t\t\tfrom \"../methods/EffectMethodBase\";\n\n/**\n * EffectEnvMapMethod provides a material method to perform reflection mapping using cube maps.\n */\nclass EffectEnvMapMethod extends EffectMethodBase\n{\n\tprivate _envMap:TextureBase;\n\tprivate _alpha:number;\n\tprivate _mask:TextureBase;\n\n\t/**\n\t * Creates an EffectEnvMapMethod object.\n\t * @param envMap The environment map containing the reflected scene.\n\t * @param alpha The reflectivity of the surface.\n\t */\n\tconstructor(envMap:TextureBase, alpha:number = 1)\n\t{\n\t\tsuper();\n\t\tthis._envMap = envMap;\n\t\tthis._alpha = alpha;\n\n\t\tif (this._envMap)\n\t\t\tthis.iAddTexture(this._envMap);\n\t}\n\n\t/**\n\t * An optional texture to modulate the reflectivity of the surface.\n\t */\n\tpublic get mask():TextureBase\n\t{\n\t\treturn this._mask;\n\t}\n\n\tpublic set mask(value:TextureBase)\n\t{\n\t\tif (value == this._mask)\n\t\t\treturn;\n\n\t\tif (this._mask)\n\t\t\tthis.iRemoveTexture(this._mask);\n\n\t\tthis._mask = value;\n\n\t\tif (this._mask)\n\t\t\tthis.iAddTexture(this._mask);\n\n\t\tthis.iInvalidateShaderProgram();\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitVO(shader:ShaderBase, methodVO:MethodVO)\n\t{\n\t\tmethodVO.needsNormals = true;\n\t\tmethodVO.needsView = true;\n\n\t\tif (this._envMap)\n\t\t\tmethodVO.textureGL = shader.getAbstraction(this._envMap);\n\n\t\tif (this._mask) {\n\t\t\tmethodVO.secondaryTextureGL = shader.getAbstraction(this._mask);\n\t\t\tshader.uvDependencies++;\n\t\t}\n\t}\n\n\t/**\n\t * The cubic environment map containing the reflected scene.\n\t */\n\tpublic get envMap():TextureBase\n\t{\n\t\treturn this._envMap;\n\t}\n\n\tpublic set envMap(value:TextureBase)\n\t{\n\t\tif (this._envMap == value)\n\t\t\treturn;\n\n\t\tif (this._envMap)\n\t\t\tthis.iRemoveTexture(this._envMap);\n\n\t\tthis._envMap = value;\n\n\t\tif (this._envMap)\n\t\t\tthis.iAddTexture(this._envMap);\n\n\t\tthis.iInvalidateShaderProgram();\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic dispose()\n\t{\n\t}\n\n\t/**\n\t * The reflectivity of the surface.\n\t */\n\tpublic get alpha():number\n\t{\n\t\treturn this._alpha;\n\t}\n\n\tpublic set alpha(value:number)\n\t{\n\t\tthis._alpha = value;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iActivate(shader:ShaderBase, methodVO:MethodVO, stage:Stage)\n\t{\n\t\tshader.fragmentConstantData[methodVO.fragmentConstantsIndex] = this._alpha;\n\n\t\tmethodVO.textureGL.activate(methodVO.pass._render);\n\n\t\tif (this._mask)\n\t\t\tmethodVO.secondaryTextureGL.activate(methodVO.pass._render);\n\t}\n\n\tpublic iSetRenderState(shader:ShaderBase, methodVO:MethodVO, renderable:GL_RenderableBase, stage:Stage, camera:Camera)\n\t{\n\t\tmethodVO.textureGL._setRenderState(renderable);\n\n\t\tif (this._mask)\n\t\t\tmethodVO.secondaryTextureGL._setRenderState(renderable);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentCode(shader:ShaderBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar dataRegister:ShaderRegisterElement = registerCache.getFreeFragmentConstant();\n\t\tvar code:string = \"\";\n\n\t\tmethodVO.fragmentConstantsIndex = dataRegister.index*4;\n\n\t\tvar temp:ShaderRegisterElement = registerCache.getFreeFragmentVectorTemp();\n\t\tregisterCache.addFragmentTempUsages(temp, 1);\n\t\tvar temp2:ShaderRegisterElement = registerCache.getFreeFragmentVectorTemp();\n\t\tregisterCache.addFragmentTempUsages(temp2, 1);\n\n\t\t// r = I - 2(I.N)*N\n\t\tcode += \"dp3 \" + temp + \".w, \" + sharedRegisters.viewDirFragment + \".xyz, \" + sharedRegisters.normalFragment + \".xyz\\n\" +\n\t\t\t\"add \" + temp + \".w, \" + temp + \".w, \" + temp + \".w\\n\" +\n\t\t\t\"mul \" + temp + \".xyz, \" + sharedRegisters.normalFragment + \".xyz, \" + temp + \".w\\n\" +\n\t\t\t\"sub \" + temp + \".xyz, \" + temp + \".xyz, \" + sharedRegisters.viewDirFragment + \".xyz\\n\" +\n\t\t\tmethodVO.textureGL._iGetFragmentCode(temp, registerCache, sharedRegisters, temp) +\n\t\t\t\"sub \" + temp2 + \".w, \" + temp + \".w, fc0.x\\n\" + // -.5\n\t\t\t\"kil \" + temp2 + \".w\\n\" +\t// used for real time reflection mapping - if alpha is not 1 (mock texture) kil output\n\t\t\t\"sub \" + temp + \", \" + temp + \", \" + targetReg + \"\\n\";\n\n\t\tif (this._mask) {\n\t\t\tcode += methodVO.secondaryTextureGL._iGetFragmentCode(temp2, registerCache, sharedRegisters, sharedRegisters.uvVarying) +\n\t\t\t\t\"mul \" + temp + \", \" + temp2 + \", \" + temp + \"\\n\";\n\t\t}\n\n\t\tcode += \"mul \" + temp + \", \" + temp + \", \" + dataRegister + \".x\\n\" +\n\t\t\t\t\"add \" + targetReg + \", \" + targetReg + \", \" + temp + \"\\n\";\n\n\t\tregisterCache.removeFragmentTempUsage(temp);\n\t\tregisterCache.removeFragmentTempUsage(temp2);\n\n\t\treturn code;\n\t}\n}\n\nexport default EffectEnvMapMethod;",
    "import Stage\t\t\t\t\t\t\tfrom \"awayjs-stagegl/lib/base/Stage\";\n\nimport LightingShader\t\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/LightingShader\";\nimport ShaderBase\t\t\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderBase\";\nimport ShaderRegisterCache\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterCache\";\nimport ShaderRegisterData\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterData\";\nimport ShaderRegisterElement\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterElement\";\n\nimport MethodVO\t\t\t\t\t\t\tfrom \"../data/MethodVO\";\nimport EffectMethodBase\t\t\t\t\tfrom \"../methods/EffectMethodBase\";\n\n/**\n * EffectFogMethod provides a method to add distance-based fog to a material.\n */\nclass EffectFogMethod extends EffectMethodBase\n{\n\tprivate _minDistance:number = 0;\n\tprivate _maxDistance:number = 1000;\n\tprivate _fogColor:number /*uint*/;\n\tprivate _fogR:number;\n\tprivate _fogG:number;\n\tprivate _fogB:number;\n\n\t/**\n\t * Creates a new EffectFogMethod object.\n\t * @param minDistance The distance from which the fog starts appearing.\n\t * @param maxDistance The distance at which the fog is densest.\n\t * @param fogColor The colour of the fog.\n\t */\n\tconstructor(minDistance:number, maxDistance:number, fogColor:number /*uint*/ = 0x808080)\n\t{\n\t\tsuper();\n\t\tthis.minDistance = minDistance;\n\t\tthis.maxDistance = maxDistance;\n\t\tthis.fogColor = fogColor;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitVO(shader:LightingShader, methodVO:MethodVO)\n\t{\n\t\tmethodVO.needsProjection = true;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitConstants(shader:ShaderBase, methodVO:MethodVO)\n\t{\n\t\tvar data:Float32Array = shader.fragmentConstantData;\n\t\tvar index:number /*int*/ = methodVO.fragmentConstantsIndex;\n\t\tdata[index + 3] = 1;\n\t\tdata[index + 6] = 0;\n\t\tdata[index + 7] = 0;\n\t}\n\n\t/**\n\t * The distance from which the fog starts appearing.\n\t */\n\tpublic get minDistance():number\n\t{\n\t\treturn this._minDistance;\n\t}\n\n\tpublic set minDistance(value:number)\n\t{\n\t\tthis._minDistance = value;\n\t}\n\n\t/**\n\t * The distance at which the fog is densest.\n\t */\n\tpublic get maxDistance():number\n\t{\n\t\treturn this._maxDistance;\n\t}\n\n\tpublic set maxDistance(value:number)\n\t{\n\t\tthis._maxDistance = value;\n\t}\n\n\t/**\n\t * The colour of the fog.\n\t */\n\tpublic get fogColor():number /*uint*/\n\t{\n\t\treturn this._fogColor;\n\t}\n\n\tpublic set fogColor(value:number/*uint*/)\n\t{\n\t\tthis._fogColor = value;\n\t\tthis._fogR = ((value >> 16) & 0xff)/0xff;\n\t\tthis._fogG = ((value >> 8) & 0xff)/0xff;\n\t\tthis._fogB = (value & 0xff)/0xff;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iActivate(shader:ShaderBase, methodVO:MethodVO, stage:Stage)\n\t{\n\t\tvar data:Float32Array = shader.fragmentConstantData;\n\t\tvar index:number /*int*/ = methodVO.fragmentConstantsIndex;\n\t\tdata[index] = this._fogR;\n\t\tdata[index + 1] = this._fogG;\n\t\tdata[index + 2] = this._fogB;\n\t\tdata[index + 4] = this._minDistance;\n\t\tdata[index + 5] = 1/(this._maxDistance - this._minDistance);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentCode(shader:ShaderBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar fogColor:ShaderRegisterElement = registerCache.getFreeFragmentConstant();\n\t\tvar fogData:ShaderRegisterElement = registerCache.getFreeFragmentConstant();\n\t\tvar temp:ShaderRegisterElement = registerCache.getFreeFragmentVectorTemp();\n\t\tregisterCache.addFragmentTempUsages(temp, 1);\n\t\tvar temp2:ShaderRegisterElement = registerCache.getFreeFragmentVectorTemp();\n\t\tvar code:string = \"\";\n\t\tmethodVO.fragmentConstantsIndex = fogColor.index*4;\n\n\t\tcode += \"sub \" + temp2 + \".w, \" + sharedRegisters.projectionFragment + \".z, \" + fogData + \".x\\n\" +\n\t\t\t\t\"mul \" + temp2 + \".w, \" + temp2 + \".w, \" + fogData + \".y\\n\" +\n\t\t\t\t\"sat \" + temp2 + \".w, \" + temp2 + \".w\\n\" +\n\t\t\t\t\"sub \" + temp + \", \" + fogColor + \", \" + targetReg + \"\\n\" + // (fogColor- col)\n\t\t\t\t\"mul \" + temp + \", \" + temp + \", \" + temp2 + \".w\\n\" + // (fogColor- col)*fogRatio\n\t\t\t\t\"add \" + targetReg + \", \" + targetReg + \", \" + temp + \"\\n\"; // fogRatio*(fogColor- col) + col\n\n\t\tregisterCache.removeFragmentTempUsage(temp);\n\n\t\treturn code;\n\t}\n}\n\nexport default EffectFogMethod;",
    "import Camera\t\t\t\t\t\t\tfrom \"awayjs-display/lib/display/Camera\";\nimport TextureBase\t\t\t\t\t\tfrom \"awayjs-display/lib/textures/TextureBase\";\n\nimport Stage\t\t\t\t\t\t\tfrom \"awayjs-stagegl/lib/base/Stage\";\n\nimport GL_RenderableBase\t\t\t\tfrom \"awayjs-renderergl/lib/renderables/GL_RenderableBase\";\nimport ShaderBase\t\t\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderBase\";\nimport ShaderRegisterCache\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterCache\";\nimport ShaderRegisterData\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterData\";\nimport ShaderRegisterElement\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterElement\";\n\nimport MethodVO\t\t\t\t\t\t\tfrom \"../data/MethodVO\";\nimport EffectMethodBase\t\t\t\t\tfrom \"../methods/EffectMethodBase\";\n\n/**\n * EffectFresnelEnvMapMethod provides a method to add fresnel-based reflectivity to an object using cube maps, which gets\n * stronger as the viewing angle becomes more grazing.\n */\nclass EffectFresnelEnvMapMethod extends EffectMethodBase\n{\n\tprivate _envMap:TextureBase;\n\tprivate _fresnelPower:number = 5;\n\tprivate _normalReflectance:number = 0;\n\tprivate _alpha:number;\n\tprivate _mask:TextureBase;\n\n\t/**\n\t * Creates a new <code>EffectFresnelEnvMapMethod</code> object.\n\t *\n\t * @param envMap The environment map containing the reflected scene.\n\t * @param alpha The reflectivity of the material.\n\t */\n\tconstructor(envMap:TextureBase, alpha:number = 1)\n\t{\n\t\tsuper();\n\n\t\tthis._envMap = envMap;\n\t\tthis._alpha = alpha;\n\n\t\tif (this._envMap)\n\t\t\tthis.iAddTexture(this._envMap);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitVO(shader:ShaderBase, methodVO:MethodVO)\n\t{\n\t\tmethodVO.needsNormals = true;\n\t\tmethodVO.needsView = true;\n\n\t\tmethodVO.textureGL = shader.getAbstraction(this._envMap);\n\n\t\tif (this._mask != null) {\n\t\t\tmethodVO.secondaryTextureGL = shader.getAbstraction(this._mask);\n\t\t\tshader.uvDependencies++;\n\t\t}\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitConstants(shader:ShaderBase, methodVO:MethodVO)\n\t{\n\t\tshader.fragmentConstantData[methodVO.fragmentConstantsIndex + 3] = 1;\n\t}\n\n\t/**\n\t * An optional texture to modulate the reflectivity of the surface.\n\t */\n\tpublic get mask():TextureBase\n\t{\n\t\treturn this._mask;\n\t}\n\n\tpublic set mask(value:TextureBase)\n\t{\n\t\tif (this._mask == value)\n\t\t\treturn;\n\n\t\tif (this._mask)\n\t\t\tthis.iRemoveTexture(this._mask);\n\n\t\tthis._mask = value;\n\n\t\tif (this._mask)\n\t\t\tthis.iAddTexture(this._mask);\n\n\t\tthis.iInvalidateShaderProgram();\n\t}\n\n\t/**\n\t * The power used in the Fresnel equation. Higher values make the fresnel effect more pronounced. Defaults to 5.\n\t */\n\tpublic get fresnelPower():number\n\t{\n\t\treturn this._fresnelPower;\n\t}\n\n\tpublic set fresnelPower(value:number)\n\t{\n\t\tthis._fresnelPower = value;\n\t}\n\n\t/**\n\t * The cubic environment map containing the reflected scene.\n\t */\n\tpublic get envMap():TextureBase\n\t{\n\t\treturn this._envMap;\n\t}\n\n\tpublic set envMap(value:TextureBase)\n\t{\n\t\tif (this._envMap == value)\n\t\t\treturn;\n\n\t\tif (this._envMap)\n\t\t\tthis.iRemoveTexture(this._envMap);\n\n\t\tthis._envMap = value;\n\n\t\tif (this._envMap)\n\t\t\tthis.iAddTexture(this._envMap);\n\t}\n\n\t/**\n\t * The reflectivity of the surface.\n\t */\n\tpublic get alpha():number\n\t{\n\t\treturn this._alpha;\n\t}\n\n\tpublic set alpha(value:number)\n\t{\n\t\tthis._alpha = value;\n\t}\n\n\t/**\n\t * The minimum amount of reflectance, ie the reflectance when the view direction is normal to the surface or light direction.\n\t */\n\tpublic get normalReflectance():number\n\t{\n\t\treturn this._normalReflectance;\n\t}\n\n\tpublic set normalReflectance(value:number)\n\t{\n\t\tthis._normalReflectance = value;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iActivate(shader:ShaderBase, methodVO:MethodVO, stage:Stage)\n\t{\n\t\tvar data:Float32Array = shader.fragmentConstantData;\n\t\tvar index:number /*int*/ = methodVO.fragmentConstantsIndex;\n\t\tdata[index] = this._alpha;\n\t\tdata[index + 1] = this._normalReflectance;\n\t\tdata[index + 2] = this._fresnelPower;\n\n\t\tmethodVO.textureGL.activate(methodVO.pass._render);\n\n\t\tif (this._mask)\n\t\t\tmethodVO.secondaryTextureGL.activate(methodVO.pass._render);\n\t}\n\n\tpublic iSetRenderState(shader:ShaderBase, methodVO:MethodVO, renderable:GL_RenderableBase, stage:Stage, camera:Camera)\n\t{\n\t\tmethodVO.textureGL._setRenderState(renderable);\n\n\t\tif (this._mask)\n\t\t\tmethodVO.secondaryTextureGL._setRenderState(renderable);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentCode(shader:ShaderBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar dataRegister:ShaderRegisterElement = registerCache.getFreeFragmentConstant();\n\t\tvar code:string = \"\";\n\t\tvar viewDirReg:ShaderRegisterElement = sharedRegisters.viewDirFragment;\n\t\tvar normalReg:ShaderRegisterElement = sharedRegisters.normalFragment;\n\n\t\tmethodVO.fragmentConstantsIndex = dataRegister.index*4;\n\n\t\tvar temp:ShaderRegisterElement = registerCache.getFreeFragmentVectorTemp();\n\t\tregisterCache.addFragmentTempUsages(temp, 1);\n\t\tvar temp2:ShaderRegisterElement = registerCache.getFreeFragmentVectorTemp();\n\t\tregisterCache.addFragmentTempUsages(temp2, 1);\n\n\t\t// r = V - 2(V.N)*N\n\t\tcode += \"dp3 \" + temp + \".w, \" + viewDirReg + \".xyz, \" + normalReg + \".xyz\\n\" +\n\t\t\t\t\"add \" + temp + \".w, \" + temp + \".w, \" + temp + \".w\\n\" +\n\t\t\t\t\"mul \" + temp + \".xyz, \" + normalReg + \".xyz, \" + temp + \".w\\n\" +\n\t\t\t\t\"sub \" + temp + \".xyz, \" + temp + \".xyz, \" + viewDirReg + \".xyz\\n\" +\n\t\t\tmethodVO.textureGL._iGetFragmentCode(temp, registerCache, sharedRegisters, temp) +\n\t\t\t\t\"sub \" + temp2 + \".w, \" + temp + \".w, fc0.x\\n\" +               \t// -.5\n\t\t\t\t\"kil \" + temp2 + \".w\\n\" +\t// used for real time reflection mapping - if alpha is not 1 (mock texture) kil output\n\t\t\t\t\"sub \" + temp + \", \" + temp + \", \" + targetReg + \"\\n\";\n\n\t\t// calculate fresnel term\n\t\tcode += \"dp3 \" + viewDirReg + \".w, \" + viewDirReg + \".xyz, \" + normalReg + \".xyz\\n\" +  // dot(V, H)\n\t\t\t\t\"sub \" + viewDirReg + \".w, \" + dataRegister + \".w, \" + viewDirReg + \".w\\n\" +       // base = 1-dot(V, H)\n\t\t\t\t\"pow \" + viewDirReg + \".w, \" + viewDirReg + \".w, \" + dataRegister + \".z\\n\" +       // exp = pow(base, 5)\n\t\t\t\t\"sub \" + normalReg + \".w, \" + dataRegister + \".w, \" + viewDirReg + \".w\\n\" +        // 1 - exp\n\t\t\t\t\"mul \" + normalReg + \".w, \" + dataRegister + \".y, \" + normalReg + \".w\\n\" +         // f0*(1 - exp)\n\t\t\t\t\"add \" + viewDirReg + \".w, \" + viewDirReg + \".w, \" + normalReg + \".w\\n\" +          // exp + f0*(1 - exp)\n\n\t\t\t\t// total alpha\n\t\t\t\t\"mul \" + viewDirReg + \".w, \" + dataRegister + \".x, \" + viewDirReg + \".w\\n\";\n\n\t\tif (this._mask) {\n\t\t\tcode += methodVO.secondaryTextureGL._iGetFragmentCode(temp2, registerCache, sharedRegisters, sharedRegisters.uvVarying) +\n\t\t\t\t\"mul \" + viewDirReg + \".w, \" + temp2 + \".x, \" + viewDirReg + \".w\\n\";\n\t\t}\n\n\t\t// blend\n\t\tcode += \"mul \" + temp + \", \" + temp + \", \" + viewDirReg + \".w\\n\" +\n\t\t\t\t\"add \" + targetReg + \", \" + targetReg + \", \" + temp + \"\\n\";\n\n\t\tregisterCache.removeFragmentTempUsage(temp);\n\t\tregisterCache.removeFragmentTempUsage(temp2);\n\n\t\treturn code;\n\t}\n}\n\nexport default EffectFresnelEnvMapMethod;",
    "import Camera\t\t\t\t\t\t\tfrom \"awayjs-display/lib/display/Camera\";\nimport TextureBase\t\t\t\t\t\tfrom \"awayjs-display/lib/textures/TextureBase\";\n\nimport Stage\t\t\t\t\t\t\tfrom \"awayjs-stagegl/lib/base/Stage\";\n\nimport GL_RenderableBase\t\t\t\tfrom \"awayjs-renderergl/lib/renderables/GL_RenderableBase\";\nimport ShaderBase\t\t\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderBase\";\nimport ShaderRegisterCache\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterCache\";\nimport ShaderRegisterData\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterData\";\nimport ShaderRegisterElement\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterElement\";\n\nimport MethodVO\t\t\t\t\t\t\tfrom \"../data/MethodVO\";\nimport EffectMethodBase\t\t\t\t\tfrom \"../methods/EffectMethodBase\";\n\n/**\n * EffectLightMapMethod provides a method that allows applying a light map texture to the calculated pixel colour.\n * It is different from DiffuseLightMapMethod in that the latter only modulates the diffuse shading value rather\n * than the whole pixel colour.\n */\nclass EffectLightMapMethod extends EffectMethodBase\n{\n\t/**\n\t * Indicates the light map should be multiplied with the calculated shading result.\n\t */\n\tpublic static MULTIPLY:string = \"multiply\";\n\n\t/**\n\t * Indicates the light map should be added into the calculated shading result.\n\t */\n\tpublic static ADD:string = \"add\";\n\n\tprivate _lightMap:TextureBase;\n\n\tprivate _blendMode:string;\n\tprivate _useSecondaryUV:boolean;\n\n\t/**\n\t * Creates a new EffectLightMapMethod object.\n\t *\n\t * @param lightMap The texture containing the light map.\n\t * @param blendMode The blend mode with which the light map should be applied to the lighting result.\n\t * @param useSecondaryUV Indicates whether the secondary UV set should be used to map the light map.\n\t */\n\tconstructor(lightMap:TextureBase, blendMode:string = \"multiply\", useSecondaryUV:boolean = false)\n\t{\n\t\tsuper();\n\n\t\tif (blendMode != EffectLightMapMethod.ADD && blendMode != EffectLightMapMethod.MULTIPLY)\n\t\t\tthrow new Error(\"Unknown blendmode!\");\n\n\t\tthis._lightMap = lightMap;\n\t\tthis._blendMode = blendMode;\n\t\tthis._useSecondaryUV = useSecondaryUV;\n\n\t\tif (this._lightMap)\n\t\t\tthis.iAddTexture(this._lightMap);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitVO(shader:ShaderBase, methodVO:MethodVO)\n\t{\n\t\tmethodVO.textureGL = shader.getAbstraction(this._lightMap);\n\n\t\tif (this._useSecondaryUV)\n\t\t\tshader.secondaryUVDependencies++;\n\t\telse\n\t\t\tshader.uvDependencies++;\n\t}\n\n\t/**\n\t * The blend mode with which the light map should be applied to the lighting result.\n\t *\n\t * @see EffectLightMapMethod.ADD\n\t * @see EffectLightMapMethod.MULTIPLY\n\t */\n\tpublic get blendMode():string\n\t{\n\t\treturn this._blendMode;\n\t}\n\n\tpublic set blendMode(value:string)\n\t{\n\t\tif (this._blendMode == value)\n\t\t\treturn;\n\n\t\tif (value != EffectLightMapMethod.ADD && value != EffectLightMapMethod.MULTIPLY)\n\t\t\tthrow new Error(\"Unknown blendmode!\");\n\n\t\tthis._blendMode = value;\n\n\t\tthis.iInvalidateShaderProgram();\n\t}\n\n\t/**\n\t * The lightMap containing the light map.\n\t */\n\tpublic get lightMap():TextureBase\n\t{\n\t\treturn this._lightMap;\n\t}\n\n\tpublic set lightMap(value:TextureBase)\n\t{\n\t\tif (this._lightMap == value)\n\t\t\treturn;\n\n\t\tif (this._lightMap)\n\t\t\tthis.iRemoveTexture(this._lightMap);\n\n\t\tthis._lightMap = value;\n\n\t\tif (this._lightMap)\n\t\t\tthis.iAddTexture(this._lightMap);\n\n\t\tthis.iInvalidateShaderProgram();\n\t}\n\n\t/**\n\t * Indicates whether the secondary UV set should be used to map the light map.\n\t */\n\tpublic get useSecondaryUV():boolean\n\t{\n\t\treturn this._useSecondaryUV;\n\t}\n\n\tpublic set useSecondaryUV(value:boolean)\n\t{\n\t\tif (this._useSecondaryUV == value)\n\t\t\treturn;\n\n\t\tthis._useSecondaryUV = value;\n\n\t\tthis.iInvalidateShaderProgram();\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentCode(shader:ShaderBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string;\n\t\tvar temp:ShaderRegisterElement = registerCache.getFreeFragmentVectorTemp();\n\n\t\tcode = methodVO.secondaryTextureGL._iGetFragmentCode(temp, registerCache, sharedRegisters, this._useSecondaryUV? sharedRegisters.secondaryUVVarying : sharedRegisters.uvVarying);\n\n\t\tswitch (this._blendMode) {\n\t\t\tcase EffectLightMapMethod.MULTIPLY:\n\t\t\t\tcode += \"mul \" + targetReg + \", \" + targetReg + \", \" + temp + \"\\n\";\n\t\t\t\tbreak;\n\t\t\tcase EffectLightMapMethod.ADD:\n\t\t\t\tcode += \"add \" + targetReg + \", \" + targetReg + \", \" + temp + \"\\n\";\n\t\t\t\tbreak;\n\t\t}\n\n\t\treturn code;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iActivate(shader:ShaderBase, methodVO:MethodVO, stage:Stage)\n\t{\n\t\tmethodVO.textureGL.activate(methodVO.pass._render);\n\t}\n\n\n\tpublic iSetRenderState(shader:ShaderBase, methodVO:MethodVO, renderable:GL_RenderableBase, stage:Stage, camera:Camera)\n\t{\n\t\tmethodVO.textureGL._setRenderState(renderable);\n\t}\n}\n\nexport default EffectLightMapMethod;",
    "import IAsset\t\t\t\t\t\tfrom \"awayjs-core/lib/library/IAsset\";\nimport AbstractMethodError\t\t\tfrom \"awayjs-core/lib/errors/AbstractMethodError\";\n\nimport ShaderBase\t\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderBase\";\nimport ShaderRegisterCache\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterCache\";\nimport ShaderRegisterData\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterData\";\nimport ShaderRegisterElement\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterElement\";\n\nimport MethodVO\t\t\t\t\t\tfrom \"../data/MethodVO\";\nimport ShadingMethodBase\t\t\tfrom \"../methods/ShadingMethodBase\";\n\n/**\n * EffectMethodBase forms an abstract base class for shader methods that are not dependent on light sources,\n * and are in essence post-process effects on the materials.\n */\nclass EffectMethodBase extends ShadingMethodBase implements IAsset\n{\n\tpublic static assetType:string = \"[asset EffectMethod]\";\n\n\tconstructor()\n\t{\n\t\tsuper();\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic get assetType():string\n\t{\n\t\treturn EffectMethodBase.assetType;\n\t}\n\n\t/**\n\t * Get the fragment shader code that should be added after all per-light code. Usually composits everything to the target register.\n\t * @param methodVO The MethodVO object containing the method data for the currently compiled material pass.\n\t * @param regCache The register cache used during the compilation.\n\t * @param targetReg The register that will be containing the method's output.\n\t * @private\n\t */\n\tpublic iGetFragmentCode(shader:ShaderBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tthrow new AbstractMethodError();\n\t}\n}\n\nexport default EffectMethodBase;",
    "import Camera\t\t\t\t\t\t\tfrom \"awayjs-display/lib/display/Camera\";\nimport TextureBase\t\t\t\t\t\tfrom \"awayjs-display/lib/textures/TextureBase\";\n\nimport Stage\t\t\t\t\t\t\tfrom \"awayjs-stagegl/lib/base/Stage\";\n\nimport GL_RenderableBase\t\t\t\tfrom \"awayjs-renderergl/lib/renderables/GL_RenderableBase\";\nimport ShaderBase\t\t\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderBase\";\nimport ShaderRegisterCache\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterCache\";\nimport ShaderRegisterData\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterData\";\nimport ShaderRegisterElement\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterElement\";\n\nimport MethodVO\t\t\t\t\t\t\tfrom \"../data/MethodVO\";\nimport EffectMethodBase\t\t\t\t\tfrom \"../methods/EffectMethodBase\";\n\n/**\n * EffectRefractionEnvMapMethod provides a method to add refracted transparency based on cube maps.\n */\nclass EffectRefractionEnvMapMethod extends EffectMethodBase\n{\n\tprivate _envMap:TextureBase;\n\n\tprivate _dispersionR:number = 0;\n\tprivate _dispersionG:number = 0;\n\tprivate _dispersionB:number = 0;\n\tprivate _useDispersion:boolean;\n\tprivate _refractionIndex:number;\n\tprivate _alpha:number = 1;\n\n\t/**\n\t * Creates a new EffectRefractionEnvMapMethod object. Example values for dispersion are: dispersionR: -0.03, dispersionG: -0.01, dispersionB: = .0015\n\t *\n\t * @param envMap The environment map containing the refracted scene.\n\t * @param refractionIndex The refractive index of the material.\n\t * @param dispersionR The amount of chromatic dispersion of the red channel. Defaults to 0 (none).\n\t * @param dispersionG The amount of chromatic dispersion of the green channel. Defaults to 0 (none).\n\t * @param dispersionB The amount of chromatic dispersion of the blue channel. Defaults to 0 (none).\n\t */\n\tconstructor(envMap:TextureBase, refractionIndex:number = .1, dispersionR:number = 0, dispersionG:number = 0, dispersionB:number = 0)\n\t{\n\t\tsuper();\n\t\tthis._envMap = envMap;\n\t\tthis._dispersionR = dispersionR;\n\t\tthis._dispersionG = dispersionG;\n\t\tthis._dispersionB = dispersionB;\n\t\tthis._useDispersion = !(this._dispersionR == this._dispersionB && this._dispersionR == this._dispersionG);\n\t\tthis._refractionIndex = refractionIndex;\n\n\t\tif (this._envMap)\n\t\t\tthis.iAddTexture(this._envMap);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitConstants(shader:ShaderBase, methodVO:MethodVO)\n\t{\n\t\tvar index:number /*int*/ = methodVO.fragmentConstantsIndex;\n\t\tvar data:Float32Array = shader.fragmentConstantData;\n\t\tdata[index + 4] = 1;\n\t\tdata[index + 5] = 0;\n\t\tdata[index + 7] = 1;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitVO(shader:ShaderBase, methodVO:MethodVO)\n\t{\n\t\tmethodVO.needsNormals = true;\n\t\tmethodVO.needsView = true;\n\n\t\tmethodVO.textureGL = shader.getAbstraction(this._envMap);\n\t}\n\n\t/**\n\t * The cube environment map to use for the refraction.\n\t */\n\tpublic get envMap():TextureBase\n\t{\n\t\treturn this._envMap;\n\t}\n\n\tpublic set envMap(value:TextureBase)\n\t{\n\t\tif (this._envMap == value)\n\t\t\treturn;\n\n\t\tif (this._envMap)\n\t\t\tthis.iRemoveTexture(this._envMap);\n\n\t\tthis._envMap = value;\n\n\t\tif (this._envMap)\n\t\t\tthis.iAddTexture(this._envMap);\n\t}\n\n\t/**\n\t * The refractive index of the material.\n\t */\n\tpublic get refractionIndex():number\n\t{\n\t\treturn this._refractionIndex;\n\t}\n\n\tpublic set refractionIndex(value:number)\n\t{\n\t\tthis._refractionIndex = value;\n\t}\n\n\t/**\n\t * The amount of chromatic dispersion of the red channel. Defaults to 0 (none).\n\t */\n\tpublic get dispersionR():number\n\t{\n\t\treturn this._dispersionR;\n\t}\n\n\tpublic set dispersionR(value:number)\n\t{\n\t\tthis._dispersionR = value;\n\n\t\tvar useDispersion:boolean = !(this._dispersionR == this._dispersionB && this._dispersionR == this._dispersionG);\n\t\tif (this._useDispersion != useDispersion) {\n\t\t\tthis.iInvalidateShaderProgram();\n\t\t\tthis._useDispersion = useDispersion;\n\t\t}\n\t}\n\n\t/**\n\t * The amount of chromatic dispersion of the green channel. Defaults to 0 (none).\n\t */\n\tpublic get dispersionG():number\n\t{\n\t\treturn this._dispersionG;\n\t}\n\n\tpublic set dispersionG(value:number)\n\t{\n\t\tthis._dispersionG = value;\n\n\t\tvar useDispersion:boolean = !(this._dispersionR == this._dispersionB && this._dispersionR == this._dispersionG);\n\t\tif (this._useDispersion != useDispersion) {\n\t\t\tthis.iInvalidateShaderProgram();\n\t\t\tthis._useDispersion = useDispersion;\n\t\t}\n\t}\n\n\t/**\n\t * The amount of chromatic dispersion of the blue channel. Defaults to 0 (none).\n\t */\n\tpublic get dispersionB():number\n\t{\n\t\treturn this._dispersionB;\n\t}\n\n\tpublic set dispersionB(value:number)\n\t{\n\t\tthis._dispersionB = value;\n\n\t\tvar useDispersion:boolean = !(this._dispersionR == this._dispersionB && this._dispersionR == this._dispersionG);\n\t\tif (this._useDispersion != useDispersion) {\n\t\t\tthis.iInvalidateShaderProgram();\n\t\t\tthis._useDispersion = useDispersion;\n\t\t}\n\t}\n\n\t/**\n\t * The amount of transparency of the object. Warning: the alpha applies to the refracted color, not the actual\n\t * material. A value of 1 will make it appear fully transparent.\n\t */\n\tpublic get alpha():number\n\t{\n\t\treturn this._alpha;\n\t}\n\n\tpublic set alpha(value:number)\n\t{\n\t\tthis._alpha = value;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iActivate(shader:ShaderBase, methodVO:MethodVO, stage:Stage)\n\t{\n\t\tvar index:number /*int*/ = methodVO.fragmentConstantsIndex;\n\t\tvar data:Float32Array = shader.fragmentConstantData;\n\n\t\tdata[index] = this._dispersionR + this._refractionIndex;\n\n\t\tif (this._useDispersion) {\n\t\t\tdata[index + 1] = this._dispersionG + this._refractionIndex;\n\t\t\tdata[index + 2] = this._dispersionB + this._refractionIndex;\n\t\t}\n\t\tdata[index + 3] = this._alpha;\n\n\t\tmethodVO.textureGL.activate(methodVO.pass._render);\n\t}\n\n\tpublic iSetRenderState(shader:ShaderBase, methodVO:MethodVO, renderable:GL_RenderableBase, stage:Stage, camera:Camera)\n\t{\n\t\tmethodVO.textureGL._setRenderState(renderable);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentCode(shader:ShaderBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\t// todo: data2.x could use common reg, so only 1 reg is used\n\t\tvar data:ShaderRegisterElement = registerCache.getFreeFragmentConstant();\n\t\tvar data2:ShaderRegisterElement = registerCache.getFreeFragmentConstant();\n\t\tvar code:string = \"\";\n\t\tvar refractionDir:ShaderRegisterElement;\n\t\tvar refractionColor:ShaderRegisterElement;\n\t\tvar temp:ShaderRegisterElement;\n\n\t\tmethodVO.fragmentConstantsIndex = data.index*4;\n\n\t\trefractionDir = registerCache.getFreeFragmentVectorTemp();\n\t\tregisterCache.addFragmentTempUsages(refractionDir, 1);\n\t\trefractionColor = registerCache.getFreeFragmentVectorTemp();\n\t\tregisterCache.addFragmentTempUsages(refractionColor, 1);\n\t\ttemp = registerCache.getFreeFragmentVectorTemp();\n\t\tregisterCache.addFragmentTempUsages(temp, 1);\n\n\t\tvar viewDirReg:ShaderRegisterElement = sharedRegisters.viewDirFragment;\n\t\tvar normalReg:ShaderRegisterElement = sharedRegisters.normalFragment;\n\n\t\tcode += \"neg \" + viewDirReg + \".xyz, \" + viewDirReg + \".xyz\\n\";\n\n\t\tcode += \"dp3 \" + temp + \".x, \" + viewDirReg + \".xyz, \" + normalReg + \".xyz\\n\" +\n\t\t\t\"mul \" + temp + \".w, \" + temp + \".x, \" + temp + \".x\\n\" +\n\t\t\t\"sub \" + temp + \".w, \" + data2 + \".x, \" + temp + \".w\\n\" +\n\t\t\t\"mul \" + temp + \".w, \" + data + \".x, \" + temp + \".w\\n\" +\n\t\t\t\"mul \" + temp + \".w, \" + data + \".x, \" + temp + \".w\\n\" +\n\t\t\t\"sub \" + temp + \".w, \" + data2 + \".x, \" + temp + \".w\\n\" +\n\t\t\t\"sqt \" + temp + \".y, \" + temp + \".w\\n\" +\n\n\t\t\t\"mul \" + temp + \".x, \" + data + \".x, \" + temp + \".x\\n\" +\n\t\t\t\"add \" + temp + \".x, \" + temp + \".x, \" + temp + \".y\\n\" +\n\t\t\t\"mul \" + temp + \".xyz, \" + temp + \".x, \" + normalReg + \".xyz\\n\" +\n\n\t\t\t\"mul \" + refractionDir + \", \" + data + \".x, \" + viewDirReg + \"\\n\" +\n\t\t\t\"sub \" + refractionDir + \".xyz, \" + refractionDir + \".xyz, \" + temp + \".xyz\\n\" +\n\t\t\t\"nrm \" + refractionDir + \".xyz, \" + refractionDir + \".xyz\\n\" +\n\t\tmethodVO.textureGL._iGetFragmentCode(refractionColor, registerCache, sharedRegisters, refractionDir) +\n\t\t\t\"sub \" + refractionColor + \".w, \" + refractionColor + \".w, fc0.x\t\\n\" +\n\t\t\t\"kil \" + refractionColor + \".w\\n\";\n\n\t\tif (this._useDispersion) {\n\t\t\t// GREEN\n\t\t\tcode += \"dp3 \" + temp + \".x, \" + viewDirReg + \".xyz, \" + normalReg + \".xyz\\n\" +\n\t\t\t\t\"mul \" + temp + \".w, \" + temp + \".x, \" + temp + \".x\\n\" +\n\t\t\t\t\"sub \" + temp + \".w, \" + data2 + \".x, \" + temp + \".w\\n\" +\n\t\t\t\t\"mul \" + temp + \".w, \" + data + \".y, \" + temp + \".w\\n\" +\n\t\t\t\t\"mul \" + temp + \".w, \" + data + \".y, \" + temp + \".w\\n\" +\n\t\t\t\t\"sub \" + temp + \".w, \" + data2 + \".x, \" + temp + \".w\\n\" +\n\t\t\t\t\"sqt \" + temp + \".y, \" + temp + \".w\\n\" +\n\n\t\t\t\t\"mul \" + temp + \".x, \" + data + \".y, \" + temp + \".x\\n\" +\n\t\t\t\t\"add \" + temp + \".x, \" + temp + \".x, \" + temp + \".y\\n\" +\n\t\t\t\t\"mul \" + temp + \".xyz, \" + temp + \".x, \" + normalReg + \".xyz\\n\" +\n\n\t\t\t\t\"mul \" + refractionDir + \", \" + data + \".y, \" + viewDirReg + \"\\n\" +\n\t\t\t\t\"sub \" + refractionDir + \".xyz, \" + refractionDir + \".xyz, \" + temp + \".xyz\\n\" +\n\t\t\t\t\"nrm \" + refractionDir + \".xyz, \" + refractionDir + \".xyz\\n\" +\n\t\t\tmethodVO.textureGL._iGetFragmentCode(temp, registerCache, sharedRegisters, refractionDir) +\n\t\t\t\t\"mov \" + refractionColor + \".y, \" + temp + \".y\\n\";\n\n\t\t\t// BLUE\n\t\t\tcode += \"dp3 \" + temp + \".x, \" + viewDirReg + \".xyz, \" + normalReg + \".xyz\\n\" +\n\t\t\t\t\"mul \" + temp + \".w, \" + temp + \".x, \" + temp + \".x\\n\" +\n\t\t\t\t\"sub \" + temp + \".w, \" + data2 + \".x, \" + temp + \".w\\n\" +\n\t\t\t\t\"mul \" + temp + \".w, \" + data + \".z, \" + temp + \".w\\n\" +\n\t\t\t\t\"mul \" + temp + \".w, \" + data + \".z, \" + temp + \".w\\n\" +\n\t\t\t\t\"sub \" + temp + \".w, \" + data2 + \".x, \" + temp + \".w\\n\" +\n\t\t\t\t\"sqt \" + temp + \".y, \" + temp + \".w\\n\" +\n\n\t\t\t\t\"mul \" + temp + \".x, \" + data + \".z, \" + temp + \".x\\n\" +\n\t\t\t\t\"add \" + temp + \".x, \" + temp + \".x, \" + temp + \".y\\n\" +\n\t\t\t\t\"mul \" + temp + \".xyz, \" + temp + \".x, \" + normalReg + \".xyz\\n\" +\n\n\t\t\t\t\"mul \" + refractionDir + \", \" + data + \".z, \" + viewDirReg + \"\\n\" +\n\t\t\t\t\"sub \" + refractionDir + \".xyz, \" + refractionDir + \".xyz, \" + temp + \".xyz\\n\" +\n\t\t\t\t\"nrm \" + refractionDir + \".xyz, \" + refractionDir + \".xyz\\n\" +\n\t\t\tmethodVO.textureGL._iGetFragmentCode(temp, registerCache, sharedRegisters, refractionDir) +\n\t\t\t\t\"mov \" + refractionColor + \".z, \" + temp + \".z\\n\";\n\t\t}\n\n\t\tcode += \"sub \" + refractionColor + \".xyz, \" + refractionColor + \".xyz, \" + targetReg + \".xyz\\n\" +\n\t\t\t\"mul \" + refractionColor + \".xyz, \" + refractionColor + \".xyz, \" + data + \".w\\n\" +\n\t\t\t\"add \" + targetReg + \".xyz, \" + targetReg + \".xyz, \" + refractionColor + \".xyz\\n\";\n\n\t\tregisterCache.removeFragmentTempUsage(temp);\n\t\tregisterCache.removeFragmentTempUsage(refractionDir);\n\t\tregisterCache.removeFragmentTempUsage(refractionColor);\n\n\t\t// restore\n\t\tcode += \"neg \" + viewDirReg + \".xyz, \" + viewDirReg + \".xyz\\n\";\n\n\t\treturn code;\n\t}\n}\n\nexport default EffectRefractionEnvMapMethod;",
    "import Stage\t\t\t\t\t\t\tfrom \"awayjs-stagegl/lib/base/Stage\";\n\nimport ShaderBase\t\t\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderBase\";\nimport ShaderRegisterCache\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterCache\";\nimport ShaderRegisterData\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterData\";\nimport ShaderRegisterElement\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterElement\";\n\nimport MethodVO\t\t\t\t\t\t\tfrom \"../data/MethodVO\";\nimport EffectMethodBase\t\t\t\t\tfrom \"../methods/EffectMethodBase\";\n\n/**\n * EffectRimLightMethod provides a method to add rim lighting to a material. This adds a glow-like effect to edges of objects.\n */\nclass EffectRimLightMethod extends EffectMethodBase\n{\n\tpublic static ADD:string = \"add\";\n\tpublic static MULTIPLY:string = \"multiply\";\n\tpublic static MIX:string = \"mix\";\n\n\tprivate _color:number /*uint*/;\n\tprivate _blendMode:string;\n\tprivate _colorR:number;\n\tprivate _colorG:number;\n\tprivate _colorB:number;\n\tprivate _strength:number;\n\tprivate _power:number;\n\n\t/**\n\t * Creates a new <code>EffectRimLightMethod</code> object.\n\t *\n\t * @param color The colour of the rim light.\n\t * @param strength The strength of the rim light.\n\t * @param power The power of the rim light. Higher values will result in a higher edge fall-off.\n\t * @param blend The blend mode with which to add the light to the object.\n\t */\n\tconstructor(color:number /*uint*/ = 0xffffff, strength:number = .4, power:number = 2, blend:string = \"mix\")\n\t{\n\t\tsuper();\n\n\t\tthis._blendMode = blend;\n\t\tthis._strength = strength;\n\t\tthis._power = power;\n\n\t\tthis.color = color;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitConstants(shader:ShaderBase, methodVO:MethodVO)\n\t{\n\t\tshader.fragmentConstantData[methodVO.fragmentConstantsIndex + 3] = 1;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitVO(shader:ShaderBase, methodVO:MethodVO)\n\t{\n\t\tmethodVO.needsNormals = true;\n\t\tmethodVO.needsView = true;\n\t}\n\n\n\t/**\n\t * The blend mode with which to add the light to the object.\n\t *\n\t * EffectRimLightMethod.MULTIPLY multiplies the rim light with the material's colour.\n\t * EffectRimLightMethod.ADD adds the rim light with the material's colour.\n\t * EffectRimLightMethod.MIX provides normal alpha blending.\n\t */\n\tpublic get blendMode():string\n\t{\n\t\treturn this._blendMode;\n\t}\n\n\tpublic set blendMode(value:string)\n\t{\n\t\tif (this._blendMode == value)\n\t\t\treturn;\n\n\t\tthis._blendMode = value;\n\n\t\tthis.iInvalidateShaderProgram();\n\t}\n\n\t/**\n\t * The color of the rim light.\n\t */\n\tpublic get color():number /*uint*/\n\t{\n\t\treturn this._color;\n\t}\n\n\tpublic set color(value:number /*uint*/)\n\t{\n\t\tthis._color = value;\n\t\tthis._colorR = ((value >> 16) & 0xff)/0xff;\n\t\tthis._colorG = ((value >> 8) & 0xff)/0xff;\n\t\tthis._colorB = (value & 0xff)/0xff;\n\t}\n\n\t/**\n\t * The strength of the rim light.\n\t */\n\tpublic get strength():number\n\t{\n\t\treturn this._strength;\n\t}\n\n\tpublic set strength(value:number)\n\t{\n\t\tthis._strength = value;\n\t}\n\n\t/**\n\t * The power of the rim light. Higher values will result in a higher edge fall-off.\n\t */\n\tpublic get power():number\n\t{\n\t\treturn this._power;\n\t}\n\n\tpublic set power(value:number)\n\t{\n\t\tthis._power = value;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iActivate(shader:ShaderBase, methodVO:MethodVO, stage:Stage)\n\t{\n\t\tvar index:number /*int*/ = methodVO.fragmentConstantsIndex;\n\t\tvar data:Float32Array = shader.fragmentConstantData;\n\t\tdata[index] = this._colorR;\n\t\tdata[index + 1] = this._colorG;\n\t\tdata[index + 2] = this._colorB;\n\t\tdata[index + 4] = this._strength;\n\t\tdata[index + 5] = this._power;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentCode(shader:ShaderBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar dataRegister:ShaderRegisterElement = registerCache.getFreeFragmentConstant();\n\t\tvar dataRegister2:ShaderRegisterElement = registerCache.getFreeFragmentConstant();\n\t\tvar temp:ShaderRegisterElement = registerCache.getFreeFragmentVectorTemp();\n\t\tvar code:string = \"\";\n\n\t\tmethodVO.fragmentConstantsIndex = dataRegister.index*4;\n\n\t\tcode += \"dp3 \" + temp + \".x, \" + sharedRegisters.viewDirFragment + \".xyz, \" + sharedRegisters.normalFragment + \".xyz\\n\" +\n\t\t\t\"sat \" + temp + \".x, \" + temp + \".x\\n\" +\n\t\t\t\"sub \" + temp + \".x, \" + dataRegister + \".w, \" + temp + \".x\\n\" +\n\t\t\t\"pow \" + temp + \".x, \" + temp + \".x, \" + dataRegister2 + \".y\\n\" +\n\t\t\t\"mul \" + temp + \".x, \" + temp + \".x, \" + dataRegister2 + \".x\\n\" +\n\t\t\t\"sub \" + temp + \".x, \" + dataRegister + \".w, \" + temp + \".x\\n\" +\n\t\t\t\"mul \" + targetReg + \".xyz, \" + targetReg + \".xyz, \" + temp + \".x\\n\" +\n\t\t\t\"sub \" + temp + \".w, \" + dataRegister + \".w, \" + temp + \".x\\n\";\n\n\t\tif (this._blendMode == EffectRimLightMethod.ADD) {\n\t\t\tcode += \"mul \" + temp + \".xyz, \" + temp + \".w, \" + dataRegister + \".xyz\\n\" +\n\t\t\t\t\"add \" + targetReg + \".xyz, \" + targetReg + \".xyz, \" + temp + \".xyz\\n\";\n\t\t} else if (this._blendMode == EffectRimLightMethod.MULTIPLY) {\n\t\t\tcode += \"mul \" + temp + \".xyz, \" + temp + \".w, \" + dataRegister + \".xyz\\n\" +\n\t\t\t\t\"mul \" + targetReg + \".xyz, \" + targetReg + \".xyz, \" + temp + \".xyz\\n\";\n\t\t} else {\n\t\t\tcode += \"sub \" + temp + \".xyz, \" + dataRegister + \".xyz, \" + targetReg + \".xyz\\n\" +\n\t\t\t\t\"mul \" + temp + \".xyz, \" + temp + \".xyz, \" + temp + \".w\\n\" +\n\t\t\t\t\"add \" + targetReg + \".xyz, \" + targetReg + \".xyz, \" + temp + \".xyz\\n\";\n\t\t}\n\n\t\treturn code;\n\t}\n}\n\nexport default EffectRimLightMethod;",
    "import ShaderBase\t\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderBase\";\nimport LightingShader\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/LightingShader\";\nimport ShaderRegisterCache\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterCache\";\nimport ShaderRegisterData\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterData\";\nimport ShaderRegisterElement\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterElement\";\n\nimport MethodVO\t\t\t\t\t\tfrom \"../data/MethodVO\";\nimport ShadingMethodBase\t\t\tfrom \"../methods/ShadingMethodBase\";\n\n/**\n * LightingMethodBase provides an abstract base method for shading methods that uses lights.\n * Used for diffuse and specular shaders only.\n */\nclass LightingMethodBase extends ShadingMethodBase\n{\n\t/**\n\t * A method that is exposed to wrappers in case the strength needs to be controlled\n\t */\n\tpublic _iModulateMethod:(shader:ShaderBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData) => string;\n\n\t/**\n\t * Creates a new LightingMethodBase.\n\t */\n\tconstructor()\n\t{\n\t\tsuper();\n\t}\n\n\t/**\n\t * Get the fragment shader code that will be needed before any per-light code is added.\n\t * @param methodVO The MethodVO object containing the method data for the currently compiled material pass.\n\t * @param regCache The register cache used during the compilation.\n\t * @private\n\t */\n\tpublic iGetFragmentPreLightingCode(shader:LightingShader, methodVO:MethodVO, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\treturn \"\";\n\t}\n\n\t/**\n\t * Get the fragment shader code that will generate the code relevant to a single light.\n\t *\n\t * @param methodVO The MethodVO object containing the method data for the currently compiled material pass.\n\t * @param lightDirReg The register containing the light direction vector.\n\t * @param lightColReg The register containing the light colour.\n\t * @param regCache The register cache used during the compilation.\n\t */\n\tpublic iGetFragmentCodePerLight(shader:LightingShader, methodVO:MethodVO, lightDirReg:ShaderRegisterElement, lightColReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\treturn \"\";\n\t}\n\n\t/**\n\t * Get the fragment shader code that will generate the code relevant to a single light probe object.\n\t *\n\t * @param methodVO The MethodVO object containing the method data for the currently compiled material pass.\n\t * @param cubeMapReg The register containing the cube map for the current probe\n\t * @param weightRegister A string representation of the register + component containing the current weight\n\t * @param regCache The register cache providing any necessary registers to the shader\n\t */\n\tpublic iGetFragmentCodePerProbe(shader:LightingShader, methodVO:MethodVO, cubeMapReg:ShaderRegisterElement, weightRegister:string, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\treturn \"\";\n\t}\n\n\t/**\n\t * Get the fragment shader code that should be added after all per-light code. Usually composits everything to the target register.\n\t *\n\t * @param methodVO The MethodVO object containing the method data for the currently compiled material pass.\n\t * @param regCache The register cache used during the compilation.\n\t * @param targetReg The register containing the final shading output.\n\t * @private\n\t */\n\tpublic iGetFragmentPostLightingCode(shader:LightingShader, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\treturn \"\";\n\t}\n}\n\nexport default LightingMethodBase;",
    "import Camera\t\t\t\t\t\t\tfrom \"awayjs-display/lib/display/Camera\";\nimport TextureBase\t\t\t\t\t\tfrom \"awayjs-display/lib/textures/TextureBase\";\n\nimport Stage\t\t\t\t\t\t\tfrom \"awayjs-stagegl/lib/base/Stage\";\n\nimport GL_RenderableBase\t\t\t\tfrom \"awayjs-renderergl/lib/renderables/GL_RenderableBase\";\nimport ShaderBase\t\t\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderBase\";\nimport ShaderRegisterCache\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterCache\";\nimport ShaderRegisterData\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterData\";\nimport ShaderRegisterElement\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterElement\";\n\nimport MethodVO\t\t\t\t\t\t\tfrom \"../data/MethodVO\";\nimport ShadingMethodBase\t\t\t\tfrom \"../methods/ShadingMethodBase\";\n\n/**\n * NormalBasicMethod is the default method for standard tangent-space normal mapping.\n */\nclass NormalBasicMethod extends ShadingMethodBase\n{\n\tprivate _texture:TextureBase;\n\n\t/**\n\t * Creates a new NormalBasicMethod object.\n\t */\n\tconstructor(texture:TextureBase = null)\n\t{\n\t\tsuper();\n\n\t\tthis._texture = texture;\n\n\t\tif (this._texture)\n\t\t\tthis.iAddTexture(this._texture);\n\t}\n\n\tpublic iIsUsed(shader:ShaderBase):boolean\n\t{\n\t\tif (this._texture && shader.normalDependencies)\n\t\t\treturn true;\n\n\t\treturn false;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitVO(shader:ShaderBase, methodVO:MethodVO)\n\t{\n\t\tif (this._texture) {\n\t\t\tmethodVO.textureGL = shader.getAbstraction(this._texture);\n\t\t\tshader.uvDependencies++;\n\t\t}\n\t}\n\n\t/**\n\t * Indicates whether or not this method outputs normals in tangent space. Override for object-space normals.\n\t */\n\tpublic iOutputsTangentNormals():boolean\n\t{\n\t\treturn true;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic copyFrom(method:ShadingMethodBase)\n\t{\n\t\tvar s:any = method;\n\t\tvar bnm:NormalBasicMethod = <NormalBasicMethod> method;\n\n\t\tif (bnm.texture != null)\n\t\t\tthis.texture = bnm.texture;\n\t}\n\n\t/**\n\t * A texture to modulate the direction of the surface for each texel (normal map). The default normal method expects\n\t * tangent-space normal maps, but others could expect object-space maps.\n\t */\n\tpublic get texture():TextureBase\n\t{\n\t\treturn this._texture;\n\t}\n\n\tpublic set texture(value:TextureBase)\n\t{\n\t\tif (this._texture == value)\n\t\t\treturn;\n\n\t\tif (this._texture)\n\t\t\tthis.iRemoveTexture(this._texture);\n\n\t\tthis._texture = value;\n\n\t\tif (this._texture)\n\t\t\tthis.iAddTexture(this._texture);\n\n\t\tthis.iInvalidateShaderProgram();\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic dispose()\n\t{\n\t\tif (this._texture)\n\t\t\tthis._texture = null;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iActivate(shader:ShaderBase, methodVO:MethodVO, stage:Stage)\n\t{\n\t\tif (this._texture)\n\t\t\tmethodVO.textureGL.activate(methodVO.pass._render);\n\t}\n\n\tpublic iSetRenderState(shader:ShaderBase, methodVO:MethodVO, renderable:GL_RenderableBase, stage:Stage, camera:Camera)\n\t{\n\t\tif (this._texture)\n\t\t\tmethodVO.textureGL._setRenderState(renderable);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentCode(shader:ShaderBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = \"\";\n\n\t\tif (this._texture)\n\t\t\tcode += methodVO.textureGL._iGetFragmentCode(targetReg, registerCache, sharedRegisters, sharedRegisters.uvVarying);\n\n\n\t\tcode += \"sub \" + targetReg + \".xyz, \" + targetReg + \".xyz, \" + sharedRegisters.commons + \".xxx\\n\" +\n\t\t\t\"nrm \" + targetReg + \".xyz, \" + targetReg + \"\\n\";\n\n\t\treturn code;\n\t}\n}\n\nexport default NormalBasicMethod;",
    "import Single2DTexture\t\t\t\t\tfrom \"awayjs-display/lib/textures/Single2DTexture\";\nimport TextureBase\t\t\t\t\t\tfrom \"awayjs-display/lib/textures/TextureBase\";\n\nimport ShaderBase\t\t\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderBase\";\nimport ShaderRegisterCache\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterCache\";\nimport ShaderRegisterData\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterData\";\nimport ShaderRegisterElement\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterElement\";\n\nimport MethodVO\t\t\t\t\t\t\tfrom \"../data/MethodVO\";\nimport NormalBasicMethod\t\t\t\tfrom \"../methods/NormalBasicMethod\";\nimport ShadingMethodBase\t\t\t\tfrom \"../methods/ShadingMethodBase\";\n\n/**\n * NormalHeightMapMethod provides a normal map method that uses a height map to calculate the normals.\n */\nclass NormalHeightMapMethod extends NormalBasicMethod\n{\n\tprivate _worldXYRatio:number;\n\tprivate _worldXZRatio:number;\n\n\t/**\n\t * Creates a new NormalHeightMapMethod method.\n\t *\n\t * @param heightMap The texture containing the height data. 0 means low, 1 means high.\n\t * @param worldWidth The width of the 'world'. This is used to map uv coordinates' u component to scene dimensions.\n\t * @param worldHeight The height of the 'world'. This is used to map the height map values to scene dimensions.\n\t * @param worldDepth The depth of the 'world'. This is used to map uv coordinates' v component to scene dimensions.\n\t */\n\tconstructor(heightMap:TextureBase, worldWidth:number, worldHeight:number, worldDepth:number)\n\t{\n\t\tsuper();\n\n\t\tthis.texture = heightMap;\n\t\tthis._worldXYRatio = worldWidth/worldHeight;\n\t\tthis._worldXZRatio = worldDepth/worldHeight;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitConstants(shader:ShaderBase, methodVO:MethodVO)\n\t{\n\t\tvar index:number /*int*/ = methodVO.fragmentConstantsIndex;\n\t\tvar data:Float32Array = shader.fragmentConstantData;\n\t\tdata[index] = 1/(<Single2DTexture> this.texture).image2D.width;\n\t\tdata[index + 1] = 1/(<Single2DTexture> this.texture).image2D.height;\n\t\tdata[index + 2] = 0;\n\t\tdata[index + 3] = 1;\n\t\tdata[index + 4] = this._worldXYRatio;\n\t\tdata[index + 5] = this._worldXZRatio;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic get tangentSpace():boolean\n\t{\n\t\treturn false;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic copyFrom(method:ShadingMethodBase)\n\t{\n\t\tsuper.copyFrom(method);\n\n\t\tthis._worldXYRatio = (<NormalHeightMapMethod> method)._worldXYRatio;\n\t\tthis._worldXZRatio = (<NormalHeightMapMethod> method)._worldXZRatio;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentCode(shader:ShaderBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = \"\";\n\t\tvar temp:ShaderRegisterElement = registerCache.getFreeFragmentVectorTemp();\n\t\tregisterCache.addFragmentTempUsages(temp, 1);\n\n\t\tvar dataReg:ShaderRegisterElement = registerCache.getFreeFragmentConstant();\n\t\tvar dataReg2:ShaderRegisterElement = registerCache.getFreeFragmentConstant();\n\n\t\tmethodVO.fragmentConstantsIndex = dataReg.index*4;\n\n\t\tcode+= methodVO.textureGL._iGetFragmentCode(targetReg, registerCache, sharedRegisters, sharedRegisters.uvVarying) +\n\n\t\t\t\"add \" + temp + \", \" + sharedRegisters.uvVarying + \", \" + dataReg + \".xzzz\\n\" +\n\n\t\tmethodVO.textureGL._iGetFragmentCode(temp, registerCache, sharedRegisters, temp) +\n\n\t\t\t\"sub \" + targetReg + \".x, \" + targetReg + \".x, \" + temp + \".x\\n\" +\n\t\t\t\"add \" + temp + \", \" + sharedRegisters.uvVarying + \", \" + dataReg + \".zyzz\\n\" +\n\n\t\tmethodVO.textureGL._iGetFragmentCode(temp, registerCache, sharedRegisters, temp) +\n\n\t\t\t\"sub \" + targetReg + \".z, \" + targetReg + \".z, \" + temp + \".x\\n\" +\n\t\t\t\"mov \" + targetReg + \".y, \" + dataReg + \".w\\n\" +\n\t\t\t\"mul \" + targetReg + \".xz, \" + targetReg + \".xz, \" + dataReg2 + \".xy\\n\" +\n\t\t\t\"nrm \" + targetReg + \".xyz, \" + targetReg + \".xyz\\n\";\n\n\t\tregisterCache.removeFragmentTempUsage(temp);\n\n\t\treturn code;\n\t}\n}\n\nexport default NormalHeightMapMethod;",
    "import Camera\t\t\t\t\t\t\tfrom \"awayjs-display/lib/display/Camera\";\nimport TextureBase\t\t\t\t\t\tfrom \"awayjs-display/lib/textures/TextureBase\";\n\nimport Stage\t\t\t\t\t\t\tfrom \"awayjs-stagegl/lib/base/Stage\";\n\nimport GL_RenderableBase\t\t\t\tfrom \"awayjs-renderergl/lib/renderables/GL_RenderableBase\";\nimport ShaderBase\t\t\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderBase\";\nimport ShaderRegisterCache\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterCache\";\nimport ShaderRegisterData\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterData\";\nimport ShaderRegisterElement\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterElement\";\n\nimport MethodVO\t\t\t\t\t\t\tfrom \"../data/MethodVO\";\nimport NormalBasicMethod\t\t\t\tfrom \"../methods/NormalBasicMethod\";\n\n/**\n * NormalSimpleWaterMethod provides a basic normal map method to create water ripples by translating two wave normal maps.\n */\nclass NormalSimpleWaterMethod extends NormalBasicMethod\n{\n\tprivate _secondaryNormalMap:TextureBase;\n\tprivate _water1OffsetX:number = 0;\n\tprivate _water1OffsetY:number = 0;\n\tprivate _water2OffsetX:number = 0;\n\tprivate _water2OffsetY:number = 0;\n\n\t/**\n\t * Creates a new NormalSimpleWaterMethod object.\n\t * @param waveMap1 A normal map containing one layer of a wave structure.\n\t * @param waveMap2 A normal map containing a second layer of a wave structure.\n\t */\n\tconstructor(normalMap:TextureBase = null, secondaryNormalMap:TextureBase = null)\n\t{\n\t\tsuper(normalMap);\n\n\t\tthis._secondaryNormalMap = secondaryNormalMap;\n\n\t\tif (this._secondaryNormalMap)\n\t\t\tthis.iAddTexture(this._secondaryNormalMap);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitConstants(shader:ShaderBase, methodVO:MethodVO)\n\t{\n\t\tvar index:number = methodVO.fragmentConstantsIndex;\n\t\tvar data:Float32Array = shader.fragmentConstantData;\n\t\tdata[index] = .5;\n\t\tdata[index + 1] = 0;\n\t\tdata[index + 2] = 0;\n\t\tdata[index + 3] = 1;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitVO(shader:ShaderBase, methodVO:MethodVO)\n\t{\n\t\tsuper.iInitVO(shader, methodVO);\n\t\t\n\t\tif (this._secondaryNormalMap) {\n\t\t\tmethodVO.secondaryTextureGL = shader.getAbstraction(this._secondaryNormalMap);\n\t\t\tshader.uvDependencies++;\n\t\t}\n\t}\n\n\t/**\n\t * The translation of the first wave layer along the X-axis.\n\t */\n\tpublic get water1OffsetX():number\n\t{\n\t\treturn this._water1OffsetX;\n\t}\n\n\tpublic set water1OffsetX(value:number)\n\t{\n\t\tthis._water1OffsetX = value;\n\t}\n\n\t/**\n\t * The translation of the first wave layer along the Y-axis.\n\t */\n\tpublic get water1OffsetY():number\n\t{\n\t\treturn this._water1OffsetY;\n\t}\n\n\tpublic set water1OffsetY(value:number)\n\t{\n\t\tthis._water1OffsetY = value;\n\t}\n\n\t/**\n\t * The translation of the second wave layer along the X-axis.\n\t */\n\tpublic get water2OffsetX():number\n\t{\n\t\treturn this._water2OffsetX;\n\t}\n\n\tpublic set water2OffsetX(value:number)\n\t{\n\t\tthis._water2OffsetX = value;\n\t}\n\n\t/**\n\t * The translation of the second wave layer along the Y-axis.\n\t */\n\tpublic get water2OffsetY():number\n\t{\n\t\treturn this._water2OffsetY;\n\t}\n\n\tpublic set water2OffsetY(value:number)\n\t{\n\t\tthis._water2OffsetY = value;\n\t}\n\n\t/**\n\t * A second normal map that will be combined with the first to create a wave-like animation pattern.\n\t */\n\tpublic get secondaryNormalMap():TextureBase\n\t{\n\t\treturn this._secondaryNormalMap;\n\t}\n\n\tpublic set secondaryNormalMap(value:TextureBase)\n\t{\n\t\tif (this._secondaryNormalMap == value)\n\t\t\treturn;\n\n\t\tif (this._secondaryNormalMap)\n\t\t\tthis.iRemoveTexture(this._secondaryNormalMap);\n\n\t\tthis._secondaryNormalMap = value;\n\n\t\tif (this._secondaryNormalMap)\n\t\t\tthis.iAddTexture(this._secondaryNormalMap);\n\n\t\tthis.iInvalidateShaderProgram();\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic dispose()\n\t{\n\t\tsuper.dispose();\n\n\t\tthis._secondaryNormalMap = null;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iActivate(shader:ShaderBase, methodVO:MethodVO, stage:Stage)\n\t{\n\t\tsuper.iActivate(shader, methodVO, stage);\n\n\t\tvar data:Float32Array = shader.fragmentConstantData;\n\t\tvar index:number = methodVO.fragmentConstantsIndex;\n\n\t\tdata[index + 4] = this._water1OffsetX;\n\t\tdata[index + 5] = this._water1OffsetY;\n\t\tdata[index + 6] = this._water2OffsetX;\n\t\tdata[index + 7] = this._water2OffsetY;\n\n\t\tif (this._secondaryNormalMap)\n\t\t\tmethodVO.secondaryTextureGL.activate(methodVO.pass._render);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iSetRenderState(shader:ShaderBase, methodVO:MethodVO, renderable:GL_RenderableBase, stage:Stage, camera:Camera)\n\t{\n\t\tsuper.iSetRenderState(shader, methodVO, renderable, stage, camera);\n\n\t\tif (this._secondaryNormalMap)\n\t\t\tmethodVO.secondaryTextureGL._setRenderState(renderable);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentCode(shader:ShaderBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = \"\";\n\t\tvar temp:ShaderRegisterElement = registerCache.getFreeFragmentVectorTemp();\n\t\tregisterCache.addFragmentTempUsages(temp, 1);\n\n\t\tvar dataReg:ShaderRegisterElement = registerCache.getFreeFragmentConstant();\n\t\tvar dataReg2:ShaderRegisterElement = registerCache.getFreeFragmentConstant();\n\t\tmethodVO.fragmentConstantsIndex = dataReg.index*4;\n\n\t\tcode += \"add \" + temp + \", \" + sharedRegisters.uvVarying + \", \" + dataReg2 + \".xyxy\\n\";\n\n\t\tif (this.texture)\n\t\t\tcode += methodVO.textureGL._iGetFragmentCode(targetReg, registerCache, sharedRegisters, temp);\n\n\t\tcode += \"add \" + temp + \", \" + sharedRegisters.uvVarying + \", \" + dataReg2 + \".zwzw\\n\";\n\n\t\tif (this._secondaryNormalMap)\n\t\t\tcode += methodVO.secondaryTextureGL._iGetFragmentCode(temp, registerCache, sharedRegisters, temp);\n\n\t\tcode +=\t\"add \" + targetReg + \", \" + targetReg + \", \" + temp + \"\t\t\\n\" +\n\t\t\t\"mul \" + targetReg + \", \" + targetReg + \", \" + dataReg + \".x\t\\n\" +\n\t\t\t\"sub \" + targetReg + \".xyz, \" + targetReg + \".xyz, \" + sharedRegisters.commons + \".xxx\t\\n\" +\n\t\t\t\"nrm \" + targetReg + \".xyz, \" + targetReg + \".xyz\t\t\t\t\t\t\t\\n\";\n\n\t\treturn code;\n\t}\n}\n\nexport default NormalSimpleWaterMethod;",
    "import AssetBase\t\t\t\t\tfrom \"awayjs-core/lib/library/AssetBase\";\n\nimport Camera\t\t\t\t\t\tfrom \"awayjs-display/lib/display/Camera\";\nimport ISurface\t\t\t\t\t\tfrom \"awayjs-display/lib/base/ISurface\";\nimport TextureBase\t\t\t\t\tfrom \"awayjs-display/lib/textures/TextureBase\";\n\nimport Stage\t\t\t\t\t\tfrom \"awayjs-stagegl/lib/base/Stage\";\n\nimport GL_RenderableBase\t\t\tfrom \"awayjs-renderergl/lib/renderables/GL_RenderableBase\";\nimport ShadingMethodEvent\t\t\tfrom \"awayjs-renderergl/lib/events/ShadingMethodEvent\";\nimport ShaderBase\t\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderBase\";\nimport ShaderRegisterCache\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterCache\";\nimport ShaderRegisterData\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterData\";\nimport ShaderRegisterElement\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterElement\";\n\nimport MethodVO\t\t\t\t\t\tfrom \"../data/MethodVO\";\n\n\n/**\n * ShadingMethodBase provides an abstract base method for shading methods, used by compiled passes to compile\n * the final shading program.\n */\nclass ShadingMethodBase extends AssetBase\n{\n\tpublic _textures:Array<TextureBase> = new Array<TextureBase>();\n\n\tpublic _owners:Array<ISurface> = new Array<ISurface>();\n\tpublic _counts:Array<number> = new Array<number>();\n\n\tpublic static assetType:string = \"[asset ShadingMethod]\";\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic get assetType():string\n\t{\n\t\treturn ShadingMethodBase.assetType;\n\t}\n\n\t/**\n\t * Create a new ShadingMethodBase object.\n\t */\n\tconstructor()\n\t{\n\t\tsuper();\n\t}\n\n\tpublic iIsUsed(shader:ShaderBase):boolean\n\t{\n\t\treturn true;\n\t}\n\n\t/**\n\t * Initializes the properties for a MethodVO, including register and texture indices.\n\t *\n\t * @param methodVO The MethodVO object linking this method with the pass currently being compiled.\n\t *\n\t * @internal\n\t */\n\tpublic iInitVO(shader:ShaderBase, methodVO:MethodVO)\n\t{\n\n\t}\n\n\t/**\n\t * Initializes unchanging shader constants using the data from a MethodVO.\n\t *\n\t * @param methodVO The MethodVO object linking this method with the pass currently being compiled.\n\t *\n\t * @internal\n\t */\n\tpublic iInitConstants(shader:ShaderBase, methodVO:MethodVO)\n\t{\n\n\n\t}\n\n\t/**\n\t * Indicates whether or not this method expects normals in tangent space. Override for object-space normals.\n\t */\n\tpublic iUsesTangentSpace():boolean\n\t{\n\t\treturn true;\n\t}\n\n\t/**\n\t * Cleans up any resources used by the current object.\n\t */\n\tpublic dispose()\n\t{\n\n\t}\n\n\n\tpublic iAddOwner(owner:ISurface)\n\t{\n\t\t//a method can be used more than once in the same material, so we check for this\n\t\tvar index:number = this._owners.indexOf(owner);\n\n\t\tif (index != -1) {\n\t\t\tthis._counts[index]++;\n\t\t} else {\n\t\t\tthis._owners.push(owner);\n\t\t\tthis._counts.push(1);\n\n\t\t\t//add textures\n\t\t\tvar len:number = this._textures.length;\n\t\t\tfor (var i:number = 0; i< len; i++)\n\t\t\t\towner.addTexture(this._textures[i]);\n\t\t}\n\t}\n\n\tpublic iRemoveOwner(owner:ISurface)\n\t{\n\t\tvar index:number = this._owners.indexOf(owner);\n\n\t\tif (this._counts[index] != 1) {\n\t\t\tthis._counts[index]--;\n\t\t} else {\n\t\t\tthis._owners.splice(index, 1);\n\t\t\tthis._counts.splice(index, 1);\n\n\t\t\t//remove textures\n\t\t\tvar len:number = this._textures.length;\n\t\t\tfor (var i:number = 0; i< len; i++)\n\t\t\t\towner.removeTexture(this._textures[i]);\n\t\t}\n\t}\n\n\n\t/**\n\t *\n\t */\n\tpublic iAddTexture(texture:TextureBase)\n\t{\n\t\tthis._textures.push(texture);\n\n\t\tvar len:number = this._owners.length;\n\t\tfor (var i:number = 0; i < len; i++)\n\t\t\tthis._owners[i].addTexture(texture);\n\t}\n\n\t/**\n\t *\n\t */\n\tpublic iRemoveTexture(texture:TextureBase)\n\t{\n\t\tthis._textures.splice(this._textures.indexOf(texture), 1);\n\n\t\tvar len:number = this._owners.length;\n\t\tfor (var i:number = 0; i < len; i++)\n\t\t\tthis._owners[i].removeTexture(texture);\n\t}\n\n\t/**\n\t * Resets the compilation state of the method.\n\t *\n\t * @internal\n\t */\n\tpublic iReset()\n\t{\n\t\tthis.iCleanCompilationData();\n\t}\n\n\t/**\n\t * Resets the method's state for compilation.\n\t *\n\t * @internal\n\t */\n\tpublic iCleanCompilationData()\n\t{\n\t}\n\n\t/**\n\t * Get the vertex shader code for this method.\n\t * @param vo The MethodVO object linking this method with the pass currently being compiled.\n\t * @param regCache The register cache used during the compilation.\n\t *\n\t * @internal\n\t */\n\tpublic iGetVertexCode(shader:ShaderBase, methodVO:MethodVO, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\treturn \"\";\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentCode(shader:ShaderBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\treturn null;\n\t}\n\n\t/**\n\t * Sets the render state for this method.\n\t *\n\t * @param methodVO The MethodVO object linking this method with the pass currently being compiled.\n\t * @param stage The Stage object currently used for rendering.\n\t *\n\t * @internal\n\t */\n\tpublic iActivate(shader:ShaderBase, methodVO:MethodVO, stage:Stage)\n\t{\n\n\t}\n\n\t/**\n\t * Sets the render state for a single renderable.\n\t *\n\t * @param vo The MethodVO object linking this method with the pass currently being compiled.\n\t * @param renderable The renderable currently being rendered.\n\t * @param stage The Stage object currently used for rendering.\n\t * @param camera The camera from which the scene is currently rendered.\n\t *\n\t * @internal\n\t */\n\tpublic iSetRenderState(shader:ShaderBase, methodVO:MethodVO, renderable:GL_RenderableBase, stage:Stage, camera:Camera)\n\t{\n\n\t}\n\n\t/**\n\t * Clears the render state for this method.\n\t * @param vo The MethodVO object linking this method with the pass currently being compiled.\n\t * @param stage The Stage object currently used for rendering.\n\t *\n\t * @internal\n\t */\n\tpublic iDeactivate(shader:ShaderBase, methodVO:MethodVO, stage:Stage)\n\t{\n\n\t}\n\n\t/**\n\t * Marks the shader program as invalid, so it will be recompiled before the next render.\n\t *\n\t * @internal\n\t */\n\tpublic iInvalidateShaderProgram()\n\t{\n\t\tthis.dispatchEvent(new ShadingMethodEvent(ShadingMethodEvent.SHADER_INVALIDATED));\n\t}\n\n\t/**\n\t * Copies the state from a ShadingMethodBase object into the current object.\n\t */\n\tpublic copyFrom(method:ShadingMethodBase)\n\t{\n\t}\n}\n\nexport default ShadingMethodBase;",
    "import AssetEvent\t\t\t\t\t\tfrom \"awayjs-core/lib/events/AssetEvent\";\n\nimport Camera\t\t\t\t\t\t\tfrom \"awayjs-display/lib/display/Camera\";\nimport DirectionalLight\t\t\t\t\tfrom \"awayjs-display/lib/display/DirectionalLight\";\nimport CascadeShadowMapper\t\t\t\tfrom \"awayjs-display/lib/materials/shadowmappers/CascadeShadowMapper\";\nimport TextureBase\t\t\t\t\t\tfrom \"awayjs-display/lib/textures/TextureBase\";\n\nimport Stage\t\t\t\t\t\t\tfrom \"awayjs-stagegl/lib/base/Stage\";\n\nimport GL_RenderableBase\t\t\t\tfrom \"awayjs-renderergl/lib/renderables/GL_RenderableBase\";\nimport ShadingMethodEvent\t\t\t\tfrom \"awayjs-renderergl/lib/events/ShadingMethodEvent\";\nimport LightingShader\t\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/LightingShader\";\nimport ShaderBase\t\t\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderBase\";\nimport ShaderRegisterCache\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterCache\";\nimport ShaderRegisterData\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterData\";\nimport ShaderRegisterElement\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterElement\";\n\nimport MethodVO\t\t\t\t\t\t\tfrom \"../data/MethodVO\";\nimport ShadowMapMethodBase\t\t\t\tfrom \"../methods/ShadowMapMethodBase\";\nimport ShadowMethodBase\t\t\t\t\tfrom \"../methods/ShadowMethodBase\";\n\n/**\n * ShadowCascadeMethod is a shadow map method to apply cascade shadow mapping on materials.\n * Must be used with a DirectionalLight with a CascadeShadowMapper assigned to its shadowMapper property.\n *\n * @see away.lights.CascadeShadowMapper\n */\nclass ShadowCascadeMethod extends ShadowMapMethodBase\n{\n\tprivate _baseMethod:ShadowMethodBase;\n\tprivate _cascadeShadowMapper:CascadeShadowMapper;\n\tprivate _depthMapCoordVaryings:Array<ShaderRegisterElement>;\n\tprivate _cascadeProjections:Array<ShaderRegisterElement>;\n\n\t/**\n\t * Creates a new ShadowCascadeMethod object.\n\t *\n\t * @param shadowMethodBase The shadow map sampling method used to sample individual cascades (fe: ShadowHardMethod, ShadowSoftMethod)\n\t */\n\tconstructor(shadowMethodBase:ShadowMethodBase)\n\t{\n\t\tsuper(shadowMethodBase.castingLight);\n\n\t\tthis._baseMethod = shadowMethodBase;\n\t\tif (!(this._pCastingLight instanceof DirectionalLight))\n\t\t\tthrow new Error(\"ShadowCascadeMethod is only compatible with DirectionalLight\");\n\n\t\tthis._cascadeShadowMapper = <CascadeShadowMapper> this._pCastingLight.shadowMapper;\n\n\t\tif (!this._cascadeShadowMapper)\n\t\t\tthrow new Error(\"ShadowCascadeMethod requires a light that has a CascadeShadowMapper instance assigned to shadowMapper.\");\n\n\t\tthis._cascadeShadowMapper.addEventListener(AssetEvent.INVALIDATE, (event:AssetEvent) => this.onCascadeChange(event));\n\t\tthis._baseMethod.addEventListener(ShadingMethodEvent.SHADER_INVALIDATED, (event:ShadingMethodEvent) => this.onShaderInvalidated(event));\n\t}\n\n\t/**\n\t * The shadow map sampling method used to sample individual cascades. These are typically those used in conjunction\n\t * with a DirectionalShadowMapper.\n\t *\n\t * @see ShadowHardMethod\n\t * @see ShadowSoftMethod\n\t */\n\tpublic get baseMethod():ShadowMethodBase\n\t{\n\t\treturn this._baseMethod;\n\t}\n\n\tpublic set baseMethod(value:ShadowMethodBase)\n\t{\n\t\tif (this._baseMethod == value)\n\t\t\treturn;\n\n\t\tthis._baseMethod.removeEventListener(ShadingMethodEvent.SHADER_INVALIDATED, (event:ShadingMethodEvent) => this.onShaderInvalidated(event));\n\n\t\tthis._baseMethod = value;\n\n\t\tthis._baseMethod.addEventListener(ShadingMethodEvent.SHADER_INVALIDATED, (event:ShadingMethodEvent) => this.onShaderInvalidated(event));\n\n\t\tthis.iInvalidateShaderProgram();\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitVO(shader:LightingShader, methodVO:MethodVO)\n\t{\n\t\tvar tempVO:MethodVO = new MethodVO(this._baseMethod, methodVO.pass);\n\t\tthis._baseMethod.iInitVO(shader, tempVO);\n\n\t\tmethodVO.needsGlobalVertexPos = true;\n\t\tmethodVO.needsProjection = true;\n\n\t\tmethodVO.textureGL = shader.getAbstraction(this._pCastingLight.shadowMapper.depthMap);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitConstants(shader:ShaderBase, methodVO:MethodVO)\n\t{\n\t\tvar fragmentData:Float32Array = shader.fragmentConstantData;\n\t\tvar vertexData:Float32Array = shader.vertexConstantData;\n\t\tvar index:number = methodVO.fragmentConstantsIndex;\n\t\tfragmentData[index] = 1.0;\n\t\tfragmentData[index + 1] = 1/255.0;\n\t\tfragmentData[index + 2] = 1/65025.0;\n\t\tfragmentData[index + 3] = 1/16581375.0;\n\n\t\tfragmentData[index + 6] = .5;\n\t\tfragmentData[index + 7] = -.5;\n\n\t\tindex = methodVO.vertexConstantsIndex;\n\t\tvertexData[index] = .5;\n\t\tvertexData[index + 1] = -.5;\n\t\tvertexData[index + 2] = 0;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iCleanCompilationData()\n\t{\n\t\tsuper.iCleanCompilationData();\n\t\tthis._cascadeProjections = null;\n\t\tthis._depthMapCoordVaryings = null;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetVertexCode(shader:ShaderBase, methodVO:MethodVO, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = \"\";\n\t\tvar dataReg:ShaderRegisterElement = registerCache.getFreeVertexConstant();\n\n\t\tthis.initProjectionsRegs(registerCache);\n\t\tmethodVO.vertexConstantsIndex = dataReg.index*4;\n\n\t\tvar temp:ShaderRegisterElement = registerCache.getFreeVertexVectorTemp();\n\n\t\tfor (var i:number = 0; i < this._cascadeShadowMapper.numCascades; ++i) {\n\t\t\tcode += \"m44 \" + temp + \", \" + sharedRegisters.globalPositionVertex + \", \" + this._cascadeProjections[i] + \"\\n\" +\n\t\t\t\t\"add \" + this._depthMapCoordVaryings[i] + \", \" + temp + \", \" + dataReg + \".zzwz\\n\";\n\t\t}\n\n\t\treturn code;\n\t}\n\n\t/**\n\t * Creates the registers for the cascades' projection coordinates.\n\t */\n\tprivate initProjectionsRegs(registerCache:ShaderRegisterCache)\n\t{\n\t\tthis._cascadeProjections = new Array<ShaderRegisterElement>(this._cascadeShadowMapper.numCascades);\n\t\tthis._depthMapCoordVaryings = new Array<ShaderRegisterElement>(this._cascadeShadowMapper.numCascades);\n\n\t\tfor (var i:number = 0; i < this._cascadeShadowMapper.numCascades; ++i) {\n\t\t\tthis._depthMapCoordVaryings[i] = registerCache.getFreeVarying();\n\t\t\tthis._cascadeProjections[i] = registerCache.getFreeVertexConstant();\n\t\t\tregisterCache.getFreeVertexConstant();\n\t\t\tregisterCache.getFreeVertexConstant();\n\t\t\tregisterCache.getFreeVertexConstant();\n\t\t}\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentCode(shader:ShaderBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar numCascades:number = this._cascadeShadowMapper.numCascades;\n\t\tvar decReg:ShaderRegisterElement = registerCache.getFreeFragmentConstant();\n\t\tvar dataReg:ShaderRegisterElement = registerCache.getFreeFragmentConstant();\n\t\tvar planeDistanceReg:ShaderRegisterElement = registerCache.getFreeFragmentConstant();\n\t\tvar planeDistances:Array<string> = Array<string>( planeDistanceReg + \".x\", planeDistanceReg + \".y\", planeDistanceReg + \".z\", planeDistanceReg + \".w\" );\n\t\tvar code:string;\n\n\t\tmethodVO.fragmentConstantsIndex = decReg.index*4;\n\n\t\tvar inQuad:ShaderRegisterElement = registerCache.getFreeFragmentVectorTemp();\n\t\tregisterCache.addFragmentTempUsages(inQuad, 1);\n\t\tvar uvCoord:ShaderRegisterElement = registerCache.getFreeFragmentVectorTemp();\n\t\tregisterCache.addFragmentTempUsages(uvCoord, 1);\n\n\t\t// assume lowest partition is selected, will be overwritten later otherwise\n\t\tcode = \"mov \" + uvCoord + \", \" + this._depthMapCoordVaryings[numCascades - 1] + \"\\n\";\n\n\t\tfor (var i:number = numCascades - 2; i >= 0; --i) {\n\t\t\tvar uvProjection:ShaderRegisterElement = this._depthMapCoordVaryings[i];\n\n\t\t\t// calculate if in texturemap (result == 0 or 1, only 1 for a single partition)\n\t\t\tcode += \"slt \" + inQuad + \".z, \" + sharedRegisters.projectionFragment + \".z, \" + planeDistances[i] + \"\\n\"; // z = x > minX, w = y > minY\n\n\t\t\tvar temp:ShaderRegisterElement = registerCache.getFreeFragmentVectorTemp();\n\n\t\t\t// linearly interpolate between old and new uv coords using predicate value == conditional toggle to new value if predicate == 1 (true)\n\t\t\tcode += \"sub \" + temp + \", \" + uvProjection + \", \" + uvCoord + \"\\n\" +\n\t\t\t\t\"mul \" + temp + \", \" + temp + \", \" + inQuad + \".z\\n\" +\n\t\t\t\t\"add \" + uvCoord + \", \" + uvCoord + \", \" + temp + \"\\n\";\n\t\t}\n\n\t\tregisterCache.removeFragmentTempUsage(inQuad);\n\n\t\tcode += \"div \" + uvCoord + \", \" + uvCoord + \", \" + uvCoord + \".w\\n\" +\n\t\t\t\"mul \" + uvCoord + \".xy, \" + uvCoord + \".xy, \" + dataReg + \".zw\\n\" +\n\t\t\t\"add \" + uvCoord + \".xy, \" + uvCoord + \".xy, \" + dataReg + \".zz\\n\";\n\n\t\tcode += this._baseMethod._iGetCascadeFragmentCode(shader, methodVO, decReg, uvCoord, targetReg, registerCache, sharedRegisters) +\n\t\t\t\"add \" + targetReg + \".w, \" + targetReg + \".w, \" + dataReg + \".y\\n\";\n\n\t\tregisterCache.removeFragmentTempUsage(uvCoord);\n\n\t\treturn code;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iActivate(shader:ShaderBase, methodVO:MethodVO, stage:Stage)\n\t{\n\t\tmethodVO.textureGL.activate(methodVO.pass._render);\n\n\t\tvar vertexData:Float32Array = shader.vertexConstantData;\n\t\tvar vertexIndex:number = methodVO.vertexConstantsIndex;\n\n\t\tshader.vertexConstantData[methodVO.vertexConstantsIndex + 3] = -1/(this._cascadeShadowMapper.depth*this._pEpsilon);\n\n\t\tvar numCascades:number = this._cascadeShadowMapper.numCascades;\n\t\tvertexIndex += 4;\n\t\tfor (var k:number = 0; k < numCascades; ++k) {\n\t\t\tthis._cascadeShadowMapper.getDepthProjections(k).copyRawDataTo(vertexData, vertexIndex, true);\n\t\t\tvertexIndex += 16;\n\t\t}\n\n\t\tvar fragmentData:Float32Array = shader.fragmentConstantData;\n\t\tvar fragmentIndex:number = methodVO.fragmentConstantsIndex;\n\t\tfragmentData[fragmentIndex + 5] = 1 - this._pAlpha;\n\n\t\tvar nearPlaneDistances:Array<number> = this._cascadeShadowMapper._iNearPlaneDistances;\n\n\t\tfragmentIndex += 8;\n\t\tfor (var i:number = 0; i < numCascades; ++i)\n\t\t\tfragmentData[fragmentIndex + i] = nearPlaneDistances[i];\n\n\t\tthis._baseMethod.iActivateForCascade(shader, methodVO, stage);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iSetRenderState(shader:ShaderBase, methodVO:MethodVO, renderable:GL_RenderableBase, stage:Stage, camera:Camera)\n\t{\n\t}\n\n\t/**\n\t * Called when the shadow mappers cascade configuration changes.\n\t */\n\tprivate onCascadeChange(event:AssetEvent)\n\t{\n\t\tthis.iInvalidateShaderProgram();\n\t}\n\n\t/**\n\t * Called when the base method's shader code is invalidated.\n\t */\n\tprivate onShaderInvalidated(event:ShadingMethodEvent)\n\t{\n\t\tthis.iInvalidateShaderProgram();\n\t}\n}\n\nexport default ShadowCascadeMethod;",
    "import BitmapImage2D\t\t\t\t\tfrom \"awayjs-core/lib/image/BitmapImage2D\";\n\nimport Camera\t\t\t\t\t\t\tfrom \"awayjs-display/lib/display/Camera\";\nimport DirectionalLight\t\t\t\t\tfrom \"awayjs-display/lib/display/DirectionalLight\";\nimport Single2DTexture\t\t\t\t\tfrom \"awayjs-display/lib/textures/Single2DTexture\";\n\nimport Stage\t\t\t\t\t\t\tfrom \"awayjs-stagegl/lib/base/Stage\";\n\nimport GL_RenderableBase\t\t\t\tfrom \"awayjs-renderergl/lib/renderables/GL_RenderableBase\";\nimport LightingShader\t\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/LightingShader\";\nimport ShaderBase\t\t\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderBase\";\nimport ShaderRegisterCache\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterCache\";\nimport ShaderRegisterData\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterData\";\nimport ShaderRegisterElement\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterElement\";\n\nimport MethodVO\t\t\t\t\t\t\tfrom \"../data/MethodVO\";\nimport ShadowMethodBase\t\t\t\t\tfrom \"../methods/ShadowMethodBase\";\n\n/**\n * ShadowDitheredMethod provides a soft shadowing technique by randomly distributing sample points differently for each fragment.\n */\nclass ShadowDitheredMethod extends ShadowMethodBase\n{\n\tprivate static _grainTexture:Single2DTexture;\n\tprivate static _grainUsages:number /*int*/;\n\tprivate static _grainBitmapImage2D:BitmapImage2D;\n\tprivate _depthMapSize:number /*int*/;\n\tprivate _range:number;\n\tprivate _numSamples:number /*int*/;\n\n\t/**\n\t * Creates a new ShadowDitheredMethod object.\n\t * @param castingLight The light casting the shadows\n\t * @param numSamples The amount of samples to take for dithering. Minimum 1, maximum 24.\n\t */\n\tconstructor(castingLight:DirectionalLight, numSamples:number /*int*/ = 4, range:number = 1)\n\t{\n\t\tsuper(castingLight);\n\n\t\tthis._depthMapSize = this._pCastingLight.shadowMapper.depthMapSize;\n\n\t\tthis.numSamples = numSamples;\n\t\tthis.range = range;\n\n\t\t++ShadowDitheredMethod._grainUsages;\n\n\t\tif (!ShadowDitheredMethod._grainTexture)\n\t\t\tthis.initGrainTexture();\n\t}\n\n\t/**\n\t * The amount of samples to take for dithering. Minimum 1, maximum 24. The actual maximum may depend on the\n\t * complexity of the shader.\n\t */\n\tpublic get numSamples():number /*int*/\n\t{\n\t\treturn this._numSamples;\n\t}\n\n\tpublic set numSamples(value:number /*int*/)\n\t{\n\t\tif (value < 1)\n\t\t\tvalue = 1;\n\t\telse if (value > 24)\n\t\t\tvalue = 24;\n\n\t\tif (this._numSamples == value)\n\t\t\treturn;\n\n\t\tthis._numSamples = value;\n\n\t\tthis.iInvalidateShaderProgram();\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitVO(shader:LightingShader, methodVO:MethodVO)\n\t{\n\t\tsuper.iInitVO(shader, methodVO);\n\n\t\tmethodVO.needsProjection = true;\n\n\t\tmethodVO.secondaryTextureGL = shader.getAbstraction(ShadowDitheredMethod._grainTexture);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitConstants(shader:ShaderBase, methodVO:MethodVO)\n\t{\n\t\tsuper.iInitConstants(shader, methodVO);\n\n\t\tvar fragmentData:Float32Array = shader.fragmentConstantData;\n\t\tvar index:number /*int*/ = methodVO.fragmentConstantsIndex;\n\t\tfragmentData[index + 8] = 1/this._numSamples;\n\t}\n\n\t/**\n\t * The range in the shadow map in which to distribute the samples.\n\t */\n\tpublic get range():number\n\t{\n\t\treturn this._range*2;\n\t}\n\n\tpublic set range(value:number)\n\t{\n\t\tthis._range = value/2;\n\t}\n\n\t/**\n\t * Creates a texture containing the dithering noise texture.\n\t */\n\tprivate initGrainTexture()\n\t{\n\t\tShadowDitheredMethod._grainBitmapImage2D = new BitmapImage2D(64, 64, false);\n\t\tvar vec:Array<number> /*uint*/ = new Array<number>();\n\t\tvar len:number /*uint*/ = 4096;\n\t\tvar step:number = 1/(this._depthMapSize*this._range);\n\t\tvar r:number, g:number;\n\n\t\tfor (var i:number /*uint*/ = 0; i < len; ++i) {\n\t\t\tr = 2*(Math.random() - .5);\n\t\t\tg = 2*(Math.random() - .5);\n\t\t\tif (r < 0)\n\t\t\t\tr -= step; else\n\t\t\t\tr += step;\n\t\t\tif (g < 0)\n\t\t\t\tg -= step; else\n\t\t\t\tg += step;\n\t\t\tif (r > 1)\n\t\t\t\tr = 1; else if (r < -1)\n\t\t\t\tr = -1;\n\t\t\tif (g > 1)\n\t\t\t\tg = 1; else if (g < -1)\n\t\t\t\tg = -1;\n\t\t\tvec[i] = (Math.floor((r*.5 + .5)*0xff) << 16) | (Math.floor((g*.5 + .5)*0xff) << 8);\n\t\t}\n\n\t\tShadowDitheredMethod._grainBitmapImage2D.setArray(ShadowDitheredMethod._grainBitmapImage2D.rect, vec);\n\t\tShadowDitheredMethod._grainTexture = new Single2DTexture(ShadowDitheredMethod._grainBitmapImage2D);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic dispose()\n\t{\n\t\tif (--ShadowDitheredMethod._grainUsages == 0) {\n\t\t\tShadowDitheredMethod._grainTexture.dispose();\n\t\t\tShadowDitheredMethod._grainBitmapImage2D.dispose();\n\t\t\tShadowDitheredMethod._grainTexture = null;\n\t\t}\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iActivate(shader:ShaderBase, methodVO:MethodVO, stage:Stage)\n\t{\n\t\tsuper.iActivate(shader, methodVO, stage);\n\n\t\tvar data:Float32Array = shader.fragmentConstantData;\n\t\tvar index:number /*uint*/ = methodVO.fragmentConstantsIndex;\n\t\tdata[index + 9] = (stage.width - 1)/63;\n\t\tdata[index + 10] = (stage.height - 1)/63;\n\t\tdata[index + 11] = 2*this._range/this._depthMapSize;\n\n\t\tmethodVO.secondaryTextureGL.activate(methodVO.pass._render);\n\t}\n\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iSetRenderState(shader:ShaderBase, methodVO:MethodVO, renderable:GL_RenderableBase, stage:Stage, camera:Camera)\n\t{\n\t\tsuper.iSetRenderState(shader, methodVO, renderable, stage, camera);\n\n\t\tmethodVO.secondaryTextureGL._setRenderState(renderable);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic _pGetPlanarFragmentCode(shader:ShaderBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, regCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar decReg:ShaderRegisterElement = regCache.getFreeFragmentConstant();\n\t\tvar dataReg:ShaderRegisterElement = regCache.getFreeFragmentConstant();\n\t\tvar customDataReg:ShaderRegisterElement = regCache.getFreeFragmentConstant();\n\n\t\tmethodVO.fragmentConstantsIndex = decReg.index*4;\n\n\t\treturn this.getSampleCode(shader, methodVO, customDataReg, decReg, targetReg, regCache, sharedRegisters);\n\t}\n\n\t/**\n\t * Get the actual shader code for shadow mapping\n\t * @param regCache The register cache managing the registers.\n\t * @param depthMapRegister The texture register containing the depth map.\n\t * @param decReg The register containing the depth map decoding data.\n\t * @param targetReg The target register to add the shadow coverage.\n\t */\n\tprivate getSampleCode(shader:ShaderBase, methodVO:MethodVO, customDataReg:ShaderRegisterElement, decReg:ShaderRegisterElement, targetReg:ShaderRegisterElement, regCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = \"\";\n\t\tvar numSamples:number /*int*/ = this._numSamples;\n\t\tvar uvReg:ShaderRegisterElement = regCache.getFreeFragmentVectorTemp();\n\t\tregCache.addFragmentTempUsages(uvReg, 1);\n\t\tvar temp:ShaderRegisterElement = regCache.getFreeFragmentVectorTemp();\n\t\tregCache.addFragmentTempUsages(temp, 1);\n\n\t\tvar projectionReg:ShaderRegisterElement = sharedRegisters.projectionFragment;\n\n\t\tcode += \"div \" + uvReg + \", \" + projectionReg + \", \" + projectionReg + \".w\\n\" +\n\t\t\t\"mul \" + uvReg + \".xy, \" + uvReg + \".xy, \" + customDataReg + \".yz\\n\";\n\n\t\twhile (numSamples > 0) {\n\t\t\tif (numSamples == this._numSamples) {\n\t\t\t\tcode += methodVO.secondaryTextureGL._iGetFragmentCode(uvReg, regCache, sharedRegisters, uvReg);\n\t\t\t} else {\n\t\t\t\tcode += \"mov \" + temp + \", \" + uvReg + \".zwxy \\n\" +\n\t\t\t\t\tmethodVO.secondaryTextureGL._iGetFragmentCode(uvReg, regCache, sharedRegisters, temp);\n\t\t\t}\n\n\t\t\t// keep grain in uvReg.zw\n\t\t\tcode += \"sub \" + uvReg + \".zw, \" + uvReg + \".xy, fc0.xx\\n\" + // uv-.5\n\t\t\t\t\"mul \" + uvReg + \".zw, \" + uvReg + \".zw, \" + customDataReg + \".w\\n\"; // (tex unpack scale and tex scale in one)\n\n\t\t\tif (numSamples == this._numSamples) {\n\t\t\t\t// first sample\n\t\t\t\tcode += \"add \" + uvReg + \".xy, \" + uvReg + \".zw, \" + this._pDepthMapCoordReg + \".xy\\n\" +\n\t\t\t\t\tmethodVO.textureGL._iGetFragmentCode(temp, regCache, sharedRegisters, uvReg) +\n\t\t\t\t\t\"dp4 \" + temp + \".z, \" + temp + \", \" + decReg + \"\\n\" +\n\t\t\t\t\t\"slt \" + targetReg + \".w, \" + this._pDepthMapCoordReg + \".z, \" + temp + \".z\\n\"; // 0 if in shadow\n\t\t\t} else {\n\t\t\t\tcode += this.addSample(shader, methodVO, uvReg, decReg, targetReg, regCache, sharedRegisters);\n\t\t\t}\n\n\t\t\tif (numSamples > 4)\n\t\t\t\tcode += \"add \" + uvReg + \".xy, \" + uvReg + \".xy, \" + uvReg + \".zw\\n\" + this.addSample(shader, methodVO, uvReg, decReg, targetReg, regCache, sharedRegisters);\n\n\t\t\tif (numSamples > 1)\n\t\t\t\tcode += \"sub \" + uvReg + \".xy, \" + this._pDepthMapCoordReg + \".xy, \" + uvReg + \".zw\\n\" + this.addSample(shader, methodVO, uvReg, decReg, targetReg, regCache, sharedRegisters);\n\n\t\t\tif (numSamples > 5)\n\t\t\t\tcode += \"sub \" + uvReg + \".xy, \" + uvReg + \".xy, \" + uvReg + \".zw\\n\" + this.addSample(shader, methodVO, uvReg, decReg, targetReg, regCache, sharedRegisters);\n\n\t\t\tif (numSamples > 2) {\n\t\t\t\tcode += \"neg \" + uvReg + \".w, \" + uvReg + \".w\\n\"; // will be rotated 90 degrees when being accessed as wz\n\t\t\t\tcode += \"add \" + uvReg + \".xy, \" + uvReg + \".wz, \" + this._pDepthMapCoordReg + \".xy\\n\" + this.addSample(shader, methodVO, uvReg, decReg, targetReg, regCache, sharedRegisters);\n\t\t\t}\n\n\t\t\tif (numSamples > 6)\n\t\t\t\tcode += \"add \" + uvReg + \".xy, \" + uvReg + \".xy, \" + uvReg + \".wz\\n\" + this.addSample(shader, methodVO, uvReg, decReg, targetReg, regCache, sharedRegisters);\n\n\t\t\tif (numSamples > 3)\n\t\t\t\tcode += \"sub \" + uvReg + \".xy, \" + this._pDepthMapCoordReg + \".xy, \" + uvReg + \".wz\\n\" + this.addSample(shader, methodVO, uvReg, decReg, targetReg, regCache, sharedRegisters);\n\n\t\t\tif (numSamples > 7)\n\t\t\t\tcode += \"sub \" + uvReg + \".xy, \" + uvReg + \".xy, \" + uvReg + \".wz\\n\" + this.addSample(shader, methodVO, uvReg, decReg, targetReg, regCache, sharedRegisters);\n\n\t\t\tnumSamples -= 8;\n\t\t}\n\n\t\tregCache.removeFragmentTempUsage(temp);\n\t\tregCache.removeFragmentTempUsage(uvReg);\n\t\tcode += \"mul \" + targetReg + \".w, \" + targetReg + \".w, \" + customDataReg + \".x\\n\"; // average\n\t\treturn code;\n\t}\n\n\t/**\n\t * Adds the code for another tap to the shader code.\n\t * @param uvReg The uv register for the tap.\n\t * @param depthMapRegister The texture register containing the depth map.\n\t * @param decReg The register containing the depth map decoding data.\n\t * @param targetReg The target register to add the tap comparison result.\n\t * @param regCache The register cache managing the registers.\n\t * @return\n\t */\n\tprivate addSample(shader:ShaderBase, methodVO:MethodVO, uvReg:ShaderRegisterElement, decReg:ShaderRegisterElement, targetReg:ShaderRegisterElement, regCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar temp:ShaderRegisterElement = regCache.getFreeFragmentVectorTemp();\n\n\t\treturn methodVO.textureGL._iGetFragmentCode(temp, regCache, sharedRegisters, uvReg) +\n\t\t\t\"dp4 \" + temp + \".z, \" + temp + \", \" + decReg + \"\\n\" +\n\t\t\t\"slt \" + temp + \".z, \" + this._pDepthMapCoordReg + \".z, \" + temp + \".z\\n\" + // 0 if in shadow\n\t\t\t\"add \" + targetReg + \".w, \" + targetReg + \".w, \" + temp + \".z\\n\";\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iActivateForCascade(shader:ShaderBase, methodVO:MethodVO, stage:Stage)\n\t{\n\t\tvar data:Float32Array = shader.fragmentConstantData;\n\t\tvar index:number /*uint*/ = methodVO.secondaryFragmentConstantsIndex;\n\t\tdata[index] = 1/this._numSamples;\n\t\tdata[index + 1] = (stage.width - 1)/63;\n\t\tdata[index + 2] = (stage.height - 1)/63;\n\t\tdata[index + 3] = 2*this._range/this._depthMapSize;\n\n\t\tmethodVO.secondaryTextureGL.activate(methodVO.pass._render);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic _iGetCascadeFragmentCode(shader:ShaderBase, methodVO:MethodVO, decodeRegister:ShaderRegisterElement, depthProjection:ShaderRegisterElement, targetRegister:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tthis._pDepthMapCoordReg = depthProjection;\n\n\t\tvar dataReg:ShaderRegisterElement = registerCache.getFreeFragmentConstant();\n\t\tmethodVO.secondaryFragmentConstantsIndex = dataReg.index*4;\n\n\t\treturn this.getSampleCode(shader, methodVO, dataReg, decodeRegister, targetRegister, registerCache, sharedRegisters);\n\t}\n}\n\nexport default ShadowDitheredMethod;",
    "import DirectionalLight\t\t\t\t\tfrom \"awayjs-display/lib/display/DirectionalLight\";\n\nimport Stage\t\t\t\t\t\t\tfrom \"awayjs-stagegl/lib/base/Stage\";\n\nimport LightingShader\t\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/LightingShader\";\nimport ShaderBase\t\t\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderBase\";\nimport ShaderRegisterCache\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterCache\";\nimport ShaderRegisterData\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterData\";\nimport ShaderRegisterElement\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterElement\";\n\nimport MethodVO\t\t\t\t\t\t\tfrom \"../data/MethodVO\";\nimport ShadowMethodBase\t\t\t\t\tfrom \"../methods/ShadowMethodBase\";\n\n/**\n * ShadowFilteredMethod provides a softened shadowing technique by bilinearly interpolating shadow comparison\n * results of neighbouring pixels.\n */\nclass ShadowFilteredMethod extends ShadowMethodBase\n{\n\t/**\n\t * Creates a new DiffuseBasicMethod object.\n\t *\n\t * @param castingLight The light casting the shadow\n\t */\n\tconstructor(castingLight:DirectionalLight)\n\t{\n\t\tsuper(castingLight);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitConstants(shader:LightingShader, methodVO:MethodVO)\n\t{\n\t\tsuper.iInitConstants(shader, methodVO);\n\n\t\tvar fragmentData:Float32Array = shader.fragmentConstantData;\n\t\tvar index:number /*int*/ = methodVO.fragmentConstantsIndex;\n\t\tfragmentData[index + 8] = .5;\n\t\tvar size:number /*int*/ = this.castingLight.shadowMapper.depthMapSize;\n\t\tfragmentData[index + 9] = size;\n\t\tfragmentData[index + 10] = 1/size;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic _pGetPlanarFragmentCode(shader:ShaderBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, regCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = \"\";\n\t\tvar decReg:ShaderRegisterElement = regCache.getFreeFragmentConstant();\n\t\tregCache.getFreeFragmentConstant();\n\t\tvar customDataReg:ShaderRegisterElement = regCache.getFreeFragmentConstant();\n\n\t\tmethodVO.fragmentConstantsIndex = decReg.index*4;\n\n\t\tvar depthCol:ShaderRegisterElement = regCache.getFreeFragmentVectorTemp();\n\t\tregCache.addFragmentTempUsages(depthCol, 1);\n\t\tvar uvReg:ShaderRegisterElement = regCache.getFreeFragmentVectorTemp();\n\t\tregCache.addFragmentTempUsages(uvReg, 1);\n\n\t\tcode += \"mov \" + uvReg + \", \" + this._pDepthMapCoordReg + \"\\n\" +\n\n\t\t\tmethodVO.textureGL._iGetFragmentCode(depthCol, regCache, sharedRegisters, this._pDepthMapCoordReg) +\n\t\t\t\"dp4 \" + depthCol + \".z, \" + depthCol + \", \" + decReg + \"\\n\" +\n\t\t\t\"slt \" + uvReg + \".z, \" + this._pDepthMapCoordReg + \".z, \" + depthCol + \".z\\n\" +   // 0 if in shadow\n\n\t\t\t\"add \" + uvReg + \".x, \" + this._pDepthMapCoordReg + \".x, \" + customDataReg + \".z\\n\" + \t// (1, 0)\n\t\t\tmethodVO.textureGL._iGetFragmentCode(depthCol, regCache, sharedRegisters, uvReg) +\n\t\t\t\"dp4 \" + depthCol + \".z, \" + depthCol + \", \" + decReg + \"\\n\" +\n\t\t\t\"slt \" + uvReg + \".w, \" + this._pDepthMapCoordReg + \".z, \" + depthCol + \".z\\n\" +   // 0 if in shadow\n\n\t\t\t\"mul \" + depthCol + \".x, \" + this._pDepthMapCoordReg + \".x, \" + customDataReg + \".y\\n\" +\n\t\t\t\"frc \" + depthCol + \".x, \" + depthCol + \".x\\n\" +\n\t\t\t\"sub \" + uvReg + \".w, \" + uvReg + \".w, \" + uvReg + \".z\\n\" +\n\t\t\t\"mul \" + uvReg + \".w, \" + uvReg + \".w, \" + depthCol + \".x\\n\" +\n\t\t\t\"add \" + targetReg + \".w, \" + uvReg + \".z, \" + uvReg + \".w\\n\" +\n\n\t\t\t\"mov \" + uvReg + \".x, \" + this._pDepthMapCoordReg + \".x\\n\" +\n\t\t\t\"add \" + uvReg + \".y, \" + this._pDepthMapCoordReg + \".y, \" + customDataReg + \".z\\n\" +\t// (0, 1)\n\t\t\tmethodVO.textureGL._iGetFragmentCode(depthCol, regCache, sharedRegisters, uvReg) +\n\t\t\t\"dp4 \" + depthCol + \".z, \" + depthCol + \", \" + decReg + \"\\n\" +\n\t\t\t\"slt \" + uvReg + \".z, \" + this._pDepthMapCoordReg + \".z, \" + depthCol + \".z\\n\" +   // 0 if in shadow\n\n\t\t\t\"add \" + uvReg + \".x, \" + this._pDepthMapCoordReg + \".x, \" + customDataReg + \".z\\n\" +\t// (1, 1)\n\t\t\tmethodVO.textureGL._iGetFragmentCode(depthCol, regCache, sharedRegisters, uvReg) +\n\t\t\t\"dp4 \" + depthCol + \".z, \" + depthCol + \", \" + decReg + \"\\n\" +\n\t\t\t\"slt \" + uvReg + \".w, \" + this._pDepthMapCoordReg + \".z, \" + depthCol + \".z\\n\" +   // 0 if in shadow\n\n\t\t\t// recalculate fraction, since we ran out of registers :(\n\t\t\t\"mul \" + depthCol + \".x, \" + this._pDepthMapCoordReg + \".x, \" + customDataReg + \".y\\n\" +\n\t\t\t\"frc \" + depthCol + \".x, \" + depthCol + \".x\\n\" + \"sub \" + uvReg + \".w, \" + uvReg + \".w, \" + uvReg + \".z\\n\" +\n\t\t\t\"mul \" + uvReg + \".w, \" + uvReg + \".w, \" + depthCol + \".x\\n\" +\n\t\t\t\"add \" + uvReg + \".w, \" + uvReg + \".z, \" + uvReg + \".w\\n\" +\n\n\t\t\t\"mul \" + depthCol + \".x, \" + this._pDepthMapCoordReg + \".y, \" + customDataReg + \".y\\n\" +\n\t\t\t\"frc \" + depthCol + \".x, \" + depthCol + \".x\\n\" +\n\t\t\t\"sub \" + uvReg + \".w, \" + uvReg + \".w, \" + targetReg + \".w\\n\" +\n\t\t\t\"mul \" + uvReg + \".w, \" + uvReg + \".w, \" + depthCol + \".x\\n\" +\n\t\t\t\"add \" + targetReg + \".w, \" + targetReg + \".w, \" + uvReg + \".w\\n\";\n\n\t\tregCache.removeFragmentTempUsage(depthCol);\n\t\tregCache.removeFragmentTempUsage(uvReg);\n\n\t\treturn code;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iActivateForCascade(shader:ShaderBase, methodVO:MethodVO, stage:Stage)\n\t{\n\t\tvar size:number /*int*/ = this.castingLight.shadowMapper.depthMapSize;\n\t\tvar index:number /*int*/ = methodVO.secondaryFragmentConstantsIndex;\n\t\tvar data:Float32Array = shader.fragmentConstantData;\n\t\tdata[index] = size;\n\t\tdata[index + 1] = 1/size;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic _iGetCascadeFragmentCode(shader:ShaderBase, methodVO:MethodVO, decodeRegister:ShaderRegisterElement, depthProjection:ShaderRegisterElement, targetRegister:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string;\n\t\tvar dataReg:ShaderRegisterElement = registerCache.getFreeFragmentConstant();\n\t\tmethodVO.secondaryFragmentConstantsIndex = dataReg.index*4;\n\n\t\tvar temp:ShaderRegisterElement = registerCache.getFreeFragmentVectorTemp();\n\t\tregisterCache.addFragmentTempUsages(temp, 1);\n\t\tvar predicate:ShaderRegisterElement = registerCache.getFreeFragmentVectorTemp();\n\t\tregisterCache.addFragmentTempUsages(predicate, 1);\n\n\t\tcode = methodVO.textureGL._iGetFragmentCode(temp, registerCache, sharedRegisters, depthProjection) +\n\t\t\t\"dp4 \" + temp + \".z, \" + temp + \", \" + decodeRegister + \"\\n\" +\n\t\t\t\"slt \" + predicate + \".x, \" + depthProjection + \".z, \" + temp + \".z\\n\" +\n\n\t\t\t\"add \" + depthProjection + \".x, \" + depthProjection + \".x, \" + dataReg + \".y\\n\" +\n\t\t\tmethodVO.textureGL._iGetFragmentCode(temp, registerCache, sharedRegisters, depthProjection) +\n\t\t\t\"dp4 \" + temp + \".z, \" + temp + \", \" + decodeRegister + \"\\n\" +\n\t\t\t\"slt \" + predicate + \".z, \" + depthProjection + \".z, \" + temp + \".z\\n\" +\n\n\t\t\t\"add \" + depthProjection + \".y, \" + depthProjection + \".y, \" + dataReg + \".y\\n\" +\n\t\t\tmethodVO.textureGL._iGetFragmentCode(temp, registerCache, sharedRegisters, depthProjection) +\n\t\t\t\"dp4 \" + temp + \".z, \" + temp + \", \" + decodeRegister + \"\\n\" +\n\t\t\t\"slt \" + predicate + \".w, \" + depthProjection + \".z, \" + temp + \".z\\n\" +\n\n\t\t\t\"sub \" + depthProjection + \".x, \" + depthProjection + \".x, \" + dataReg + \".y\\n\" +\n\t\t\tmethodVO.textureGL._iGetFragmentCode(temp, registerCache, sharedRegisters, depthProjection) +\n\t\t\t\"dp4 \" + temp + \".z, \" + temp + \", \" + decodeRegister + \"\\n\" +\n\t\t\t\"slt \" + predicate + \".y, \" + depthProjection + \".z, \" + temp + \".z\\n\" +\n\n\t\t\t\"mul \" + temp + \".xy, \" + depthProjection + \".xy, \" + dataReg + \".x\\n\" +\n\t\t\t\"frc \" + temp + \".xy, \" + temp + \".xy\\n\" +\n\n\t\t\t// some strange register juggling to prevent agal bugging out\n\t\t\t\"sub \" + depthProjection + \", \" + predicate + \".xyzw, \" + predicate + \".zwxy\\n\" +\n\t\t\t\"mul \" + depthProjection + \", \" + depthProjection + \", \" + temp + \".x\\n\" +\n\n\t\t\t\"add \" + predicate + \".xy, \" + predicate + \".xy, \" + depthProjection + \".zw\\n\" +\n\n\t\t\t\"sub \" + predicate + \".y, \" + predicate + \".y, \" + predicate + \".x\\n\" +\n\t\t\t\"mul \" + predicate + \".y, \" + predicate + \".y, \" + temp + \".y\\n\" +\n\t\t\t\"add \" + targetRegister + \".w, \" + predicate + \".x, \" + predicate + \".y\\n\";\n\n\t\tregisterCache.removeFragmentTempUsage(temp);\n\t\tregisterCache.removeFragmentTempUsage(predicate);\n\t\treturn code;\n\t}\n}\n\nexport default ShadowFilteredMethod;",
    "import LightBase\t\t\t\t\t\tfrom \"awayjs-display/lib/display/LightBase\";\n\nimport Stage\t\t\t\t\t\t\tfrom \"awayjs-stagegl/lib/base/Stage\";\n\nimport ShaderBase\t\t\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderBase\";\nimport ShaderRegisterCache\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterCache\";\nimport ShaderRegisterData\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterData\";\nimport ShaderRegisterElement\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterElement\";\n\nimport MethodVO\t\t\t\t\t\t\tfrom \"../data/MethodVO\";\nimport ShadowMethodBase\t\t\t\t\tfrom \"../methods/ShadowMethodBase\";\n\n/**\n * ShadowHardMethod provides the cheapest shadow map method by using a single tap without any filtering.\n */\nclass ShadowHardMethod extends ShadowMethodBase\n{\n\t/**\n\t * Creates a new ShadowHardMethod object.\n\t */\n\tconstructor(castingLight:LightBase)\n\t{\n\t\tsuper(castingLight);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic _pGetPlanarFragmentCode(shader:ShaderBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, regCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = \"\";\n\t\tvar decReg:ShaderRegisterElement = regCache.getFreeFragmentConstant();\n\t\tregCache.getFreeFragmentConstant();\n\n\t\tvar depthCol:ShaderRegisterElement = regCache.getFreeFragmentVectorTemp();\n\n\t\tmethodVO.fragmentConstantsIndex = decReg.index*4;\n\n\t\tcode += methodVO.textureGL._iGetFragmentCode(depthCol, regCache, sharedRegisters, this._pDepthMapCoordReg) +\n\t\t\t\"dp4 \" + depthCol + \".z, \" + depthCol + \", \" + decReg + \"\\n\" +\n\t\t\t\"slt \" + targetReg + \".w, \" + this._pDepthMapCoordReg + \".z, \" + depthCol + \".z\\n\"; // 0 if in shadow\n\n\t\treturn code;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic _pGetPointFragmentCode(shader:ShaderBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, regCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = \"\";\n\t\tvar decReg:ShaderRegisterElement = regCache.getFreeFragmentConstant();\n\t\tvar epsReg:ShaderRegisterElement = regCache.getFreeFragmentConstant();\n\t\tvar posReg:ShaderRegisterElement = regCache.getFreeFragmentConstant();\n\t\tvar depthSampleCol:ShaderRegisterElement = regCache.getFreeFragmentVectorTemp();\n\t\tregCache.addFragmentTempUsages(depthSampleCol, 1);\n\t\tvar lightDir:ShaderRegisterElement = regCache.getFreeFragmentVectorTemp();\n\t\tregCache.addFragmentTempUsages(lightDir, 1);\n\n\t\tmethodVO.fragmentConstantsIndex = decReg.index*4;\n\n\t\tcode += \"sub \" + lightDir + \", \" + sharedRegisters.globalPositionVarying + \", \" + posReg + \"\\n\" +\n\t\t\t\"dp3 \" + lightDir + \".w, \" + lightDir + \".xyz, \" + lightDir + \".xyz\\n\" +\n\t\t\t\"mul \" + lightDir + \".w, \" + lightDir + \".w, \" + posReg + \".w\\n\" +\n\t\t\t\"nrm \" + lightDir + \".xyz, \" + lightDir + \".xyz\\n\" +\n\n\t\t\tmethodVO.textureGL._iGetFragmentCode(depthSampleCol, regCache, sharedRegisters, lightDir) +\n\t\t\t\"dp4 \" + depthSampleCol + \".z, \" + depthSampleCol + \", \" + decReg + \"\\n\" +\n\t\t\t\"add \" + targetReg + \".w, \" + lightDir + \".w, \" + epsReg + \".x\\n\" +    // offset by epsilon\n\n\t\t\t\"slt \" + targetReg + \".w, \" + targetReg + \".w, \" + depthSampleCol + \".z\\n\"; // 0 if in shadow\n\n\t\tregCache.removeFragmentTempUsage(lightDir);\n\t\tregCache.removeFragmentTempUsage(depthSampleCol);\n\n\t\treturn code;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic _iGetCascadeFragmentCode(shader:ShaderBase, methodVO:MethodVO, decodeRegister:ShaderRegisterElement, depthProjection:ShaderRegisterElement, targetRegister:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar temp:ShaderRegisterElement = registerCache.getFreeFragmentVectorTemp();\n\n\t\treturn methodVO.textureGL._iGetFragmentCode(temp, registerCache, sharedRegisters, depthProjection) +\n\t\t\t\"dp4 \" + temp + \".z, \" + temp + \", \" + decodeRegister + \"\\n\" +\n\t\t\t\"slt \" + targetRegister + \".w, \" + depthProjection + \".z, \" + temp + \".z\\n\"; // 0 if in shadow\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iActivateForCascade(shader:ShaderBase, methodVO:MethodVO, stage:Stage)\n\t{\n\t}\n}\n\nexport default ShadowHardMethod;",
    "import IAsset\t\t\t\t\t\t\tfrom \"awayjs-core/lib/library/IAsset\";\n\nimport LightBase\t\t\t\t\t\tfrom \"awayjs-display/lib/display/LightBase\";\nimport ShadowMapperBase\t\t\t\t\tfrom \"awayjs-display/lib/materials/shadowmappers/ShadowMapperBase\";\n\nimport ShadingMethodBase\t\t\t\tfrom \"../methods/ShadingMethodBase\";\n\n/**\n * ShadowMapMethodBase provides an abstract base method for shadow map methods.\n */\nclass ShadowMapMethodBase extends ShadingMethodBase implements IAsset\n{\n\tpublic static assetType:string = \"[asset ShadowMapMethod]\";\n\n\tpublic _pCastingLight:LightBase;\n\tpublic _pShadowMapper:ShadowMapperBase;\n\n\tpublic _pEpsilon:number = .02;\n\tpublic _pAlpha:number = 1;\n\n\t/**\n\t * Creates a new ShadowMapMethodBase object.\n\t * @param castingLight The light used to cast shadows.\n\t */\n\tconstructor(castingLight:LightBase)\n\t{\n\t\tsuper();\n\t\tthis._pCastingLight = castingLight;\n\t\tcastingLight.shadowsEnabled = true;\n\t\tthis._pShadowMapper = castingLight.shadowMapper;\n\n\t\tthis.iAddTexture(castingLight.shadowMapper.depthMap);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic get assetType():string\n\t{\n\t\treturn ShadowMapMethodBase.assetType;\n\t}\n\n\t/**\n\t * The \"transparency\" of the shadows. This allows making shadows less strong.\n\t */\n\tpublic get alpha():number\n\t{\n\t\treturn this._pAlpha;\n\t}\n\n\tpublic set alpha(value:number)\n\t{\n\t\tthis._pAlpha = value;\n\t}\n\n\t/**\n\t * The light casting the shadows.\n\t */\n\tpublic get castingLight():LightBase\n\t{\n\t\treturn this._pCastingLight;\n\t}\n\n\t/**\n\t * A small value to counter floating point precision errors when comparing values in the shadow map with the\n\t * calculated depth value. Increase this if shadow banding occurs, decrease it if the shadow seems to be too detached.\n\t */\n\tpublic get epsilon():number\n\t{\n\t\treturn this._pEpsilon;\n\t}\n\n\tpublic set epsilon(value:number)\n\t{\n\t\tthis._pEpsilon = value;\n\t}\n}\n\nexport default ShadowMapMethodBase;",
    "import Vector3D\t\t\t\t\t\t\tfrom \"awayjs-core/lib/geom/Vector3D\";\nimport AbstractMethodError\t\t\t\tfrom \"awayjs-core/lib/errors/AbstractMethodError\";\n\nimport LightBase\t\t\t\t\t\tfrom \"awayjs-display/lib/display/LightBase\";\nimport Camera\t\t\t\t\t\t\tfrom \"awayjs-display/lib/display/Camera\";\nimport DirectionalLight\t\t\t\t\tfrom \"awayjs-display/lib/display/DirectionalLight\";\nimport PointLight\t\t\t\t\t\tfrom \"awayjs-display/lib/display/PointLight\";\nimport DirectionalShadowMapper\t\t\tfrom \"awayjs-display/lib/materials/shadowmappers/DirectionalShadowMapper\";\nimport TextureBase\t\t\t\t\t\tfrom \"awayjs-display/lib/textures/TextureBase\";\n\nimport Stage\t\t\t\t\t\t\tfrom \"awayjs-stagegl/lib/base/Stage\";\n\nimport GL_RenderableBase\t\t\t\tfrom \"awayjs-renderergl/lib/renderables/GL_RenderableBase\";\nimport LightingShader\t\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/LightingShader\";\nimport ShaderBase\t\t\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderBase\";\nimport ShaderRegisterCache\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterCache\";\nimport ShaderRegisterData\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterData\";\nimport ShaderRegisterElement\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterElement\";\n\nimport MethodVO\t\t\t\t\t\t\tfrom \"../data/MethodVO\";\nimport ShadowMapMethodBase\t\t\t\tfrom \"../methods/ShadowMapMethodBase\";\n\n/**\n * ShadowMethodBase provides an abstract method for simple (non-wrapping) shadow map methods.\n */\nclass ShadowMethodBase extends ShadowMapMethodBase\n{\n\tpublic _pDepthMapCoordReg:ShaderRegisterElement;\n\tpublic _pUsePoint:boolean;\n\n\t/**\n\t * Creates a new ShadowMethodBase object.\n\t * @param castingLight The light used to cast shadows.\n\t */\n\tconstructor(castingLight:LightBase)\n\t{\n\t\tsuper(castingLight);\n\n\t\tthis._pUsePoint = (castingLight instanceof PointLight);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitVO(shader:LightingShader, methodVO:MethodVO)\n\t{\n\t\tmethodVO.needsView = true;\n\t\tmethodVO.needsGlobalVertexPos = true;\n\t\tmethodVO.needsGlobalFragmentPos = this._pUsePoint;\n\t\tmethodVO.needsNormals = shader.numLights > 0;\n\n\t\tmethodVO.textureGL = shader.getAbstraction(this._pCastingLight.shadowMapper.depthMap);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitConstants(shader:ShaderBase, methodVO:MethodVO)\n\t{\n\t\tvar fragmentData:Float32Array = shader.fragmentConstantData;\n\t\tvar vertexData:Float32Array = shader.vertexConstantData;\n\t\tvar index:number /*int*/ = methodVO.fragmentConstantsIndex;\n\t\tfragmentData[index] = 1.0;\n\t\tfragmentData[index + 1] = 1/255.0;\n\t\tfragmentData[index + 2] = 1/65025.0;\n\t\tfragmentData[index + 3] = 1/16581375.0;\n\n\t\tfragmentData[index + 6] = 0;\n\t\tfragmentData[index + 7] = 1;\n\n\t\tif (this._pUsePoint) {\n\t\t\tfragmentData[index + 8] = 0;\n\t\t\tfragmentData[index + 9] = 0;\n\t\t\tfragmentData[index + 10] = 0;\n\t\t\tfragmentData[index + 11] = 1;\n\t\t}\n\n\t\tindex = methodVO.vertexConstantsIndex;\n\t\tif (index != -1) {\n\t\t\tvertexData[index] = .5;\n\t\t\tvertexData[index + 1] = .5;\n\t\t\tvertexData[index + 2] = 0.0;\n\t\t\tvertexData[index + 3] = 1.0;\n\t\t}\n\t}\n\n\t/**\n\t * Wrappers that override the vertex shader need to set this explicitly\n\t */\n\tpublic get _iDepthMapCoordReg():ShaderRegisterElement\n\t{\n\t\treturn this._pDepthMapCoordReg;\n\t}\n\n\tpublic set _iDepthMapCoordReg(value:ShaderRegisterElement)\n\t{\n\t\tthis._pDepthMapCoordReg = value;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iCleanCompilationData()\n\t{\n\t\tsuper.iCleanCompilationData();\n\n\t\tthis._pDepthMapCoordReg = null;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetVertexCode(shader:ShaderBase, methodVO:MethodVO, regCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\treturn this._pUsePoint? this._pGetPointVertexCode(methodVO, regCache, sharedRegisters):this.pGetPlanarVertexCode(methodVO, regCache, sharedRegisters);\n\t}\n\n\t/**\n\t * Gets the vertex code for shadow mapping with a point light.\n\t *\n\t * @param methodVO The MethodVO object linking this method with the pass currently being compiled.\n\t * @param regCache The register cache used during the compilation.\n\t */\n\tpublic _pGetPointVertexCode(methodVO:MethodVO, regCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tmethodVO.vertexConstantsIndex = -1;\n\t\treturn \"\";\n\t}\n\n\t/**\n\t * Gets the vertex code for shadow mapping with a planar shadow map (fe: directional lights).\n\t *\n\t * @param methodVO The MethodVO object linking this method with the pass currently being compiled.\n\t * @param regCache The register cache used during the compilation.\n\t */\n\tpublic pGetPlanarVertexCode(methodVO:MethodVO, regCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = \"\";\n\t\tvar temp:ShaderRegisterElement = regCache.getFreeVertexVectorTemp();\n\t\tvar dataReg:ShaderRegisterElement = regCache.getFreeVertexConstant();\n\t\tvar depthMapProj:ShaderRegisterElement = regCache.getFreeVertexConstant();\n\t\tregCache.getFreeVertexConstant();\n\t\tregCache.getFreeVertexConstant();\n\t\tregCache.getFreeVertexConstant();\n\t\tthis._pDepthMapCoordReg = regCache.getFreeVarying();\n\t\tmethodVO.vertexConstantsIndex = dataReg.index*4;\n\n\t\t// todo: can epsilon be applied here instead of fragment shader?\n\n\t\tcode += \"m44 \" + temp + \", \" + sharedRegisters.globalPositionVertex + \", \" + depthMapProj + \"\\n\" +\n\t\t\t\"div \" + temp + \", \" + temp + \", \" + temp + \".w\\n\" +\n\t\t\t\"mul \" + temp + \".xy, \" + temp + \".xy, \" + dataReg + \".xy\\n\" +\n\t\t\t\"add \" + this._pDepthMapCoordReg + \", \" + temp + \", \" + dataReg + \".xxwz\\n\";\n\t\t//\"sub \" + this._pDepthMapCoordReg + \".z, \" + this._pDepthMapCoordReg + \".z, \" + this._pDepthMapCoordReg + \".w\\n\";\n\n\t\treturn code;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentCode(shader:ShaderBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = this._pUsePoint? this._pGetPointFragmentCode(shader, methodVO, targetReg, registerCache, sharedRegisters) : this._pGetPlanarFragmentCode(shader, methodVO, targetReg, registerCache, sharedRegisters);\n\t\tcode += \"add \" + targetReg + \".w, \" + targetReg + \".w, fc\" + (methodVO.fragmentConstantsIndex/4 + 1) + \".y\\n\" +\n\t\t\t\"sat \" + targetReg + \".w, \" + targetReg + \".w\\n\";\n\t\treturn code;\n\t}\n\n\t/**\n\t * Gets the fragment code for shadow mapping with a planar shadow map.\n\t * @param methodVO The MethodVO object linking this method with the pass currently being compiled.\n\t * @param regCache The register cache used during the compilation.\n\t * @param targetReg The register to contain the shadow coverage\n\t * @return\n\t */\n\tpublic _pGetPlanarFragmentCode(shader:ShaderBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, regCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tthrow new AbstractMethodError();\n\t}\n\n\t/**\n\t * Gets the fragment code for shadow mapping with a point light.\n\t * @param methodVO The MethodVO object linking this method with the pass currently being compiled.\n\t * @param regCache The register cache used during the compilation.\n\t * @param targetReg The register to contain the shadow coverage\n\t * @return\n\t */\n\tpublic _pGetPointFragmentCode(shader:ShaderBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, regCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tthrow new AbstractMethodError();\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iSetRenderState(shader:ShaderBase, methodVO:MethodVO, renderable:GL_RenderableBase, stage:Stage, camera:Camera)\n\t{\n\t\tif (!this._pUsePoint)\n\t\t\t(<DirectionalShadowMapper> this._pShadowMapper).iDepthProjection.copyRawDataTo(shader.vertexConstantData, methodVO.vertexConstantsIndex + 4, true);\n\n\t\tmethodVO.textureGL._setRenderState(renderable);\n\t}\n\n\t/**\n\t * Gets the fragment code for combining this method with a cascaded shadow map method.\n\t * @param methodVO The MethodVO object linking this method with the pass currently being compiled.\n\t * @param regCache The register cache used during the compilation.\n\t * @param decodeRegister The register containing the data to decode the shadow map depth value.\n\t * @param depthTexture The texture containing the shadow map.\n\t * @param depthProjection The projection of the fragment relative to the light.\n\t * @param targetRegister The register to contain the shadow coverage\n\t * @return\n\t */\n\tpublic _iGetCascadeFragmentCode(shader:ShaderBase, methodVO:MethodVO, decodeRegister:ShaderRegisterElement, depthProjection:ShaderRegisterElement, targetRegister:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tthrow new Error(\"This shadow method is incompatible with cascade shadows\");\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iActivate(shader:ShaderBase, methodVO:MethodVO, stage:Stage)\n\t{\n\t\tvar fragmentData:Float32Array = shader.fragmentConstantData;\n\t\tvar index:number /*int*/ = methodVO.fragmentConstantsIndex;\n\n\t\tif (this._pUsePoint)\n\t\t\tfragmentData[index + 4] = -Math.pow(1/((<PointLight> this._pCastingLight).fallOff*this._pEpsilon), 2);\n\t\telse\n\t\t\tshader.vertexConstantData[methodVO.vertexConstantsIndex + 3] = -1/((<DirectionalShadowMapper> this._pShadowMapper).depth*this._pEpsilon);\n\n\t\tfragmentData[index + 5] = 1 - this._pAlpha;\n\n\t\tif (this._pUsePoint) {\n\t\t\tvar pos:Vector3D = this._pCastingLight.scenePosition;\n\t\t\tfragmentData[index + 8] = pos.x;\n\t\t\tfragmentData[index + 9] = pos.y;\n\t\t\tfragmentData[index + 10] = pos.z;\n\t\t\t// used to decompress distance\n\t\t\tvar f:number = (<PointLight> this._pCastingLight).fallOff;\n\t\t\tfragmentData[index + 11] = 1/(2*f*f);\n\t\t}\n\n\t\tmethodVO.textureGL.activate(methodVO.pass._render);\n\t}\n\n\t/**\n\t * Sets the method state for cascade shadow mapping.\n\t */\n\tpublic iActivateForCascade(shader:ShaderBase, methodVO:MethodVO, stage:Stage)\n\t{\n\t\tthrow new Error(\"This shadow method is incompatible with cascade shadows\");\n\t}\n}\n\nexport default ShadowMethodBase;",
    "import NearDirectionalShadowMapper\t\tfrom \"awayjs-display/lib/materials/shadowmappers/NearDirectionalShadowMapper\";\nimport Camera\t\t\t\t\t\t\tfrom \"awayjs-display/lib/display/Camera\";\n\nimport Stage\t\t\t\t\t\t\tfrom \"awayjs-stagegl/lib/base/Stage\";\n\nimport GL_RenderableBase\t\t\t\tfrom \"awayjs-renderergl/lib/renderables/GL_RenderableBase\";\nimport ShadingMethodEvent\t\t\t\tfrom \"awayjs-renderergl/lib/events/ShadingMethodEvent\";\nimport LightingShader\t\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/LightingShader\";\nimport ShaderBase\t\t\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderBase\";\nimport ShaderRegisterCache\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterCache\";\nimport ShaderRegisterData\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterData\";\nimport ShaderRegisterElement\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterElement\";\n\nimport MethodVO\t\t\t\t\t\t\tfrom \"../data/MethodVO\";\nimport ShadowMethodBase\t\t\t\t\tfrom \"../methods/ShadowMethodBase\";\n\n// TODO: shadow mappers references in materials should be an interface so that this class should NOT extend ShadowMapMethodBase just for some delegation work\n/**\n * ShadowNearMethod provides a shadow map method that restricts the shadowed area near the camera to optimize\n * shadow map usage. This method needs to be used in conjunction with a NearDirectionalShadowMapper.\n *\n * @see away.lights.NearDirectionalShadowMapper\n */\nclass ShadowNearMethod extends ShadowMethodBase\n{\n\tprivate _baseMethod:ShadowMethodBase;\n\n\tprivate _fadeRatio:number;\n\tprivate _nearShadowMapper:NearDirectionalShadowMapper;\n\n\tprivate _onShaderInvalidatedDelegate:(event:ShadingMethodEvent) => void;\n\n\t/**\n\t * Creates a new ShadowNearMethod object.\n\t * @param baseMethod The shadow map sampling method used to sample individual cascades (fe: ShadowHardMethod, ShadowSoftMethod)\n\t * @param fadeRatio The amount of shadow fading to the outer shadow area. A value of 1 would mean the shadows start fading from the camera's near plane.\n\t */\n\tconstructor(baseMethod:ShadowMethodBase, fadeRatio:number = .1)\n\t{\n\t\tsuper(baseMethod.castingLight);\n\n\t\tthis._onShaderInvalidatedDelegate = (event:ShadingMethodEvent) => this.onShaderInvalidated(event);\n\n\t\tthis._baseMethod = baseMethod;\n\t\tthis._fadeRatio = fadeRatio;\n\t\tthis._nearShadowMapper = <NearDirectionalShadowMapper> this._pCastingLight.shadowMapper;\n\t\tif (!this._nearShadowMapper)\n\t\t\tthrow new Error(\"ShadowNearMethod requires a light that has a NearDirectionalShadowMapper instance assigned to shadowMapper.\");\n\t\tthis._baseMethod.addEventListener(ShadingMethodEvent.SHADER_INVALIDATED, this._onShaderInvalidatedDelegate);\n\t}\n\n\t/**\n\t * The base shadow map method on which this method's shading is based.\n\t */\n\tpublic get baseMethod():ShadowMethodBase\n\t{\n\t\treturn this._baseMethod;\n\t}\n\n\tpublic set baseMethod(value:ShadowMethodBase)\n\t{\n\t\tif (this._baseMethod == value)\n\t\t\treturn;\n\n\t\tthis._baseMethod.removeEventListener(ShadingMethodEvent.SHADER_INVALIDATED, this._onShaderInvalidatedDelegate);\n\n\t\tthis._baseMethod = value;\n\n\t\tthis._baseMethod.addEventListener(ShadingMethodEvent.SHADER_INVALIDATED, this._onShaderInvalidatedDelegate);\n\n\t\tthis.iInvalidateShaderProgram();\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitConstants(shader:ShaderBase, methodVO:MethodVO)\n\t{\n\t\tsuper.iInitConstants(shader, methodVO);\n\t\tthis._baseMethod.iInitConstants(shader, methodVO);\n\n\t\tvar fragmentData:Float32Array = shader.fragmentConstantData;\n\t\tvar index:number /*int*/ = methodVO.secondaryFragmentConstantsIndex;\n\t\tfragmentData[index + 2] = 0;\n\t\tfragmentData[index + 3] = 1;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitVO(shader:LightingShader, methodVO:MethodVO)\n\t{\n\t\tthis._baseMethod.iInitVO(shader, methodVO);\n\n\t\tmethodVO.needsProjection = true;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic dispose()\n\t{\n\t\tthis._baseMethod.removeEventListener(ShadingMethodEvent.SHADER_INVALIDATED, this._onShaderInvalidatedDelegate);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic get alpha():number\n\t{\n\t\treturn this._baseMethod.alpha;\n\t}\n\n\tpublic set alpha(value:number)\n\t{\n\t\tthis._baseMethod.alpha = value;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic get epsilon():number\n\t{\n\t\treturn this._baseMethod.epsilon;\n\t}\n\n\tpublic set epsilon(value:number)\n\t{\n\t\tthis._baseMethod.epsilon = value;\n\t}\n\n\t/**\n\t * The amount of shadow fading to the outer shadow area. A value of 1 would mean the shadows start fading from the camera's near plane.\n\t */\n\tpublic get fadeRatio():number\n\t{\n\t\treturn this._fadeRatio;\n\t}\n\n\tpublic set fadeRatio(value:number)\n\t{\n\t\tthis._fadeRatio = value;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentCode(shader:ShaderBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = this._baseMethod.iGetFragmentCode(shader, methodVO, targetReg, registerCache, sharedRegisters);\n\n\t\tvar dataReg:ShaderRegisterElement = registerCache.getFreeFragmentConstant();\n\t\tvar temp:ShaderRegisterElement = registerCache.getFreeFragmentSingleTemp();\n\t\tmethodVO.secondaryFragmentConstantsIndex = dataReg.index*4;\n\n\t\tcode += \"abs \" + temp + \", \" + sharedRegisters.projectionFragment + \".w\\n\" +\n\t\t\t\"sub \" + temp + \", \" + temp + \", \" + dataReg + \".x\\n\" +\n\t\t\t\"mul \" + temp + \", \" + temp + \", \" + dataReg + \".y\\n\" +\n\t\t\t\"sat \" + temp + \", \" + temp + \"\\n\" +\n\t\t\t\"sub \" + temp + \", \" + dataReg + \".w,\" + temp + \"\\n\" +\n\t\t\t\"sub \" + targetReg + \".w, \" + dataReg + \".w,\" + targetReg + \".w\\n\" +\n\t\t\t\"mul \" + targetReg + \".w, \" + targetReg + \".w, \" + temp + \"\\n\" +\n\t\t\t\"sub \" + targetReg + \".w, \" + dataReg + \".w,\" + targetReg + \".w\\n\";\n\n\t\treturn code;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iActivate(shader:ShaderBase, methodVO:MethodVO, stage:Stage)\n\t{\n\t\tthis._baseMethod.iActivate(shader, methodVO, stage);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iDeactivate(shader:ShaderBase, methodVO:MethodVO, stage:Stage)\n\t{\n\t\tthis._baseMethod.iDeactivate(shader, methodVO, stage);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iSetRenderState(shader:ShaderBase, methodVO:MethodVO, renderable:GL_RenderableBase, stage:Stage, camera:Camera)\n\t{\n\t\t// todo: move this to activate (needs camera)\n\t\tvar near:number = camera.projection.near;\n\t\tvar d:number = camera.projection.far - near;\n\t\tvar maxDistance:number = this._nearShadowMapper.coverageRatio;\n\t\tvar minDistance:number = maxDistance*(1 - this._fadeRatio);\n\n\t\tmaxDistance = near + maxDistance*d;\n\t\tminDistance = near + minDistance*d;\n\n\t\tvar fragmentData:Float32Array = shader.fragmentConstantData;\n\t\tvar index:number /*int*/ = methodVO.secondaryFragmentConstantsIndex;\n\t\tfragmentData[index] = minDistance;\n\t\tfragmentData[index + 1] = 1/(maxDistance - minDistance);\n\n\t\tthis._baseMethod.iSetRenderState(shader, methodVO, renderable, stage, camera);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetVertexCode(shader:ShaderBase, methodVO:MethodVO, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\treturn this._baseMethod.iGetVertexCode(shader, methodVO, registerCache, sharedRegisters);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iReset()\n\t{\n\t\tthis._baseMethod.iReset();\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iCleanCompilationData()\n\t{\n\t\tsuper.iCleanCompilationData();\n\t\tthis._baseMethod.iCleanCompilationData();\n\t}\n\n\t/**\n\t * Called when the base method's shader code is invalidated.\n\t */\n\tprivate onShaderInvalidated(event:ShadingMethodEvent)\n\t{\n\t\tthis.iInvalidateShaderProgram();\n\t}\n}\n\nexport default ShadowNearMethod;",
    "import PoissonLookup\t\t\t\t\tfrom \"awayjs-core/lib/geom/PoissonLookup\";\n\nimport DirectionalLight\t\t\t\t\tfrom \"awayjs-display/lib/display/DirectionalLight\";\n\nimport Stage\t\t\t\t\t\t\tfrom \"awayjs-stagegl/lib/base/Stage\";\n\nimport ShaderBase\t\t\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderBase\";\nimport ShaderRegisterCache\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterCache\";\nimport ShaderRegisterData\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterData\";\nimport ShaderRegisterElement\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterElement\";\n\nimport MethodVO\t\t\t\t\t\t\tfrom \"../data/MethodVO\";\nimport ShadowMethodBase\t\t\t\t\tfrom \"../methods/ShadowMethodBase\";\n\n/**\n * ShadowSoftMethod provides a soft shadowing technique by randomly distributing sample points.\n */\nclass ShadowSoftMethod extends ShadowMethodBase\n{\n\tprivate _range:number = 1;\n\tprivate _numSamples:number /*int*/;\n\tprivate _offsets:Array<number>;\n\n\t/**\n\t * Creates a new DiffuseBasicMethod object.\n\t *\n\t * @param castingLight The light casting the shadows\n\t * @param numSamples The amount of samples to take for dithering. Minimum 1, maximum 32.\n\t */\n\tconstructor(castingLight:DirectionalLight, numSamples:number /*int*/ = 5, range:number = 1)\n\t{\n\t\tsuper(castingLight);\n\n\t\tthis.numSamples = numSamples;\n\t\tthis.range = range;\n\t}\n\n\t/**\n\t * The amount of samples to take for dithering. Minimum 1, maximum 32. The actual maximum may depend on the\n\t * complexity of the shader.\n\t */\n\tpublic get numSamples():number /*int*/\n\t{\n\t\treturn this._numSamples;\n\t}\n\n\tpublic set numSamples(value:number /*int*/)\n\t{\n\t\tthis._numSamples = value;\n\t\t\n\t\tif (this._numSamples < 1)\n\t\t\tthis._numSamples = 1;\n\t\telse if (this._numSamples > 32)\n\t\t\tthis._numSamples = 32;\n\n\t\tthis._offsets = PoissonLookup.getDistribution(this._numSamples);\n\t\t\n\t\tthis.iInvalidateShaderProgram();\n\t}\n\n\t/**\n\t * The range in the shadow map in which to distribute the samples.\n\t */\n\tpublic get range():number\n\t{\n\t\treturn this._range;\n\t}\n\n\tpublic set range(value:number)\n\t{\n\t\tthis._range = value;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitConstants(shader:ShaderBase, methodVO:MethodVO)\n\t{\n\t\tsuper.iInitConstants(shader, methodVO);\n\n\t\tshader.fragmentConstantData[methodVO.fragmentConstantsIndex + 8] = 1/this._numSamples;\n\t\tshader.fragmentConstantData[methodVO.fragmentConstantsIndex + 9] = 0;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iActivate(shader:ShaderBase, methodVO:MethodVO, stage:Stage)\n\t{\n\t\tsuper.iActivate(shader, methodVO, stage);\n\n\t\tvar texRange:number = .5*this._range/this._pCastingLight.shadowMapper.depthMapSize;\n\t\tvar data:Float32Array = shader.fragmentConstantData;\n\t\tvar index:number /*uint*/ = methodVO.fragmentConstantsIndex + 10;\n\t\tvar len:number /*uint*/ = this._numSamples << 1;\n\n\t\tfor (var i:number /*int*/ = 0; i < len; ++i)\n\t\t\tdata[index + i] = this._offsets[i]*texRange;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic _pGetPlanarFragmentCode(shader:ShaderBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, regCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\t// todo: move some things to super\n\t\tvar decReg:ShaderRegisterElement = regCache.getFreeFragmentConstant();\n\t\tregCache.getFreeFragmentConstant();\n\t\tvar dataReg:ShaderRegisterElement = regCache.getFreeFragmentConstant();\n\n\t\tmethodVO.fragmentConstantsIndex = decReg.index*4;\n\n\t\treturn this.getSampleCode(shader, methodVO, decReg, targetReg, regCache, sharedRegisters, dataReg);\n\t}\n\n\t/**\n\t * Adds the code for another tap to the shader code.\n\t * @param uv The uv register for the tap.\n\t * @param texture The texture register containing the depth map.\n\t * @param decode The register containing the depth map decoding data.\n\t * @param target The target register to add the tap comparison result.\n\t * @param regCache The register cache managing the registers.\n\t * @return\n\t */\n\tprivate addSample(shader:ShaderBase, methodVO:MethodVO, decodeRegister:ShaderRegisterElement, targetRegister:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData, uvReg:ShaderRegisterElement):string\n\t{\n\t\tvar temp:ShaderRegisterElement = registerCache.getFreeFragmentVectorTemp();\n\t\treturn methodVO.textureGL._iGetFragmentCode(temp, registerCache, sharedRegisters, uvReg) +\n\t\t\t\"dp4 \" + temp + \".z, \" + temp + \", \" + decodeRegister + \"\\n\" +\n\t\t\t\"slt \" + uvReg + \".w, \" + this._pDepthMapCoordReg + \".z, \" + temp + \".z\\n\" + // 0 if in shadow\n\t\t\t\"add \" + targetRegister + \".w, \" + targetRegister + \".w, \" + uvReg + \".w\\n\";\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iActivateForCascade(shader:ShaderBase, methodVO:MethodVO, stage:Stage)\n\t{\n\t\tsuper.iActivate(shader, methodVO, stage);\n\n\t\tvar texRange:number = this._range/this._pCastingLight.shadowMapper.depthMapSize;\n\t\tvar data:Float32Array = shader.fragmentConstantData;\n\t\tvar index:number /*uint*/ = methodVO.secondaryFragmentConstantsIndex;\n\t\tvar len:number /*uint*/ = this._numSamples << 1;\n\t\tdata[index] = 1/this._numSamples;\n\t\tdata[index + 1] = 0;\n\t\tindex += 2;\n\n\t\tfor (var i:number /*int*/ = 0; i < len; ++i)\n\t\t\tdata[index + i] = this._offsets[i]*texRange;\n\n\t\tif (len%4 == 0) {\n\t\t\tdata[index + len] = 0;\n\t\t\tdata[index + len + 1] = 0;\n\t\t}\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic _iGetCascadeFragmentCode(shader:ShaderBase, methodVO:MethodVO, decodeRegister:ShaderRegisterElement, depthProjection:ShaderRegisterElement, targetRegister:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tthis._pDepthMapCoordReg = depthProjection;\n\n\t\tvar dataReg:ShaderRegisterElement = registerCache.getFreeFragmentConstant();\n\t\tmethodVO.secondaryFragmentConstantsIndex = dataReg.index*4;\n\n\t\treturn this.getSampleCode(shader, methodVO, decodeRegister, targetRegister, registerCache, sharedRegisters, dataReg);\n\t}\n\n\t/**\n\t * Get the actual shader code for shadow mapping\n\t * @param regCache The register cache managing the registers.\n\t * @param depthTexture The texture register containing the depth map.\n\t * @param decodeRegister The register containing the depth map decoding data.\n\t * @param targetReg The target register to add the shadow coverage.\n\t * @param dataReg The register containing additional data.\n\t */\n\tprivate getSampleCode(shader:ShaderBase, methodVO:MethodVO, decodeRegister:ShaderRegisterElement, targetRegister:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData, dataReg:ShaderRegisterElement):string\n\t{\n\t\tvar code:string;\n\t\tvar uvReg:ShaderRegisterElement = registerCache.getFreeFragmentVectorTemp();\n\t\tregisterCache.addFragmentTempUsages(uvReg, 1);\n\n\t\tvar offsets:Array<string> = new Array<string>(dataReg + \".zw\");\n\t\tvar numRegs:number /*int*/ = this._numSamples >> 1;\n\n\t\tfor (var i:number /*int*/ = 0; i < numRegs; ++i) {\n\t\t\tvar reg:ShaderRegisterElement = registerCache.getFreeFragmentConstant();\n\t\t\toffsets.push(reg + \".xy\");\n\t\t\toffsets.push(reg + \".zw\");\n\t\t}\n\n\t\tfor (i = 0; i < this._numSamples; ++i) {\n\t\t\tif (i == 0) {\n\t\t\t\tvar temp:ShaderRegisterElement = registerCache.getFreeFragmentVectorTemp();\n\n\t\t\t\tcode = \"add \" + uvReg + \", \" + this._pDepthMapCoordReg + \", \" + dataReg + \".zwyy\\n\" +\n\t\t\t\t\tmethodVO.textureGL._iGetFragmentCode(temp, registerCache, sharedRegisters, uvReg) +\n\t\t\t\t\t\"dp4 \" + temp + \".z, \" + temp + \", \" + decodeRegister + \"\\n\" +\n\t\t\t\t\t\"slt \" + targetRegister + \".w, \" + this._pDepthMapCoordReg + \".z, \" + temp + \".z\\n\"; // 0 if in shadow;\n\t\t\t} else {\n\t\t\t\tcode += \"add \" + uvReg + \".xy, \" + this._pDepthMapCoordReg + \".xy, \" + offsets[i] + \"\\n\" +\n\t\t\t\t\tthis.addSample(shader, methodVO, decodeRegister, targetRegister, registerCache, sharedRegisters, uvReg);\n\t\t\t}\n\t\t}\n\n\t\tregisterCache.removeFragmentTempUsage(uvReg);\n\n\t\tcode += \"mul \" + targetRegister + \".w, \" + targetRegister + \".w, \" + dataReg + \".x\\n\"; // average\n\n\t\treturn code;\n\t}\n}\n\nexport default ShadowSoftMethod;",
    "import LightingShader\t\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/LightingShader\";\nimport ShaderRegisterCache\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterCache\";\nimport ShaderRegisterData\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterData\";\nimport ShaderRegisterElement\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterElement\";\n\nimport MethodVO\t\t\t\t\t\t\tfrom \"../data/MethodVO\";\nimport SpecularBasicMethod\t\t\t\tfrom \"../methods/SpecularBasicMethod\";\n\n/**\n * SpecularAnisotropicMethod provides a specular method resulting in anisotropic highlights. These are typical for\n * surfaces with microfacet details such as tiny grooves. In particular, this uses the Heidrich-Seidel distrubution.\n * The tangent vectors are used as the surface groove directions.\n */\nclass SpecularAnisotropicMethod extends SpecularBasicMethod\n{\n\t/**\n\t * Creates a new SpecularAnisotropicMethod object.\n\t */\n\tconstructor()\n\t{\n\t\tsuper();\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitVO(shader:LightingShader, methodVO:MethodVO)\n\t{\n\t\tmethodVO.needsTangents = true;\n\t\tmethodVO.needsView = true;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentCodePerLight(shader:LightingShader, methodVO:MethodVO, lightDirReg:ShaderRegisterElement, lightColReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = \"\";\n\t\tvar t:ShaderRegisterElement;\n\n\t\tif (this._pIsFirstLight)\n\t\t\tt = this._pTotalLightColorReg;\n\t\telse {\n\t\t\tt = registerCache.getFreeFragmentVectorTemp();\n\t\t\tregisterCache.addFragmentTempUsages(t, 1);\n\t\t}\n\n\t\t// (sin(l,t) * sin(v,t) - cos(l,t)*cos(v,t)) ^ k\n\n\t\tcode += \"nrm \" + t + \".xyz, \" + sharedRegisters.tangentVarying + \".xyz\\n\" +\n\t\t\t\"dp3 \" + t + \".w, \" + t + \".xyz, \" + lightDirReg + \".xyz\\n\" +\n\t\t\t\"dp3 \" + t + \".z, \" + t + \".xyz, \" + sharedRegisters.viewDirFragment + \".xyz\\n\";\n\n\t\t// (sin(t.w) * sin(t.z) - cos(t.w)*cos(t.z)) ^ k\n\t\tcode += \"sin \" + t + \".x, \" + t + \".w\\n\" +\n\t\t\t\"sin \" + t + \".y, \" + t + \".z\\n\" +\n\t\t\t// (t.x * t.y - cos(t.w)*cos(t.z)) ^ k\n\t\t\t\"mul \" + t + \".x, \" + t + \".x, \" + t + \".y\\n\" +\n\t\t\t// (t.x - cos(t.w)*cos(t.z)) ^ k\n\t\t\t\"cos \" + t + \".z, \" + t + \".z\\n\" +\n\t\t\t\"cos \" + t + \".w, \" + t + \".w\\n\" +\n\t\t\t// (t.x - t.w*t.z) ^ k\n\t\t\t\"mul \" + t + \".w, \" + t + \".w, \" + t + \".z\\n\" +\n\t\t\t// (t.x - t.w) ^ k\n\t\t\t\"sub \" + t + \".w, \" + t + \".x, \" + t + \".w\\n\";\n\n\t\tif (this.texture) {\n\t\t\t// apply gloss modulation from texture\n\t\t\tcode += \"mul \" + this._pSpecularTexData + \".w, \" + this._pSpecularTexData + \".y, \" + this._pSpecularDataRegister + \".w\\n\" +\n\t\t\t\t\"pow \" + t + \".w, \" + t + \".w, \" + this._pSpecularTexData + \".w\\n\";\n\t\t} else\n\t\t\tcode += \"pow \" + t + \".w, \" + t + \".w, \" + this._pSpecularDataRegister + \".w\\n\";\n\n\t\t// attenuate\n\t\tcode += \"mul \" + t + \".w, \" + t + \".w, \" + lightDirReg + \".w\\n\";\n\n\t\tif (this._iModulateMethod != null)\n\t\t\tcode += this._iModulateMethod(shader, methodVO, t, registerCache, sharedRegisters);\n\n\t\tcode += \"mul \" + t + \".xyz, \" + lightColReg + \".xyz, \" + t + \".w\\n\";\n\n\t\tif (!this._pIsFirstLight) {\n\t\t\tcode += \"add \" + this._pTotalLightColorReg + \".xyz, \" + this._pTotalLightColorReg + \".xyz, \" + t + \".xyz\\n\";\n\t\t\tregisterCache.removeFragmentTempUsage(t);\n\t\t}\n\n\t\tthis._pIsFirstLight = false;\n\n\t\treturn code;\n\t}\n}\n\nexport default SpecularAnisotropicMethod;",
    "import AssetEvent\t\t\t\t\t\tfrom \"awayjs-core/lib/events/AssetEvent\";\n\nimport Camera\t\t\t\t\t\t\tfrom \"awayjs-display/lib/display/Camera\";\nimport TextureBase\t\t\t\t\t\tfrom \"awayjs-display/lib/textures/TextureBase\";\n\nimport Stage\t\t\t\t\t\t\tfrom \"awayjs-stagegl/lib/base/Stage\";\n\nimport GL_RenderableBase\t\t\t\tfrom \"awayjs-renderergl/lib/renderables/GL_RenderableBase\";\nimport LightingShader\t\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/LightingShader\";\nimport ShaderRegisterCache\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterCache\";\nimport ShaderRegisterData\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterData\";\nimport ShaderRegisterElement\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterElement\";\n\nimport MethodVO\t\t\t\t\t\t\tfrom \"../data/MethodVO\";\nimport LightingMethodBase\t\t\t\tfrom \"../methods/LightingMethodBase\";\nimport ShadingMethodBase\t\t\t\tfrom \"../methods/ShadingMethodBase\";\n\n/**\n * SpecularBasicMethod provides the default shading method for Blinn-Phong specular highlights (an optimized but approximated\n * version of Phong specularity).\n */\nclass SpecularBasicMethod extends LightingMethodBase\n{\n\tpublic _pTotalLightColorReg:ShaderRegisterElement;\n\tpublic _pSpecularTexData:ShaderRegisterElement;\n\tpublic _pSpecularDataRegister:ShaderRegisterElement;\n\n\tprivate _texture:TextureBase;\n\n\tprivate _gloss:number = 50;\n\tprivate _strength:number = 1;\n\tprivate _color:number = 0xffffff;\n\tpublic _iSpecularR:number = 1;\n\tpublic _iSpecularG:number = 1;\n\tpublic _iSpecularB:number = 1;\n\tpublic _pIsFirstLight:boolean;\n\n\t/**\n\t * Creates a new SpecularBasicMethod object.\n\t */\n\tconstructor()\n\t{\n\t\tsuper();\n\t}\n\n\tpublic iIsUsed(shader:LightingShader):boolean\n\t{\n\t\tif (!shader.numLights)\n\t\t\treturn false;\n\n\t\treturn true;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitVO(shader:LightingShader, methodVO:MethodVO)\n\t{\n\t\tmethodVO.needsNormals = shader.numLights > 0;\n\t\tmethodVO.needsView = shader.numLights > 0;\n\n\t\tif (this._texture) {\n\t\t\tmethodVO.textureGL = shader.getAbstraction(this._texture);\n\t\t\tshader.uvDependencies++;\n\t\t} else if (methodVO.textureGL) {\n\t\t\tmethodVO.textureGL.onClear(new AssetEvent(AssetEvent.CLEAR, null));\n\t\t\tmethodVO.textureGL = null;\n\t\t}\n\t}\n\n\t/**\n\t * The glossiness of the material (sharpness of the specular highlight).\n\t */\n\tpublic get gloss():number\n\t{\n\t\treturn this._gloss;\n\t}\n\n\tpublic set gloss(value:number)\n\t{\n\t\tthis._gloss = value;\n\t}\n\n\t/**\n\t * The overall strength of the specular highlights.\n\t */\n\tpublic get strength():number\n\t{\n\t\treturn this._strength;\n\t}\n\n\tpublic set strength(value:number)\n\t{\n\t\tif (value == this._strength)\n\t\t\treturn;\n\n\t\tthis._strength = value;\n\t\tthis.updateSpecular();\n\t}\n\n\t/**\n\t * The colour of the specular reflection of the surface.\n\t */\n\tpublic get color():number\n\t{\n\t\treturn this._color;\n\t}\n\n\tpublic set color(value:number)\n\t{\n\t\tif (this._color == value)\n\t\t\treturn;\n\n\t\t// specular is now either enabled or disabled\n\t\tif (this._color == 0 || value == 0)\n\t\t\tthis.iInvalidateShaderProgram();\n\n\t\tthis._color = value;\n\t\tthis.updateSpecular();\n\t}\n\n\t/**\n\t * A texture that defines the strength of specular reflections for each texel in the red channel,\n\t * and the gloss factor (sharpness) in the green channel. You can use Specular2DTexture if you want to easily set\n\t * specular and gloss maps from grayscale images, but correctly authored images are preferred.\n\t */\n\tpublic get texture():TextureBase\n\t{\n\t\treturn this._texture;\n\t}\n\n\tpublic set texture(value:TextureBase)\n\t{\n\t\tif (this._texture == value)\n\t\t\treturn;\n\n\t\tif (this._texture)\n\t\t\tthis.iRemoveTexture(this._texture);\n\n\t\tthis._texture = value;\n\n\t\tif (this._texture)\n\t\t\tthis.iAddTexture(this._texture);\n\n\t\tthis.iInvalidateShaderProgram();\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic copyFrom(method:ShadingMethodBase)\n\t{\n\n\t\tvar m:any = method;\n\t\tvar bsm:SpecularBasicMethod = <SpecularBasicMethod> method;\n\n\t\tvar spec:SpecularBasicMethod = bsm;//SpecularBasicMethod(method);\n\t\tthis.texture = spec.texture;\n\t\tthis.strength = spec.strength;\n\t\tthis.color = spec.color;\n\t\tthis.gloss = spec.gloss;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iCleanCompilationData()\n\t{\n\t\tsuper.iCleanCompilationData();\n\t\tthis._pTotalLightColorReg = null;\n\t\tthis._pSpecularTexData = null;\n\t\tthis._pSpecularDataRegister = null;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentPreLightingCode(shader:LightingShader, methodVO:MethodVO, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = \"\";\n\n\t\tthis._pIsFirstLight = true;\n\n\t\tthis._pSpecularDataRegister = registerCache.getFreeFragmentConstant();\n\t\tmethodVO.fragmentConstantsIndex = this._pSpecularDataRegister.index*4;\n\n\t\tif (this._texture) {\n\n\t\t\tthis._pSpecularTexData = registerCache.getFreeFragmentVectorTemp();\n\t\t\tregisterCache.addFragmentTempUsages(this._pSpecularTexData, 1);\n\n\t\t\tcode += methodVO.textureGL._iGetFragmentCode(this._pSpecularTexData, registerCache, sharedRegisters, sharedRegisters.uvVarying);\n\t\t}\n\n\t\tthis._pTotalLightColorReg = registerCache.getFreeFragmentVectorTemp();\n\t\tregisterCache.addFragmentTempUsages(this._pTotalLightColorReg, 1);\n\n\t\treturn code;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentCodePerLight(shader:LightingShader, methodVO:MethodVO, lightDirReg:ShaderRegisterElement, lightColReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = \"\";\n\t\tvar t:ShaderRegisterElement;\n\n\t\tif (this._pIsFirstLight) {\n\t\t\tt = this._pTotalLightColorReg;\n\t\t} else {\n\t\t\tt = registerCache.getFreeFragmentVectorTemp();\n\t\t\tregisterCache.addFragmentTempUsages(t, 1);\n\t\t}\n\n\t\tvar viewDirReg:ShaderRegisterElement = sharedRegisters.viewDirFragment;\n\t\tvar normalReg:ShaderRegisterElement = sharedRegisters.normalFragment;\n\n\t\t// blinn-phong half vector model\n\t\tcode += \"add \" + t + \", \" + lightDirReg + \", \" + viewDirReg + \"\\n\" +\n\t\t\t\t\"nrm \" + t + \".xyz, \" + t + \"\\n\" +\n\t\t\t\t\"dp3 \" + t + \".w, \" + normalReg + \", \" + t + \"\\n\" +\n\t\t\t\t\"sat \" + t + \".w, \" + t + \".w\\n\";\n\n\t\tif (this._texture) {\n\t\t\t// apply gloss modulation from texture\n\t\t\tcode += \"mul \" + this._pSpecularTexData + \".w, \" + this._pSpecularTexData + \".y, \" + this._pSpecularDataRegister + \".w\\n\" +\n\t\t\t\t\t\"pow \" + t + \".w, \" + t + \".w, \" + this._pSpecularTexData + \".w\\n\";\n\t\t} else {\n\t\t\tcode += \"pow \" + t + \".w, \" + t + \".w, \" + this._pSpecularDataRegister + \".w\\n\";\n\t\t}\n\n\t\t// attenuate\n\t\tif (shader.usesLightFallOff)\n\t\t\tcode += \"mul \" + t + \".w, \" + t + \".w, \" + lightDirReg + \".w\\n\";\n\n\t\tif (this._iModulateMethod != null)\n\t\t\tcode += this._iModulateMethod(shader, methodVO, t, registerCache, sharedRegisters);\n\n\t\tcode += \"mul \" + t + \".xyz, \" + lightColReg + \", \" + t + \".w\\n\";\n\n\t\tif (!this._pIsFirstLight) {\n\t\t\tcode += \"add \" + this._pTotalLightColorReg + \".xyz, \" + this._pTotalLightColorReg + \", \" + t + \"\\n\";\n\t\t\tregisterCache.removeFragmentTempUsage(t);\n\t\t}\n\n\t\tthis._pIsFirstLight = false;\n\n\t\treturn code;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentCodePerProbe(shader:LightingShader, methodVO:MethodVO, cubeMapReg:ShaderRegisterElement, weightRegister:string, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = \"\";\n\t\tvar t:ShaderRegisterElement;\n\n\t\t// write in temporary if not first light, so we can add to total diffuse colour\n\t\tif (this._pIsFirstLight) {\n\t\t\tt = this._pTotalLightColorReg;\n\t\t} else {\n\t\t\tt = registerCache.getFreeFragmentVectorTemp();\n\t\t\tregisterCache.addFragmentTempUsages(t, 1);\n\t\t}\n\n\t\tvar normalReg:ShaderRegisterElement = sharedRegisters.normalFragment;\n\t\tvar viewDirReg:ShaderRegisterElement = sharedRegisters.viewDirFragment;\n\n\t\tcode += \"dp3 \" + t + \".w, \" + normalReg + \", \" + viewDirReg + \"\\n\" +\n\t\t\t\t\"add \" + t + \".w, \" + t + \".w, \" + t + \".w\\n\" +\n\t\t\t\t\"mul \" + t + \", \" + t + \".w, \" + normalReg + \"\\n\" +\n\t\t\t\t\"sub \" + t + \", \" + t + \", \" + viewDirReg + \"\\n\" +\n\t\t\t\t\"tex \" + t + \", \" + t + \", \" + cubeMapReg + \" <cube,\" + \"linear\" + \",miplinear>\\n\" +\n\t\t\t\t\"mul \" + t + \".xyz, \" + t + \", \" + weightRegister + \"\\n\";\n\n\t\tif (this._iModulateMethod != null)\n\t\t\tcode += this._iModulateMethod(shader, methodVO, t, registerCache, sharedRegisters);\n\n\t\tif (!this._pIsFirstLight) {\n\t\t\tcode += \"add \" + this._pTotalLightColorReg + \".xyz, \" + this._pTotalLightColorReg + \", \" + t + \"\\n\";\n\t\t\tregisterCache.removeFragmentTempUsage(t);\n\t\t}\n\n\t\tthis._pIsFirstLight = false;\n\n\t\treturn code;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentPostLightingCode(shader:LightingShader, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = \"\";\n\n\t\tif (sharedRegisters.shadowTarget)\n\t\t\tcode += \"mul \" + this._pTotalLightColorReg + \".xyz, \" + this._pTotalLightColorReg + \", \" + sharedRegisters.shadowTarget + \".w\\n\";\n\n\t\tif (this._texture) {\n\t\t\t// apply strength modulation from texture\n\t\t\tcode += \"mul \" + this._pTotalLightColorReg + \".xyz, \" + this._pTotalLightColorReg + \", \" + this._pSpecularTexData + \".x\\n\";\n\t\t\tregisterCache.removeFragmentTempUsage(this._pSpecularTexData);\n\t\t}\n\n\t\t// apply material's specular reflection\n\t\tcode += \"mul \" + this._pTotalLightColorReg + \".xyz, \" + this._pTotalLightColorReg + \", \" + this._pSpecularDataRegister + \"\\n\" +\n\t\t\t\"add \" + targetReg + \".xyz, \" + targetReg + \", \" + this._pTotalLightColorReg + \"\\n\";\n\t\tregisterCache.removeFragmentTempUsage(this._pTotalLightColorReg);\n\n\t\treturn code;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iActivate(shader:LightingShader, methodVO:MethodVO, stage:Stage)\n\t{\n\t\tif (this._texture)\n\t\t\tmethodVO.textureGL.activate(methodVO.pass._render);\n\n\t\tvar index:number = methodVO.fragmentConstantsIndex;\n\t\tvar data:Float32Array = shader.fragmentConstantData;\n\t\tdata[index] = this._iSpecularR;\n\t\tdata[index + 1] = this._iSpecularG;\n\t\tdata[index + 2] = this._iSpecularB;\n\t\tdata[index + 3] = this._gloss;\n\t}\n\n\tpublic iSetRenderState(shader:LightingShader, methodVO:MethodVO, renderable:GL_RenderableBase, stage:Stage, camera:Camera)\n\t{\n\t\tif (this._texture)\n\t\t\tmethodVO.textureGL._setRenderState(renderable);\n\t}\n\n\t/**\n\t * Updates the specular color data used by the render state.\n\t */\n\tprivate updateSpecular()\n\t{\n\t\tthis._iSpecularR = (( this._color >> 16) & 0xff)/0xff*this._strength;\n\t\tthis._iSpecularG = (( this._color >> 8) & 0xff)/0xff*this._strength;\n\t\tthis._iSpecularB = ( this._color & 0xff)/0xff*this._strength;\n\t}\n}\n\nexport default SpecularBasicMethod;",
    "import Stage\t\t\t\t\t\t\tfrom \"awayjs-stagegl/lib/base/Stage\";\n\nimport LightingShader\t\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/LightingShader\";\nimport ShaderBase\t\t\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderBase\";\nimport ShaderRegisterCache\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterCache\";\nimport ShaderRegisterData\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterData\";\nimport ShaderRegisterElement\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterElement\";\n\nimport MethodVO\t\t\t\t\t\t\tfrom \"../data/MethodVO\";\nimport SpecularBasicMethod\t\t\t\tfrom \"../methods/SpecularBasicMethod\";\nimport SpecularCompositeMethod\t\t\tfrom \"../methods/SpecularCompositeMethod\";\n\n/**\n * SpecularCelMethod provides a shading method to add specular cel (cartoon) shading.\n */\nclass SpecularCelMethod extends SpecularCompositeMethod\n{\n\tprivate _dataReg:ShaderRegisterElement;\n\tprivate _smoothness:number = .1;\n\tprivate _specularCutOff:number = .1;\n\n\t/**\n\t * Creates a new SpecularCelMethod object.\n\t * @param specularCutOff The threshold at which the specular highlight should be shown.\n\t * @param baseMethod An optional specular method on which the cartoon shading is based. If ommitted, SpecularBasicMethod is used.\n\t */\n\tconstructor(specularCutOff:number = .5, baseMethod:SpecularBasicMethod = null)\n\t{\n\t\tsuper(null, baseMethod);\n\n\t\tthis.baseMethod._iModulateMethod = (shader:ShaderBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData) => this.clampSpecular(shader, methodVO, targetReg, registerCache, sharedRegisters);\n\n\t\tthis._specularCutOff = specularCutOff;\n\t}\n\n\t/**\n\t * The smoothness of the highlight edge.\n\t */\n\tpublic get smoothness():number\n\t{\n\t\treturn this._smoothness;\n\t}\n\n\tpublic set smoothness(value:number)\n\t{\n\t\tthis._smoothness = value;\n\t}\n\n\t/**\n\t * The threshold at which the specular highlight should be shown.\n\t */\n\tpublic get specularCutOff():number\n\t{\n\t\treturn this._specularCutOff;\n\t}\n\n\tpublic set specularCutOff(value:number)\n\t{\n\t\tthis._specularCutOff = value;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iActivate(shader:LightingShader, methodVO:MethodVO, stage:Stage)\n\t{\n\t\tsuper.iActivate(shader, methodVO, stage);\n\n\t\tvar index:number /*int*/ = methodVO.secondaryFragmentConstantsIndex;\n\t\tvar data:Float32Array = shader.fragmentConstantData;\n\t\tdata[index] = this._smoothness;\n\t\tdata[index + 1] = this._specularCutOff;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iCleanCompilationData()\n\t{\n\t\tsuper.iCleanCompilationData();\n\t\tthis._dataReg = null;\n\t}\n\n\t/**\n\t * Snaps the specular shading strength of the wrapped method to zero or one, depending on whether or not it exceeds the specularCutOff\n\t * @param vo The MethodVO used to compile the current shader.\n\t * @param t The register containing the specular strength in the \"w\" component, and either the half-vector or the reflection vector in \"xyz\".\n\t * @param regCache The register cache used for the shader compilation.\n\t * @param sharedRegisters The shared register data for this shader.\n\t * @return The AGAL fragment code for the method.\n\t */\n\tprivate clampSpecular(shader:ShaderBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\treturn \"sub \" + targetReg + \".y, \" + targetReg + \".w, \" + this._dataReg + \".y\\n\" + // x - cutoff\n\t\t\t\"div \" + targetReg + \".y, \" + targetReg + \".y, \" + this._dataReg + \".x\\n\" + // (x - cutoff)/epsilon\n\t\t\t\"sat \" + targetReg + \".y, \" + targetReg + \".y\\n\" +\n\t\t\t\"sge \" + targetReg + \".w, \" + targetReg + \".w, \" + this._dataReg + \".y\\n\" +\n\t\t\t\"mul \" + targetReg + \".w, \" + targetReg + \".w, \" + targetReg + \".y\\n\";\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentPreLightingCode(shader:LightingShader, methodVO:MethodVO, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tthis._dataReg = registerCache.getFreeFragmentConstant();\n\t\tmethodVO.secondaryFragmentConstantsIndex = this._dataReg.index*4;\n\n\t\treturn super.iGetFragmentPreLightingCode(shader, methodVO, registerCache, sharedRegisters);\n\t}\n}\n\nexport default SpecularCelMethod;",
    "import Camera\t\t\t\t\t\t\tfrom \"awayjs-display/lib/display/Camera\";\nimport TextureBase\t\t\t\t\t\tfrom \"awayjs-display/lib/textures/TextureBase\";\nimport ISurface\t\t\t\t\t\t\tfrom \"awayjs-display/lib/base/ISurface\";\n\nimport Stage\t\t\t\t\t\t\tfrom \"awayjs-stagegl/lib/base/Stage\";\n\nimport GL_RenderableBase\t\t\t\tfrom \"awayjs-renderergl/lib/renderables/GL_RenderableBase\";\nimport ShadingMethodEvent\t\t\t\tfrom \"awayjs-renderergl/lib/events/ShadingMethodEvent\";\nimport LightingShader\t\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/LightingShader\";\nimport ShaderBase\t\t\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderBase\";\nimport ShaderRegisterCache\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterCache\";\nimport ShaderRegisterData\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterData\";\nimport ShaderRegisterElement\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterElement\";\n\nimport MethodVO\t\t\t\t\t\t\tfrom \"../data/MethodVO\";\nimport SpecularBasicMethod\t\t\t\tfrom \"../methods/SpecularBasicMethod\";\n\n/**\n * SpecularCompositeMethod provides a base class for specular methods that wrap a specular method to alter the\n * calculated specular reflection strength.\n */\nclass SpecularCompositeMethod extends SpecularBasicMethod\n{\n\tprivate _baseMethod:SpecularBasicMethod;\n\n\tprivate _onShaderInvalidatedDelegate:(event:ShadingMethodEvent) => void;\n\n\t/**\n\t * Creates a new <code>SpecularCompositeMethod</code> object.\n\t *\n\t * @param modulateMethod The method which will add the code to alter the base method's strength. It needs to have the signature modSpecular(t:ShaderRegisterElement, regCache:ShaderRegisterCache):string, in which t.w will contain the specular strength and t.xyz will contain the half-vector or the reflection vector.\n\t * @param baseMethod The base specular method on which this method's shading is based.\n\t */\n\tconstructor(modulateMethod:(shader:ShaderBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData) => string, baseMethod:SpecularBasicMethod = null)\n\t{\n\t\tsuper();\n\n\t\tthis._onShaderInvalidatedDelegate = (event:ShadingMethodEvent) => this.onShaderInvalidated(event);\n\n\t\tthis._baseMethod = baseMethod || new SpecularBasicMethod();\n\t\tthis._baseMethod._iModulateMethod = modulateMethod;\n\t\tthis._baseMethod.addEventListener(ShadingMethodEvent.SHADER_INVALIDATED, this._onShaderInvalidatedDelegate);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitVO(shader:LightingShader, methodVO:MethodVO)\n\t{\n\t\tthis._baseMethod.iInitVO(shader, methodVO);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitConstants(shader:ShaderBase, methodVO:MethodVO)\n\t{\n\t\tthis._baseMethod.iInitConstants(shader, methodVO);\n\t}\n\n\n\tpublic iAddOwner(owner:ISurface)\n\t{\n\t\tsuper.iAddOwner(owner);\n\n\t\tthis._baseMethod.iAddOwner(owner);\n\t}\n\n\tpublic iRemoveOwner(owner:ISurface)\n\t{\n\t\tsuper.iRemoveOwner(owner);\n\n\t\tthis._baseMethod.iRemoveOwner(owner);\n\t}\n\n\t/**\n\t * The base specular method on which this method's shading is based.\n\t */\n\tpublic get baseMethod():SpecularBasicMethod\n\t{\n\t\treturn this._baseMethod;\n\t}\n\n\tpublic set baseMethod(value:SpecularBasicMethod)\n\t{\n\t\tif (this._baseMethod == value)\n\t\t\treturn;\n\n\t\tthis._baseMethod.removeEventListener(ShadingMethodEvent.SHADER_INVALIDATED, this._onShaderInvalidatedDelegate);\n\n\t\tthis._baseMethod = value;\n\n\t\tthis._baseMethod.addEventListener(ShadingMethodEvent.SHADER_INVALIDATED, this._onShaderInvalidatedDelegate);\n\n\t\tthis.iInvalidateShaderProgram();\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic get gloss():number\n\t{\n\t\treturn this._baseMethod.gloss;\n\t}\n\n\tpublic set gloss(value:number)\n\t{\n\t\tthis._baseMethod.gloss = value;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic get strength():number\n\t{\n\t\treturn this._baseMethod.strength;\n\t}\n\n\tpublic set strength(value:number)\n\t{\n\t\tthis._baseMethod.strength = value;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic get color():number\n\t{\n\t\treturn this._baseMethod.color;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic set color(value:number)\n\t{\n\t\tthis._baseMethod.color = value;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic dispose()\n\t{\n\t\tthis._baseMethod.removeEventListener(ShadingMethodEvent.SHADER_INVALIDATED, this._onShaderInvalidatedDelegate);\n\t\tthis._baseMethod.dispose();\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic get texture():TextureBase\n\t{\n\t\treturn this._baseMethod.texture;\n\t}\n\n\tpublic set texture(value:TextureBase)\n\t{\n\t\tthis._baseMethod.texture = value;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iActivate(shader:LightingShader, methodVO:MethodVO, stage:Stage)\n\t{\n\t\tthis._baseMethod.iActivate(shader, methodVO, stage);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iSetRenderState(shader:LightingShader, methodVO:MethodVO, renderable:GL_RenderableBase, stage:Stage, camera:Camera)\n\t{\n\t\tthis._baseMethod.iSetRenderState(shader, methodVO, renderable, stage, camera);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iDeactivate(shader:ShaderBase, methodVO:MethodVO, stage:Stage)\n\t{\n\t\tthis._baseMethod.iDeactivate(shader, methodVO, stage);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetVertexCode(shader:ShaderBase, methodVO:MethodVO, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\treturn this._baseMethod.iGetVertexCode(shader, methodVO, registerCache, sharedRegisters);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentPreLightingCode(shader:LightingShader, methodVO:MethodVO, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\treturn this._baseMethod.iGetFragmentPreLightingCode(shader, methodVO, registerCache, sharedRegisters);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentCodePerLight(shader:LightingShader, methodVO:MethodVO, lightDirReg:ShaderRegisterElement, lightColReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\treturn this._baseMethod.iGetFragmentCodePerLight(shader, methodVO, lightDirReg, lightColReg, registerCache, sharedRegisters);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t * @return\n\t */\n\tpublic iGetFragmentCodePerProbe(shader:LightingShader, methodVO:MethodVO, cubeMapReg:ShaderRegisterElement, weightRegister:string, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\treturn this._baseMethod.iGetFragmentCodePerProbe(shader, methodVO, cubeMapReg, weightRegister, registerCache, sharedRegisters);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentPostLightingCode(shader:LightingShader, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\treturn this._baseMethod.iGetFragmentPostLightingCode(shader, methodVO, targetReg, registerCache, sharedRegisters);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iReset()\n\t{\n\t\tthis._baseMethod.iReset();\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iCleanCompilationData()\n\t{\n\t\tsuper.iCleanCompilationData();\n\t\tthis._baseMethod.iCleanCompilationData();\n\t}\n\n\t/**\n\t * Called when the base method's shader code is invalidated.\n\t */\n\tprivate onShaderInvalidated(event:ShadingMethodEvent)\n\t{\n\t\tthis.iInvalidateShaderProgram();\n\t}\n}\n\nexport default SpecularCompositeMethod;",
    "import Camera\t\t\t\t\t\t\tfrom \"awayjs-display/lib/display/Camera\";\n\nimport Stage\t\t\t\t\t\t\tfrom \"awayjs-stagegl/lib/base/Stage\";\n\nimport LightingShader\t\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/LightingShader\";\nimport ShaderBase\t\t\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderBase\";\nimport ShaderRegisterCache\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterCache\";\nimport ShaderRegisterData\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterData\";\nimport ShaderRegisterElement\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterElement\";\n\nimport MethodVO\t\t\t\t\t\t\tfrom \"../data/MethodVO\";\nimport SpecularBasicMethod\t\t\t\tfrom \"../methods/SpecularBasicMethod\";\nimport SpecularCompositeMethod\t\t\tfrom \"../methods/SpecularCompositeMethod\";\n\n/**\n * SpecularFresnelMethod provides a specular shading method that causes stronger highlights on grazing view angles.\n */\nclass SpecularFresnelMethod extends SpecularCompositeMethod\n{\n\tprivate _dataReg:ShaderRegisterElement;\n\tprivate _incidentLight:boolean;\n\tprivate _fresnelPower:number = 5;\n\tprivate _normalReflectance:number = .028; // default value for skin\n\n\t/**\n\t * Creates a new SpecularFresnelMethod object.\n\t * @param basedOnSurface Defines whether the fresnel effect should be based on the view angle on the surface (if true), or on the angle between the light and the view.\n\t * @param baseMethod The specular method to which the fresnel equation. Defaults to SpecularBasicMethod.\n\t */\n\tconstructor(basedOnSurface:boolean = true, baseMethod:SpecularBasicMethod = null)\n\t{\n\t\t// may want to offer diff speculars\n\t\tsuper(null, baseMethod);\n\n\t\tthis.baseMethod._iModulateMethod = (shader:ShaderBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData) => this.modulateSpecular(shader, methodVO, targetReg, registerCache, sharedRegisters);\n\n\t\tthis._incidentLight = !basedOnSurface;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitConstants(shader:ShaderBase, methodVO:MethodVO)\n\t{\n\n\t\tvar index:number = methodVO.secondaryFragmentConstantsIndex;\n\t\tshader.fragmentConstantData[index + 2] = 1;\n\t\tshader.fragmentConstantData[index + 3] = 0;\n\t}\n\n\t/**\n\t * Defines whether the fresnel effect should be based on the view angle on the surface (if true), or on the angle between the light and the view.\n\t */\n\tpublic get basedOnSurface():boolean\n\t{\n\t\treturn !this._incidentLight;\n\t}\n\n\tpublic set basedOnSurface(value:boolean)\n\t{\n\t\tif (this._incidentLight != value)\n\t\t\treturn;\n\n\t\tthis._incidentLight = !value;\n\n\t\tthis.iInvalidateShaderProgram();\n\t}\n\n\t/**\n\t * The power used in the Fresnel equation. Higher values make the fresnel effect more pronounced. Defaults to 5.\n\t */\n\tpublic get fresnelPower():number\n\t{\n\t\treturn this._fresnelPower;\n\t}\n\n\tpublic set fresnelPower(value:number)\n\t{\n\t\tthis._fresnelPower = value;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iCleanCompilationData()\n\t{\n\t\tsuper.iCleanCompilationData();\n\t\tthis._dataReg = null;\n\t}\n\n\t/**\n\t * The minimum amount of reflectance, ie the reflectance when the view direction is normal to the surface or light direction.\n\t */\n\tpublic get normalReflectance():number\n\t{\n\t\treturn this._normalReflectance;\n\t}\n\n\tpublic set normalReflectance(value:number)\n\t{\n\t\tthis._normalReflectance = value;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iActivate(shader:LightingShader, methodVO:MethodVO, stage:Stage)\n\t{\n\t\tsuper.iActivate(shader, methodVO, stage);\n\n\t\tvar fragmentData:Float32Array = shader.fragmentConstantData;\n\n\t\tvar index:number = methodVO.secondaryFragmentConstantsIndex;\n\t\tfragmentData[index] = this._normalReflectance;\n\t\tfragmentData[index + 1] = this._fresnelPower;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentPreLightingCode(shader:LightingShader, methodVO:MethodVO, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tthis._dataReg = registerCache.getFreeFragmentConstant();\n\n\t\tmethodVO.secondaryFragmentConstantsIndex = this._dataReg.index*4;\n\n\t\treturn super.iGetFragmentPreLightingCode(shader, methodVO, registerCache, sharedRegisters);\n\t}\n\n\t/**\n\t * Applies the fresnel effect to the specular strength.\n\t *\n\t * @param vo The MethodVO object containing the method data for the currently compiled material pass.\n\t * @param target The register containing the specular strength in the \"w\" component, and the half-vector/reflection vector in \"xyz\".\n\t * @param regCache The register cache used for the shader compilation.\n\t * @param sharedRegisters The shared registers created by the compiler.\n\t * @return The AGAL fragment code for the method.\n\t */\n\tprivate modulateSpecular(shader:ShaderBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string;\n\n\t\tcode = \"dp3 \" + targetReg + \".y, \" + sharedRegisters.viewDirFragment + \".xyz, \" + (this._incidentLight? targetReg : sharedRegisters.normalFragment) + \".xyz\\n\" +   // dot(V, H)\n\t\t\t\"sub \" + targetReg + \".y, \" + this._dataReg + \".z, \" + targetReg + \".y\\n\" +             // base = 1-dot(V, H)\n\t\t\t\"pow \" + targetReg + \".x, \" + targetReg + \".y, \" + this._dataReg + \".y\\n\" +             // exp = pow(base, 5)\n\t\t\t\"sub \" + targetReg + \".y, \" + this._dataReg + \".z, \" + targetReg + \".y\\n\" +             // 1 - exp\n\t\t\t\"mul \" + targetReg + \".y, \" + this._dataReg + \".x, \" + targetReg + \".y\\n\" +             // f0*(1 - exp)\n\t\t\t\"add \" + targetReg + \".y, \" + targetReg + \".x, \" + targetReg + \".y\\n\" +          // exp + f0*(1 - exp)\n\t\t\t\"mul \" + targetReg + \".w, \" + targetReg + \".w, \" + targetReg + \".y\\n\";\n\n\t\treturn code;\n\t}\n\n}\n\nexport default SpecularFresnelMethod;",
    "import LightingShader\t\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/LightingShader\";\nimport ShaderRegisterCache\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterCache\";\nimport ShaderRegisterData\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterData\";\nimport ShaderRegisterElement\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterElement\";\n\nimport MethodVO\t\t\t\t\t\t\tfrom \"../data/MethodVO\";\nimport SpecularBasicMethod\t\t\t\tfrom \"../methods/SpecularBasicMethod\";\n\n/**\n * SpecularPhongMethod provides a specular method that provides Phong highlights.\n */\nclass SpecularPhongMethod extends SpecularBasicMethod\n{\n\t/**\n\t * Creates a new SpecularPhongMethod object.\n\t */\n\tconstructor()\n\t{\n\t\tsuper();\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentCodePerLight(shader:LightingShader, methodVO:MethodVO, lightDirReg:ShaderRegisterElement, lightColReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = \"\";\n\t\tvar t:ShaderRegisterElement;\n\n\t\tif (this._pIsFirstLight) {\n\t\t\tt = this._pTotalLightColorReg;\n\t\t} else {\n\t\t\tt = registerCache.getFreeFragmentVectorTemp();\n\t\t\tregisterCache.addFragmentTempUsages(t, 1);\n\t\t}\n\n\t\tvar viewDirReg:ShaderRegisterElement =sharedRegisters.viewDirFragment;\n\t\tvar normalReg:ShaderRegisterElement =sharedRegisters.normalFragment;\n\n\t\t// phong model\n\t\tcode += \"dp3 \" + t + \".w, \" + lightDirReg + \", \" + normalReg + \"\\n\" + // sca1 = light.normal\n\n\t\t\t//find the reflected light vector R\n\t\t\t\"add \" + t + \".w, \" + t + \".w, \" + t + \".w\\n\" + // sca1 = sca1*2\n\t\t\t\"mul \" + t + \".xyz, \" + normalReg + \", \" + t + \".w\\n\" + // vec1 = normal*sca1\n\t\t\t\"sub \" + t + \".xyz, \" + t + \", \" + lightDirReg + \"\\n\" + // vec1 = vec1 - light (light vector is negative)\n\n\t\t\t//smooth the edge as incidence angle approaches 90\n\t\t\t\"add \" + t + \".w, \" + t + \".w, \" +sharedRegisters.commons + \".w\\n\" + // sca1 = sca1 + smoothtep;\n\t\t\t\"sat \" + t + \".w, \" + t + \".w\\n\" + // sca1 range 0 - 1\n\t\t\t\"mul \" + t + \".xyz, \" + t + \", \" + t + \".w\\n\" + // vec1 = vec1*sca1\n\n\t\t\t//find the dot product between R and V\n\t\t\t\"dp3 \" + t + \".w, \" + t + \", \" + viewDirReg + \"\\n\" + // sca1 = vec1.view\n\t\t\t\"sat \" + t + \".w, \" + t + \".w\\n\";\n\n\t\tif (this.texture) {\n\t\t\t// apply gloss modulation from texture\n\t\t\tcode += \"mul \" + this._pSpecularTexData + \".w, \" + this._pSpecularTexData + \".y, \" + this._pSpecularDataRegister + \".w\\n\" +\n\t\t\t\t\"pow \" + t + \".w, \" + t + \".w, \" + this._pSpecularTexData + \".w\\n\";\n\t\t} else\n\t\t\tcode += \"pow \" + t + \".w, \" + t + \".w, \" + this._pSpecularDataRegister + \".w\\n\";\n\n\t\t// attenuate\n\t\tif (shader.usesLightFallOff)\n\t\t\tcode += \"mul \" + t + \".w, \" + t + \".w, \" + lightDirReg + \".w\\n\";\n\n\t\tif (this._iModulateMethod != null)\n\t\t\tcode += this._iModulateMethod(shader, methodVO, t, registerCache, sharedRegisters);\n\n\t\tcode += \"mul \" + t + \".xyz, \" + lightColReg + \".xyz, \" + t + \".w\\n\";\n\n\t\tif (!this._pIsFirstLight) {\n\t\t\tcode += \"add \" + this._pTotalLightColorReg + \".xyz, \" + this._pTotalLightColorReg + \".xyz, \" + t + \".xyz\\n\";\n\t\t\tregisterCache.removeFragmentTempUsage(t);\n\t\t}\n\n\t\tthis._pIsFirstLight = false;\n\n\t\treturn code;\n\t}\n}\n\nexport default SpecularPhongMethod;",
    "export {default as AmbientBasicMethod}\t\t\t\tfrom \"./methods/AmbientBasicMethod\";\nexport {default as AmbientEnvMapMethod}\t\t\t\tfrom \"./methods/AmbientEnvMapMethod\";\nexport {default as CurveBasicMethod}\t\t\t\tfrom \"./methods/CurveBasicMethod\";\nexport {default as DiffuseBasicMethod}\t\t\t\tfrom \"./methods/DiffuseBasicMethod\";\nexport {default as DiffuseCelMethod}\t\t\t\tfrom \"./methods/DiffuseCelMethod\";\nexport {default as DiffuseCompositeMethod}\t\t\tfrom \"./methods/DiffuseCompositeMethod\";\nexport {default as DiffuseDepthMethod}\t\t\t\tfrom \"./methods/DiffuseDepthMethod\";\nexport {default as DiffuseGradientMethod}\t\t\tfrom \"./methods/DiffuseGradientMethod\";\nexport {default as DiffuseLightMapMethod}\t\t\tfrom \"./methods/DiffuseLightMapMethod\";\nexport {default as DiffuseSubSurfaceMethod}\t\t\tfrom \"./methods/DiffuseSubSurfaceMethod\";\nexport {default as DiffuseWrapMethod}\t\t\t\tfrom \"./methods/DiffuseWrapMethod\";\nexport {default as EffectAlphaMaskMethod}\t\t\tfrom \"./methods/EffectAlphaMaskMethod\";\nexport {default as EffectColorMatrixMethod}\t\t\tfrom \"./methods/EffectColorMatrixMethod\";\nexport {default as EffectColorTransformMethod}\t\tfrom \"./methods/EffectColorTransformMethod\";\nexport {default as EffectEnvMapMethod}\t\t\t\tfrom \"./methods/EffectEnvMapMethod\";\nexport {default as EffectFogMethod}\t\t\t\t\tfrom \"./methods/EffectFogMethod\";\nexport {default as EffectFresnelEnvMapMethod}\t\tfrom \"./methods/EffectFresnelEnvMapMethod\";\nexport {default as EffectLightMapMethod}\t\t\tfrom \"./methods/EffectLightMapMethod\";\nexport {default as EffectMethodBase}\t\t\t\tfrom \"./methods/EffectMethodBase\";\nexport {default as EffectRefractionEnvMapMethod}\tfrom \"./methods/EffectRefractionEnvMapMethod\";\nexport {default as EffectRimLightMethod}\t\t\tfrom \"./methods/EffectRimLightMethod\";\nexport {default as LightingMethodBase}\t\t\t\tfrom \"./methods/LightingMethodBase\";\nexport {default as NormalBasicMethod}\t\t\t\tfrom \"./methods/NormalBasicMethod\";\nexport {default as NormalHeightMapMethod}\t\t\tfrom \"./methods/NormalHeightMapMethod\";\nexport {default as NormalSimpleWaterMethod}\t\t\tfrom \"./methods/NormalSimpleWaterMethod\";\nexport {default as ShadingMethodBase}\t\t\t\tfrom \"./methods/ShadingMethodBase\";\nexport {default as ShadowCascadeMethod}\t\t\t\tfrom \"./methods/ShadowCascadeMethod\";\nexport {default as ShadowDitheredMethod}\t\t\tfrom \"./methods/ShadowDitheredMethod\";\nexport {default as ShadowFilteredMethod}\t\t\tfrom \"./methods/ShadowFilteredMethod\";\nexport {default as ShadowHardMethod}\t\t\t\tfrom \"./methods/ShadowHardMethod\";\nexport {default as ShadowMapMethodBase}\t\t\t\tfrom \"./methods/ShadowMapMethodBase\";\nexport {default as ShadowMethodBase}\t\t\t\tfrom \"./methods/ShadowMethodBase\";\nexport {default as ShadowNearMethod}\t\t\t\tfrom \"./methods/ShadowNearMethod\";\nexport {default as ShadowSoftMethod}\t\t\t\tfrom \"./methods/ShadowSoftMethod\";\nexport {default as SpecularAnisotropicMethod}\t\tfrom \"./methods/SpecularAnisotropicMethod\";\nexport {default as SpecularBasicMethod}\t\t\t\tfrom \"./methods/SpecularBasicMethod\";\nexport {default as SpecularCelMethod}\t\t\t\tfrom \"./methods/SpecularCelMethod\";\nexport {default as SpecularCompositeMethod}\t\t\tfrom \"./methods/SpecularCompositeMethod\";\nexport {default as SpecularFresnelMethod}\t\t\tfrom \"./methods/SpecularFresnelMethod\";\nexport {default as SpecularPhongMethod}\t\t\t\tfrom \"./methods/SpecularPhongMethod\";",
    "import BlendMode\t\t\t\t\t\tfrom \"awayjs-core/lib/image/BlendMode\";\nimport AssetEvent\t\t\t\t\t\tfrom \"awayjs-core/lib/events/AssetEvent\";\n\nimport StaticLightPicker\t\t\t\tfrom \"awayjs-display/lib/materials/lightpickers/StaticLightPicker\";\n\nimport ContextGLCompareMode\t\t\t\tfrom \"awayjs-stagegl/lib/base/ContextGLCompareMode\";\n\nimport IElementsClassGL\t\t\t\t\tfrom \"awayjs-renderergl/lib/elements/IElementsClassGL\";\nimport GL_SurfaceBase\t\t\t\t\tfrom \"awayjs-renderergl/lib/surfaces/GL_SurfaceBase\";\nimport SurfacePool\t\t\t\t\t\tfrom \"awayjs-renderergl/lib/surfaces/SurfacePool\";\n\nimport MethodMaterial\t\t\t\t\tfrom \"../MethodMaterial\";\nimport MethodMaterialMode\t\t\t\tfrom \"../MethodMaterialMode\";\nimport MethodPassMode\t\t\t\t\tfrom \"../surfaces/passes/MethodPassMode\";\nimport MethodPass\t\t\t\t\t\tfrom \"../surfaces/passes/MethodPass\";\nimport EffectMethodBase\t\t\t\t\tfrom \"../methods/EffectMethodBase\";\n\n/**\n * CompiledPass forms an abstract base class for the default compiled pass materials provided by Away3D,\n * using material methods to define their appearance.\n */\nclass GL_MethodMaterialSurface extends GL_SurfaceBase\n{\n\tprivate _material:MethodMaterial;\n\tprivate _pass:MethodPass;\n\tprivate _casterLightPass:MethodPass;\n\tprivate _nonCasterLightPasses:Array<MethodPass>;\n\t\n\t/**\n\t * The maximum total number of lights provided by the light picker.\n\t */\n\tprivate get numLights():number\n\t{\n\t\treturn this._material.lightPicker? this._material.lightPicker.numLightProbes + this._material.lightPicker.numDirectionalLights + this._material.lightPicker.numPointLights + this._material.lightPicker.numCastingDirectionalLights + this._material.lightPicker.numCastingPointLights : 0;\n\t}\n\n\t/**\n\t * The amount of lights that don't cast shadows.\n\t */\n\tprivate get numNonCasters():number\n\t{\n\t\treturn this._material.lightPicker? this._material.lightPicker.numLightProbes + this._material.lightPicker.numDirectionalLights + this._material.lightPicker.numPointLights : 0;\n\t}\n\n\t/**\n\t * Creates a new CompiledPass object.\n\t *\n\t * @param material The material to which this pass belongs.\n\t */\n\tconstructor(material:MethodMaterial, elementsClass:IElementsClassGL, pool:SurfacePool)\n\t{\n\t\tsuper(material, elementsClass, pool);\n\n\t\tthis._material = material;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic _pUpdateRender()\n\t{\n\t\tsuper._pUpdateRender();\n\n\t\tthis.initPasses();\n\n\t\tthis.setBlendAndCompareModes();\n\n\t\tthis._pClearPasses();\n\n\t\tif (this._material.mode == MethodMaterialMode.MULTI_PASS) {\n\t\t\tif (this._casterLightPass)\n\t\t\t\tthis._pAddPass(this._casterLightPass);\n\n\t\t\tif (this._nonCasterLightPasses)\n\t\t\t\tfor (var i:number = 0; i < this._nonCasterLightPasses.length; ++i)\n\t\t\t\t\tthis._pAddPass(this._nonCasterLightPasses[i]);\n\t\t}\n\n\t\tif (this._pass)\n\t\t\tthis._pAddPass(this._pass);\n\t}\n\n\t/**\n\t * Initializes all the passes and their dependent passes.\n\t */\n\tprivate initPasses()\n\t{\n\t\t// let the effects pass handle everything if there are no lights, when there are effect methods applied\n\t\t// after shading, or when the material mode is single pass.\n\t\tif (this.numLights == 0 || this._material.numEffectMethods > 0 || this._material.mode == MethodMaterialMode.SINGLE_PASS)\n\t\t\tthis.initEffectPass();\n\t\telse if (this._pass)\n\t\t\tthis.removeEffectPass();\n\n\t\t// only use a caster light pass if shadows need to be rendered\n\t\tif (this._material.shadowMethod && this._material.mode == MethodMaterialMode.MULTI_PASS)\n\t\t\tthis.initCasterLightPass();\n\t\telse if (this._casterLightPass)\n\t\t\tthis.removeCasterLightPass();\n\n\t\t// only use non caster light passes if there are lights that don't cast\n\t\tif (this.numNonCasters > 0 && this._material.mode == MethodMaterialMode.MULTI_PASS)\n\t\t\tthis.initNonCasterLightPasses();\n\t\telse if (this._nonCasterLightPasses)\n\t\t\tthis.removeNonCasterLightPasses();\n\t}\n\n\t/**\n\t * Sets up the various blending modes for all screen passes, based on whether or not there are previous passes.\n\t */\n\tprivate setBlendAndCompareModes()\n\t{\n\t\tvar forceSeparateMVP:boolean = Boolean(this._casterLightPass || this._pass);\n\n\t\t// caster light pass is always first if it exists, hence it uses normal blending\n\t\tif (this._casterLightPass) {\n\t\t\tthis._casterLightPass.forceSeparateMVP = forceSeparateMVP;\n\t\t\tthis._casterLightPass.shader.setBlendMode(BlendMode.NORMAL);\n\t\t\tthis._casterLightPass.shader.depthCompareMode = this._material.depthCompareMode;\n\t\t}\n\n\t\tif (this._nonCasterLightPasses) {\n\t\t\tvar firstAdditiveIndex:number = 0;\n\n\t\t\t// if there's no caster light pass, the first non caster light pass will be the first\n\t\t\t// and should use normal blending\n\t\t\tif (!this._casterLightPass) {\n\t\t\t\tthis._nonCasterLightPasses[0].forceSeparateMVP = forceSeparateMVP;\n\t\t\t\tthis._nonCasterLightPasses[0].shader.setBlendMode(BlendMode.NORMAL);\n\t\t\t\tthis._nonCasterLightPasses[0].shader.depthCompareMode = this._material.depthCompareMode;\n\t\t\t\tfirstAdditiveIndex = 1;\n\t\t\t}\n\n\t\t\t// all lighting passes following the first light pass should use additive blending\n\t\t\tfor (var i:number = firstAdditiveIndex; i < this._nonCasterLightPasses.length; ++i) {\n\t\t\t\tthis._nonCasterLightPasses[i].forceSeparateMVP = forceSeparateMVP;\n\t\t\t\tthis._nonCasterLightPasses[i].shader.setBlendMode(BlendMode.ADD);\n\t\t\t\tthis._nonCasterLightPasses[i].shader.depthCompareMode = ContextGLCompareMode.LESS_EQUAL;\n\t\t\t}\n\t\t}\n\n\t\tif (this._casterLightPass || this._nonCasterLightPasses) {\n\t\t\t//cannot be blended by blendmode property if multipass enabled\n\t\t\tthis._pRequiresBlending = false;\n\n\t\t\t// there are light passes, so this should be blended in\n\t\t\tif (this._pass) {\n\t\t\t\tthis._pass.mode = MethodPassMode.EFFECTS;\n\t\t\t\tthis._pass.forceSeparateMVP = forceSeparateMVP;\n\t\t\t\tthis._pass.shader.depthCompareMode = ContextGLCompareMode.LESS_EQUAL;\n\t\t\t\tthis._pass.shader.setBlendMode(BlendMode.LAYER);\n\t\t\t}\n\n\t\t} else if (this._pass) {\n\t\t\tthis._pRequiresBlending = (this._material.blendMode != BlendMode.NORMAL || this._material.alphaBlending || (this._material.colorTransform && this._material.colorTransform.alphaMultiplier < 1));\n\t\t\t// effects pass is the only pass, so it should just blend normally\n\t\t\tthis._pass.mode = MethodPassMode.SUPER_SHADER;\n\t\t\tthis._pass.preserveAlpha = this._pRequiresBlending;\n\t\t\tthis._pass.forceSeparateMVP = false;\n\t\t\tthis._pass.colorTransform = this._material.colorTransform;\n\t\t\tthis._pass.shader.setBlendMode((this._material.blendMode == BlendMode.NORMAL && this._pRequiresBlending)? BlendMode.LAYER : this._material.blendMode);\n\t\t\tthis._pass.shader.depthCompareMode = this._material.depthCompareMode;\n\t\t}\n\t}\n\n\tprivate initCasterLightPass()\n\t{\n\n\t\tif (this._casterLightPass == null)\n\t\t\tthis._casterLightPass = new MethodPass(MethodPassMode.LIGHTING, this, this._material, this._elementsClass, this._stage);\n\n\t\tthis._casterLightPass.lightPicker = new StaticLightPicker([this._material.shadowMethod.castingLight]);\n\t\tthis._casterLightPass.shadowMethod = this._material.shadowMethod;\n\t\tthis._casterLightPass.diffuseMethod = this._material.diffuseMethod;\n\t\tthis._casterLightPass.ambientMethod = this._material.ambientMethod;\n\t\tthis._casterLightPass.normalMethod = this._material.normalMethod;\n\t\tthis._casterLightPass.specularMethod = this._material.specularMethod;\n\t}\n\n\tprivate removeCasterLightPass()\n\t{\n\t\tthis._casterLightPass.dispose();\n\t\tthis._pRemovePass(this._casterLightPass);\n\t\tthis._casterLightPass = null;\n\t}\n\n\tprivate initNonCasterLightPasses()\n\t{\n\t\tthis.removeNonCasterLightPasses();\n\t\tvar pass:MethodPass;\n\t\tvar numDirLights:number = this._material.lightPicker.numDirectionalLights;\n\t\tvar numPointLights:number = this._material.lightPicker.numPointLights;\n\t\tvar numLightProbes:number = this._material.lightPicker.numLightProbes;\n\t\tvar dirLightOffset:number = 0;\n\t\tvar pointLightOffset:number = 0;\n\t\tvar probeOffset:number = 0;\n\n\t\tif (!this._casterLightPass) {\n\t\t\tnumDirLights += this._material.lightPicker.numCastingDirectionalLights;\n\t\t\tnumPointLights += this._material.lightPicker.numCastingPointLights;\n\t\t}\n\n\t\tthis._nonCasterLightPasses = new Array<MethodPass>();\n\n\t\twhile (dirLightOffset < numDirLights || pointLightOffset < numPointLights || probeOffset < numLightProbes) {\n\t\t\tpass = new MethodPass(MethodPassMode.LIGHTING, this, this._material, this._elementsClass, this._stage);\n\t\t\tpass.includeCasters = this._material.shadowMethod == null;\n\t\t\tpass.directionalLightsOffset = dirLightOffset;\n\t\t\tpass.pointLightsOffset = pointLightOffset;\n\t\t\tpass.lightProbesOffset = probeOffset;\n\t\t\tpass.lightPicker = this._material.lightPicker;\n\t\t\tpass.diffuseMethod = this._material.diffuseMethod;\n\t\t\tpass.ambientMethod = this._material.ambientMethod;\n\t\t\tpass.normalMethod = this._material.normalMethod;\n\t\t\tpass.specularMethod = this._material.specularMethod;\n\t\t\tthis._nonCasterLightPasses.push(pass);\n\n\t\t\tdirLightOffset += pass.numDirectionalLights;\n\t\t\tpointLightOffset += pass.numPointLights;\n\t\t\tprobeOffset += pass.numLightProbes;\n\t\t}\n\t}\n\n\tprivate removeNonCasterLightPasses()\n\t{\n\t\tif (!this._nonCasterLightPasses)\n\t\t\treturn;\n\n\t\tfor (var i:number = 0; i < this._nonCasterLightPasses.length; ++i)\n\t\t\tthis._pRemovePass(this._nonCasterLightPasses[i]);\n\n\t\tthis._nonCasterLightPasses = null;\n\t}\n\n\tprivate removeEffectPass()\n\t{\n\t\tif (this._pass.ambientMethod != this._material.ambientMethod)\n\t\t\tthis._pass.ambientMethod.dispose();\n\n\t\tif (this._pass.diffuseMethod != this._material.diffuseMethod)\n\t\t\tthis._pass.diffuseMethod.dispose();\n\n\t\tif (this._pass.specularMethod != this._material.specularMethod)\n\t\t\tthis._pass.specularMethod.dispose();\n\n\t\tif (this._pass.normalMethod != this._material.normalMethod)\n\t\t\tthis._pass.normalMethod.dispose();\n\n\t\tthis._pRemovePass(this._pass);\n\t\tthis._pass = null;\n\t}\n\n\tprivate initEffectPass()\n\t{\n\t\tif (this._pass == null)\n\t\t\tthis._pass = new MethodPass(MethodPassMode.SUPER_SHADER, this, this._material, this._elementsClass, this._stage);\n\n\t\tif (this._material.mode == MethodMaterialMode.SINGLE_PASS) {\n\t\t\tthis._pass.ambientMethod = this._material.ambientMethod;\n\t\t\tthis._pass.diffuseMethod = this._material.diffuseMethod;\n\t\t\tthis._pass.specularMethod = this._material.specularMethod;\n\t\t\tthis._pass.normalMethod = this._material.normalMethod;\n\t\t\tthis._pass.shadowMethod = this._material.shadowMethod;\n\t\t} else if (this._material.mode == MethodMaterialMode.MULTI_PASS) {\n\t\t\tif (this.numLights == 0) {\n\t\t\t\tthis._pass.ambientMethod = this._material.ambientMethod;\n\t\t\t} else {\n\t\t\t\tthis._pass.ambientMethod = null;\n\t\t\t}\n\n\t\t\tthis._pass.preserveAlpha = false;\n\t\t\tthis._pass.normalMethod = this._material.normalMethod;\n\t\t}\n\n\t\t//update effect methods\n\t\tvar i:number = 0;\n\t\tvar effectMethod:EffectMethodBase;\n\t\tvar len:number = Math.max(this._material.numEffectMethods, this._pass.numEffectMethods);\n\n\t\twhile (i < len) {\n\t\t\teffectMethod = this._material.getEffectMethodAt(i);\n\t\t\tif (effectMethod != this._pass.getEffectMethodAt(i)) {\n\t\t\t\tthis._pass.removeEffectMethodAt(i);\n\n\t\t\t\tif (effectMethod != null) {\n\t\t\t\t\tif (i < this._pass.numEffectMethods)\n\t\t\t\t\t\tthis._pass.addEffectMethodAt(effectMethod, i);\n\t\t\t\t\telse\n\t\t\t\t\t\tthis._pass.addEffectMethod(effectMethod);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\ti++;\n\t\t}\n\t}\n\t\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic onClear(event:AssetEvent)\n\t{\n\t\tsuper.onClear(event);\n\n\t\t//TODO\n\t}\n}\n\nexport default GL_MethodMaterialSurface;",
    "class PassMode\n{\n\t/**\n\t *\n\t */\n\tpublic static EFFECTS:number = 0x01;\n\n\t/**\n\t *\n\t */\n\tpublic static LIGHTING:number = 0x02;\n\n\t/**\n\t *\n\t */\n\tpublic static SUPER_SHADER:number = 0x03;\n}\n\nexport default PassMode;",
    "import ColorTransform\t\t\t\t\tfrom \"awayjs-core/lib/geom/ColorTransform\";\nimport Matrix\t\t\t\t\t\t\tfrom \"awayjs-core/lib/geom/Matrix\";\nimport Matrix3D\t\t\t\t\t\t\tfrom \"awayjs-core/lib/geom/Matrix3D\";\nimport Matrix3DUtils\t\t\t\t\tfrom \"awayjs-core/lib/geom/Matrix3DUtils\";\nimport Vector3D\t\t\t\t\t\t\tfrom \"awayjs-core/lib/geom/Vector3D\";\nimport AbstractMethodError\t\t\t\tfrom \"awayjs-core/lib/errors/AbstractMethodError\";\nimport AssetEvent\t\t\t\t\t\tfrom \"awayjs-core/lib/events/AssetEvent\";\nimport MaterialBase\t\t\t\t\t\tfrom \"awayjs-display/lib/materials/MaterialBase\";\n\nimport Camera\t\t\t\t\t\t\tfrom \"awayjs-display/lib/display/Camera\";\nimport ISurface\t\t\t\t\t\t\tfrom \"awayjs-display/lib/base/ISurface\";\nimport LightPickerBase\t\t\t\t\tfrom \"awayjs-display/lib/materials/lightpickers/LightPickerBase\";\nimport LightSources\t\t\t\t\t\tfrom \"awayjs-display/lib/materials/LightSources\";\n\nimport Stage\t\t\t\t\t\t\tfrom \"awayjs-stagegl/lib/base/Stage\";\n\nimport RendererBase\t\t\t\t\t\tfrom \"awayjs-renderergl/lib/RendererBase\";\nimport LightingShader\t\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/LightingShader\";\nimport ShadingMethodEvent\t\t\t\tfrom \"awayjs-renderergl/lib/events/ShadingMethodEvent\";\nimport ShaderBase\t\t\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderBase\";\nimport ShaderRegisterCache\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterCache\";\nimport ShaderRegisterData\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterData\";\nimport ShaderRegisterElement\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterElement\";\nimport GL_RenderableBase\t\t\t\tfrom \"awayjs-renderergl/lib/renderables/GL_RenderableBase\";\nimport PassBase\t\t\t\t\t\t\tfrom \"awayjs-renderergl/lib/surfaces/passes/PassBase\";\nimport ILightingPass\t\t\t\t\tfrom \"awayjs-renderergl/lib/surfaces/passes/ILightingPass\";\nimport IElementsClassGL\t\t\t\t\tfrom \"awayjs-renderergl/lib/elements/IElementsClassGL\";\n\nimport MethodVO\t\t\t\t\t\t\tfrom \"../../data/MethodVO\";\nimport AmbientBasicMethod\t\t\t\tfrom \"../../methods/AmbientBasicMethod\";\nimport DiffuseBasicMethod\t\t\t\tfrom \"../../methods/DiffuseBasicMethod\";\nimport EffectColorTransformMethod\t\tfrom \"../../methods/EffectColorTransformMethod\";\nimport EffectMethodBase\t\t\t\t\tfrom \"../../methods/EffectMethodBase\";\nimport LightingMethodBase\t\t\t\tfrom \"../../methods/LightingMethodBase\";\nimport NormalBasicMethod\t\t\t\tfrom \"../../methods/NormalBasicMethod\";\nimport ShadowMapMethodBase\t\t\t\tfrom \"../../methods/ShadowMapMethodBase\";\nimport SpecularBasicMethod\t\t\t\tfrom \"../../methods/SpecularBasicMethod\";\nimport MethodPassMode\t\t\t\t\tfrom \"../../surfaces/passes/MethodPassMode\";\nimport GL_MethodMaterialSurface\t\t\tfrom \"../../surfaces/GL_MethodMaterialSurface\";\n\n/**\n * CompiledPass forms an abstract base class for the default compiled pass materials provided by Away3D,\n * using material methods to define their appearance.\n */\nclass MethodPass extends PassBase implements ILightingPass\n{\n\tprivate _maxLights:number = 3;\n\n\tprivate _mode:number = 0x03;\n\tprivate _material:MaterialBase;\n\tprivate _lightPicker:LightPickerBase;\n\n\tprivate _includeCasters:boolean = true;\n\n\tpublic _iColorTransformMethodVO:MethodVO;\n\tpublic _iNormalMethodVO:MethodVO;\n\tpublic _iAmbientMethodVO:MethodVO;\n\tpublic _iShadowMethodVO:MethodVO;\n\tpublic _iDiffuseMethodVO:MethodVO;\n\tpublic _iSpecularMethodVO:MethodVO;\n\tpublic _iMethodVOs:Array<MethodVO> = new Array<MethodVO>();\n\n\tpublic _numEffectDependencies:number = 0;\n\n\tprivate _onLightsChangeDelegate:(event:AssetEvent) => void;\n\tprivate _onMethodInvalidatedDelegate:(event:ShadingMethodEvent) => void;\n\n\tpublic numDirectionalLights:number = 0;\n\n\tpublic numPointLights:number = 0;\n\n\tpublic numLightProbes:number = 0;\n\n\tpublic pointLightsOffset:number = 0;\n\t\n\tpublic directionalLightsOffset:number= 0;\n\t\n\tpublic lightProbesOffset:number = 0;\n\t\n\t/**\n\t *\n\t */\n\tpublic get mode():number\n\t{\n\t\treturn this._mode;\n\t}\n\n\tpublic set mode(value:number)\n\t{\n\t\tif (this._mode == value)\n\t\t\treturn;\n\t\t\n\t\tthis._mode = value;\n\n\t\tthis._updateLights();\n\t}\n\n\t/**\n\t * Indicates whether or not shadow casting lights need to be included.\n\t */\n\tpublic get includeCasters():boolean\n\t{\n\t\treturn this._includeCasters;\n\t}\n\n\tpublic set includeCasters(value:boolean)\n\t{\n\t\tif (this._includeCasters == value)\n\t\t\treturn;\n\n\t\tthis._includeCasters = value;\n\n\t\tthis._updateLights();\n\t}\n\n\t/**\n\t * \n\t * @returns {LightPickerBase}\n\t */\n\tpublic get lightPicker():LightPickerBase\n\t{\n\t\treturn this._lightPicker;\n\t}\n\n\tpublic set lightPicker(value:LightPickerBase)\n\t{\n\t\t//if (this._lightPicker == value)\n\t\t//\treturn;\n\n\t\tif (this._lightPicker)\n\t\t\tthis._lightPicker.removeEventListener(AssetEvent.INVALIDATE, this._onLightsChangeDelegate);\n\n\t\tthis._lightPicker = value;\n\n\t\tif (this._lightPicker)\n\t\t\tthis._lightPicker.addEventListener(AssetEvent.INVALIDATE, this._onLightsChangeDelegate);\n\n\t\tthis._updateLights();\n\t}\n\t\n\t/**\n\t * Whether or not to use fallOff and radius properties for lights. This can be used to improve performance and\n\t * compatibility for constrained mode.\n\t */\n\tpublic get enableLightFallOff():boolean\n\t{\n\t\treturn this._material.enableLightFallOff;\n\t}\n\n\t/**\n\t * Define which light source types to use for diffuse reflections. This allows choosing between regular lights\n\t * and/or light probes for diffuse reflections.\n\t *\n\t * @see away3d.materials.LightSources\n\t */\n\tpublic get diffuseLightSources():number\n\t{\n\t\treturn this._material.diffuseLightSources;\n\t}\n\n\t/**\n\t * Define which light source types to use for specular reflections. This allows choosing between regular lights\n\t * and/or light probes for specular reflections.\n\t *\n\t * @see away3d.materials.LightSources\n\t */\n\tpublic get specularLightSources():number\n\t{\n\t\treturn this._material.specularLightSources;\n\t}\n\n\t/**\n\t * Creates a new CompiledPass object.\n\t *\n\t * @param material The material to which this pass belongs.\n\t */\n\tconstructor(mode:number, render:GL_MethodMaterialSurface, renderOwner:MaterialBase, elementsClass:IElementsClassGL, stage:Stage)\n\t{\n\t\tsuper(render, renderOwner, elementsClass, stage);\n\n\t\tthis._mode = mode;\n\n\t\tthis._material = renderOwner;\n\n\t\tthis._onLightsChangeDelegate = (event:AssetEvent) => this.onLightsChange(event);\n\t\t\n\t\tthis._onMethodInvalidatedDelegate = (event:ShadingMethodEvent) => this.onMethodInvalidated(event);\n\n\t\tthis.lightPicker = renderOwner.lightPicker;\n\n\t\tif (this._shader == null)\n\t\t\tthis._updateShader();\n\t}\n\n\tprivate _updateShader()\n\t{\n\t\tif ((this.numDirectionalLights || this.numPointLights || this.numLightProbes) && !(this._shader instanceof LightingShader)) {\n\t\t\tif (this._shader != null)\n\t\t\t\tthis._shader.dispose();\n\n\t\t\tthis._shader = new LightingShader(this._elementsClass, this, this._stage);\n\t\t} else if (!(this._shader instanceof ShaderBase)) {\n\t\t\tif (this._shader != null)\n\t\t\t\tthis._shader.dispose();\n\n\t\t\tthis._shader = new ShaderBase(this._elementsClass, this, this._stage);\n\t\t}\n\t}\n\n\t/**\n\t * Initializes the unchanging constant data for this material.\n\t */\n\tpublic _iInitConstantData(shader:ShaderBase)\n\t{\n\t\tsuper._iInitConstantData(shader);\n\n\t\t//Updates method constants if they have changed.\n\t\tvar len:number = this._iMethodVOs.length;\n\t\tfor (var i:number = 0; i < len; ++i)\n\t\t\tthis._iMethodVOs[i].method.iInitConstants(shader, this._iMethodVOs[i]);\n\t}\n\n\t/**\n\t * The ColorTransform object to transform the colour of the material with. Defaults to null.\n\t */\n\tpublic get colorTransform():ColorTransform\n\t{\n\t\treturn this.colorTransformMethod? this.colorTransformMethod.colorTransform : null;\n\t}\n\n\tpublic set colorTransform(value:ColorTransform)\n\t{\n\t\tif (value) {\n\t\t\tif (this.colorTransformMethod == null)\n\t\t\t\tthis.colorTransformMethod = new EffectColorTransformMethod();\n\n\t\t\tthis.colorTransformMethod.colorTransform = value;\n\n\t\t} else if (!value) {\n\t\t\tif (this.colorTransformMethod)\n\t\t\t\tthis.colorTransformMethod = null;\n\t\t}\n\t}\n\n\t/**\n\t * The EffectColorTransformMethod object to transform the colour of the material with. Defaults to null.\n\t */\n\tpublic get colorTransformMethod():EffectColorTransformMethod\n\t{\n\t\treturn this._iColorTransformMethodVO? <EffectColorTransformMethod> this._iColorTransformMethodVO.method : null;\n\t}\n\n\tpublic set colorTransformMethod(value:EffectColorTransformMethod)\n\t{\n\t\tif (this._iColorTransformMethodVO && this._iColorTransformMethodVO.method == value)\n\t\t\treturn;\n\n\t\tif (this._iColorTransformMethodVO) {\n\t\t\tthis._removeDependency(this._iColorTransformMethodVO);\n\t\t\tthis._iColorTransformMethodVO = null;\n\t\t}\n\n\t\tif (value) {\n\t\t\tthis._iColorTransformMethodVO = new MethodVO(value, this);\n\t\t\tthis._addDependency(this._iColorTransformMethodVO);\n\t\t}\n\t}\n\n\tprivate _removeDependency(methodVO:MethodVO, effectsDependency:boolean = false)\n\t{\n\t\tvar index:number = this._iMethodVOs.indexOf(methodVO);\n\n\t\tif (!effectsDependency)\n\t\t\tthis._numEffectDependencies--;\n\n\t\tmethodVO.method.removeEventListener(ShadingMethodEvent.SHADER_INVALIDATED, this._onMethodInvalidatedDelegate);\n\t\tthis._iMethodVOs.splice(index, 1);\n\n\t\tthis.invalidate();\n\t}\n\n\tprivate _addDependency(methodVO:MethodVO, effectsDependency:boolean = false, index:number = -1)\n\t{\n\t\tmethodVO.method.addEventListener(ShadingMethodEvent.SHADER_INVALIDATED, this._onMethodInvalidatedDelegate);\n\n\t\tif (effectsDependency) {\n\t\t\tif (index != -1)\n\t\t\t\tthis._iMethodVOs.splice(index + this._iMethodVOs.length - this._numEffectDependencies, 0, methodVO);\n\t\t\telse\n\t\t\t\tthis._iMethodVOs.push(methodVO);\n\t\t\tthis._numEffectDependencies++;\n\t\t} else {\n\t\t\tthis._iMethodVOs.splice(this._iMethodVOs.length - this._numEffectDependencies, 0, methodVO);\n\t\t}\n\n\t\tthis.invalidate();\n\t}\n\n\t/**\n\t * Appends an \"effect\" shading method to the shader. Effect methods are those that do not influence the lighting\n\t * but modulate the shaded colour, used for fog, outlines, etc. The method will be applied to the result of the\n\t * methods added prior.\n\t */\n\tpublic addEffectMethod(method:EffectMethodBase)\n\t{\n\t\tthis._addDependency(new MethodVO(method, this), true);\n\t}\n\n\t/**\n\t * The number of \"effect\" methods added to the material.\n\t */\n\tpublic get numEffectMethods():number\n\t{\n\t\treturn this._numEffectDependencies;\n\t}\n\n\t/**\n\t * Queries whether a given effects method was added to the material.\n\t *\n\t * @param method The method to be queried.\n\t * @return true if the method was added to the material, false otherwise.\n\t */\n\tpublic hasEffectMethod(method:EffectMethodBase):boolean\n\t{\n\t\treturn this.getDependencyForMethod(method) != null;\n\t}\n\n\t/**\n\t * Returns the method added at the given index.\n\t * @param index The index of the method to retrieve.\n\t * @return The method at the given index.\n\t */\n\tpublic getEffectMethodAt(index:number):EffectMethodBase\n\t{\n\t\tif (index < 0 || index > this._numEffectDependencies - 1)\n\t\t\treturn null;\n\n\t\treturn <EffectMethodBase> this._iMethodVOs[index + this._iMethodVOs.length - this._numEffectDependencies].method;\n\t}\n\n\t/**\n\t * Adds an effect method at the specified index amongst the methods already added to the material. Effect\n\t * methods are those that do not influence the lighting but modulate the shaded colour, used for fog, outlines,\n\t * etc. The method will be applied to the result of the methods with a lower index.\n\t */\n\tpublic addEffectMethodAt(method:EffectMethodBase, index:number)\n\t{\n\t\tthis._addDependency(new MethodVO(method, this), true, index);\n\t}\n\n\t/**\n\t * Removes an effect method from the material.\n\t * @param method The method to be removed.\n\t */\n\tpublic removeEffectMethod(method:EffectMethodBase)\n\t{\n\t\tvar methodVO:MethodVO = this.getDependencyForMethod(method);\n\n\t\tif (methodVO != null)\n\t\t\tthis._removeDependency(methodVO, true);\n\t}\n\n\n\t/**\n\t * remove an effect method at the specified index from the material.\n\t */\n\tpublic removeEffectMethodAt(index:number)\n\t{\n\t\tif (index < 0 || index > this._numEffectDependencies - 1)\n\t\t\treturn;\n\n\t\tvar methodVO:MethodVO = this._iMethodVOs[index + this._iMethodVOs.length - this._numEffectDependencies];\n\n\t\tif (methodVO != null)\n\t\t\tthis._removeDependency(methodVO, true);\n\t}\n\n\n\tprivate getDependencyForMethod(method:EffectMethodBase):MethodVO\n\t{\n\t\tvar len:number = this._iMethodVOs.length;\n\t\tfor (var i:number = 0; i < len; ++i)\n\t\t\tif (this._iMethodVOs[i].method == method)\n\t\t\t\treturn this._iMethodVOs[i];\n\n\t\treturn null;\n\t}\n\n\t/**\n\t * The method used to generate the per-pixel normals. Defaults to NormalBasicMethod.\n\t */\n\tpublic get normalMethod():NormalBasicMethod\n\t{\n\t\treturn this._iNormalMethodVO? <NormalBasicMethod> this._iNormalMethodVO.method : null;\n\t}\n\n\tpublic set normalMethod(value:NormalBasicMethod)\n\t{\n\t\tif (this._iNormalMethodVO && this._iNormalMethodVO.method == value)\n\t\t\treturn;\n\n\t\tif (this._iNormalMethodVO) {\n\t\t\tthis._removeDependency(this._iNormalMethodVO);\n\t\t\tthis._iNormalMethodVO = null;\n\t\t}\n\n\t\tif (value) {\n\t\t\tthis._iNormalMethodVO = new MethodVO(value, this);\n\t\t\tthis._addDependency(this._iNormalMethodVO);\n\t\t}\n\t}\n\n\t/**\n\t * The method that provides the ambient lighting contribution. Defaults to AmbientBasicMethod.\n\t */\n\tpublic get ambientMethod():AmbientBasicMethod\n\t{\n\t\treturn this._iAmbientMethodVO? <AmbientBasicMethod> this._iAmbientMethodVO.method : null;\n\t}\n\n\tpublic set ambientMethod(value:AmbientBasicMethod)\n\t{\n\t\tif (this._iAmbientMethodVO && this._iAmbientMethodVO.method == value)\n\t\t\treturn;\n\n\t\tif (this._iAmbientMethodVO) {\n\t\t\tthis._removeDependency(this._iAmbientMethodVO);\n\t\t\tthis._iAmbientMethodVO = null;\n\t\t}\n\n\t\tif (value) {\n\t\t\tthis._iAmbientMethodVO = new MethodVO(value, this);\n\t\t\tthis._addDependency(this._iAmbientMethodVO);\n\t\t}\n\t}\n\n\t/**\n\t * The method used to render shadows cast on this surface, or null if no shadows are to be rendered. Defaults to null.\n\t */\n\tpublic get shadowMethod():ShadowMapMethodBase\n\t{\n\t\treturn this._iShadowMethodVO? <ShadowMapMethodBase> this._iShadowMethodVO.method : null;\n\t}\n\n\tpublic set shadowMethod(value:ShadowMapMethodBase)\n\t{\n\t\tif (this._iShadowMethodVO && this._iShadowMethodVO.method == value)\n\t\t\treturn;\n\n\t\tif (this._iShadowMethodVO) {\n\t\t\tthis._removeDependency(this._iShadowMethodVO);\n\t\t\tthis._iShadowMethodVO = null;\n\t\t}\n\n\t\tif (value) {\n\t\t\tthis._iShadowMethodVO = new MethodVO(value, this);\n\t\t\tthis._addDependency(this._iShadowMethodVO);\n\t\t}\n\t}\n\n\t/**\n\t * The method that provides the diffuse lighting contribution. Defaults to DiffuseBasicMethod.\n\t */\n\tpublic get diffuseMethod():DiffuseBasicMethod\n\t{\n\t\treturn this._iDiffuseMethodVO? <DiffuseBasicMethod> this._iDiffuseMethodVO.method : null;\n\t}\n\n\tpublic set diffuseMethod(value:DiffuseBasicMethod)\n\t{\n\t\tif (this._iDiffuseMethodVO && this._iDiffuseMethodVO.method == value)\n\t\t\treturn;\n\n\t\tif (this._iDiffuseMethodVO) {\n\t\t\tthis._removeDependency(this._iDiffuseMethodVO);\n\t\t\tthis._iDiffuseMethodVO = null;\n\t\t}\n\n\t\tif (value) {\n\t\t\tthis._iDiffuseMethodVO = new MethodVO(value, this);\n\t\t\tthis._addDependency(this._iDiffuseMethodVO);\n\t\t}\n\t}\n\n\t/**\n\t * The method that provides the specular lighting contribution. Defaults to SpecularBasicMethod.\n\t */\n\tpublic get specularMethod():SpecularBasicMethod\n\t{\n\t\treturn this._iSpecularMethodVO? <SpecularBasicMethod> this._iSpecularMethodVO.method : null;\n\t}\n\n\tpublic set specularMethod(value:SpecularBasicMethod)\n\t{\n\t\tif (this._iSpecularMethodVO && this._iSpecularMethodVO.method == value)\n\t\t\treturn;\n\n\t\tif (this._iSpecularMethodVO) {\n\t\t\tthis._removeDependency(this._iSpecularMethodVO);\n\t\t\tthis._iSpecularMethodVO = null;\n\t\t}\n\n\t\tif (value) {\n\t\t\tthis._iSpecularMethodVO = new MethodVO(value, this);\n\t\t\tthis._addDependency(this._iSpecularMethodVO);\n\t\t}\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic dispose()\n\t{\n\t\tif (this._lightPicker)\n\t\t\tthis._lightPicker.removeEventListener(AssetEvent.INVALIDATE, this._onLightsChangeDelegate);\n\n\t\twhile (this._iMethodVOs.length)\n\t\t\tthis._removeDependency(this._iMethodVOs[0]);\n\n\t\tsuper.dispose();\n\n\t\tthis._iMethodVOs = null;\n\t}\n\n\t/**\n\t * Called when any method's shader code is invalidated.\n\t */\n\tprivate onMethodInvalidated(event:ShadingMethodEvent)\n\t{\n\t\tthis.invalidate();\n\t}\n\n\t// RENDER LOOP\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic _iActivate(camera:Camera)\n\t{\n\t\tsuper._iActivate(camera);\n\n\t\tvar methodVO:MethodVO;\n\t\tvar len:number = this._iMethodVOs.length;\n\t\tfor (var i:number = 0; i < len; ++i) {\n\t\t\tmethodVO = this._iMethodVOs[i];\n\t\t\tif (methodVO.useMethod)\n\t\t\t\tmethodVO.method.iActivate(this._shader, methodVO, this._stage);\n\t\t}\n\t}\n\n\t/**\n\t *\n\t *\n\t * @param renderable\n\t * @param stage\n\t * @param camera\n\t */\n\tpublic _iRender(renderable:GL_RenderableBase, camera:Camera, viewProjection:Matrix3D)\n\t{\n\t\tsuper._iRender(renderable, camera, viewProjection);\n\n\t\tvar methodVO:MethodVO;\n\t\tvar len:number = this._iMethodVOs.length;\n\t\tfor (var i:number = 0; i < len; ++i) {\n\t\t\tmethodVO = this._iMethodVOs[i];\n\t\t\tif (methodVO.useMethod)\n\t\t\t\tmethodVO.method.iSetRenderState(this._shader, methodVO, renderable, this._stage, camera);\n\t\t}\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic _iDeactivate()\n\t{\n\t\tsuper._iDeactivate();\n\n\t\tvar methodVO:MethodVO;\n\t\tvar len:number = this._iMethodVOs.length;\n\t\tfor (var i:number = 0; i < len; ++i) {\n\t\t\tmethodVO = this._iMethodVOs[i];\n\t\t\tif (methodVO.useMethod)\n\t\t\t\tmethodVO.method.iDeactivate(this._shader, methodVO, this._stage);\n\t\t}\n\t}\n\n\tpublic _iIncludeDependencies(shader:LightingShader)\n\t{\n\t\tsuper._iIncludeDependencies(shader);\n\n\t\t//TODO: fragment animtion should be compatible with lighting pass\n\t\tshader.usesFragmentAnimation = Boolean(this._mode == MethodPassMode.SUPER_SHADER);\n\n\t\tif (shader.useAlphaPremultiplied && shader.usesBlending)\n\t\t\tshader.usesCommonData = true;\n\n\t\tvar i:number;\n\t\tvar len:number = this._iMethodVOs.length;\n\t\tfor (i = 0; i < len; ++i)\n\t\t\tthis.setupAndCountDependencies(shader, this._iMethodVOs[i]);\n\n\t\tvar usesTangentSpace:boolean = true;\n\n\t\tvar methodVO:MethodVO;\n\t\tfor (i = 0; i < len; ++i) {\n\t\t\tmethodVO = this._iMethodVOs[i];\n\t\t\tif ((methodVO.useMethod = methodVO.method.iIsUsed(shader)) && !methodVO.method.iUsesTangentSpace())\n\t\t\t\tusesTangentSpace = false;\n\t\t}\n\n\t\tshader.outputsNormals = this._iNormalMethodVO && this._iNormalMethodVO.useMethod;\n\t\tshader.outputsTangentNormals = shader.outputsNormals && (<NormalBasicMethod> this._iNormalMethodVO.method).iOutputsTangentNormals();\n\t\tshader.usesTangentSpace = shader.outputsTangentNormals && !shader.usesProbes && usesTangentSpace;\n\n\t\tif (!shader.usesTangentSpace) {\n\t\t\tif (shader.viewDirDependencies > 0) {\n\t\t\t\tshader.globalPosDependencies++;\n\t\t\t} else if (this.numPointLights > 0 && shader.usesLights) {\n\t\t\t\tshader.globalPosDependencies++;\n\t\t\t\tif (Boolean(this._mode & MethodPassMode.EFFECTS))\n\t\t\t\t\tshader.usesGlobalPosFragment = true;\n\t\t\t}\n\t\t}\n\t}\n\n\n\t/**\n\t * Counts the dependencies for a given method.\n\t * @param method The method to count the dependencies for.\n\t * @param methodVO The method's data for this material.\n\t */\n\tprivate setupAndCountDependencies(shader:ShaderBase, methodVO:MethodVO)\n\t{\n\t\tmethodVO.reset();\n\n\t\tmethodVO.method.iInitVO(shader, methodVO);\n\n\t\tif (methodVO.needsProjection)\n\t\t\tshader.projectionDependencies++;\n\n\t\tif (methodVO.needsGlobalVertexPos || methodVO.needsGlobalFragmentPos) {\n\n\t\t\tshader.globalPosDependencies++;\n\n\t\t\tif (methodVO.needsGlobalFragmentPos)\n\t\t\t\tshader.usesGlobalPosFragment = true;\n\n\t\t}\n\n\t\tif (methodVO.needsNormals)\n\t\t\tshader.normalDependencies++;\n\n\t\tif (methodVO.needsTangents)\n\t\t\tshader.tangentDependencies++;\n\n\t\tif (methodVO.needsView)\n\t\t\tshader.viewDirDependencies++;\n\t}\n\n\tpublic _iGetPreLightingVertexCode(shader:ShaderBase, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = \"\";\n\n\t\tif (this._iAmbientMethodVO && this._iAmbientMethodVO.useMethod)\n\t\t\tcode += this._iAmbientMethodVO.method.iGetVertexCode(shader, this._iAmbientMethodVO, registerCache, sharedRegisters);\n\n\t\tif (this._iDiffuseMethodVO && this._iDiffuseMethodVO.useMethod)\n\t\t\tcode += this._iDiffuseMethodVO.method.iGetVertexCode(shader, this._iDiffuseMethodVO, registerCache, sharedRegisters);\n\n\t\tif (this._iSpecularMethodVO && this._iSpecularMethodVO.useMethod)\n\t\t\tcode += this._iSpecularMethodVO.method.iGetVertexCode(shader, this._iSpecularMethodVO, registerCache, sharedRegisters);\n\n\t\treturn code;\n\t}\n\n\tpublic _iGetPreLightingFragmentCode(shader:ShaderBase, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = \"\";\n\n\t\tif (this._iAmbientMethodVO && this._iAmbientMethodVO.useMethod) {\n\t\t\tcode += this._iAmbientMethodVO.method.iGetFragmentCode(shader, this._iAmbientMethodVO, sharedRegisters.shadedTarget, registerCache, sharedRegisters);\n\n\t\t\tif (this._iAmbientMethodVO.needsNormals)\n\t\t\t\tregisterCache.removeFragmentTempUsage(sharedRegisters.normalFragment);\n\n\t\t\tif (this._iAmbientMethodVO.needsView)\n\t\t\t\tregisterCache.removeFragmentTempUsage(sharedRegisters.viewDirFragment);\n\t\t}\n\n\t\tif (this._iDiffuseMethodVO && this._iDiffuseMethodVO.useMethod)\n\t\t\tcode += (<LightingMethodBase> this._iDiffuseMethodVO.method).iGetFragmentPreLightingCode(<LightingShader> shader, this._iDiffuseMethodVO, registerCache, sharedRegisters);\n\n\t\tif (this._iSpecularMethodVO && this._iSpecularMethodVO.useMethod)\n\t\t\tcode += (<LightingMethodBase> this._iSpecularMethodVO.method).iGetFragmentPreLightingCode(<LightingShader> shader, this._iSpecularMethodVO, registerCache, sharedRegisters);\n\n\t\treturn code;\n\t}\n\n\tpublic _iGetPerLightDiffuseFragmentCode(shader:LightingShader, lightDirReg:ShaderRegisterElement, diffuseColorReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\treturn (<LightingMethodBase> this._iDiffuseMethodVO.method).iGetFragmentCodePerLight(shader, this._iDiffuseMethodVO, lightDirReg, diffuseColorReg, registerCache, sharedRegisters);\n\t}\n\n\tpublic _iGetPerLightSpecularFragmentCode(shader:LightingShader, lightDirReg:ShaderRegisterElement, specularColorReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\treturn (<LightingMethodBase> this._iSpecularMethodVO.method).iGetFragmentCodePerLight(shader, this._iSpecularMethodVO, lightDirReg, specularColorReg, registerCache, sharedRegisters);\n\t}\n\n\tpublic _iGetPerProbeDiffuseFragmentCode(shader:LightingShader, texReg:ShaderRegisterElement, weightReg:string, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\treturn (<LightingMethodBase> this._iDiffuseMethodVO.method).iGetFragmentCodePerProbe(shader, this._iDiffuseMethodVO, texReg, weightReg, registerCache, sharedRegisters);\n\t}\n\n\tpublic _iGetPerProbeSpecularFragmentCode(shader:LightingShader, texReg:ShaderRegisterElement, weightReg:string, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\treturn (<LightingMethodBase> this._iSpecularMethodVO.method).iGetFragmentCodePerProbe(shader, this._iSpecularMethodVO, texReg, weightReg, registerCache, sharedRegisters);\n\t}\n\n\tpublic _iGetPostLightingVertexCode(shader:LightingShader, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = \"\";\n\n\t\tif (this._iShadowMethodVO)\n\t\t\tcode += this._iShadowMethodVO.method.iGetVertexCode(shader, this._iShadowMethodVO, registerCache, sharedRegisters);\n\n\t\treturn code;\n\t}\n\n\tpublic _iGetPostLightingFragmentCode(shader:LightingShader, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = \"\";\n\n\t\tif (shader.useAlphaPremultiplied && shader.usesBlending) {\n\t\t\tcode += \"add \" + sharedRegisters.shadedTarget + \".w, \" + sharedRegisters.shadedTarget + \".w, \" + sharedRegisters.commons + \".z\\n\" +\n\t\t\t\"div \" + sharedRegisters.shadedTarget + \".xyz, \" + sharedRegisters.shadedTarget + \", \" + sharedRegisters.shadedTarget + \".w\\n\" +\n\t\t\t\"sub \" + sharedRegisters.shadedTarget + \".w, \" + sharedRegisters.shadedTarget + \".w, \" + sharedRegisters.commons + \".z\\n\" +\n\t\t\t\"sat \" + sharedRegisters.shadedTarget + \".xyz, \" + sharedRegisters.shadedTarget + \"\\n\";\n\t\t}\n\n\t\tif (this._iShadowMethodVO)\n\t\t\tcode += this._iShadowMethodVO.method.iGetFragmentCode(shader, this._iShadowMethodVO, sharedRegisters.shadowTarget, registerCache, sharedRegisters);\n\n\t\tif (this._iDiffuseMethodVO && this._iDiffuseMethodVO.useMethod) {\n\t\t\tcode += (<LightingMethodBase> this._iDiffuseMethodVO.method).iGetFragmentPostLightingCode(shader, this._iDiffuseMethodVO, sharedRegisters.shadedTarget, registerCache, sharedRegisters);\n\n\t\t\t// resolve other dependencies as well?\n\t\t\tif (this._iDiffuseMethodVO.needsNormals)\n\t\t\t\tregisterCache.removeFragmentTempUsage(sharedRegisters.normalFragment);\n\n\t\t\tif (this._iDiffuseMethodVO.needsView)\n\t\t\t\tregisterCache.removeFragmentTempUsage(sharedRegisters.viewDirFragment);\n\t\t}\n\n\t\tif (this._iSpecularMethodVO && this._iSpecularMethodVO.useMethod) {\n\t\t\tcode += (<LightingMethodBase> this._iSpecularMethodVO.method).iGetFragmentPostLightingCode(shader, this._iSpecularMethodVO, sharedRegisters.shadedTarget, registerCache, sharedRegisters);\n\t\t\tif (this._iSpecularMethodVO.needsNormals)\n\t\t\t\tregisterCache.removeFragmentTempUsage(sharedRegisters.normalFragment);\n\t\t\tif (this._iSpecularMethodVO.needsView)\n\t\t\t\tregisterCache.removeFragmentTempUsage(sharedRegisters.viewDirFragment);\n\t\t}\n\n\t\tif (this._iShadowMethodVO)\n\t\t\tregisterCache.removeFragmentTempUsage(sharedRegisters.shadowTarget);\n\n\t\treturn code;\n\t}\n\n\n\tpublic _iGetNormalVertexCode(shader:ShaderBase, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\treturn this._iNormalMethodVO.method.iGetVertexCode(shader, this._iNormalMethodVO, registerCache, sharedRegisters);\n\t}\n\n\tpublic _iGetNormalFragmentCode(shader:ShaderBase, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = this._iNormalMethodVO.method.iGetFragmentCode(shader, this._iNormalMethodVO, sharedRegisters.normalFragment, registerCache, sharedRegisters);\n\n\t\tif (this._iNormalMethodVO.needsView)\n\t\t\tregisterCache.removeFragmentTempUsage(sharedRegisters.viewDirFragment);\n\n\t\tif (this._iNormalMethodVO.needsGlobalFragmentPos || this._iNormalMethodVO.needsGlobalVertexPos)\n\t\t\tregisterCache.removeVertexTempUsage(sharedRegisters.globalPositionVertex);\n\n\t\treturn code;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic _iGetVertexCode(shader:ShaderBase, regCache:ShaderRegisterCache, sharedReg:ShaderRegisterData):string\n\t{\n\t\tvar code:string = \"\";\n\t\tvar methodVO:MethodVO;\n\t\tvar len:number = this._iMethodVOs.length;\n\t\tfor (var i:number = len - this._numEffectDependencies; i < len; i++) {\n\t\t\tmethodVO = this._iMethodVOs[i];\n\t\t\tif (methodVO.useMethod) {\n\t\t\t\tcode += methodVO.method.iGetVertexCode(shader, methodVO, regCache, sharedReg);\n\n\t\t\t\tif (methodVO.needsGlobalVertexPos || methodVO.needsGlobalFragmentPos)\n\t\t\t\t\tregCache.removeVertexTempUsage(sharedReg.globalPositionVertex);\n\t\t\t}\n\t\t}\n\n\t\tif (this._iColorTransformMethodVO && this._iColorTransformMethodVO.useMethod)\n\t\t\tcode += this._iColorTransformMethodVO.method.iGetVertexCode(shader, this._iColorTransformMethodVO, regCache, sharedReg);\n\n\t\treturn code;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic _iGetFragmentCode(shader:ShaderBase, regCache:ShaderRegisterCache, sharedReg:ShaderRegisterData):string\n\t{\n\t\tvar code:string = \"\";\n\t\tvar alphaReg:ShaderRegisterElement;\n\n\t\tif (this.preserveAlpha && this._numEffectDependencies > 0) {\n\t\t\talphaReg = regCache.getFreeFragmentSingleTemp();\n\t\t\tregCache.addFragmentTempUsages(alphaReg, 1);\n\t\t\tcode += \"mov \" + alphaReg + \", \" + sharedReg.shadedTarget + \".w\\n\";\n\t\t}\n\n\t\tvar methodVO:MethodVO;\n\t\tvar len:number = this._iMethodVOs.length;\n\t\tfor (var i:number = len - this._numEffectDependencies; i < len; i++) {\n\t\t\tmethodVO = this._iMethodVOs[i];\n\t\t\tif (methodVO.useMethod) {\n\t\t\t\tcode += methodVO.method.iGetFragmentCode(shader, methodVO, sharedReg.shadedTarget, regCache, sharedReg);\n\n\t\t\t\tif (methodVO.needsNormals)\n\t\t\t\t\tregCache.removeFragmentTempUsage(sharedReg.normalFragment);\n\n\t\t\t\tif (methodVO.needsView)\n\t\t\t\t\tregCache.removeFragmentTempUsage(sharedReg.viewDirFragment);\n\n\t\t\t}\n\t\t}\n\n\t\tif (this.preserveAlpha && this._numEffectDependencies > 0) {\n\t\t\tcode += \"mov \" + sharedReg.shadedTarget + \".w, \" + alphaReg + \"\\n\";\n\t\t\tregCache.removeFragmentTempUsage(alphaReg);\n\t\t}\n\n\t\tif (this._iColorTransformMethodVO && this._iColorTransformMethodVO.useMethod)\n\t\t\tcode += this._iColorTransformMethodVO.method.iGetFragmentCode(shader, this._iColorTransformMethodVO, sharedReg.shadedTarget, regCache, sharedReg);\n\n\t\treturn code;\n\t}\n\t/**\n\t * Indicates whether the shader uses any shadows.\n\t */\n\tpublic _iUsesShadows(shader:ShaderBase):boolean\n\t{\n\t\treturn Boolean(this._iShadowMethodVO && (this._lightPicker.castingDirectionalLights.length > 0 || this._lightPicker.castingPointLights.length > 0));\n\t}\n\n\t/**\n\t * Indicates whether the shader uses any specular component.\n\t */\n\tpublic _iUsesSpecular(shader:ShaderBase):boolean\n\t{\n\t\treturn Boolean(this._iSpecularMethodVO);\n\t}\n\n\t/**\n\t * Indicates whether the shader uses any specular component.\n\t */\n\tpublic _iUsesDiffuse(shader:ShaderBase):boolean\n\t{\n\t\treturn Boolean(this._iDiffuseMethodVO);\n\t}\n\n\n\tprivate onLightsChange(event:AssetEvent)\n\t{\n\t\tthis._updateLights();\n\t}\n\n\tprivate _updateLights()\n\t{\n\t\tvar numDirectionalLightsOld:number = this.numDirectionalLights;\n\t\tvar numPointLightsOld:number = this.numPointLights;\n\t\tvar numLightProbesOld:number = this.numLightProbes;\n\n\t\tif (this._lightPicker && (this._mode & MethodPassMode.LIGHTING)) {\n\t\t\tthis.numDirectionalLights = this.calculateNumDirectionalLights(this._lightPicker.numDirectionalLights);\n\t\t\tthis.numPointLights = this.calculateNumPointLights(this._lightPicker.numPointLights);\n\t\t\tthis.numLightProbes = this.calculateNumProbes(this._lightPicker.numLightProbes);\n\n\t\t\tif (this._includeCasters) {\n\t\t\t\tthis.numDirectionalLights += this._lightPicker.numCastingDirectionalLights;\n\t\t\t\tthis.numPointLights += this._lightPicker.numCastingPointLights;\n\t\t\t}\n\n\t\t} else {\n\t\t\tthis.numDirectionalLights = 0;\n\t\t\tthis.numPointLights = 0;\n\t\t\tthis.numLightProbes = 0;\n\t\t}\n\n\t\tif (numDirectionalLightsOld != this.numDirectionalLights || numPointLightsOld != this.numPointLights || numLightProbesOld != this.numLightProbes) {\n\t\t\tthis._updateShader();\n\n\t\t\tthis.invalidate();\n\t\t}\n\t}\n\n\t/**\n\t * Calculates the amount of directional lights this material will support.\n\t * @param numDirectionalLights The maximum amount of directional lights to support.\n\t * @return The amount of directional lights this material will support, bounded by the amount necessary.\n\t */\n\tprivate calculateNumDirectionalLights(numDirectionalLights:number):number\n\t{\n\t\treturn Math.min(numDirectionalLights - this.directionalLightsOffset, this._maxLights);\n\t}\n\n\t/**\n\t * Calculates the amount of point lights this material will support.\n\t * @param numDirectionalLights The maximum amount of point lights to support.\n\t * @return The amount of point lights this material will support, bounded by the amount necessary.\n\t */\n\tprivate calculateNumPointLights(numPointLights:number):number\n\t{\n\t\tvar numFree:number = this._maxLights - this.numDirectionalLights;\n\t\treturn Math.min(numPointLights - this.pointLightsOffset, numFree);\n\t}\n\n\t/**\n\t * Calculates the amount of light probes this material will support.\n\t * @param numDirectionalLights The maximum amount of light probes to support.\n\t * @return The amount of light probes this material will support, bounded by the amount necessary.\n\t */\n\tprivate calculateNumProbes(numLightProbes:number):number\n\t{\n\t\tvar numChannels:number = 0;\n\n\t\tif ((this.specularLightSources & LightSources.PROBES) != 0)\n\t\t\t++numChannels;\n\n\t\tif ((this.diffuseLightSources & LightSources.PROBES) != 0)\n\t\t\t++numChannels;\n\n\t\t// 4 channels available\n\t\treturn Math.min(numLightProbes - this.lightProbesOffset, (4/numChannels) | 0);\n\t}\n}\n\nexport default MethodPass;",
    "import Image2D\t\t\t\t\t\t\tfrom \"awayjs-core/lib/image/Image2D\";\nimport Matrix3D\t\t\t\t\t\t\tfrom \"awayjs-core/lib/geom/Matrix3D\";\n\nimport LightBase\t\t\t\t\t\tfrom \"awayjs-display/lib/display/LightBase\";\nimport Camera\t\t\t\t\t\t\tfrom \"awayjs-display/lib/display/Camera\";\nimport MaterialBase\t\t\t\t\t\tfrom \"awayjs-display/lib/materials/MaterialBase\";\nimport ISurface\t\t\t\t\t\t\tfrom \"awayjs-display/lib/base/ISurface\";\nimport Single2DTexture\t\t\t\t\tfrom \"awayjs-display/lib/textures/Single2DTexture\";\nimport TextureBase\t\t\t\t\t\tfrom \"awayjs-display/lib/textures/TextureBase\";\nimport TriangleElements\t\t\t\t\tfrom \"awayjs-display/lib/graphics/TriangleElements\";\n\nimport ContextGLDrawMode\t\t\t\tfrom \"awayjs-stagegl/lib/base/ContextGLDrawMode\";\nimport ContextGLProgramType\t\t\t\tfrom \"awayjs-stagegl/lib/base/ContextGLProgramType\";\nimport IContextGL\t\t\t\t\t\tfrom \"awayjs-stagegl/lib/base/IContextGL\";\nimport Stage\t\t\t\t\t\t\tfrom \"awayjs-stagegl/lib/base/Stage\";\n\nimport RendererBase\t\t\t\t\t\tfrom \"awayjs-renderergl/lib/RendererBase\";\nimport ShaderBase\t\t\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderBase\";\nimport ShaderRegisterCache\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterCache\";\nimport ShaderRegisterData\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterData\";\nimport PassBase\t\t\t\t\t\t\tfrom \"awayjs-renderergl/lib/surfaces/passes/PassBase\";\nimport IElementsClassGL\t\t\t\t\tfrom \"awayjs-renderergl/lib/elements/IElementsClassGL\";\nimport GL_RenderableBase\t\t\t\tfrom \"awayjs-renderergl/lib/renderables/GL_RenderableBase\";\nimport GL_SurfaceBase\t\t\t\t\tfrom \"awayjs-renderergl/lib/surfaces/GL_SurfaceBase\";\nimport GL_ElementsBase\t\t\t\t\tfrom \"awayjs-renderergl/lib/elements/GL_ElementsBase\";\n\n/**\n * The SingleObjectDepthPass provides a material pass that renders a single object to a depth map from the point\n * of view from a light.\n */\nclass SingleObjectDepthPass extends PassBase\n{\n\tprivate _textures:Object;\n\tprivate _projections:Object;\n\tprivate _textureSize:number /*uint*/ = 512;\n\tprivate _polyOffset:Float32Array = new Float32Array([15, 0, 0, 0]);\n\tprivate _enc:Float32Array;\n\tprivate _projectionTexturesInvalid:Boolean = true;\n\n\t/**\n\t * The size of the depth map texture to render to.\n\t */\n\tpublic get textureSize():number\n\t{\n\t\treturn this._textureSize;\n\t}\n\n\tpublic set textureSize(value:number)\n\t{\n\t\tthis._textureSize = value;\n\t}\n\n\t/**\n\t * The amount by which the rendered object will be inflated, to prevent depth map rounding errors.\n\t */\n\tpublic get polyOffset():number\n\t{\n\t\treturn this._polyOffset[0];\n\t}\n\n\tpublic set polyOffset(value:number)\n\t{\n\t\tthis._polyOffset[0] = value;\n\t}\n\n\t/**\n\t * Creates a new SingleObjectDepthPass object.\n\t */\n\tconstructor(render:GL_SurfaceBase, renderOwner:ISurface, elementsClass:IElementsClassGL, stage:Stage)\n\t{\n\t\tsuper(render, renderOwner, elementsClass, stage);\n\n\t\t//this._pNumUsedStreams = 2;\n\t\t//this._pNumUsedVertexConstants = 7;\n\t\t//this._enc = Array<number>(1.0, 255.0, 65025.0, 16581375.0, 1.0/255.0, 1.0/255.0, 1.0/255.0, 0.0);\n\t\t//\n\t\t//this._pAnimatableAttributes = Array<string>(\"va0\", \"va1\";\n\t\t//this._pAnimationTargetRegisters = Array<string>(\"vt0\", \"vt1\";\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic dispose()\n\t{\n\t\tif (this._textures) {\n\t\t\tfor (var key in this._textures) {\n\t\t\t\tvar texture:TextureBase = this._textures[key];\n\t\t\t\ttexture.dispose();\n\t\t\t}\n\t\t\tthis._textures = null;\n\t\t}\n\t}\n\n\t/**\n\t * Updates the projection textures used to contain the depth renders.\n\t */\n\tprivate updateProjectionTextures()\n\t{\n\t\tif (this._textures) {\n\t\t\tfor (var key in this._textures) {\n\t\t\t\tvar texture:TextureBase = this._textures[key];\n\t\t\t\ttexture.dispose();\n\t\t\t}\n\t\t}\n\n\t\tthis._textures = new Object();\n\t\tthis._projections = new Object();\n\t\tthis._projectionTexturesInvalid = false;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic _iGetVertexCode():string\n\t{\n\t\tvar code:string;\n\t\t// offset\n\t\tcode = \"mul vt7, vt1, vc4.x\t\\n\" +\n\t\t\t\t\"add vt7, vt7, vt0\\n\" +\n\t\t\t\t\"mov vt7.w, vt0.w\\n\";\n\t\t// project\n\t\tcode += \"m44 vt2, vt7, vc0\\n\" +\n\t\t\t\t\"mov op, vt2\\n\";\n\n\t\t// perspective divide\n\t\tcode += \"div v0, vt2, vt2.w\\n\";\n\n\t\treturn code;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic _iGetFragmentCode(shader:ShaderBase, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = \"\";\n\n\t\t// encode float -> rgba\n\t\tcode += \"mul ft0, fc0, v0.z\\n\" +\n\t\t\t\t\"frc ft0, ft0\\n\" +\n\t\t\t\t\"mul ft1, ft0.yzww, fc1\\n\" +\n\t\t\t\t\"sub ft0, ft0, ft1\\n\" +\n\t\t\t\t\"mov oc, ft0\\n\";\n\n\t\treturn code;\n\t}\n\n\t/**\n\t * Gets the depth maps rendered for this object from all lights.\n\t * @param renderableGL The renderableGL for which to retrieve the depth maps.\n\t * @param stage3DProxy The Stage3DProxy object currently used for rendering.\n\t * @return A list of depth map textures for all supported lights.\n\t */\n\tpublic _iGetDepthMap(renderableGL:GL_RenderableBase):TextureBase\n\t{\n\t\treturn this._textures[renderableGL.renderable.id];\n\t}\n\n\t/**\n\t * Retrieves the depth map projection maps for all lights.\n\t * @param renderableGL The renderableGL for which to retrieve the projection maps.\n\t * @return A list of projection maps for all supported lights.\n\t */\n\tpublic _iGetProjection(renderableGL:GL_RenderableBase):Matrix3D\n\t{\n\t\treturn this._projections[renderableGL.renderable.id];\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic _iRender(renderableGL:GL_RenderableBase, camera:Camera, viewProjection:Matrix3D)\n\t{\n\t\tvar matrix:Matrix3D;\n\t\tvar context:IContextGL = this._stage.context;\n\t\tvar len:number /*uint*/;\n\t\tvar light:LightBase;\n\t\tvar lights:Array<LightBase> = this._surface.lightPicker.allPickedLights;\n\t\tvar rId:number = renderableGL.renderable.id;\n\n\t\tif (!this._textures[rId])\n\t\t\tthis._textures[rId] = new Single2DTexture(new Image2D(this._textureSize, this._textureSize));\n\n\t\tif (!this._projections[rId])\n\t\t\tthis._projections[rId] = new Matrix3D();\n\n\t\tlen = lights.length;\n\n\t\t// local position = enough\n\t\tlight = lights[0];\n\n\t\tmatrix = light.iGetObjectProjectionMatrix(renderableGL.sourceEntity, camera.sceneTransform, this._projections[rId]);\n\n\t\tthis._stage.setRenderTarget(this._textures[rId], true);\n\t\tcontext.clear(1.0, 1.0, 1.0);\n\t\t//context.setProgramConstantsFromMatrix(ContextGLProgramType.VERTEX, 0, matrix, true);\n\t\t//context.setProgramConstantsFromArray(ContextGLProgramType.FRAGMENT, 0, this._enc, 2);\n\n\t\tvar elements:TriangleElements = <TriangleElements> renderableGL.elements;\n\t\tvar elementsGL:GL_ElementsBase = this._shader._elementsPool.getAbstraction(elements);\n\n\t\telementsGL.activateVertexBufferVO(0, elements.positions);\n\t\telementsGL.activateVertexBufferVO(1, elements.normals);\n\t\telementsGL.getIndexBufferGL().draw(ContextGLDrawMode.TRIANGLES, 0, elements.numElements);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic _iActivate(camera:Camera)\n\t{\n\t\tif (this._projectionTexturesInvalid)\n\t\t\tthis.updateProjectionTextures();\n\n\t\t// never scale\n\t\tsuper._iActivate(camera);\n\n\t\t//this._stage.context.setProgramConstantsFromArray(ContextGLProgramType.VERTEX, 4, this._polyOffset, 1);\n\t}\n}\n\nexport default SingleObjectDepthPass;",
    "export {default as MethodPass}\t\t\t\t\t\tfrom \"./surfaces/passes/MethodPass\";\nexport {default as MethodPassMode}\t\t\t\t\tfrom \"./surfaces/passes/MethodPassMode\";\nexport {default as SingleObjectDepthPass}\t\t\tfrom \"./surfaces/passes/SingleObjectDepthPass\";\nexport {default as GL_MethodMaterialSurface}\t\tfrom \"./surfaces/GL_MethodMaterialSurface\";"
  ],
  "sourceRoot": ""
}