{
  "version": 3,
  "sources": [
    "node_modules/browserify/node_modules/browser-pack/_prelude.js",
    "awayjs-methodmaterials/lib/MethodMaterialMode.ts",
    "awayjs-methodmaterials.js",
    "awayjs-methodmaterials/lib/MethodMaterial.ts",
    "awayjs-methodmaterials/lib/data/MethodVO.ts",
    "awayjs-methodmaterials/lib/methods/AmbientBasicMethod.ts",
    "awayjs-methodmaterials/lib/methods/AmbientEnvMapMethod.ts",
    "awayjs-methodmaterials/lib/methods/CurveBasicMethod.ts",
    "awayjs-methodmaterials/lib/methods/DiffuseBasicMethod.ts",
    "awayjs-methodmaterials/lib/methods/DiffuseCelMethod.ts",
    "awayjs-methodmaterials/lib/methods/DiffuseCompositeMethod.ts",
    "awayjs-methodmaterials/lib/methods/DiffuseDepthMethod.ts",
    "awayjs-methodmaterials/lib/methods/DiffuseGradientMethod.ts",
    "awayjs-methodmaterials/lib/methods/DiffuseLightMapMethod.ts",
    "awayjs-methodmaterials/lib/methods/DiffuseSubSurfaceMethod.ts",
    "awayjs-methodmaterials/lib/methods/DiffuseWrapMethod.ts",
    "awayjs-methodmaterials/lib/methods/EffectAlphaMaskMethod.ts",
    "awayjs-methodmaterials/lib/methods/EffectColorMatrixMethod.ts",
    "awayjs-methodmaterials/lib/methods/EffectColorTransformMethod.ts",
    "awayjs-methodmaterials/lib/methods/EffectEnvMapMethod.ts",
    "awayjs-methodmaterials/lib/methods/EffectFogMethod.ts",
    "awayjs-methodmaterials/lib/methods/EffectFresnelEnvMapMethod.ts",
    "awayjs-methodmaterials/lib/methods/EffectLightMapMethod.ts",
    "awayjs-methodmaterials/lib/methods/EffectMethodBase.ts",
    "awayjs-methodmaterials/lib/methods/EffectRefractionEnvMapMethod.ts",
    "awayjs-methodmaterials/lib/methods/EffectRimLightMethod.ts",
    "awayjs-methodmaterials/lib/methods/LightingMethodBase.ts",
    "awayjs-methodmaterials/lib/methods/NormalBasicMethod.ts",
    "awayjs-methodmaterials/lib/methods/NormalHeightMapMethod.ts",
    "awayjs-methodmaterials/lib/methods/NormalSimpleWaterMethod.ts",
    "awayjs-methodmaterials/lib/methods/ShadingMethodBase.ts",
    "awayjs-methodmaterials/lib/methods/ShadowCascadeMethod.ts",
    "awayjs-methodmaterials/lib/methods/ShadowDitheredMethod.ts",
    "awayjs-methodmaterials/lib/methods/ShadowFilteredMethod.ts",
    "awayjs-methodmaterials/lib/methods/ShadowHardMethod.ts",
    "awayjs-methodmaterials/lib/methods/ShadowMapMethodBase.ts",
    "awayjs-methodmaterials/lib/methods/ShadowMethodBase.ts",
    "awayjs-methodmaterials/lib/methods/ShadowNearMethod.ts",
    "awayjs-methodmaterials/lib/methods/ShadowSoftMethod.ts",
    "awayjs-methodmaterials/lib/methods/SpecularAnisotropicMethod.ts",
    "awayjs-methodmaterials/lib/methods/SpecularBasicMethod.ts",
    "awayjs-methodmaterials/lib/methods/SpecularCelMethod.ts",
    "awayjs-methodmaterials/lib/methods/SpecularCompositeMethod.ts",
    "awayjs-methodmaterials/lib/methods/SpecularFresnelMethod.ts",
    "awayjs-methodmaterials/lib/methods/SpecularPhongMethod.ts",
    "awayjs-methodmaterials/lib/render/MethodMaterialRender.ts",
    "awayjs-methodmaterials/lib/render/passes/MethodPassMode.ts",
    "awayjs-methodmaterials/lib/render/passes/MethodPass.ts",
    "awayjs-methodmaterials/lib/render/passes/SingleObjectDepthPass.ts"
  ],
  "names": [
    "require",
    "e",
    "t",
    "n",
    "r",
    "s",
    "o",
    "u",
    "a",
    "i",
    "f",
    "Error",
    "code",
    "l",
    "exports",
    "call",
    "length",
    "awayjs-methodmaterials/lib/MethodMaterialMode",
    "module",
    "MethodMaterialMode",
    "SINGLE_PASS",
    "MULTI_PASS",
    "awayjs-methodmaterials/lib/MethodMaterial",
    "__extends",
    "this",
    "d",
    "b",
    "p",
    "hasOwnProperty",
    "__",
    "constructor",
    "prototype",
    "Image2D",
    "MaterialBase",
    "Single2DTexture",
    "TextureBase",
    "ContextGLCompareMode",
    "RenderPool",
    "AmbientBasicMethod",
    "DiffuseBasicMethod",
    "NormalBasicMethod",
    "SpecularBasicMethod",
    "MethodMaterialRender",
    "MethodMaterial",
    "_super",
    "textureColor",
    "smoothAlpha",
    "repeat",
    "mipmap",
    "_effectMethods",
    "Array",
    "_ambientMethod",
    "_diffuseMethod",
    "_normalMethod",
    "_specularMethod",
    "_depthCompareMode",
    "LESS_EQUAL",
    "_mode",
    "texture",
    "smooth",
    "color",
    "Number",
    "alpha",
    "addRenderable",
    "registerClass",
    "Object",
    "defineProperty",
    "get",
    "assetType",
    "enumerable",
    "configurable",
    "set",
    "value",
    "_pInvalidateRender",
    "copyFrom",
    "_shadowMethod",
    "addEffectMethod",
    "method",
    "push",
    "getEffectMethodAt",
    "index",
    "addEffectMethodAt",
    "splice",
    "removeEffectMethod",
    "indexOf",
    "normalMap",
    "gloss",
    "ambient",
    "specular",
    "ambientColor",
    "diffuseColor",
    "specularColor",
    "register",
    "awayjs-core/lib/data/Image2D",
    "undefined",
    "awayjs-display/lib/materials/MaterialBase",
    "awayjs-display/lib/textures/Single2DTexture",
    "awayjs-display/lib/textures/TextureBase",
    "awayjs-methodmaterials/lib/methods/AmbientBasicMethod",
    "awayjs-methodmaterials/lib/methods/DiffuseBasicMethod",
    "awayjs-methodmaterials/lib/methods/NormalBasicMethod",
    "awayjs-methodmaterials/lib/methods/SpecularBasicMethod",
    "awayjs-methodmaterials/lib/render/MethodMaterialRender",
    "awayjs-renderergl/lib/render/RenderPool",
    "awayjs-stagegl/lib/base/ContextGLCompareMode",
    "awayjs-methodmaterials/lib/data/MethodVO",
    "MethodVO",
    "useMethod",
    "reset",
    "iReset",
    "vertexConstantsIndex",
    "secondaryVertexConstantsIndex",
    "fragmentConstantsIndex",
    "secondaryFragmentConstantsIndex",
    "needsProjection",
    "needsView",
    "needsNormals",
    "needsTangents",
    "needsGlobalVertexPos",
    "needsGlobalFragmentPos",
    "ShadingMethodBase",
    "_color",
    "_alpha",
    "_colorR",
    "_colorG",
    "_colorB",
    "_ambient",
    "iInitVO",
    "shader",
    "methodVO",
    "uvDependencies",
    "iInitConstants",
    "updateColor",
    "m",
    "iGetFragmentCode",
    "targetReg",
    "registerCache",
    "sharedRegisters",
    "_iInitRegisters",
    "_iGetFragmentCode",
    "uvVarying",
    "alphaThreshold",
    "cutOffReg",
    "getFreeFragmentConstant",
    "ambientInputRegister",
    "iActivate",
    "stage",
    "activate",
    "fragmentConstantData",
    "data",
    "awayjs-methodmaterials/lib/methods/ShadingMethodBase",
    "awayjs-methodmaterials/lib/methods/AmbientEnvMapMethod",
    "AmbientEnvMapMethod",
    "regCache",
    "normalFragment",
    "awayjs-methodmaterials/lib/methods/CurveBasicMethod",
    "CurveBasicMethod",
    "LightingMethodBase",
    "_multiply",
    "_diffuseColor",
    "_ambientColor",
    "_diffuseR",
    "_diffuseG",
    "_diffuseB",
    "_ambientR",
    "_ambientG",
    "_ambientB",
    "iIsUsed",
    "numLights",
    "iInvalidateShaderProgram",
    "_texture",
    "textureVO",
    "getTextureVO",
    "dispose",
    "usesCommonData",
    "updateDiffuse",
    "updateAmbient",
    "diff",
    "multiply",
    "iCleanCompilationData",
    "_pTotalLightColorReg",
    "iGetFragmentPreLightingCode",
    "_pIsFirstLight",
    "addFragmentTempUsages",
    "getFreeFragmentVectorTemp",
    "iGetFragmentCodePerLight",
    "lightDirReg",
    "lightColReg",
    "commons",
    "usesLightFallOff",
    "_iModulateMethod",
    "removeFragmentTempUsage",
    "iGetFragmentCodePerProbe",
    "cubeMapReg",
    "weightRegister",
    "iGetFragmentPostLightingCode",
    "albedo",
    "shadowTarget",
    "pApplyShadow",
    "ambientColorRegister",
    "diffuseInputRegister",
    "iSetRenderState",
    "renderable",
    "camera",
    "ambientR",
    "ambientG",
    "ambientB",
    "awayjs-methodmaterials/lib/methods/LightingMethodBase",
    "awayjs-methodmaterials/lib/methods/DiffuseCelMethod",
    "DiffuseCompositeMethod",
    "DiffuseCelMethod",
    "levels",
    "baseMethod",
    "_this",
    "_smoothness",
    "clampDiffuse",
    "_levels",
    "_dataReg",
    "awayjs-methodmaterials/lib/methods/DiffuseCompositeMethod",
    "ShadingMethodEvent",
    "modulateMethod",
    "_onShaderInvalidatedDelegate",
    "event",
    "onShaderInvalidated",
    "pBaseMethod",
    "addEventListener",
    "SHADER_INVALIDATED",
    "removeEventListener",
    "iDeactivate",
    "iGetVertexCode",
    "awayjs-renderergl/lib/events/ShadingMethodEvent",
    "awayjs-methodmaterials/lib/methods/DiffuseDepthMethod",
    "DiffuseDepthMethod",
    "temp",
    "decReg",
    "awayjs-methodmaterials/lib/methods/DiffuseGradientMethod",
    "DiffuseGradientMethod",
    "gradient",
    "_gradient",
    "secondaryTextureVO",
    "awayjs-methodmaterials/lib/methods/DiffuseLightMapMethod",
    "DiffuseLightMapMethod",
    "lightMap",
    "blendMode",
    "useSecondaryUV",
    "_useSecondaryUV",
    "_lightMap",
    "secondaryUVDependencies",
    "_blendMode",
    "ADD",
    "MULTIPLY",
    "secondaryUVVarying",
    "awayjs-methodmaterials/lib/methods/DiffuseSubSurfaceMethod",
    "DiffuseSubSurfaceMethod",
    "depthMapSize",
    "depthMapOffset",
    "_translucency",
    "_scatterColor",
    "_scatterR",
    "_scatterG",
    "_scatterB",
    "scatterLight",
    "_scattering",
    "vertexConstantData",
    "_lightProjVarying",
    "_propReg",
    "_lightColorReg",
    "_colorReg",
    "_decReg",
    "_targetReg",
    "scatterColor",
    "lightProjection",
    "toTexRegister",
    "getFreeVertexVectorTemp",
    "getFreeVertexConstant",
    "getFreeVarying",
    "viewDirFragment",
    "_depthPass",
    "_iGetDepthMap",
    "_iGetProjection",
    "copyRawDataTo",
    "awayjs-methodmaterials/lib/methods/DiffuseWrapMethod",
    "DiffuseWrapMethod",
    "wrapFactor",
    "_wrapDataRegister",
    "_wrapFactor",
    "awayjs-methodmaterials/lib/methods/EffectAlphaMaskMethod",
    "EffectMethodBase",
    "EffectAlphaMaskMethod",
    "awayjs-methodmaterials/lib/methods/EffectMethodBase",
    "awayjs-methodmaterials/lib/methods/EffectColorMatrixMethod",
    "EffectColorMatrixMethod",
    "matrix",
    "_matrix",
    "colorMultReg",
    "colorOffsetReg",
    "awayjs-methodmaterials/lib/methods/EffectColorTransformMethod",
    "EffectColorTransformMethod",
    "_colorTransform",
    "colorOffsReg",
    "inv",
    "redMultiplier",
    "greenMultiplier",
    "blueMultiplier",
    "alphaMultiplier",
    "redOffset",
    "greenOffset",
    "blueOffset",
    "alphaOffset",
    "awayjs-methodmaterials/lib/methods/EffectEnvMapMethod",
    "EffectEnvMapMethod",
    "envMap",
    "_envMap",
    "_mask",
    "dataRegister",
    "temp2",
    "awayjs-methodmaterials/lib/methods/EffectFogMethod",
    "EffectFogMethod",
    "minDistance",
    "maxDistance",
    "fogColor",
    "_minDistance",
    "_maxDistance",
    "_fogColor",
    "_fogR",
    "_fogG",
    "_fogB",
    "fogData",
    "projectionFragment",
    "awayjs-methodmaterials/lib/methods/EffectFresnelEnvMapMethod",
    "EffectFresnelEnvMapMethod",
    "_fresnelPower",
    "_normalReflectance",
    "viewDirReg",
    "normalReg",
    "awayjs-methodmaterials/lib/methods/EffectLightMapMethod",
    "EffectLightMapMethod",
    "AbstractMethodError",
    "awayjs-core/lib/errors/AbstractMethodError",
    "awayjs-methodmaterials/lib/methods/EffectRefractionEnvMapMethod",
    "EffectRefractionEnvMapMethod",
    "refractionIndex",
    "dispersionR",
    "dispersionG",
    "dispersionB",
    "_dispersionR",
    "_dispersionG",
    "_dispersionB",
    "_useDispersion",
    "_refractionIndex",
    "useDispersion",
    "data2",
    "refractionDir",
    "refractionColor",
    "awayjs-methodmaterials/lib/methods/EffectRimLightMethod",
    "EffectRimLightMethod",
    "strength",
    "power",
    "blend",
    "_strength",
    "_power",
    "dataRegister2",
    "MIX",
    "_normalMap",
    "normalDependencies",
    "iOutputsTangentNormals",
    "bnm",
    "awayjs-methodmaterials/lib/methods/NormalHeightMapMethod",
    "NormalHeightMapMethod",
    "heightMap",
    "worldWidth",
    "worldHeight",
    "worldDepth",
    "_worldXYRatio",
    "_worldXZRatio",
    "width",
    "height",
    "dataReg",
    "dataReg2",
    "awayjs-methodmaterials/lib/methods/NormalSimpleWaterMethod",
    "NormalSimpleWaterMethod",
    "secondaryNormalMap",
    "_water1OffsetX",
    "_water1OffsetY",
    "_water2OffsetX",
    "_water2OffsetY",
    "_secondaryNormalMap",
    "AssetBase",
    "iUsesTangentSpace",
    "dispatchEvent",
    "awayjs-core/lib/library/AssetBase",
    "awayjs-methodmaterials/lib/methods/ShadowCascadeMethod",
    "Event",
    "DirectionalLight",
    "ShadowMapMethodBase",
    "ShadowCascadeMethod",
    "shadowMethodBase",
    "castingLight",
    "_baseMethod",
    "_pCastingLight",
    "_cascadeShadowMapper",
    "shadowMapper",
    "CHANGE",
    "onCascadeChange",
    "tempVO",
    "depthMap",
    "fragmentData",
    "vertexData",
    "_cascadeProjections",
    "_depthMapCoordVaryings",
    "initProjectionsRegs",
    "numCascades",
    "globalPositionVertex",
    "planeDistanceReg",
    "planeDistances",
    "inQuad",
    "uvCoord",
    "uvProjection",
    "_iGetCascadeFragmentCode",
    "vertexIndex",
    "depth",
    "_pEpsilon",
    "k",
    "getDepthProjections",
    "fragmentIndex",
    "_pAlpha",
    "nearPlaneDistances",
    "_iNearPlaneDistances",
    "iActivateForCascade",
    "awayjs-core/lib/events/Event",
    "awayjs-display/lib/entities/DirectionalLight",
    "awayjs-methodmaterials/lib/methods/ShadowMapMethodBase",
    "awayjs-methodmaterials/lib/methods/ShadowDitheredMethod",
    "BitmapImage2D",
    "ShadowMethodBase",
    "ShadowDitheredMethod",
    "numSamples",
    "range",
    "_depthMapSize",
    "_grainUsages",
    "_grainTexture",
    "initGrainTexture",
    "_numSamples",
    "_range",
    "_grainBitmapImage2D",
    "vec",
    "len",
    "step",
    "g",
    "Math",
    "random",
    "floor",
    "setArray",
    "rect",
    "_pGetPlanarFragmentCode",
    "customDataReg",
    "getSampleCode",
    "uvReg",
    "projectionReg",
    "_pDepthMapCoordReg",
    "addSample",
    "decodeRegister",
    "depthProjection",
    "targetRegister",
    "awayjs-core/lib/data/BitmapImage2D",
    "awayjs-methodmaterials/lib/methods/ShadowMethodBase",
    "awayjs-methodmaterials/lib/methods/ShadowFilteredMethod",
    "ShadowFilteredMethod",
    "size",
    "depthCol",
    "predicate",
    "awayjs-methodmaterials/lib/methods/ShadowHardMethod",
    "ShadowHardMethod",
    "_pGetPointFragmentCode",
    "epsReg",
    "posReg",
    "depthSampleCol",
    "lightDir",
    "globalPositionVarying",
    "castsShadows",
    "_pShadowMapper",
    "PointLight",
    "_pUsePoint",
    "_pGetPointVertexCode",
    "pGetPlanarVertexCode",
    "depthMapProj",
    "iDepthProjection",
    "pow",
    "fallOff",
    "pos",
    "scenePosition",
    "x",
    "y",
    "z",
    "awayjs-display/lib/entities/PointLight",
    "awayjs-methodmaterials/lib/methods/ShadowNearMethod",
    "ShadowNearMethod",
    "fadeRatio",
    "_fadeRatio",
    "_nearShadowMapper",
    "epsilon",
    "getFreeFragmentSingleTemp",
    "near",
    "projection",
    "far",
    "coverageRatio",
    "awayjs-methodmaterials/lib/methods/ShadowSoftMethod",
    "PoissonLookup",
    "ShadowSoftMethod",
    "_offsets",
    "getDistribution",
    "texRange",
    "offsets",
    "numRegs",
    "reg",
    "awayjs-core/lib/geom/PoissonLookup",
    "awayjs-methodmaterials/lib/methods/SpecularAnisotropicMethod",
    "SpecularAnisotropicMethod",
    "tangentVarying",
    "_pSpecularTexData",
    "_pSpecularDataRegister",
    "_gloss",
    "_specular",
    "_specularColor",
    "_iSpecularR",
    "_iSpecularG",
    "_iSpecularB",
    "updateSpecular",
    "bsm",
    "spec",
    "useSmoothTextures",
    "awayjs-methodmaterials/lib/methods/SpecularCelMethod",
    "SpecularCompositeMethod",
    "SpecularCelMethod",
    "specularCutOff",
    "_specularCutOff",
    "clampSpecular",
    "awayjs-methodmaterials/lib/methods/SpecularCompositeMethod",
    "awayjs-methodmaterials/lib/methods/SpecularFresnelMethod",
    "SpecularFresnelMethod",
    "basedOnSurface",
    "modulateSpecular",
    "_incidentLight",
    "awayjs-methodmaterials/lib/methods/SpecularPhongMethod",
    "SpecularPhongMethod",
    "BlendMode",
    "StaticLightPicker",
    "RenderBase",
    "MethodPassMode",
    "MethodPass",
    "pool",
    "material",
    "renderableClass",
    "_material",
    "lightPicker",
    "numLightProbes",
    "numDirectionalLights",
    "numPointLights",
    "numCastingDirectionalLights",
    "numCastingPointLights",
    "_pUpdateRender",
    "initPasses",
    "setBlendAndCompareModes",
    "_pClearPasses",
    "mode",
    "_casterLightPass",
    "_pAddPass",
    "_nonCasterLightPasses",
    "_pass",
    "numEffectMethods",
    "initEffectPass",
    "removeEffectPass",
    "shadowMethod",
    "initCasterLightPass",
    "removeCasterLightPass",
    "numNonCasters",
    "initNonCasterLightPasses",
    "removeNonCasterLightPasses",
    "forceSeparateMVP",
    "Boolean",
    "setBlendMode",
    "NORMAL",
    "depthCompareMode",
    "firstAdditiveIndex",
    "_pRequiresBlending",
    "EFFECTS",
    "LAYER",
    "alphaBlending",
    "colorTransform",
    "SUPER_SHADER",
    "preserveAlpha",
    "LIGHTING",
    "_renderableClass",
    "_stage",
    "diffuseMethod",
    "ambientMethod",
    "normalMethod",
    "specularMethod",
    "_pRemovePass",
    "pass",
    "numDirLights",
    "dirLightOffset",
    "pointLightOffset",
    "probeOffset",
    "includeCasters",
    "directionalLightsOffset",
    "pointLightsOffset",
    "lightProbesOffset",
    "effectMethod",
    "max",
    "removeEffectMethodAt",
    "awayjs-core/lib/data/BlendMode",
    "awayjs-display/lib/materials/lightpickers/StaticLightPicker",
    "awayjs-methodmaterials/lib/render/passes/MethodPass",
    "awayjs-methodmaterials/lib/render/passes/MethodPassMode",
    "awayjs-renderergl/lib/render/RenderBase",
    "PassMode",
    "LightSources",
    "LightingShader",
    "ShaderBase",
    "PassBase",
    "render",
    "renderOwner",
    "_maxLights",
    "_includeCasters",
    "_iMethodVOs",
    "_numEffectDependencies",
    "_onLightsChangeDelegate",
    "onLightsChange",
    "_onMethodInvalidatedDelegate",
    "onMethodInvalidated",
    "_shader",
    "_updateShader",
    "_updateLights",
    "_lightPicker",
    "enableLightFallOff",
    "diffuseLightSources",
    "specularLightSources",
    "_iInitConstantData",
    "colorTransformMethod",
    "_iColorTransformMethodVO",
    "_removeDependency",
    "_addDependency",
    "effectsDependency",
    "invalidatePass",
    "hasEffectMethod",
    "getDependencyForMethod",
    "_iNormalMethodVO",
    "_iAmbientMethodVO",
    "_iShadowMethodVO",
    "_iDiffuseMethodVO",
    "_iSpecularMethodVO",
    "_iActivate",
    "_iRender",
    "viewProjection",
    "_iDeactivate",
    "_iIncludeDependencies",
    "usesFragmentAnimation",
    "useAlphaPremultiplied",
    "usesBlending",
    "setupAndCountDependencies",
    "usesTangentSpace",
    "outputsNormals",
    "outputsTangentNormals",
    "usesProbes",
    "viewDirDependencies",
    "globalPosDependencies",
    "usesLights",
    "usesGlobalPosFragment",
    "projectionDependencies",
    "tangentDependencies",
    "_iGetPreLightingVertexCode",
    "_iGetPreLightingFragmentCode",
    "shadedTarget",
    "_iGetPerLightDiffuseFragmentCode",
    "diffuseColorReg",
    "_iGetPerLightSpecularFragmentCode",
    "specularColorReg",
    "_iGetPerProbeDiffuseFragmentCode",
    "texReg",
    "weightReg",
    "_iGetPerProbeSpecularFragmentCode",
    "_iGetPostLightingVertexCode",
    "_iGetPostLightingFragmentCode",
    "_iGetNormalVertexCode",
    "_iGetNormalFragmentCode",
    "removeVertexTempUsage",
    "_iGetVertexCode",
    "sharedReg",
    "alphaReg",
    "_iUsesShadows",
    "castingDirectionalLights",
    "castingPointLights",
    "_iUsesSpecular",
    "_iUsesDiffuse",
    "numDirectionalLightsOld",
    "numPointLightsOld",
    "numLightProbesOld",
    "calculateNumDirectionalLights",
    "calculateNumPointLights",
    "calculateNumProbes",
    "min",
    "numFree",
    "numChannels",
    "PROBES",
    "awayjs-display/lib/materials/LightSources",
    "awayjs-renderergl/lib/render/passes/PassBase",
    "awayjs-renderergl/lib/shaders/LightingShader",
    "awayjs-renderergl/lib/shaders/ShaderBase",
    "awayjs-methodmaterials/lib/render/passes/SingleObjectDepthPass",
    "Matrix3D",
    "ContextGLDrawMode",
    "ContextGLProgramType",
    "SubGeometryVOPool",
    "SingleObjectDepthPass",
    "_textureSize",
    "_polyOffset",
    "_projectionTexturesInvalid",
    "_subGeometryVOPool",
    "getPool",
    "_textures",
    "key",
    "updateProjectionTextures",
    "_projections",
    "renderableOwner",
    "id",
    "context",
    "light",
    "lights",
    "_renderOwner",
    "allPickedLights",
    "rId",
    "iGetObjectProjectionMatrix",
    "sourceEntity",
    "setRenderTarget",
    "clear",
    "setProgramConstantsFromMatrix",
    "VERTEX",
    "setProgramConstantsFromArray",
    "FRAGMENT",
    "_enc",
    "subGeometryVO",
    "subGeom",
    "subGeometry",
    "activateVertexBufferVO",
    "positions",
    "normals",
    "getIndexBufferVO",
    "draw",
    "TRIANGLES",
    "numElements",
    "awayjs-core/lib/geom/Matrix3D",
    "awayjs-renderergl/lib/vos/SubGeometryVOPool",
    "awayjs-stagegl/lib/base/ContextGLDrawMode",
    "awayjs-stagegl/lib/base/ContextGLProgramType"
  ],
  "mappings": "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",
  "file": "awayjs-methodmaterials.min.js",
  "sourcesContent": [
    "(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})",
    "class MethodMaterialMode\n{\n\t/**\n\t *\n\t */\n\tpublic static SINGLE_PASS:string = \"singlePass\";\n\n\t/**\n\t *\n\t */\n\tpublic static MULTI_PASS:string = \"multiPass\";\n}\n\nexport = MethodMaterialMode;",
    null,
    "import BlendMode\t\t\t\t\t= require(\"awayjs-core/lib/data/BlendMode\");\nimport Image2D\t\t\t\t\t\t= require(\"awayjs-core/lib/data/Image2D\");\n\nimport IRenderOwner\t\t\t\t\t= require(\"awayjs-display/lib/base/IRenderOwner\");\nimport Camera\t\t\t\t\t\t= require(\"awayjs-display/lib/entities/Camera\");\nimport StaticLightPicker\t\t\t= require(\"awayjs-display/lib/materials/lightpickers/StaticLightPicker\");\nimport MaterialBase\t\t\t\t\t= require(\"awayjs-display/lib/materials/MaterialBase\");\nimport IRender\t\t\t\t\t\t= require(\"awayjs-display/lib/pool/IRender\");\nimport Single2DTexture\t\t\t\t= require(\"awayjs-display/lib/textures/Single2DTexture\");\nimport TextureBase\t\t\t\t\t= require(\"awayjs-display/lib/textures/TextureBase\");\n\nimport ContextGLCompareMode\t\t\t= require(\"awayjs-stagegl/lib/base/ContextGLCompareMode\");\n\nimport RenderPool\t\t\t\t\t= require(\"awayjs-renderergl/lib/render/RenderPool\");\n\nimport MethodMaterialMode\t\t\t= require(\"awayjs-methodmaterials/lib/MethodMaterialMode\");\nimport AmbientBasicMethod\t\t\t= require(\"awayjs-methodmaterials/lib/methods/AmbientBasicMethod\");\nimport DiffuseBasicMethod\t\t\t= require(\"awayjs-methodmaterials/lib/methods/DiffuseBasicMethod\");\nimport EffectMethodBase\t\t\t\t= require(\"awayjs-methodmaterials/lib/methods/EffectMethodBase\");\nimport NormalBasicMethod\t\t\t= require(\"awayjs-methodmaterials/lib/methods/NormalBasicMethod\");\nimport ShadowMapMethodBase\t\t\t= require(\"awayjs-methodmaterials/lib/methods/ShadowMapMethodBase\");\nimport SpecularBasicMethod\t\t\t= require(\"awayjs-methodmaterials/lib/methods/SpecularBasicMethod\");\nimport MethodMaterialRender\t\t\t= require(\"awayjs-methodmaterials/lib/render/MethodMaterialRender\");\n\n/**\n * MethodMaterial forms an abstract base class for the default shaded materials provided by Stage,\n * using material methods to define their appearance.\n */\nclass MethodMaterial extends MaterialBase\n{\n\tpublic static assetType:string = \"[materials MethodMaterial]\";\n\n\tprivate _effectMethods:Array<EffectMethodBase> = new Array<EffectMethodBase>();\n\tprivate _mode:string;\n\n\tprivate _ambientMethod:AmbientBasicMethod = new AmbientBasicMethod();\n\tprivate _shadowMethod:ShadowMapMethodBase;\n\tprivate _diffuseMethod:DiffuseBasicMethod = new DiffuseBasicMethod();\n\tprivate _normalMethod:NormalBasicMethod = new NormalBasicMethod();\n\tprivate _specularMethod:SpecularBasicMethod = new SpecularBasicMethod();\n\n\n\tprivate _depthCompareMode:string = ContextGLCompareMode.LESS_EQUAL;\n\n\tprivate static register = MethodMaterial.addRenderable();\n\n\tprivate static addRenderable()\n\t{\n\t\tRenderPool.registerClass(MethodMaterialRender, MethodMaterial);\n\t}\n\n\t/**\n\t *\n\t */\n\tpublic get assetType():string\n\t{\n\t\treturn MethodMaterial.assetType;\n\t}\n\n\t/**\n\t * Creates a new MethodMaterial object.\n\t *\n\t * @param texture The texture used for the material's albedo color.\n\t * @param smooth Indicates whether the texture should be filtered when sampled. Defaults to true.\n\t * @param repeat Indicates whether the texture should be tiled when sampled. Defaults to false.\n\t * @param mipmap Indicates whether or not any used textures should use mipmapping. Defaults to false.\n\t */\n\tconstructor(texture?:Image2D, smooth?:boolean, repeat?:boolean, mipmap?:boolean);\n\tconstructor(texture?:TextureBase, smooth?:boolean, repeat?:boolean, mipmap?:boolean);\n\tconstructor(color?:number, alpha?:number);\n\tconstructor(textureColor:any = null, smoothAlpha:any = null, repeat:boolean = false, mipmap:boolean = true)\n\t{\n\t\tsuper();\n\n\t\tthis._mode = MethodMaterialMode.SINGLE_PASS;\n\n\t\tif (textureColor instanceof Image2D)\n\t\t\ttextureColor = new Single2DTexture(textureColor);\n\n\t\tif (textureColor instanceof TextureBase) {\n\t\t\tthis.texture = <TextureBase> textureColor;\n\n\t\t\tthis.smooth = (smoothAlpha == null)? true : false;\n\t\t\tthis.repeat = repeat;\n\t\t\tthis.mipmap = mipmap;\n\t\t} else {\n\t\t\tthis.color = (textureColor == null)? 0xFFFFFF : Number(textureColor);\n\t\t\tthis.alpha = (smoothAlpha == null)? 1 : Number(smoothAlpha);\n\t\t}\n\t}\n\n\n\tpublic get mode():string\n\t{\n\t\treturn this._mode;\n\t}\n\n\tpublic set mode(value:string)\n\t{\n\t\tif (this._mode == value)\n\t\t\treturn;\n\n\t\tthis._mode = value;\n\n\t\tthis._pInvalidateRender();\n\t}\n\n\t/**\n\t * The depth compare mode used to render the renderables using this material.\n\t *\n\t * @see away.stagegl.ContextGLCompareMode\n\t */\n\n\tpublic get depthCompareMode():string\n\t{\n\t\treturn this._depthCompareMode;\n\t}\n\n\tpublic set depthCompareMode(value:string)\n\t{\n\t\tif (this._depthCompareMode == value)\n\t\t\treturn;\n\n\t\tthis._depthCompareMode = value;\n\n\t\tthis._pInvalidateRender();\n\t}\n\n\t/**\n\t * The texture object to use for the ambient colour.\n\t */\n\tpublic get diffuseTexture():TextureBase\n\t{\n\t\treturn this._diffuseMethod.texture;\n\t}\n\n\tpublic set diffuseTexture(value:TextureBase)\n\t{\n\t\tthis._diffuseMethod.texture = value;\n\t}\n\n\t/**\n\t * The method that provides the ambient lighting contribution. Defaults to AmbientBasicMethod.\n\t */\n\tpublic get ambientMethod():AmbientBasicMethod\n\t{\n\t\treturn this._ambientMethod;\n\t}\n\n\tpublic set ambientMethod(value:AmbientBasicMethod)\n\t{\n\t\tif (this._ambientMethod == value)\n\t\t\treturn;\n\n\t\tif (value && this._ambientMethod)\n\t\t\tvalue.copyFrom(this._ambientMethod);\n\n\t\tthis._ambientMethod = value;\n\n\t\tthis._pInvalidateRender();\n\t}\n\n\t/**\n\t * The method used to render shadows cast on this surface, or null if no shadows are to be rendered. Defaults to null.\n\t */\n\tpublic get shadowMethod():ShadowMapMethodBase\n\t{\n\t\treturn this._shadowMethod;\n\t}\n\n\tpublic set shadowMethod(value:ShadowMapMethodBase)\n\t{\n\t\tif (this._shadowMethod == value)\n\t\t\treturn;\n\n\t\tif (value && this._shadowMethod)\n\t\t\tvalue.copyFrom(this._shadowMethod);\n\n\t\tthis._shadowMethod = value;\n\n\t\tthis._pInvalidateRender();\n\t}\n\n\t/**\n\t * The method that provides the diffuse lighting contribution. Defaults to DiffuseBasicMethod.\n\t */\n\tpublic get diffuseMethod():DiffuseBasicMethod\n\t{\n\t\treturn this._diffuseMethod;\n\t}\n\n\tpublic set diffuseMethod(value:DiffuseBasicMethod)\n\t{\n\t\tif (this._diffuseMethod == value)\n\t\t\treturn;\n\n\t\tif (value && this._diffuseMethod)\n\t\t\tvalue.copyFrom(this._diffuseMethod);\n\n\t\tthis._diffuseMethod = value;\n\n\t\tthis._pInvalidateRender();\n\t}\n\n\t/**\n\t * The method that provides the specular lighting contribution. Defaults to SpecularBasicMethod.\n\t */\n\tpublic get specularMethod():SpecularBasicMethod\n\t{\n\t\treturn this._specularMethod;\n\t}\n\n\tpublic set specularMethod(value:SpecularBasicMethod)\n\t{\n\t\tif (this._specularMethod == value)\n\t\t\treturn;\n\n\t\tif (value && this._specularMethod)\n\t\t\tvalue.copyFrom(this._specularMethod);\n\n\t\tthis._specularMethod = value;\n\n\t\tthis._pInvalidateRender();\n\t}\n\n\t/**\n\t * The method used to generate the per-pixel normals. Defaults to NormalBasicMethod.\n\t */\n\tpublic get normalMethod():NormalBasicMethod\n\t{\n\t\treturn this._normalMethod;\n\t}\n\n\tpublic set normalMethod(value:NormalBasicMethod)\n\t{\n\t\tif (this._normalMethod == value)\n\t\t\treturn;\n\n\t\tif (value && this._normalMethod)\n\t\t\tvalue.copyFrom(this._normalMethod);\n\n\t\tthis._normalMethod = value;\n\n\t\tthis._pInvalidateRender();\n\t}\n\n\tpublic get numEffectMethods():number\n\t{\n\t\treturn this._effectMethods.length;\n\t}\n\n\t/**\n\t * Appends an \"effect\" shading method to the shader. Effect methods are those that do not influence the lighting\n\t * but modulate the shaded colour, used for fog, outlines, etc. The method will be applied to the result of the\n\t * methods added prior.\n\t */\n\tpublic addEffectMethod(method:EffectMethodBase)\n\t{\n\t\tthis._effectMethods.push(method);\n\n\t\tthis._pInvalidateRender();\n\t}\n\n\t/**\n\t * Returns the method added at the given index.\n\t * @param index The index of the method to retrieve.\n\t * @return The method at the given index.\n\t */\n\tpublic getEffectMethodAt(index:number):EffectMethodBase\n\t{\n\t\treturn this._effectMethods[index];\n\t}\n\n\t/**\n\t * Adds an effect method at the specified index amongst the methods already added to the material. Effect\n\t * methods are those that do not influence the lighting but modulate the shaded colour, used for fog, outlines,\n\t * etc. The method will be applied to the result of the methods with a lower index.\n\t */\n\tpublic addEffectMethodAt(method:EffectMethodBase, index:number)\n\t{\n\t\tthis._effectMethods.splice(index, 0, method);\n\n\t\tthis._pInvalidateRender();\n\t}\n\n\t/**\n\t * Removes an effect method from the material.\n\t * @param method The method to be removed.\n\t */\n\tpublic removeEffectMethod(method:EffectMethodBase)\n\t{\n\t\tthis._effectMethods.splice(this._effectMethods.indexOf(method), 1);\n\n\t\tthis._pInvalidateRender();\n\t}\n\n\t/**\n\t * The normal map to modulate the direction of the surface for each texel. The default normal method expects\n\t * tangent-space normal maps, but others could expect object-space maps.\n\t */\n\tpublic get normalMap():TextureBase\n\t{\n\t\treturn this._normalMethod.normalMap;\n\t}\n\n\tpublic set normalMap(value:TextureBase)\n\t{\n\t\tthis._normalMethod.normalMap = value;\n\t}\n\n\t/**\n\t * A specular map that defines the strength of specular reflections for each texel in the red channel,\n\t * and the gloss factor in the green channel. You can use Specular2DTexture if you want to easily set\n\t * specular and gloss maps from grayscale images, but correctly authored images are preferred.\n\t */\n\tpublic get specularMap():TextureBase\n\t{\n\t\treturn this._specularMethod.texture;\n\t}\n\n\tpublic set specularMap(value:TextureBase)\n\t{\n\t\tthis._specularMethod.texture = value;\n\t}\n\n\t/**\n\t * The glossiness of the material (sharpness of the specular highlight).\n\t */\n\tpublic get gloss():number\n\t{\n\t\treturn this._specularMethod.gloss;\n\t}\n\n\tpublic set gloss(value:number)\n\t{\n\t\tthis._specularMethod.gloss = value;\n\t}\n\n\t/**\n\t * The strength of the ambient reflection.\n\t */\n\tpublic get ambient():number\n\t{\n\t\treturn this._ambientMethod.ambient;\n\t}\n\n\tpublic set ambient(value:number)\n\t{\n\t\tthis._ambientMethod.ambient = value;\n\t}\n\n\t/**\n\t * The overall strength of the specular reflection.\n\t */\n\tpublic get specular():number\n\t{\n\t\treturn this._specularMethod.specular;\n\t}\n\n\tpublic set specular(value:number)\n\t{\n\t\tthis._specularMethod.specular = value;\n\t}\n\n\t/**\n\t * The colour of the ambient reflection.\n\t */\n\tpublic get ambientColor():number\n\t{\n\t\treturn this._diffuseMethod.ambientColor;\n\t}\n\n\tpublic set ambientColor(value:number)\n\t{\n\t\tthis._diffuseMethod.ambientColor = value;\n\t}\n\n\t/**\n\t * The colour of the diffuse reflection.\n\t */\n\tpublic get diffuseColor():number\n\t{\n\t\treturn this._diffuseMethod.diffuseColor;\n\t}\n\n\tpublic set diffuseColor(value:number)\n\t{\n\t\tthis._diffuseMethod.diffuseColor = value;\n\t}\n\n\t/**\n\t * The colour of the specular reflection.\n\t */\n\tpublic get specularColor():number\n\t{\n\t\treturn this._specularMethod.specularColor;\n\t}\n\n\tpublic set specularColor(value:number)\n\t{\n\t\tthis._specularMethod.specularColor = value;\n\t}\n}\n\nexport = MethodMaterial;",
    "import TextureVOBase\t\t\t\t= require(\"awayjs-renderergl/lib/vos/TextureVOBase\");\n\nimport ShadingMethodBase\t\t\t= require(\"awayjs-methodmaterials/lib/methods/ShadingMethodBase\");\n\n/**\n * MethodVO contains data for a given shader object for the use within a single material.\n * This allows shader methods to be shared across materials while their non-public state differs.\n */\nclass MethodVO\n{\n\tpublic useMethod:boolean = true;\n\n\tpublic method:ShadingMethodBase;\n\n\t// public register indices\n\tpublic textureVO:TextureVOBase;\n\tpublic secondaryTextureVO:TextureVOBase; // sometimes needed for composites\n\tpublic vertexConstantsIndex:number;\n\tpublic secondaryVertexConstantsIndex:number; // sometimes needed for composites\n\tpublic fragmentConstantsIndex:number;\n\tpublic secondaryFragmentConstantsIndex:number; // sometimes needed for composites\n\n\t// internal stuff for the material to know before assembling code\n\tpublic needsProjection:boolean;\n\tpublic needsView:boolean;\n\tpublic needsNormals:boolean;\n\tpublic needsTangents:boolean;\n\tpublic needsGlobalVertexPos:boolean;\n\tpublic needsGlobalFragmentPos:boolean;\n\t/**\n\t * Creates a new MethodVO object.\n\t */\n\tconstructor(method:ShadingMethodBase)\n\t{\n\t\tthis.method = method;\n\t}\n\n\t/**\n\t * Resets the values of the value object to their \"unused\" state.\n\t */\n\tpublic reset()\n\t{\n\t\tthis.method.iReset();\n\n\t\tthis.vertexConstantsIndex = -1;\n\t\tthis.secondaryVertexConstantsIndex = -1;\n\t\tthis.fragmentConstantsIndex = -1;\n\t\tthis.secondaryFragmentConstantsIndex = -1;\n\n\t\tthis.needsProjection = false;\n\t\tthis.needsView = false;\n\t\tthis.needsNormals = false;\n\t\tthis.needsTangents = false;\n\t\tthis.needsGlobalVertexPos = false;\n\t\tthis.needsGlobalFragmentPos = false;\n\t}\n}\n\nexport = MethodVO;\n",
    "import Stage\t\t\t\t\t\t= require(\"awayjs-stagegl/lib/base/Stage\");\n\nimport ShaderBase\t\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderBase\");\nimport ShaderRegisterCache\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterCache\");\nimport ShaderRegisterData\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterData\");\nimport ShaderRegisterElement\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterElement\");\n\nimport MethodVO\t\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/data/MethodVO\");\nimport ShadingMethodBase\t\t\t= require(\"awayjs-methodmaterials/lib/methods/ShadingMethodBase\");\n\n/**\n * AmbientBasicMethod provides the default shading method for uniform ambient lighting.\n */\nclass AmbientBasicMethod extends ShadingMethodBase\n{\n\tprivate _color:number = 0xffffff;\n\tprivate _alpha:number = 1;\n\n\tprivate _colorR:number = 1;\n\tprivate _colorG:number = 1;\n\tprivate _colorB:number = 1;\n\n\tprivate _ambient:number = 1;\n\n\t/**\n\t * Creates a new AmbientBasicMethod object.\n\t */\n\tconstructor()\n\t{\n\t\tsuper();\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitVO(shader:ShaderBase, methodVO:MethodVO)\n\t{\n\t\tif (shader.texture)\n\t\t\tshader.uvDependencies++;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitConstants(shader:ShaderBase, methodVO:MethodVO)\n\t{\n\t\tif (!shader.texture) {\n\t\t\tthis._color = shader.color;\n\t\t\tthis.updateColor();\n\t\t}\n\t}\n\n\t/**\n\t * The strength of the ambient reflection of the surface.\n\t */\n\tpublic get ambient():number\n\t{\n\t\treturn this._ambient;\n\t}\n\n\tpublic set ambient(value:number)\n\t{\n\t\tif (this._ambient == value)\n\t\t\treturn;\n\n\t\tthis._ambient = value;\n\n\t\tthis.updateColor();\n\t}\n\n\t/**\n\t * The alpha component of the surface.\n\t */\n\tpublic get alpha():number\n\t{\n\t\treturn this._alpha;\n\t}\n\n\tpublic set alpha(value:number)\n\t{\n\t\tif (this._alpha == value)\n\t\t\treturn;\n\n\t\tthis._alpha = value;\n\n\t\tthis.updateColor();\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic copyFrom(method:ShadingMethodBase)\n\t{\n\t\tvar m:any = method;\n\t\tvar b:AmbientBasicMethod = <AmbientBasicMethod> m;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentCode(shader:ShaderBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = \"\";\n\n\t\tif (shader.texture) {\n\t\t\tshader.texture._iInitRegisters(shader, registerCache);\n\n\t\t\tcode += shader.texture._iGetFragmentCode(shader, targetReg, registerCache, sharedRegisters.uvVarying);\n\n\t\t\tif (shader.alphaThreshold > 0) {\n\t\t\t\tvar cutOffReg:ShaderRegisterElement = registerCache.getFreeFragmentConstant();\n\t\t\t\tmethodVO.fragmentConstantsIndex = cutOffReg.index*4;\n\n\t\t\t\tcode += \"sub \" + targetReg + \".w, \" + targetReg + \".w, \" + cutOffReg + \".x\\n\" +\n\t\t\t\t\t\"kil \" + targetReg + \".w\\n\" +\n\t\t\t\t\t\"add \" + targetReg + \".w, \" + targetReg + \".w, \" + cutOffReg + \".x\\n\";\n\t\t\t}\n\n\t\t} else {\n\t\t\tvar ambientInputRegister:ShaderRegisterElement = registerCache.getFreeFragmentConstant();\n\t\t\tmethodVO.fragmentConstantsIndex = ambientInputRegister.index*4;\n\n\t\t\tcode += \"mov \" + targetReg + \", \" + ambientInputRegister + \"\\n\";\n\t\t}\n\n\t\treturn code;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iActivate(shader:ShaderBase, methodVO:MethodVO, stage:Stage)\n\t{\n\t\tif (shader.texture) {\n\t\t\tshader.texture.activate(shader);\n\n\t\t\tif (shader.alphaThreshold > 0)\n\t\t\t\tshader.fragmentConstantData[methodVO.fragmentConstantsIndex] = shader.alphaThreshold;\n\t\t} else {\n\t\t\tvar index:number = methodVO.fragmentConstantsIndex;\n\t\t\tvar data:Array<number> = shader.fragmentConstantData;\n\t\t\tdata[index] = this._colorR;\n\t\t\tdata[index + 1] = this._colorG;\n\t\t\tdata[index + 2] = this._colorB;\n\t\t\tdata[index + 3] = this._alpha;\n\t\t}\n\t}\n\n\t/**\n\t * Updates the ambient color data used by the render state.\n\t */\n\tprivate updateColor()\n\t{\n\t\tthis._colorR = ((this._color >> 16) & 0xff)/0xff*this._ambient;\n\t\tthis._colorG = ((this._color >> 8) & 0xff)/0xff*this._ambient;\n\t\tthis._colorB = (this._color & 0xff)/0xff*this._ambient;\n\t}\n}\n\nexport = AmbientBasicMethod;",
    "import ShaderBase\t\t\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderBase\");\nimport ShaderRegisterCache\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterCache\");\nimport ShaderRegisterData\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterData\");\nimport ShaderRegisterElement\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterElement\");\n\nimport MethodVO\t\t\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/data/MethodVO\");\nimport AmbientBasicMethod\t\t\t\t= require(\"awayjs-methodmaterials/lib/methods/AmbientBasicMethod\");\n\n/**\n * AmbientEnvMapMethod provides a diffuse shading method that uses a diffuse irradiance environment map to\n * approximate global lighting rather than lights.\n */\nclass AmbientEnvMapMethod extends AmbientBasicMethod\n{\n\t/**\n\t * Creates a new <code>AmbientEnvMapMethod</code> object.\n\t *\n\t * @param envMap The cube environment map to use for the ambient lighting.\n\t */\n\tconstructor()\n\t{\n\t\tsuper();\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitVO(shader:ShaderBase, methodVO:MethodVO)\n\t{\n\t\tmethodVO.needsNormals = true;\n\t}\n\t\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentCode(shader:ShaderBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, regCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tshader.texture._iInitRegisters(shader, regCache);\n\n\t\treturn shader.texture._iGetFragmentCode(shader, targetReg, regCache, sharedRegisters.normalFragment);\n\t}\n}\n\nexport = AmbientEnvMapMethod;",
    "import Stage\t\t\t\t\t\t= require(\"awayjs-stagegl/lib/base/Stage\");\n\nimport ShaderBase\t\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderBase\");\nimport ShaderRegisterCache\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterCache\");\nimport ShaderRegisterData\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterData\");\nimport ShaderRegisterElement\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterElement\");\n\nimport MethodVO\t\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/data/MethodVO\");\nimport ShadingMethodBase\t\t\t= require(\"awayjs-methodmaterials/lib/methods/ShadingMethodBase\");\n\n/**\n * AmbientBasicMethod provides the default shading method for uniform ambient lighting.\n */\nclass CurveBasicMethod extends ShadingMethodBase\n{\n\tprivate _color:number = 0xffffff;\n\tprivate _alpha:number = 1;\n\n\tprivate _colorR:number = 1;\n\tprivate _colorG:number = 1;\n\tprivate _colorB:number = 1;\n\n\tprivate _ambient:number = 1;\n\n\t/**\n\t * Creates a new AmbientBasicMethod object.\n\t */\n\tconstructor()\n\t{\n\t\tsuper();\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitVO(shader:ShaderBase, methodVO:MethodVO)\n\t{\n\t\tif (shader.texture)\n\t\t\tshader.uvDependencies++;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitConstants(shader:ShaderBase, methodVO:MethodVO)\n\t{\n\t\tif (!shader.texture) {\n\t\t\tthis._color = shader.color;\n\t\t\tthis.updateColor();\n\t\t}\n\t}\n\n\t/**\n\t * The strength of the ambient reflection of the surface.\n\t */\n\tpublic get ambient():number\n\t{\n\t\treturn this._ambient;\n\t}\n\n\tpublic set ambient(value:number)\n\t{\n\t\tif (this._ambient == value)\n\t\t\treturn;\n\n\t\tthis._ambient = value;\n\n\t\tthis.updateColor();\n\t}\n\n\t/**\n\t * The alpha component of the surface.\n\t */\n\tpublic get alpha():number\n\t{\n\t\treturn this._alpha;\n\t}\n\n\tpublic set alpha(value:number)\n\t{\n\t\tif (this._alpha == value)\n\t\t\treturn;\n\n\t\tthis._alpha = value;\n\n\t\tthis.updateColor();\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic copyFrom(method:ShadingMethodBase)\n\t{\n\t\tvar m:any = method;\n\t\tvar b:CurveBasicMethod = <CurveBasicMethod> m;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n    /*\n    public iGeVertexCode(shader:ShaderBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string {\n        var code:string = \"\";\n        code = \"mov \" + sharedRegisters.uvVarying + \" \" + registerCache.uv +  \" \\n\";\n    }*/\n    public iGetFragmentCode(shader:ShaderBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = \"\";\n\t\tvar ambientInputRegister:ShaderRegisterElement;\n\n\t\tif (shader.texture) {\n\t\t\tshader.texture._iInitRegisters(shader, registerCache);\n\n\t\t\tcode += shader.texture._iGetFragmentCode(shader, targetReg, registerCache, sharedRegisters.uvVarying);\n\n\t\t\tif (shader.alphaThreshold > 0) {\n\t\t\t\tvar cutOffReg:ShaderRegisterElement = registerCache.getFreeFragmentConstant();\n\t\t\t\tmethodVO.fragmentConstantsIndex = cutOffReg.index*4;\n\n\t\t\t\tcode += \"sub \" + targetReg + \".w, \" + targetReg + \".w, \" + cutOffReg + \".x\\n\" +\n\t\t\t\t\t\"kil \" + targetReg + \".w\\n\" +\n\t\t\t\t\t\"add \" + targetReg + \".w, \" + targetReg + \".w, \" + cutOffReg + \".x\\n\";\n\t\t\t}\n\n\t\t} else {\n\t\t\tambientInputRegister = registerCache.getFreeFragmentConstant();\n\t\t\tmethodVO.fragmentConstantsIndex = ambientInputRegister.index*4;\n\n\t\t\tcode += \"mov \" + targetReg + \", \" + ambientInputRegister + \"\\n\";\n\t\t}\n        code = \"mov \" + targetReg + \", \" + sharedRegisters.uvVarying + \"\\n\";\n\t\treturn code;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iActivate(shader:ShaderBase, methodVO:MethodVO, stage:Stage)\n\t{\n\t\tif (shader.texture) {\n\t\t\tshader.texture.activate(shader);\n\n\t\t\tif (shader.alphaThreshold > 0)\n\t\t\t\tshader.fragmentConstantData[methodVO.fragmentConstantsIndex] = shader.alphaThreshold;\n\t\t} else {\n\t\t\tvar index:number = methodVO.fragmentConstantsIndex;\n\t\t\tvar data:Array<number> = shader.fragmentConstantData;\n\t\t\tdata[index] = this._colorR;\n\t\t\tdata[index + 1] = this._colorG;\n\t\t\tdata[index + 2] = this._colorB;\n\t\t\tdata[index + 3] = this._alpha;\n\t\t}\n\t}\n\n\t/**\n\t * Updates the ambient color data used by the render state.\n\t */\n\tprivate updateColor()\n\t{\n\t\tthis._colorR = ((this._color >> 16) & 0xff)/0xff*this._ambient;\n\t\tthis._colorG = ((this._color >> 8) & 0xff)/0xff*this._ambient;\n\t\tthis._colorB = (this._color & 0xff)/0xff*this._ambient;\n\t}\n}\nexport = CurveBasicMethod;",
    "import Camera\t\t\t\t\t\t= require(\"awayjs-display/lib/entities/Camera\");\nimport TextureBase\t\t\t\t\t= require(\"awayjs-display/lib/textures/TextureBase\");\n\nimport Stage\t\t\t\t\t\t= require(\"awayjs-stagegl/lib/base/Stage\");\n\nimport LightingShader\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/LightingShader\");\nimport ShaderRegisterCache\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterCache\");\nimport ShaderRegisterData\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterData\");\nimport ShaderRegisterElement\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterElement\");\nimport RenderableBase\t\t\t\t= require(\"awayjs-renderergl/lib/renderables/RenderableBase\");\n\nimport MethodVO\t\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/data/MethodVO\");\nimport ShadingMethodBase\t\t\t= require(\"awayjs-methodmaterials/lib/methods/ShadingMethodBase\");\nimport LightingMethodBase\t\t\t= require(\"awayjs-methodmaterials/lib/methods/LightingMethodBase\");\n\n/**\n * DiffuseBasicMethod provides the default shading method for Lambert (dot3) diffuse lighting.\n */\nclass DiffuseBasicMethod extends LightingMethodBase\n{\n\tprivate _multiply:boolean = true;\n\n\tpublic _pTotalLightColorReg:ShaderRegisterElement;\n\n\tpublic _texture:TextureBase;\n\tprivate _diffuseColor:number = 0xffffff;\n\tprivate _ambientColor:number = 0xffffff;\n\tprivate _diffuseR:number = 1;\n\tprivate _diffuseG:number = 1;\n\tprivate _diffuseB:number = 1;\n\tprivate _ambientR:number = 1;\n\tprivate _ambientG:number = 1;\n\tprivate _ambientB:number = 1;\n\n\tpublic _pIsFirstLight:boolean;\n\n\t/**\n\t * Creates a new DiffuseBasicMethod object.\n\t */\n\tconstructor()\n\t{\n\t\tsuper();\n\t}\n\n\tpublic iIsUsed(shader:LightingShader):boolean\n\t{\n\t\tif (!shader.numLights)\n\t\t\treturn false;\n\n\t\treturn true;\n\t}\n\n\t/**\n\t * Set internally if diffuse color component multiplies or replaces the ambient color\n\t */\n\tpublic get multiply():boolean\n\t{\n\t\treturn this._multiply;\n\t}\n\n\tpublic set multiply(value:boolean)\n\t{\n\t\tif (this._multiply == value)\n\t\t\treturn;\n\n\t\tthis._multiply = value;\n\n\t\tthis.iInvalidateShaderProgram();\n\t}\n\n\tpublic iInitVO(shader:LightingShader, methodVO:MethodVO)\n\t{\n\t\tif (this._texture) {\n\t\t\tmethodVO.textureVO = shader.getTextureVO(this._texture);\n\t\t\tshader.uvDependencies++;\n\t\t} else if (methodVO.textureVO) {\n\t\t\tmethodVO.textureVO.dispose();\n\t\t\tmethodVO.textureVO = null;\n\t\t}\n\n\t\tif (shader.numLights > 0) {\n\t\t\tshader.usesCommonData = true;\n\t\t\tmethodVO.needsNormals = true;\n\t\t}\n\t}\n\n\t/**\n\t * The color of the diffuse reflection when not using a texture.\n\t */\n\tpublic get diffuseColor():number\n\t{\n\t\treturn this._diffuseColor;\n\t}\n\n\tpublic set diffuseColor(value:number)\n\t{\n\t\tif (this._diffuseColor == value)\n\t\t\treturn;\n\n\t\tthis._diffuseColor = value;\n\n\t\tthis.updateDiffuse();\n\t}\n\n\t/**\n\t * The color of the ambient reflection\n\t */\n\tpublic get ambientColor():number\n\t{\n\t\treturn this._ambientColor;\n\t}\n\n\tpublic set ambientColor(value:number)\n\t{\n\t\tif (this._ambientColor == value)\n\t\t\treturn;\n\n\t\tthis._ambientColor = value;\n\n\t\tthis.updateAmbient();\n\t}\n\n\n\t/**\n\t * The bitmapData to use to define the diffuse reflection color per texel.\n\t */\n\tpublic get texture():TextureBase\n\t{\n\t\treturn this._texture;\n\t}\n\n\tpublic set texture(value:TextureBase)\n\t{\n\t\tif (this._texture == value)\n\t\t\treturn;\n\n\t\tthis._texture = value;\n\n\t\tthis.iInvalidateShaderProgram();\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic dispose()\n\t{\n\t\tthis._texture = null;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic copyFrom(method:ShadingMethodBase)\n\t{\n\t\tvar diff:DiffuseBasicMethod = <DiffuseBasicMethod> method;\n\n\t\tthis.texture = diff.texture;\n\t\tthis.multiply = diff.multiply;\n\t\tthis.diffuseColor = diff.diffuseColor;\n\t\tthis.ambientColor = diff.ambientColor;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iCleanCompilationData()\n\t{\n\t\tsuper.iCleanCompilationData();\n\n\t\tthis._pTotalLightColorReg = null;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentPreLightingCode(shader:LightingShader, methodVO:MethodVO, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = \"\";\n\n\t\tthis._pIsFirstLight = true;\n\n\t\tregisterCache.addFragmentTempUsages(this._pTotalLightColorReg = registerCache.getFreeFragmentVectorTemp(), 1);\n\n\t\treturn code;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentCodePerLight(shader:LightingShader, methodVO:MethodVO, lightDirReg:ShaderRegisterElement, lightColReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = \"\";\n\t\tvar t:ShaderRegisterElement;\n\n\t\t// write in temporary if not first light, so we can add to total diffuse colour\n\t\tif (this._pIsFirstLight) {\n\t\t\tt = this._pTotalLightColorReg;\n\t\t} else {\n\t\t\tt = registerCache.getFreeFragmentVectorTemp();\n\t\t\tregisterCache.addFragmentTempUsages(t, 1);\n\t\t}\n\n\t\tcode += \"dp3 \" + t + \".x, \" + lightDirReg + \", \" + sharedRegisters.normalFragment + \"\\n\" +\n\t\t\t\t\"max \" + t + \".w, \" + t + \".x, \" + sharedRegisters.commons + \".y\\n\";\n\n\t\tif (shader.usesLightFallOff)\n\t\t\tcode += \"mul \" + t + \".w, \" + t + \".w, \" + lightDirReg + \".w\\n\";\n\n\t\tif (this._iModulateMethod != null)\n\t\t\tcode += this._iModulateMethod(shader, methodVO, t, registerCache, sharedRegisters);\n\n\t\tcode += \"mul \" + t + \", \" + t + \".w, \" + lightColReg + \"\\n\";\n\n\t\tif (!this._pIsFirstLight) {\n\t\t\tcode += \"add \" + this._pTotalLightColorReg + \".xyz, \" + this._pTotalLightColorReg + \", \" + t + \"\\n\";\n\t\t\tregisterCache.removeFragmentTempUsage(t);\n\t\t}\n\n\t\tthis._pIsFirstLight = false;\n\n\t\treturn code;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentCodePerProbe(shader:LightingShader, methodVO:MethodVO, cubeMapReg:ShaderRegisterElement, weightRegister:string, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = \"\";\n\t\tvar t:ShaderRegisterElement;\n\n\t\t// write in temporary if not first light, so we can add to total diffuse colour\n\t\tif (this._pIsFirstLight) {\n\t\t\tt = this._pTotalLightColorReg;\n\t\t} else {\n\t\t\tt = registerCache.getFreeFragmentVectorTemp();\n\t\t\tregisterCache.addFragmentTempUsages(t, 1);\n\t\t}\n\n\t\tcode += \"tex \" + t + \", \" + sharedRegisters.normalFragment + \", \" + cubeMapReg + \" <cube,linear,miplinear>\\n\" +\n\t\t\t\t\"mul \" + t + \".xyz, \" + t + \".xyz, \" + weightRegister + \"\\n\";\n\n\t\tif (this._iModulateMethod != null)\n\t\t\tcode += this._iModulateMethod(shader, methodVO, t, registerCache, sharedRegisters);\n\n\t\tif (!this._pIsFirstLight) {\n\t\t\tcode += \"add \" + this._pTotalLightColorReg + \".xyz, \" + this._pTotalLightColorReg + \", \" + t + \"\\n\";\n\t\t\tregisterCache.removeFragmentTempUsage(t);\n\t\t}\n\n\t\tthis._pIsFirstLight = false;\n\n\t\treturn code;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentPostLightingCode(shader:LightingShader, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = \"\";\n\n\t\tvar albedo:ShaderRegisterElement;\n\t\tvar cutOffReg:ShaderRegisterElement;\n\n\t\t// incorporate input from ambient\n\t\tif (sharedRegisters.shadowTarget)\n\t\t\tcode += this.pApplyShadow(shader, methodVO, registerCache, sharedRegisters);\n\n\t\tregisterCache.addFragmentTempUsages(albedo = registerCache.getFreeFragmentVectorTemp(), 1);\n\n\t\tvar ambientColorRegister:ShaderRegisterElement = registerCache.getFreeFragmentConstant();\n\t\tmethodVO.fragmentConstantsIndex = ambientColorRegister.index*4;\n\n\t\tif (this._texture) {\n\t\t\tmethodVO.textureVO._iInitRegisters(shader, registerCache);\n\n\t\t\tcode += methodVO.textureVO._iGetFragmentCode(shader, albedo, registerCache, sharedRegisters.uvVarying);\n\t\t} else {\n\t\t\tvar diffuseInputRegister:ShaderRegisterElement = registerCache.getFreeFragmentConstant();\n\n\t\t\tcode += \"mov \" + albedo + \", \" + diffuseInputRegister + \"\\n\";\n\t\t}\n\n\t\tcode += \"sat \" + this._pTotalLightColorReg + \", \" + this._pTotalLightColorReg + \"\\n\" +\n\t\t\t\"mul \" + albedo + \".xyz, \" + albedo + \", \" + this._pTotalLightColorReg + \"\\n\";\n\n\t\tif (this._multiply) {\n\t\t\tcode += \"add \" + albedo + \".xyz, \" + albedo + \", \" + ambientColorRegister + \"\\n\" +\n\t\t\t\t\"mul \" + targetReg + \".xyz, \" + targetReg + \", \" + albedo + \"\\n\";\n\t\t} else {\n\t\t\tcode += \"mul \" + targetReg + \".xyz, \" + targetReg + \", \" + ambientColorRegister + \"\\n\" +\n\t\t\t\t\"mul \" + this._pTotalLightColorReg + \".xyz, \" + targetReg + \", \" + this._pTotalLightColorReg + \"\\n\" +\n\t\t\t\t\"sub \" + targetReg + \".xyz, \" + targetReg + \", \" + this._pTotalLightColorReg + \"\\n\" +\n\t\t\t\t\"add \" + targetReg + \".xyz, \" + targetReg + \", \" + albedo + \"\\n\";\n\t\t}\n\n\t\tregisterCache.removeFragmentTempUsage(this._pTotalLightColorReg);\n\t\tregisterCache.removeFragmentTempUsage(albedo);\n\n\t\treturn code;\n\t}\n\n\t/**\n\t * Generate the code that applies the calculated shadow to the diffuse light\n\t * @param methodVO The MethodVO object for which the compilation is currently happening.\n\t * @param regCache The register cache the compiler is currently using for the register management.\n\t */\n\tpublic pApplyShadow(shader:LightingShader, methodVO:MethodVO, regCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\treturn \"mul \" + this._pTotalLightColorReg + \".xyz, \" + this._pTotalLightColorReg + \", \" + sharedRegisters.shadowTarget + \".w\\n\";\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iActivate(shader:LightingShader, methodVO:MethodVO, stage:Stage)\n\t{\n\t\tif (this._texture) {\n\t\t\tmethodVO.textureVO.activate(shader);\n\t\t} else {\n\t\t\tvar index:number = methodVO.fragmentConstantsIndex;\n\t\t\tvar data:Array<number> = shader.fragmentConstantData;\n\t\t\tdata[index + 4] = this._diffuseR;\n\t\t\tdata[index + 5] = this._diffuseG;\n\t\t\tdata[index + 6] = this._diffuseB;\n\t\t\tdata[index + 7] = 1;\n\t\t}\n\t}\n\n\t/**\n\t * Updates the diffuse color data used by the render state.\n\t */\n\tprivate updateDiffuse()\n\t{\n\t\tthis._diffuseR = ((this._diffuseColor >> 16) & 0xff)/0xff;\n\t\tthis._diffuseG = ((this._diffuseColor >> 8) & 0xff)/0xff;\n\t\tthis._diffuseB = (this._diffuseColor & 0xff)/0xff;\n\t}\n\n\t/**\n\t * Updates the ambient color data used by the render state.\n\t */\n\tprivate updateAmbient()\n\t{\n\t\tthis._ambientR = ((this._ambientColor >> 16) & 0xff)/0xff;\n\t\tthis._ambientG = ((this._ambientColor >> 8) & 0xff)/0xff;\n\t\tthis._ambientB = (this._ambientColor & 0xff)/0xff;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iSetRenderState(shader:LightingShader, methodVO:MethodVO, renderable:RenderableBase, stage:Stage, camera:Camera)\n\t{\n\t\t//TODO move this to Activate (ambientR/G/B currently calc'd in render state)\n\t\tif (shader.numLights > 0) {\n\t\t\tvar index:number = methodVO.fragmentConstantsIndex;\n\t\t\tvar data:Array<number> = shader.fragmentConstantData;\n\t\t\tdata[index] = shader.ambientR*this._ambientR;\n\t\t\tdata[index + 1] = shader.ambientG*this._ambientG;\n\t\t\tdata[index + 2] = shader.ambientB*this._ambientB;\n\t\t\tdata[index + 3] = 1;\n\t\t}\n\t}\n}\n\nexport = DiffuseBasicMethod;",
    "import Stage\t\t\t\t\t\t\t= require(\"awayjs-stagegl/lib/base/Stage\");\n\nimport LightingShader\t\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/LightingShader\");\nimport ShaderBase\t\t\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderBase\");\nimport ShaderRegisterCache\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterCache\");\nimport ShaderRegisterData\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterData\");\nimport ShaderRegisterElement\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterElement\");\n\nimport MethodVO\t\t\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/data/MethodVO\");\nimport DiffuseBasicMethod\t\t\t\t= require(\"awayjs-methodmaterials/lib/methods/DiffuseBasicMethod\");\nimport DiffuseCompositeMethod\t\t\t= require(\"awayjs-methodmaterials/lib/methods/DiffuseCompositeMethod\");\n\n/**\n * DiffuseCelMethod provides a shading method to add diffuse cel (cartoon) shading.\n */\nclass DiffuseCelMethod extends DiffuseCompositeMethod\n{\n\tprivate _levels:number /*uint*/;\n\tprivate _dataReg:ShaderRegisterElement;\n\tprivate _smoothness:number = .1;\n\n\t/**\n\t * Creates a new DiffuseCelMethod object.\n\t * @param levels The amount of shadow gradations.\n\t * @param baseMethod An optional diffuse method on which the cartoon shading is based. If omitted, DiffuseBasicMethod is used.\n\t */\n\tconstructor(levels:number /*uint*/ = 3, baseMethod:DiffuseBasicMethod = null)\n\t{\n\t\tsuper(null, baseMethod);\n\n\t\tthis.baseMethod._iModulateMethod = (shader:ShaderBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData) => this.clampDiffuse(shader, methodVO, targetReg, registerCache, sharedRegisters);\n\n\t\tthis._levels = levels;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitConstants(shader:LightingShader, methodVO:MethodVO)\n\t{\n\t\tvar data:Array<number> = shader.fragmentConstantData;\n\t\tvar index:number /*int*/ = methodVO.secondaryFragmentConstantsIndex;\n\t\tsuper.iInitConstants(shader, methodVO);\n\t\tdata[index + 1] = 1;\n\t\tdata[index + 2] = 0;\n\t}\n\n\t/**\n\t * The amount of shadow gradations.\n\t */\n\tpublic get levels():number /*uint*/\n\t{\n\t\treturn this._levels;\n\t}\n\n\tpublic set levels(value:number /*uint*/)\n\t{\n\t\tthis._levels = value;\n\t}\n\n\t/**\n\t * The smoothness of the edge between 2 shading levels.\n\t */\n\tpublic get smoothness():number\n\t{\n\t\treturn this._smoothness;\n\t}\n\n\tpublic set smoothness(value:number)\n\t{\n\t\tthis._smoothness = value;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iCleanCompilationData()\n\t{\n\t\tsuper.iCleanCompilationData();\n\t\tthis._dataReg = null;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentPreLightingCode(shader:LightingShader, methodVO:MethodVO, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tthis._dataReg = registerCache.getFreeFragmentConstant();\n\t\tmethodVO.secondaryFragmentConstantsIndex = this._dataReg.index*4;\n\n\t\treturn super.iGetFragmentPreLightingCode(shader, methodVO, registerCache, sharedRegisters);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iActivate(shader:LightingShader, methodVO:MethodVO, stage:Stage)\n\t{\n\t\tsuper.iActivate(shader, methodVO, stage);\n\t\tvar data:Array<number> = shader.fragmentConstantData;\n\t\tvar index:number /*int*/ = methodVO.secondaryFragmentConstantsIndex;\n\t\tdata[index] = this._levels;\n\t\tdata[index + 3] = this._smoothness;\n\t}\n\n\t/**\n\t * Snaps the diffuse shading of the wrapped method to one of the levels.\n\t * @param vo The MethodVO used to compile the current shader.\n\t * @param t The register containing the diffuse strength in the \"w\" component.\n\t * @param regCache The register cache used for the shader compilation.\n\t * @param sharedRegisters The shared register data for this shader.\n\t * @return The AGAL fragment code for the method.\n\t */\n\tprivate clampDiffuse(shader:ShaderBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\treturn \"mul \" + targetReg + \".w, \" + targetReg + \".w, \" + this._dataReg + \".x\\n\" +\n\t\t\t\"frc \" + targetReg + \".z, \" + targetReg + \".w\\n\" +\n\t\t\t\"sub \" + targetReg + \".y, \" + targetReg + \".w, \" + targetReg + \".z\\n\" +\n\t\t\t\"mov \" + targetReg + \".x, \" + this._dataReg + \".x\\n\" +\n\t\t\t\"sub \" + targetReg + \".x, \" + targetReg + \".x, \" + this._dataReg + \".y\\n\" +\n\t\t\t\"rcp \" + targetReg + \".x,\" + targetReg + \".x\\n\" +\n\t\t\t\"mul \" + targetReg + \".w, \" + targetReg + \".y, \" + targetReg + \".x\\n\" +\n\n\t\t\t// previous clamped strength\n\t\t\t\"sub \" + targetReg + \".y, \" + targetReg + \".w, \" + targetReg + \".x\\n\" +\n\n\t\t\t// fract/epsilon (so 0 - epsilon will become 0 - 1)\n\t\t\t\"div \" + targetReg + \".z, \" + targetReg + \".z, \" + this._dataReg + \".w\\n\" +\n\t\t\t\"sat \" + targetReg + \".z, \" + targetReg + \".z\\n\" +\n\n\t\t\t\"mul \" + targetReg + \".w, \" + targetReg + \".w, \" + targetReg + \".z\\n\" +\n\t\t\t// 1-z\n\t\t\t\"sub \" + targetReg + \".z, \" + this._dataReg + \".y, \" + targetReg + \".z\\n\" +\n\t\t\t\"mul \" + targetReg + \".y, \" + targetReg + \".y, \" + targetReg + \".z\\n\" +\n\t\t\t\"add \" + targetReg + \".w, \" + targetReg + \".w, \" + targetReg + \".y\\n\" +\n\t\t\t\"sat \" + targetReg + \".w, \" + targetReg + \".w\\n\";\n\t}\n}\n\nexport = DiffuseCelMethod;",
    "import Camera\t\t\t\t\t\t\t= require(\"awayjs-display/lib/entities/Camera\");\nimport TextureBase\t\t\t\t\t\t= require(\"awayjs-display/lib/textures/TextureBase\");\n\nimport Stage\t\t\t\t\t\t\t= require(\"awayjs-stagegl/lib/base/Stage\");\n\nimport LightingShader\t\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/LightingShader\");\nimport ShaderBase\t\t\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderBase\");\nimport ShaderRegisterCache\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterCache\");\nimport ShaderRegisterData\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterData\");\nimport ShaderRegisterElement\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterElement\");\nimport ShadingMethodEvent\t\t\t\t= require(\"awayjs-renderergl/lib/events/ShadingMethodEvent\");\nimport RenderableBase\t\t\t\t\t= require(\"awayjs-renderergl/lib/renderables/RenderableBase\");\n\nimport MethodVO\t\t\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/data/MethodVO\");\nimport DiffuseBasicMethod\t\t\t\t= require(\"awayjs-methodmaterials/lib/methods/DiffuseBasicMethod\");\n\n/**\n * DiffuseCompositeMethod provides a base class for diffuse methods that wrap a diffuse method to alter the\n * calculated diffuse reflection strength.\n */\nclass DiffuseCompositeMethod extends DiffuseBasicMethod\n{\n\tpublic pBaseMethod:DiffuseBasicMethod;\n\n\tprivate _onShaderInvalidatedDelegate:Function;\n\n\t/**\n\t * Creates a new <code>DiffuseCompositeMethod</code> object.\n\t *\n\t * @param modulateMethod The method which will add the code to alter the base method's strength. It needs to have the signature clampDiffuse(t:ShaderRegisterElement, regCache:ShaderRegisterCache):string, in which t.w will contain the diffuse strength.\n\t * @param baseMethod The base diffuse method on which this method's shading is based.\n\t */\n\tconstructor(modulateMethod:(shader:ShaderBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData) => string, baseMethod:DiffuseBasicMethod = null)\n\t{\n\t\tsuper();\n\n\t\tthis._onShaderInvalidatedDelegate = (event:ShadingMethodEvent) => this.onShaderInvalidated(event);\n\n\t\tthis.pBaseMethod = baseMethod || new DiffuseBasicMethod();\n\t\tthis.pBaseMethod._iModulateMethod = modulateMethod;\n\t\tthis.pBaseMethod.addEventListener(ShadingMethodEvent.SHADER_INVALIDATED, this._onShaderInvalidatedDelegate);\n\t}\n\n\t/**\n\t * The base diffuse method on which this method's shading is based.\n\t */\n\tpublic get baseMethod():DiffuseBasicMethod\n\t{\n\t\treturn this.pBaseMethod;\n\t}\n\n\tpublic set baseMethod(value:DiffuseBasicMethod)\n\t{\n\t\tif (this.pBaseMethod == value)\n\t\t\treturn;\n\n\t\tthis.pBaseMethod.removeEventListener(ShadingMethodEvent.SHADER_INVALIDATED, this._onShaderInvalidatedDelegate);\n\t\tthis.pBaseMethod = value;\n\t\tthis.pBaseMethod.addEventListener(ShadingMethodEvent.SHADER_INVALIDATED, this._onShaderInvalidatedDelegate);\n\t\tthis.iInvalidateShaderProgram();\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitVO(shader:LightingShader, methodVO:MethodVO)\n\t{\n\t\tthis.pBaseMethod.iInitVO(shader, methodVO);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitConstants(shader:LightingShader, methodVO:MethodVO)\n\t{\n\t\tthis.pBaseMethod.iInitConstants(shader, methodVO);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic dispose()\n\t{\n\t\tthis.pBaseMethod.removeEventListener(ShadingMethodEvent.SHADER_INVALIDATED, this._onShaderInvalidatedDelegate);\n\t\tthis.pBaseMethod.dispose();\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic get texture():TextureBase\n\t{\n\t\treturn this.pBaseMethod.texture;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic set texture(value:TextureBase)\n\t{\n\t\tthis.pBaseMethod.texture = value;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic get diffuseColor():number\n\t{\n\t\treturn this.pBaseMethod.diffuseColor;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic set diffuseColor(value:number)\n\t{\n\t\tthis.pBaseMethod.diffuseColor = value;\n\t}\n\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic get ambientColor():number\n\t{\n\t\treturn this.pBaseMethod.ambientColor;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic set ambientColor(value:number)\n\t{\n\t\tthis.pBaseMethod.ambientColor = value;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentPreLightingCode(shader:LightingShader, methodVO:MethodVO, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\treturn this.pBaseMethod.iGetFragmentPreLightingCode(shader, methodVO, registerCache, sharedRegisters);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentCodePerLight(shader:LightingShader, methodVO:MethodVO, lightDirReg:ShaderRegisterElement, lightColReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = this.pBaseMethod.iGetFragmentCodePerLight(shader, methodVO, lightDirReg, lightColReg, registerCache, sharedRegisters);\n\t\tthis._pTotalLightColorReg = this.pBaseMethod._pTotalLightColorReg;\n\t\treturn code;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentCodePerProbe(shader:LightingShader, methodVO:MethodVO, cubeMapReg:ShaderRegisterElement, weightRegister:string, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = this.pBaseMethod.iGetFragmentCodePerProbe(shader, methodVO, cubeMapReg, weightRegister, registerCache, sharedRegisters);\n\t\tthis._pTotalLightColorReg = this.pBaseMethod._pTotalLightColorReg;\n\t\treturn code;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iActivate(shader:LightingShader, methodVO:MethodVO, stage:Stage)\n\t{\n\t\tthis.pBaseMethod.iActivate(shader, methodVO, stage);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iSetRenderState(shader:LightingShader, methodVO:MethodVO, renderable:RenderableBase, stage:Stage, camera:Camera)\n\t{\n\t\tthis.pBaseMethod.iSetRenderState(shader, methodVO, renderable, stage, camera);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iDeactivate(shader:LightingShader, methodVO:MethodVO, stage:Stage)\n\t{\n\t\tthis.pBaseMethod.iDeactivate(shader, methodVO, stage);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetVertexCode(shader:ShaderBase, methodVO:MethodVO, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\treturn this.pBaseMethod.iGetVertexCode(shader, methodVO, registerCache, sharedRegisters);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentPostLightingCode(shader:LightingShader, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\treturn this.pBaseMethod.iGetFragmentPostLightingCode(shader, methodVO, targetReg, registerCache, sharedRegisters);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iReset()\n\t{\n\t\tthis.pBaseMethod.iReset();\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iCleanCompilationData()\n\t{\n\t\tsuper.iCleanCompilationData();\n\t\tthis.pBaseMethod.iCleanCompilationData();\n\t}\n\n\t/**\n\t * Called when the base method's shader code is invalidated.\n\t */\n\tprivate onShaderInvalidated(event:ShadingMethodEvent)\n\t{\n\t\tthis.iInvalidateShaderProgram();\n\t}\n}\n\nexport = DiffuseCompositeMethod;",
    "import LightingShader\t\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/LightingShader\");\nimport ShaderBase\t\t\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderBase\");\nimport ShaderRegisterCache\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterCache\");\nimport ShaderRegisterData\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterData\");\nimport ShaderRegisterElement\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterElement\");\n\nimport MethodVO\t\t\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/data/MethodVO\");\nimport DiffuseBasicMethod\t\t\t\t= require(\"awayjs-methodmaterials/lib/methods/DiffuseBasicMethod\");\n\n/**\n * DiffuseDepthMethod provides a debug method to visualise depth maps\n */\nclass DiffuseDepthMethod extends DiffuseBasicMethod\n{\n\t/**\n\t * Creates a new DiffuseBasicMethod object.\n\t */\n\tconstructor()\n\t{\n\t\tsuper();\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitConstants(shader:ShaderBase, methodVO:MethodVO)\n\t{\n\t\tvar data:Array<number> = shader.fragmentConstantData;\n\t\tvar index:number /*int*/ = methodVO.fragmentConstantsIndex;\n\t\tdata[index] = 1.0;\n\t\tdata[index + 1] = 1/255.0;\n\t\tdata[index + 2] = 1/65025.0;\n\t\tdata[index + 3] = 1/16581375.0;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentPostLightingCode(shader:LightingShader, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = \"\";\n\t\tvar temp:ShaderRegisterElement;\n\t\tvar decReg:ShaderRegisterElement;\n\n\t\tif (!this._texture)\n\t\t\tthrow new Error(\"DiffuseDepthMethod requires texture!\");\n\n\t\t// incorporate input from ambient\n\t\tif (shader.numLights > 0) {\n\t\t\tif (sharedRegisters.shadowTarget)\n\t\t\t\tcode += \"mul \" + this._pTotalLightColorReg + \".xyz, \" + this._pTotalLightColorReg + \".xyz, \" + sharedRegisters.shadowTarget + \".w\\n\";\n\t\t\tcode += \"add \" + targetReg + \".xyz, \" + this._pTotalLightColorReg + \".xyz, \" + targetReg + \".xyz\\n\" +\n\t\t\t\t\"sat \" + targetReg + \".xyz, \" + targetReg + \".xyz\\n\";\n\t\t\tregisterCache.removeFragmentTempUsage(this._pTotalLightColorReg);\n\t\t\tregisterCache.addFragmentTempUsages(temp = registerCache.getFreeFragmentVectorTemp(), 1);\n\t\t} else {\n\t\t\ttemp = targetReg;\n\t\t}\n\n\t\tdecReg = registerCache.getFreeFragmentConstant();\n\t\tmethodVO.fragmentConstantsIndex = decReg.index*4;\n\n\t\tmethodVO.textureVO._iInitRegisters(shader, registerCache);\n\n\t\tcode += methodVO.textureVO._iGetFragmentCode(shader, temp, registerCache, sharedRegisters.uvVarying) +\n\t\t\t\"dp4 \" + temp + \".x, \" + temp + \", \" + decReg + \"\\n\" +\n\t\t\t\"mov \" + temp + \".yz, \" + temp + \".xx\t\t\t\\n\" +\n\t\t\t\"mov \" + temp + \".w, \" + decReg + \".x\\n\" +\n\t\t\t\"sub \" + temp + \".xyz, \" + decReg + \".xxx, \" + temp + \".xyz\\n\";\n\n\t\tif (shader.numLights == 0)\n\t\t\treturn code;\n\n\t\tcode += \"mul \" + targetReg + \".xyz, \" + temp + \".xyz, \" + targetReg + \".xyz\\n\" +\n\t\t\t\"mov \" + targetReg + \".w, \" + temp + \".w\\n\";\n\n\t\tif (shader.numLights > 0)\n\t\t\tregisterCache.removeFragmentTempUsage(temp);\n\n\t\treturn code;\n\t}\n}\n\nexport = DiffuseDepthMethod;",
    "import TextureBase\t\t\t\t\t\t= require(\"awayjs-display/lib/textures/TextureBase\");\n\nimport Stage\t\t\t\t\t\t\t= require(\"awayjs-stagegl/lib/base/Stage\");\n\nimport LightingShader\t\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/LightingShader\");\nimport ShaderRegisterCache\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterCache\");\nimport ShaderRegisterData\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterData\");\nimport ShaderRegisterElement\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterElement\");\n\nimport MethodVO\t\t\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/data/MethodVO\");\nimport DiffuseBasicMethod\t\t\t\t= require(\"awayjs-methodmaterials/lib/methods/DiffuseBasicMethod\");\n\n/**\n * DiffuseGradientMethod is an alternative to DiffuseBasicMethod in which the shading can be modulated with a gradient\n * to introduce color-tinted shading as opposed to the single-channel diffuse strength. This can be used as a crude\n * approximation to subsurface scattering (for instance, the mid-range shading for skin can be tinted red to similate\n * scattered light within the skin attributing to the final colour)\n */\nclass DiffuseGradientMethod extends DiffuseBasicMethod\n{\n\tprivate _gradient:TextureBase;\n\n\t/**\n\t * Creates a new DiffuseGradientMethod object.\n\t * @param gradient A texture that contains the light colour based on the angle. This can be used to change\n\t * the light colour due to subsurface scattering when the surface faces away from the light.\n\t */\n\tconstructor(gradient:TextureBase)\n\t{\n\t\tsuper();\n\n\t\tthis._gradient = gradient;\n\t}\n\n\tpublic iInitVO(shader:LightingShader, methodVO:MethodVO)\n\t{\n\t\tsuper.iInitVO(shader, methodVO);\n\n\t\tmethodVO.secondaryTextureVO = shader.getTextureVO(this._gradient);\n\t}\n\n\t/**\n\t * A texture that contains the light colour based on the angle. This can be used to change the light colour\n\t * due to subsurface scattering when the surface faces away from the light.\n\t */\n\tpublic get gradient():TextureBase\n\t{\n\t\treturn this._gradient;\n\t}\n\n\tpublic set gradient(value:TextureBase)\n\t{\n\t\tif (this._gradient == value)\n\t\t\treturn;\n\n\t\tthis._gradient = value;\n\n\t\tthis.iInvalidateShaderProgram();\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iCleanCompilationData()\n\t{\n\t\tsuper.iCleanCompilationData();\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentPreLightingCode(shader:LightingShader, methodVO:MethodVO, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = super.iGetFragmentPreLightingCode(shader, methodVO, registerCache, sharedRegisters);\n\t\tthis._pIsFirstLight = true;\n\n\t\tif (shader.numLights > 0)\n\t\t\tmethodVO.secondaryTextureVO._iInitRegisters(shader, registerCache);\n\n\t\treturn code;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentCodePerLight(shader:LightingShader, methodVO:MethodVO, lightDirReg:ShaderRegisterElement, lightColReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = \"\";\n\t\tvar t:ShaderRegisterElement;\n\n\t\t// write in temporary if not first light, so we can add to total diffuse colour\n\t\tif (this._pIsFirstLight)\n\t\t\tt = this._pTotalLightColorReg;\n\t\telse {\n\t\t\tt = registerCache.getFreeFragmentVectorTemp();\n\t\t\tregisterCache.addFragmentTempUsages(t, 1);\n\t\t}\n\n\t\tcode += \"dp3 \" + t + \".w, \" + lightDirReg + \".xyz, \" + sharedRegisters.normalFragment + \".xyz\\n\" +\n\t\t\t\"mul \" + t + \".w, \" + t + \".w, \" + sharedRegisters.commons + \".x\\n\" +\n\t\t\t\"add \" + t + \".w, \" + t + \".w, \" + sharedRegisters.commons + \".x\\n\" +\n\t\t\t\"mul \" + t + \".xyz, \" + t + \".w, \" + lightDirReg + \".w\\n\";\n\n\t\tif (this._iModulateMethod != null)\n\t\t\tcode += this._iModulateMethod(shader, methodVO, t, registerCache, sharedRegisters);\n\n\t\tcode += methodVO.secondaryTextureVO._iGetFragmentCode(shader, t, registerCache, t) +\n\t\t\t//\t\t\t\t\t\"mul \" + t + \".xyz, \" + t + \".xyz, \" + t + \".w\\n\" +\n\t\t\t\"mul \" + t + \".xyz, \" + t + \".xyz, \" + lightColReg + \".xyz\\n\";\n\n\t\tif (!this._pIsFirstLight) {\n\t\t\tcode += \"add \" + this._pTotalLightColorReg + \".xyz, \" + this._pTotalLightColorReg + \".xyz, \" + t + \".xyz\\n\";\n\t\t\tregisterCache.removeFragmentTempUsage(t);\n\t\t}\n\n\t\tthis._pIsFirstLight = false;\n\n\t\treturn code;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic pApplyShadow(shader:LightingShader, methodVO:MethodVO, regCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar t:ShaderRegisterElement = regCache.getFreeFragmentVectorTemp();\n\n\t\treturn \"mov \" + t + \", \" + sharedRegisters.shadowTarget + \".wwww\\n\" +\n\t\t\tmethodVO.secondaryTextureVO._iGetFragmentCode(shader, t, regCache, sharedRegisters.uvVarying) +\n\t\t\t\"mul \" + this._pTotalLightColorReg + \".xyz, \" + this._pTotalLightColorReg + \", \" + t + \"\\n\";\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iActivate(shader:LightingShader, methodVO:MethodVO, stage:Stage)\n\t{\n\t\tsuper.iActivate(shader, methodVO, stage);\n\n\t\tmethodVO.secondaryTextureVO.activate(shader);\n\t}\n}\n\nexport = DiffuseGradientMethod;",
    "import TextureBase\t\t\t\t\t\t= require(\"awayjs-display/lib/textures/TextureBase\");\n\nimport Stage\t\t\t\t\t\t\t= require(\"awayjs-stagegl/lib/base/Stage\");\n\nimport LightingShader\t\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/LightingShader\");\nimport ShaderRegisterCache\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterCache\");\nimport ShaderRegisterData\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterData\");\nimport ShaderRegisterElement\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterElement\");\n\nimport MethodVO\t\t\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/data/MethodVO\");\nimport DiffuseBasicMethod\t\t\t\t= require(\"awayjs-methodmaterials/lib/methods/DiffuseBasicMethod\");\nimport DiffuseCompositeMethod\t\t\t= require(\"awayjs-methodmaterials/lib/methods/DiffuseCompositeMethod\");\n\n/**\n * DiffuseLightMapMethod provides a diffuse shading method that uses a light map to modulate the calculated diffuse\n * lighting. It is different from EffectLightMapMethod in that the latter modulates the entire calculated pixel color, rather\n * than only the diffuse lighting value.\n */\nclass DiffuseLightMapMethod extends DiffuseCompositeMethod\n{\n\t/**\n\t * Indicates the light map should be multiplied with the calculated shading result.\n\t * This can be used to add pre-calculated shadows or occlusion.\n\t */\n\tpublic static MULTIPLY:string = \"multiply\";\n\n\t/**\n\t * Indicates the light map should be added into the calculated shading result.\n\t * This can be used to add pre-calculated lighting or global illumination.\n\t */\n\tpublic static ADD:string = \"add\";\n\n\tprivate _lightMap:TextureBase;\n\tprivate _blendMode:string;\n\tprivate _useSecondaryUV:boolean;\n\n\t/**\n\t * Creates a new DiffuseLightMapMethod method.\n\t *\n\t * @param lightMap The texture containing the light map.\n\t * @param blendMode The blend mode with which the light map should be applied to the lighting result.\n\t * @param useSecondaryUV Indicates whether the secondary UV set should be used to map the light map.\n\t * @param baseMethod The diffuse method used to calculate the regular diffuse-based lighting.\n\t */\n\tconstructor(lightMap:TextureBase, blendMode:string = \"multiply\", useSecondaryUV:boolean = false, baseMethod:DiffuseBasicMethod = null)\n\t{\n\t\tsuper(null, baseMethod);\n\n\t\tthis._useSecondaryUV = useSecondaryUV;\n\t\tthis._lightMap = lightMap;\n\t\tthis.blendMode = blendMode;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitVO(shader:LightingShader, methodVO:MethodVO)\n\t{\n\t\tmethodVO.secondaryTextureVO = shader.getTextureVO(this._lightMap);\n\n\t\tif (this._useSecondaryUV)\n\t\t\tshader.secondaryUVDependencies++;\n\t\telse\n\t\t\tshader.uvDependencies++;\n\t}\n\n\t/**\n\t * The blend mode with which the light map should be applied to the lighting result.\n\t *\n\t * @see DiffuseLightMapMethod.ADD\n\t * @see DiffuseLightMapMethod.MULTIPLY\n\t */\n\tpublic get blendMode():string\n\t{\n\t\treturn this._blendMode;\n\t}\n\n\tpublic set blendMode(value:string)\n\t{\n\t\tif (value != DiffuseLightMapMethod.ADD && value != DiffuseLightMapMethod.MULTIPLY)\n\t\t\tthrow new Error(\"Unknown blendmode!\");\n\n\t\tif (this._blendMode == value)\n\t\t\treturn;\n\n\t\tthis._blendMode = value;\n\n\t\tthis.iInvalidateShaderProgram();\n\t}\n\n\t/**\n\t * The texture containing the light map data.\n\t */\n\tpublic get lightMap():TextureBase\n\t{\n\t\treturn this._lightMap;\n\t}\n\n\tpublic set lightMap(value:TextureBase)\n\t{\n\t\tif (this._lightMap == value)\n\t\t\treturn;\n\n\t\tthis._lightMap = value;\n\n\t\tthis.iInvalidateShaderProgram();\n\t}\n\n\t/**\n\t * Indicates whether the secondary UV set should be used to map the light map.\n\t */\n\tpublic get useSecondaryUV():boolean\n\t{\n\t\treturn this._useSecondaryUV;\n\t}\n\n\tpublic set useSecondaryUV(value:boolean)\n\t{\n\t\tif (this._useSecondaryUV == value)\n\t\t\treturn;\n\n\t\tthis._useSecondaryUV = value;\n\n\t\tthis.iInvalidateShaderProgram();\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentPostLightingCode(shader:LightingShader, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string;\n\t\tvar temp:ShaderRegisterElement = registerCache.getFreeFragmentVectorTemp();\n\n\t\tmethodVO.secondaryTextureVO._iInitRegisters(shader, registerCache);\n\n\t\tcode = methodVO.secondaryTextureVO._iGetFragmentCode(shader, temp, registerCache, this._useSecondaryUV? sharedRegisters.secondaryUVVarying : sharedRegisters.uvVarying);\n\n\t\tswitch (this._blendMode) {\n\t\t\tcase DiffuseLightMapMethod.MULTIPLY:\n\t\t\t\tcode += \"mul \" + this._pTotalLightColorReg + \", \" + this._pTotalLightColorReg + \", \" + temp + \"\\n\";\n\t\t\t\tbreak;\n\t\t\tcase DiffuseLightMapMethod.ADD:\n\t\t\t\tcode += \"add \" + this._pTotalLightColorReg + \", \" + this._pTotalLightColorReg + \", \" + temp + \"\\n\";\n\t\t\t\tbreak;\n\t\t}\n\n\t\tcode += super.iGetFragmentPostLightingCode(shader, methodVO, targetReg, registerCache, sharedRegisters);\n\n\t\treturn code;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iActivate(shader:LightingShader, methodVO:MethodVO, stage:Stage)\n\t{\n\t\tsuper.iActivate(shader, methodVO, stage);\n\n\t\tmethodVO.secondaryTextureVO.activate(shader);\n\t}\n}\n\nexport = DiffuseLightMapMethod;",
    "import Camera\t\t\t\t\t\t\t= require(\"awayjs-display/lib/entities/Camera\");\n\nimport Stage\t\t\t\t\t\t\t= require(\"awayjs-stagegl/lib/base/Stage\");\n\nimport LightingShader\t\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/LightingShader\");\nimport ShaderBase\t\t\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderBase\");\nimport ShaderRegisterCache\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterCache\");\nimport ShaderRegisterData\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterData\");\nimport ShaderRegisterElement\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterElement\");\nimport RenderableBase\t\t\t\t\t= require(\"awayjs-renderergl/lib/renderables/RenderableBase\");\n\nimport MethodVO\t\t\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/data/MethodVO\");\nimport DiffuseBasicMethod\t\t\t\t= require(\"awayjs-methodmaterials/lib/methods/DiffuseBasicMethod\");\nimport DiffuseCompositeMethod\t\t\t= require(\"awayjs-methodmaterials/lib/methods/DiffuseCompositeMethod\");\nimport SingleObjectDepthPass\t\t\t= require(\"awayjs-methodmaterials/lib/render/passes/SingleObjectDepthPass\");\n\n/**\n * DiffuseSubSurfaceMethod provides a depth map-based diffuse shading method that mimics the scattering of\n * light inside translucent surfaces. It allows light to shine through an object and to soften the diffuse shading.\n * It can be used for candle wax, ice, skin, ...\n */\nclass DiffuseSubSurfaceMethod extends DiffuseCompositeMethod\n{\n\tprivate _depthPass:SingleObjectDepthPass;\n\tprivate _lightProjVarying:ShaderRegisterElement;\n\tprivate _propReg:ShaderRegisterElement;\n\tprivate _scattering:number;\n\tprivate _translucency:number = 1;\n\tprivate _lightColorReg:ShaderRegisterElement;\n\tprivate _scatterColor:number /*uint*/ = 0xffffff;\n\tprivate _colorReg:ShaderRegisterElement;\n\tprivate _decReg:ShaderRegisterElement;\n\tprivate _scatterR:number = 1.0;\n\tprivate _scatterG:number = 1.0;\n\tprivate _scatterB:number = 1.0;\n\tprivate _targetReg:ShaderRegisterElement;\n\t\n\t/**\n\t * Creates a new <code>DiffuseSubSurfaceMethod</code> object.\n\t *\n\t * @param depthMapSize The size of the depth map used.\n\t * @param depthMapOffset The amount by which the rendered object will be inflated, to prevent depth map rounding errors.\n\t * @param baseMethod The diffuse method used to calculate the regular diffuse-based lighting.\n\t */\n\tconstructor(depthMapSize:number /*int*/ = 512, depthMapOffset:number = 15, baseMethod:DiffuseBasicMethod = null)\n\t{\n\t\tsuper(null, baseMethod);\n\n\t\tthis.pBaseMethod._iModulateMethod = (shader:ShaderBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData) => this.scatterLight(shader, methodVO, targetReg, registerCache, sharedRegisters);\n\n\t\t//this._passes = new Array<MaterialPassGLBase>();\n\t\t//this._depthPass = new SingleObjectDepthPass();\n\t\t//this._depthPass.textureSize = depthMapSize;\n\t\t//this._depthPass.polyOffset = depthMapOffset;\n\t\t//this._passes.push(this._depthPass);\n\t\tthis._scattering = 0.2;\n\t\tthis._translucency = 1;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitConstants(shader:LightingShader, methodVO:MethodVO)\n\t{\n\t\tsuper.iInitConstants(shader, methodVO);\n\n\t\tvar data:Array<number> = shader.vertexConstantData;\n\t\tvar index:number /*int*/ = methodVO.secondaryVertexConstantsIndex;\n\t\tdata[index] = .5;\n\t\tdata[index + 1] = -.5;\n\t\tdata[index + 2] = 0;\n\t\tdata[index + 3] = 1;\n\t\t\n\t\tdata = shader.fragmentConstantData;\n\t\tindex = methodVO.secondaryFragmentConstantsIndex;\n\t\tdata[index + 3] = 1.0;\n\t\tdata[index + 4] = 1.0;\n\t\tdata[index + 5] = 1/255;\n\t\tdata[index + 6] = 1/65025;\n\t\tdata[index + 7] = 1/16581375;\n\t\tdata[index + 10] = .5;\n\t\tdata[index + 11] = -.1;\n\t}\n\t\n\tpublic iCleanCompilationData()\n\t{\n\t\tsuper.iCleanCompilationData();\n\n\t\tthis._lightProjVarying = null;\n\t\tthis._propReg = null;\n\t\tthis._lightColorReg = null;\n\t\tthis._colorReg = null;\n\t\tthis._decReg = null;\n\t\tthis._targetReg = null;\n\t}\n\t\n\t/**\n\t * The amount by which the light scatters. It can be used to set the translucent surface's thickness. Use low\n\t * values for skin.\n\t */\n\tpublic get scattering():number\n\t{\n\t\treturn this._scattering;\n\t}\n\t\n\tpublic set scattering(value:number)\n\t{\n\t\tthis._scattering = value;\n\t}\n\t\n\t/**\n\t * The translucency of the object.\n\t */\n\tpublic get translucency():number\n\t{\n\t\treturn this._translucency;\n\t}\n\t\n\tpublic set translucency(value:number)\n\t{\n\t\tthis._translucency = value;\n\t}\n\t\n\t/**\n\t * The colour of the \"insides\" of the object, ie: the colour the light becomes after leaving the object.\n\t */\n\tpublic get scatterColor():number /*uint*/\n\t{\n\t\treturn this._scatterColor;\n\t}\n\t\n\tpublic set scatterColor(scatterColor:number /*uint*/)\n\t{\n\t\tthis._scatterColor = scatterColor;\n\t\tthis._scatterR = ((scatterColor >> 16) & 0xff)/0xff;\n\t\tthis._scatterG = ((scatterColor >> 8) & 0xff)/0xff;\n\t\tthis._scatterB = (scatterColor & 0xff)/0xff;\n\t}\n\t\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetVertexCode(shader:ShaderBase, methodVO:MethodVO, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = super.iGetVertexCode(shader, methodVO, registerCache, sharedRegisters);\n\t\tvar lightProjection:ShaderRegisterElement;\n\t\tvar toTexRegister:ShaderRegisterElement;\n\t\tvar temp:ShaderRegisterElement = registerCache.getFreeVertexVectorTemp();\n\t\t\n\t\ttoTexRegister = registerCache.getFreeVertexConstant();\n\t\tmethodVO.secondaryVertexConstantsIndex = toTexRegister.index*4;\n\n\t\tthis._lightProjVarying = registerCache.getFreeVarying();\n\t\tlightProjection = registerCache.getFreeVertexConstant();\n\t\tregisterCache.getFreeVertexConstant();\n\t\tregisterCache.getFreeVertexConstant();\n\t\tregisterCache.getFreeVertexConstant();\n\t\t\n\t\tcode += \"m44 \" + temp + \", vt0, \" + lightProjection + \"\\n\" +\n\t\t\t\"div \" + temp + \".xyz, \" + temp + \".xyz, \" + temp + \".w\\n\" +\n\t\t\t\"mul \" + temp + \".xy, \" + temp + \".xy, \" + toTexRegister + \".xy\\n\" +\n\t\t\t\"add \" + temp + \".xy, \" + temp + \".xy, \" + toTexRegister + \".xx\\n\" +\n\t\t\t\"mov \" + this._lightProjVarying + \".xyz, \" + temp + \".xyz\\n\" +\n\t\t\t\"mov \" + this._lightProjVarying + \".w, va0.w\\n\";\n\t\t\n\t\treturn code;\n\t}\n\t\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentPreLightingCode(shader:LightingShader, methodVO:MethodVO, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tthis._colorReg = registerCache.getFreeFragmentConstant();\n\t\tthis._decReg = registerCache.getFreeFragmentConstant();\n\t\tthis._propReg = registerCache.getFreeFragmentConstant();\n\t\tmethodVO.secondaryFragmentConstantsIndex = this._colorReg.index*4;\n\t\t\n\t\treturn super.iGetFragmentPreLightingCode(shader, methodVO, registerCache, sharedRegisters);\n\t}\n\t\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentCodePerLight(shader:LightingShader, methodVO:MethodVO, lightDirReg:ShaderRegisterElement, lightColReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tthis._pIsFirstLight = true;\n\t\tthis._lightColorReg = lightColReg;\n\t\treturn super.iGetFragmentCodePerLight(shader, methodVO, lightDirReg, lightColReg, registerCache, sharedRegisters);\n\t}\n\t\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentPostLightingCode(shader:LightingShader, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = super.iGetFragmentPostLightingCode(shader, methodVO, targetReg, registerCache, sharedRegisters);\n\t\tvar temp:ShaderRegisterElement = registerCache.getFreeFragmentVectorTemp();\n\t\t\n\t\tcode += \"mul \" + temp + \".xyz, \" + this._lightColorReg + \".xyz, \" + this._targetReg + \".w\\n\" +\n\t\t\t\"mul \" + temp + \".xyz, \" + temp + \".xyz, \" + this._colorReg + \".xyz\\n\" +\n\t\t\t\"add \" + targetReg + \".xyz, \" + targetReg + \".xyz, \" + temp + \".xyz\\n\";\n\t\t\n\t\tif (this._targetReg != sharedRegisters.viewDirFragment)\n\t\t\tregisterCache.removeFragmentTempUsage(targetReg);\n\t\t\n\t\treturn code;\n\t}\n\t\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iActivate(shader:LightingShader, methodVO:MethodVO, stage:Stage)\n\t{\n\t\tsuper.iActivate(shader, methodVO, stage);\n\n\t\tvar index:number /*int*/ = methodVO.secondaryFragmentConstantsIndex;\n\t\tvar data:Array<number> = shader.fragmentConstantData;\n\t\tdata[index] = this._scatterR;\n\t\tdata[index + 1] = this._scatterG;\n\t\tdata[index + 2] = this._scatterB;\n\t\tdata[index + 8] = this._scattering;\n\t\tdata[index + 9] = this._translucency;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iSetRenderState(shader:ShaderBase, methodVO:MethodVO, renderable:RenderableBase, stage:Stage, camera:Camera)\n\t{\n\t\tmethodVO.secondaryTextureVO = shader.getTextureVO(this._depthPass._iGetDepthMap(renderable));\n\t\tmethodVO.secondaryTextureVO.activate(shader);\n\n\t\tthis._depthPass._iGetProjection(renderable).copyRawDataTo(shader.vertexConstantData, methodVO.secondaryVertexConstantsIndex + 4, true);\n\t}\n\t\n\t/**\n\t * Generates the code for this method\n\t */\n\tprivate scatterLight(shader:ShaderBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\t// only scatter first light\n\t\tif (!this._pIsFirstLight)\n\t\t\treturn \"\";\n\n\t\tthis._pIsFirstLight = false;\n\n\t\tvar code:string = \"\";\n\n\t\tif (sharedRegisters.viewDirFragment)\n\t\t\tthis._targetReg = sharedRegisters.viewDirFragment;\n\t\telse\n\t\t\tregisterCache.addFragmentTempUsages(this._targetReg = registerCache.getFreeFragmentVectorTemp(), 1);\n\n\t\tvar temp:ShaderRegisterElement = registerCache.getFreeFragmentVectorTemp();\n\n\t\tcode += methodVO.secondaryTextureVO._iGetFragmentCode(shader, temp, registerCache, this._lightProjVarying) +\n\t\t\t// reencode RGBA\n\t\t\t\"dp4 \" + targetReg + \".z, \" + temp + \", \" + this._decReg + \"\\n\";\n\t\t// currentDistanceToLight - closestDistanceToLight\n\t\tcode += \"sub \" + targetReg + \".z, \" + this._lightProjVarying + \".z, \" + targetReg + \".z\\n\" +\n\t\t\t\n\t\t\t\"sub \" + targetReg + \".z, \" + this._propReg + \".x, \" + targetReg + \".z\\n\" +\n\t\t\t\"mul \" + targetReg + \".z, \" + this._propReg + \".y, \" + targetReg + \".z\\n\" +\n\t\t\t\"sat \" + targetReg + \".z, \" + targetReg + \".z\\n\" +\n\t\t\t\n\t\t\t// targetReg.x contains dot(lightDir, normal)\n\t\t\t// modulate according to incident light angle (scatter = scatter*(-.5*dot(light, normal) + .5)\n\t\t\t\"neg \" + targetReg + \".y, \" + targetReg + \".x\\n\" +\n\t\t\t\"mul \" + targetReg + \".y, \" + targetReg + \".y, \" + this._propReg + \".z\\n\" +\n\t\t\t\"add \" + targetReg + \".y, \" + targetReg + \".y, \" + this._propReg + \".z\\n\" +\n\t\t\t\"mul \" + this._targetReg + \".w, \" + targetReg + \".z, \" + targetReg + \".y\\n\" +\n\t\t\t\n\t\t\t// blend diffuse: d' = (1-s)*d + s*1\n\t\t\t\"sub \" + targetReg + \".y, \" + this._colorReg + \".w, \" + this._targetReg + \".w\\n\" +\n\t\t\t\"mul \" + targetReg + \".w, \" + targetReg + \".w, \" + targetReg + \".y\\n\";\n\t\t\n\t\treturn code;\n\t}\n}\n\nexport = DiffuseSubSurfaceMethod;",
    "import Stage\t\t\t\t\t\t\t= require(\"awayjs-stagegl/lib/base/Stage\");\n\nimport LightingShader\t\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/LightingShader\");\nimport ShaderRegisterCache\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterCache\");\nimport ShaderRegisterData\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterData\");\nimport ShaderRegisterElement\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterElement\");\n\nimport MethodVO\t\t\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/data/MethodVO\");\nimport DiffuseBasicMethod\t\t\t\t= require(\"awayjs-methodmaterials/lib/methods/DiffuseBasicMethod\");\n\n/**\n * DiffuseWrapMethod is an alternative to DiffuseBasicMethod in which the light is allowed to be \"wrapped around\" the normally dark area, to some extent.\n * It can be used as a crude approximation to Oren-Nayar or simple subsurface scattering.\n */\nclass DiffuseWrapMethod extends DiffuseBasicMethod\n{\n\tprivate _wrapDataRegister:ShaderRegisterElement;\n\tprivate _wrapFactor:number;\n\n\t/**\n\t * Creates a new DiffuseWrapMethod object.\n\t * @param wrapFactor A factor to indicate the amount by which the light is allowed to wrap\n\t */\n\tconstructor(wrapFactor:number = .5)\n\t{\n\t\tsuper();\n\n\t\tthis.wrapFactor = wrapFactor;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iCleanCompilationData()\n\t{\n\t\tsuper.iCleanCompilationData();\n\n\t\tthis._wrapDataRegister = null;\n\t}\n\n\t/**\n\t * A factor to indicate the amount by which the light is allowed to wrap.\n\t */\n\tpublic get wrapFactor():number\n\t{\n\t\treturn this._wrapFactor;\n\t}\n\n\tpublic set wrapFactor(value:number)\n\t{\n\t\tthis._wrapFactor = value;\n\t\tthis._wrapFactor = 1/(value + 1);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentPreLightingCode(shader:LightingShader, methodVO:MethodVO, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = super.iGetFragmentPreLightingCode(shader, methodVO, registerCache, sharedRegisters);\n\t\tthis._pIsFirstLight = true;\n\t\tthis._wrapDataRegister = registerCache.getFreeFragmentConstant();\n\t\tmethodVO.secondaryFragmentConstantsIndex = this._wrapDataRegister.index*4;\n\n\t\treturn code;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentCodePerLight(shader:LightingShader, methodVO:MethodVO, lightDirReg:ShaderRegisterElement, lightColReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = \"\";\n\t\tvar t:ShaderRegisterElement;\n\n\t\t// write in temporary if not first light, so we can add to total diffuse colour\n\t\tif (this._pIsFirstLight) {\n\t\t\tt = this._pTotalLightColorReg;\n\t\t} else {\n\t\t\tt = registerCache.getFreeFragmentVectorTemp();\n\t\t\tregisterCache.addFragmentTempUsages(t, 1);\n\t\t}\n\n\t\tcode += \"dp3 \" + t + \".x, \" + lightDirReg + \".xyz, \" + sharedRegisters.normalFragment + \".xyz\\n\" +\n\t\t\t\"add \" + t + \".y, \" + t + \".x, \" + this._wrapDataRegister + \".x\\n\" +\n\t\t\t\"mul \" + t + \".y, \" + t + \".y, \" + this._wrapDataRegister + \".y\\n\" +\n\t\t\t\"sat \" + t + \".w, \" + t + \".y\\n\" +\n\t\t\t\"mul \" + t + \".xz, \" + t + \".w, \" + lightDirReg + \".wz\\n\";\n\n\t\tif (this._iModulateMethod != null)\n\t\t\tcode += this._iModulateMethod(shader, methodVO, lightDirReg, registerCache, sharedRegisters);\n\n\t\tcode += \"mul \" + t + \", \" + t + \".x, \" + lightColReg + \"\\n\";\n\n\t\tif (!this._pIsFirstLight) {\n\t\t\tcode += \"add \" + this._pTotalLightColorReg + \".xyz, \" + this._pTotalLightColorReg + \".xyz, \" + t + \".xyz\\n\";\n\t\t\tregisterCache.removeFragmentTempUsage(t);\n\t\t}\n\n\t\tthis._pIsFirstLight = false;\n\n\t\treturn code;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iActivate(shader:LightingShader, methodVO:MethodVO, stage:Stage)\n\t{\n\t\tsuper.iActivate(shader, methodVO, stage);\n\n\t\tvar index:number /*int*/ = methodVO.secondaryFragmentConstantsIndex;\n\t\tvar data:Array<number> = shader.fragmentConstantData;\n\t\tdata[index] = this._wrapFactor;\n\t\tdata[index + 1] = 1/(this._wrapFactor + 1);\n\t}\n}\n\nexport = DiffuseWrapMethod;",
    "import TextureBase\t\t\t\t\t\t= require(\"awayjs-display/lib/textures/TextureBase\");\n\nimport Stage\t\t\t\t\t\t\t= require(\"awayjs-stagegl/lib/base/Stage\");\n\nimport LightingShader\t\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/LightingShader\");\nimport ShaderBase\t\t\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderBase\");\nimport ShaderRegisterCache\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterCache\");\nimport ShaderRegisterData\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterData\");\nimport ShaderRegisterElement\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterElement\");\n\nimport MethodVO\t\t\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/data/MethodVO\");\nimport EffectMethodBase\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/methods/EffectMethodBase\");\n\n/**\n * EffectAlphaMaskMethod allows the use of an additional texture to specify the alpha value of the material. When used\n * with the secondary uv set, it allows for a tiled main texture with independently varying alpha (useful for water\n * etc).\n */\nclass EffectAlphaMaskMethod extends EffectMethodBase\n{\n\tprivate _texture:TextureBase;\n\tprivate _useSecondaryUV:boolean;\n\n\t/**\n\t * Creates a new EffectAlphaMaskMethod object.\n\t *\n\t * @param texture The texture to use as the alpha mask.\n\t * @param useSecondaryUV Indicated whether or not the secondary uv set for the mask. This allows mapping alpha independently.\n\t */\n\tconstructor(texture:TextureBase, useSecondaryUV:boolean = false)\n\t{\n\t\tsuper();\n\n\t\tthis._texture = texture;\n\t\tthis._useSecondaryUV = useSecondaryUV;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitVO(shader:ShaderBase, methodVO:MethodVO)\n\t{\n\t\tmethodVO.textureVO = shader.getTextureVO(this._texture);\n\n\t\tif (this._useSecondaryUV)\n\t\t\tshader.secondaryUVDependencies++;\n\t\telse\n\t\t\tshader.uvDependencies++;\n\t}\n\n\t/**\n\t * Indicated whether or not the secondary uv set for the mask. This allows mapping alpha independently, for\n\t * instance to tile the main texture and normal map while providing untiled alpha, for example to define the\n\t * transparency over a tiled water surface.\n\t */\n\tpublic get useSecondaryUV():boolean\n\t{\n\t\treturn this._useSecondaryUV;\n\t}\n\n\tpublic set useSecondaryUV(value:boolean)\n\t{\n\t\tif (this._useSecondaryUV == value)\n\t\t\treturn;\n\n\t\tthis._useSecondaryUV = value;\n\n\t\tthis.iInvalidateShaderProgram();\n\t}\n\n\t/**\n\t * The texture to use as the alpha mask.\n\t */\n\tpublic get texture():TextureBase\n\t{\n\t\treturn this._texture;\n\t}\n\n\tpublic set texture(value:TextureBase)\n\t{\n\t\tif (this._texture == value)\n\t\t\treturn;\n\n\t\tthis._texture = value;\n\n\t\tthis.iInvalidateShaderProgram();\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentCode(shader:ShaderBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar temp:ShaderRegisterElement = registerCache.getFreeFragmentVectorTemp();\n\n\t\treturn methodVO.textureVO._iGetFragmentCode(shader, temp, registerCache, this._useSecondaryUV? sharedRegisters.secondaryUVVarying : sharedRegisters.uvVarying) +\n\t\t\t\"mul \" + targetReg + \", \" + targetReg + \", \" + temp + \".x\\n\";\n\t}\n\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iActivate(shader:LightingShader, methodVO:MethodVO, stage:Stage)\n\t{\n\t\tsuper.iActivate(shader, methodVO, stage);\n\n\t\tmethodVO.textureVO.activate(shader);\n\t}\n}\n\nexport = EffectAlphaMaskMethod;",
    "import Stage\t\t\t\t\t\t\t= require(\"awayjs-stagegl/lib/base/Stage\");\n\nimport ShaderBase\t\t\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderBase\");\nimport ShaderRegisterCache\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterCache\");\nimport ShaderRegisterData\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterData\");\nimport ShaderRegisterElement\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterElement\");\n\nimport MethodVO\t\t\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/data/MethodVO\");\nimport EffectMethodBase\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/methods/EffectMethodBase\");\n\n/**\n * EffectColorMatrixMethod provides a shading method that changes the colour of a material analogous to a ColorMatrixFilter.\n */\nclass EffectColorMatrixMethod extends EffectMethodBase\n{\n\tprivate _matrix:Array<number>;\n\n\t/**\n\t * Creates a new EffectColorTransformMethod.\n\t *\n\t * @param matrix An array of 20 items for 4 x 5 color transform.\n\t */\n\tconstructor(matrix:Array<number>)\n\t{\n\t\tsuper();\n\n\t\tif (matrix.length != 20)\n\t\t\tthrow new Error(\"Matrix length must be 20!\");\n\n\t\tthis._matrix = matrix;\n\t}\n\n\t/**\n\t * The 4 x 5 matrix to transform the color of the material.\n\t */\n\tpublic get colorMatrix():Array<number>\n\t{\n\t\treturn this._matrix;\n\t}\n\n\tpublic set colorMatrix(value:Array<number>)\n\t{\n\t\tthis._matrix = value;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentCode(shader:ShaderBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = \"\";\n\t\tvar colorMultReg:ShaderRegisterElement = registerCache.getFreeFragmentConstant();\n\t\tregisterCache.getFreeFragmentConstant();\n\t\tregisterCache.getFreeFragmentConstant();\n\t\tregisterCache.getFreeFragmentConstant();\n\n\t\tvar colorOffsetReg:ShaderRegisterElement = registerCache.getFreeFragmentConstant();\n\n\t\tmethodVO.fragmentConstantsIndex = colorMultReg.index*4;\n\n\t\tvar temp:ShaderRegisterElement = registerCache.getFreeFragmentVectorTemp();\n\n\t\tcode += \"m44 \" + temp + \", \" + targetReg + \", \" + colorMultReg + \"\\n\" +\n\t\t\t\t\"add \" + targetReg + \", \" + temp + \", \" + colorOffsetReg + \"\\n\";\n\n\t\treturn code;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iActivate(shader:ShaderBase, methodVO:MethodVO, stage:Stage)\n\t{\n\t\tvar matrix:Array<number> = this._matrix;\n\t\tvar index:number /*int*/ = methodVO.fragmentConstantsIndex;\n\t\tvar data:Array<number> = shader.fragmentConstantData;\n\n\t\t// r\n\t\tdata[index] = matrix[0];\n\t\tdata[index + 1] = matrix[1];\n\t\tdata[index + 2] = matrix[2];\n\t\tdata[index + 3] = matrix[3];\n\n\t\t// g\n\t\tdata[index + 4] = matrix[5];\n\t\tdata[index + 5] = matrix[6];\n\t\tdata[index + 6] = matrix[7];\n\t\tdata[index + 7] = matrix[8];\n\n\t\t// b\n\t\tdata[index + 8] = matrix[10];\n\t\tdata[index + 9] = matrix[11];\n\t\tdata[index + 10] = matrix[12];\n\t\tdata[index + 11] = matrix[13];\n\n\t\t// a\n\t\tdata[index + 12] = matrix[15];\n\t\tdata[index + 13] = matrix[16];\n\t\tdata[index + 14] = matrix[17];\n\t\tdata[index + 15] = matrix[18];\n\n\t\t// rgba offset\n\t\tdata[index + 16] = matrix[4];\n\t\tdata[index + 17] = matrix[9];\n\t\tdata[index + 18] = matrix[14];\n\t\tdata[index + 19] = matrix[19];\n\t}\n}\n\nexport = EffectColorMatrixMethod;",
    "import ColorTransform\t\t\t\t= require(\"awayjs-core/lib/geom/ColorTransform\");\n\nimport Stage\t\t\t\t\t\t= require(\"awayjs-stagegl/lib/base/Stage\");\n\nimport ShaderBase\t\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderBase\");\nimport ShaderRegisterCache\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterCache\");\nimport ShaderRegisterData\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterData\");\nimport ShaderRegisterElement\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterElement\");\n\nimport MethodVO\t\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/data/MethodVO\");\nimport EffectMethodBase\t\t\t\t= require(\"awayjs-methodmaterials/lib/methods/EffectMethodBase\");\n\n/**\n * EffectColorTransformMethod provides a shading method that changes the colour of a material analogous to a\n * ColorTransform object.\n */\nclass EffectColorTransformMethod extends EffectMethodBase\n{\n\tprivate _colorTransform:ColorTransform;\n\n\t/**\n\t * Creates a new EffectColorTransformMethod.\n\t */\n\tconstructor()\n\t{\n\t\tsuper();\n\t}\n\n\t/**\n\t * The ColorTransform object to transform the colour of the material with.\n\t */\n\tpublic get colorTransform():ColorTransform\n\t{\n\t\treturn this._colorTransform;\n\t}\n\n\tpublic set colorTransform(value:ColorTransform)\n\t{\n\t\tthis._colorTransform = value;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentCode(shader:ShaderBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = \"\";\n\t\tvar colorMultReg:ShaderRegisterElement = registerCache.getFreeFragmentConstant();\n\t\tvar colorOffsReg:ShaderRegisterElement = registerCache.getFreeFragmentConstant();\n\n\t\tmethodVO.fragmentConstantsIndex = colorMultReg.index*4;\n\n\t\t//TODO: AGAL <> GLSL\n\n\t\tcode += \"mul \" + targetReg + \", \" + targetReg + \", \" + colorMultReg + \"\\n\" + \"add \" + targetReg + \", \" + targetReg + \", \" + colorOffsReg + \"\\n\";\n\n\t\treturn code;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iActivate(shader:ShaderBase, methodVO:MethodVO, stage:Stage)\n\t{\n\t\tvar inv:number = 1/0xff;\n\t\tvar index:number = methodVO.fragmentConstantsIndex;\n\t\tvar data:Array<number> = shader.fragmentConstantData;\n\n\t\tdata[index] = this._colorTransform.redMultiplier;\n\t\tdata[index + 1] = this._colorTransform.greenMultiplier;\n\t\tdata[index + 2] = this._colorTransform.blueMultiplier;\n\t\tdata[index + 3] = this._colorTransform.alphaMultiplier;\n\t\tdata[index + 4] = this._colorTransform.redOffset*inv;\n\t\tdata[index + 5] = this._colorTransform.greenOffset*inv;\n\t\tdata[index + 6] = this._colorTransform.blueOffset*inv;\n\t\tdata[index + 7] = this._colorTransform.alphaOffset*inv;\n\n\t}\n}\n\nexport = EffectColorTransformMethod;",
    "import TextureBase\t\t\t\t\t\t= require(\"awayjs-display/lib/textures/TextureBase\");\n\nimport Stage\t\t\t\t\t\t\t= require(\"awayjs-stagegl/lib/base/Stage\");\n\nimport ShaderBase\t\t\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderBase\");\nimport ShaderRegisterCache\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterCache\");\nimport ShaderRegisterData\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterData\");\nimport ShaderRegisterElement\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterElement\");\n\nimport MethodVO\t\t\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/data/MethodVO\");\nimport EffectMethodBase\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/methods/EffectMethodBase\");\n\n/**\n * EffectEnvMapMethod provides a material method to perform reflection mapping using cube maps.\n */\nclass EffectEnvMapMethod extends EffectMethodBase\n{\n\tprivate _envMap:TextureBase;\n\tprivate _alpha:number;\n\tprivate _mask:TextureBase;\n\n\t/**\n\t * Creates an EffectEnvMapMethod object.\n\t * @param envMap The environment map containing the reflected scene.\n\t * @param alpha The reflectivity of the surface.\n\t */\n\tconstructor(envMap:TextureBase, alpha:number = 1)\n\t{\n\t\tsuper();\n\t\tthis._envMap = envMap;\n\t\tthis._alpha = alpha;\n\n\t}\n\n\t/**\n\t * An optional texture to modulate the reflectivity of the surface.\n\t */\n\tpublic get mask():TextureBase\n\t{\n\t\treturn this._mask;\n\t}\n\n\tpublic set mask(value:TextureBase)\n\t{\n\t\tif (value == this._mask)\n\t\t\treturn;\n\n\t\tthis._mask = value;\n\n\t\tthis.iInvalidateShaderProgram();\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitVO(shader:ShaderBase, methodVO:MethodVO)\n\t{\n\t\tmethodVO.needsNormals = true;\n\t\tmethodVO.needsView = true;\n\n\t\tmethodVO.textureVO = shader.getTextureVO(this._envMap);\n\n\t\tif (this._mask != null) {\n\t\t\tmethodVO.secondaryTextureVO = shader.getTextureVO(this._mask);\n\t\t\tshader.uvDependencies++;\n\t\t}\n\t}\n\n\t/**\n\t * The cubic environment map containing the reflected scene.\n\t */\n\tpublic get envMap():TextureBase\n\t{\n\t\treturn this._envMap;\n\t}\n\n\tpublic set envMap(value:TextureBase)\n\t{\n\t\tif (this._envMap == value)\n\t\t\treturn;\n\n\t\tthis._envMap = value;\n\n\t\tthis.iInvalidateShaderProgram();\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic dispose()\n\t{\n\t}\n\n\t/**\n\t * The reflectivity of the surface.\n\t */\n\tpublic get alpha():number\n\t{\n\t\treturn this._alpha;\n\t}\n\n\tpublic set alpha(value:number)\n\t{\n\t\tthis._alpha = value;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iActivate(shader:ShaderBase, methodVO:MethodVO, stage:Stage)\n\t{\n\t\tshader.fragmentConstantData[methodVO.fragmentConstantsIndex] = this._alpha;\n\n\t\tmethodVO.textureVO.activate(shader);\n\n\t\tif (this._mask)\n\t\t\tmethodVO.secondaryTextureVO.activate(shader);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentCode(shader:ShaderBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar dataRegister:ShaderRegisterElement = registerCache.getFreeFragmentConstant();\n\t\tvar code:string = \"\";\n\n\t\tmethodVO.fragmentConstantsIndex = dataRegister.index*4;\n\n\t\tvar temp:ShaderRegisterElement = registerCache.getFreeFragmentVectorTemp();\n\t\tregisterCache.addFragmentTempUsages(temp, 1);\n\t\tvar temp2:ShaderRegisterElement = registerCache.getFreeFragmentVectorTemp();\n\t\tregisterCache.addFragmentTempUsages(temp2, 1);\n\n\t\tmethodVO.textureVO._iInitRegisters(shader, registerCache);\n\n\t\t// r = I - 2(I.N)*N\n\t\tcode += \"dp3 \" + temp + \".w, \" + sharedRegisters.viewDirFragment + \".xyz, \" + sharedRegisters.normalFragment + \".xyz\\n\" +\n\t\t\t\"add \" + temp + \".w, \" + temp + \".w, \" + temp + \".w\\n\" +\n\t\t\t\"mul \" + temp + \".xyz, \" + sharedRegisters.normalFragment + \".xyz, \" + temp + \".w\\n\" +\n\t\t\t\"sub \" + temp + \".xyz, \" + temp + \".xyz, \" + sharedRegisters.viewDirFragment + \".xyz\\n\" +\n\t\t\tmethodVO.textureVO._iGetFragmentCode(shader, temp, registerCache, temp) +\n\t\t\t\"sub \" + temp2 + \".w, \" + temp + \".w, fc0.x\\n\" + // -.5\n\t\t\t\"kil \" + temp2 + \".w\\n\" +\t// used for real time reflection mapping - if alpha is not 1 (mock texture) kil output\n\t\t\t\"sub \" + temp + \", \" + temp + \", \" + targetReg + \"\\n\";\n\n\t\tif (this._mask) {\n\t\t\tmethodVO.secondaryTextureVO._iInitRegisters(shader, registerCache);\n\n\t\t\tcode += methodVO.secondaryTextureVO._iGetFragmentCode(shader, temp2, registerCache, sharedRegisters.uvVarying) +\n\t\t\t\t\"mul \" + temp + \", \" + temp2 + \", \" + temp + \"\\n\";\n\t\t}\n\n\t\tcode += \"mul \" + temp + \", \" + temp + \", \" + dataRegister + \".x\\n\" +\n\t\t\t\t\"add \" + targetReg + \", \" + targetReg + \", \" + temp + \"\\n\";\n\n\t\tregisterCache.removeFragmentTempUsage(temp);\n\t\tregisterCache.removeFragmentTempUsage(temp2);\n\n\t\treturn code;\n\t}\n}\n\nexport = EffectEnvMapMethod;",
    "import Stage\t\t\t\t\t\t\t= require(\"awayjs-stagegl/lib/base/Stage\");\n\nimport LightingShader\t\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/LightingShader\");\nimport ShaderBase\t\t\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderBase\");\nimport ShaderRegisterCache\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterCache\");\nimport ShaderRegisterData\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterData\");\nimport ShaderRegisterElement\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterElement\");\n\nimport MethodVO\t\t\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/data/MethodVO\");\nimport EffectMethodBase\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/methods/EffectMethodBase\");\n\n/**\n * EffectFogMethod provides a method to add distance-based fog to a material.\n */\nclass EffectFogMethod extends EffectMethodBase\n{\n\tprivate _minDistance:number = 0;\n\tprivate _maxDistance:number = 1000;\n\tprivate _fogColor:number /*uint*/;\n\tprivate _fogR:number;\n\tprivate _fogG:number;\n\tprivate _fogB:number;\n\n\t/**\n\t * Creates a new EffectFogMethod object.\n\t * @param minDistance The distance from which the fog starts appearing.\n\t * @param maxDistance The distance at which the fog is densest.\n\t * @param fogColor The colour of the fog.\n\t */\n\tconstructor(minDistance:number, maxDistance:number, fogColor:number /*uint*/ = 0x808080)\n\t{\n\t\tsuper();\n\t\tthis.minDistance = minDistance;\n\t\tthis.maxDistance = maxDistance;\n\t\tthis.fogColor = fogColor;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitVO(shader:LightingShader, methodVO:MethodVO)\n\t{\n\t\tmethodVO.needsProjection = true;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitConstants(shader:ShaderBase, methodVO:MethodVO)\n\t{\n\t\tvar data:Array<number> = shader.fragmentConstantData;\n\t\tvar index:number /*int*/ = methodVO.fragmentConstantsIndex;\n\t\tdata[index + 3] = 1;\n\t\tdata[index + 6] = 0;\n\t\tdata[index + 7] = 0;\n\t}\n\n\t/**\n\t * The distance from which the fog starts appearing.\n\t */\n\tpublic get minDistance():number\n\t{\n\t\treturn this._minDistance;\n\t}\n\n\tpublic set minDistance(value:number)\n\t{\n\t\tthis._minDistance = value;\n\t}\n\n\t/**\n\t * The distance at which the fog is densest.\n\t */\n\tpublic get maxDistance():number\n\t{\n\t\treturn this._maxDistance;\n\t}\n\n\tpublic set maxDistance(value:number)\n\t{\n\t\tthis._maxDistance = value;\n\t}\n\n\t/**\n\t * The colour of the fog.\n\t */\n\tpublic get fogColor():number /*uint*/\n\t{\n\t\treturn this._fogColor;\n\t}\n\n\tpublic set fogColor(value:number/*uint*/)\n\t{\n\t\tthis._fogColor = value;\n\t\tthis._fogR = ((value >> 16) & 0xff)/0xff;\n\t\tthis._fogG = ((value >> 8) & 0xff)/0xff;\n\t\tthis._fogB = (value & 0xff)/0xff;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iActivate(shader:ShaderBase, methodVO:MethodVO, stage:Stage)\n\t{\n\t\tvar data:Array<number> = shader.fragmentConstantData;\n\t\tvar index:number /*int*/ = methodVO.fragmentConstantsIndex;\n\t\tdata[index] = this._fogR;\n\t\tdata[index + 1] = this._fogG;\n\t\tdata[index + 2] = this._fogB;\n\t\tdata[index + 4] = this._minDistance;\n\t\tdata[index + 5] = 1/(this._maxDistance - this._minDistance);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentCode(shader:ShaderBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar fogColor:ShaderRegisterElement = registerCache.getFreeFragmentConstant();\n\t\tvar fogData:ShaderRegisterElement = registerCache.getFreeFragmentConstant();\n\t\tvar temp:ShaderRegisterElement = registerCache.getFreeFragmentVectorTemp();\n\t\tregisterCache.addFragmentTempUsages(temp, 1);\n\t\tvar temp2:ShaderRegisterElement = registerCache.getFreeFragmentVectorTemp();\n\t\tvar code:string = \"\";\n\t\tmethodVO.fragmentConstantsIndex = fogColor.index*4;\n\n\t\tcode += \"sub \" + temp2 + \".w, \" + sharedRegisters.projectionFragment + \".z, \" + fogData + \".x\\n\" +\n\t\t\t\t\"mul \" + temp2 + \".w, \" + temp2 + \".w, \" + fogData + \".y\\n\" +\n\t\t\t\t\"sat \" + temp2 + \".w, \" + temp2 + \".w\\n\" +\n\t\t\t\t\"sub \" + temp + \", \" + fogColor + \", \" + targetReg + \"\\n\" + // (fogColor- col)\n\t\t\t\t\"mul \" + temp + \", \" + temp + \", \" + temp2 + \".w\\n\" + // (fogColor- col)*fogRatio\n\t\t\t\t\"add \" + targetReg + \", \" + targetReg + \", \" + temp + \"\\n\"; // fogRatio*(fogColor- col) + col\n\n\t\tregisterCache.removeFragmentTempUsage(temp);\n\n\t\treturn code;\n\t}\n}\n\nexport = EffectFogMethod;",
    "import TextureBase\t\t\t\t\t\t= require(\"awayjs-display/lib/textures/TextureBase\");\n\nimport Stage\t\t\t\t\t\t\t= require(\"awayjs-stagegl/lib/base/Stage\");\n\nimport ShaderBase\t\t\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderBase\");\nimport ShaderRegisterCache\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterCache\");\nimport ShaderRegisterData\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterData\");\nimport ShaderRegisterElement\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterElement\");\n\nimport MethodVO\t\t\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/data/MethodVO\");\nimport EffectMethodBase\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/methods/EffectMethodBase\");\n\n/**\n * EffectFresnelEnvMapMethod provides a method to add fresnel-based reflectivity to an object using cube maps, which gets\n * stronger as the viewing angle becomes more grazing.\n */\nclass EffectFresnelEnvMapMethod extends EffectMethodBase\n{\n\tprivate _envMap:TextureBase;\n\tprivate _fresnelPower:number = 5;\n\tprivate _normalReflectance:number = 0;\n\tprivate _alpha:number;\n\tprivate _mask:TextureBase;\n\n\t/**\n\t * Creates a new <code>EffectFresnelEnvMapMethod</code> object.\n\t *\n\t * @param envMap The environment map containing the reflected scene.\n\t * @param alpha The reflectivity of the material.\n\t */\n\tconstructor(envMap:TextureBase, alpha:number = 1)\n\t{\n\t\tsuper();\n\n\t\tthis._envMap = envMap;\n\t\tthis._alpha = alpha;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitVO(shader:ShaderBase, methodVO:MethodVO)\n\t{\n\t\tmethodVO.needsNormals = true;\n\t\tmethodVO.needsView = true;\n\n\t\tmethodVO.textureVO = shader.getTextureVO(this._envMap);\n\n\t\tif (this._mask != null) {\n\t\t\tmethodVO.secondaryTextureVO = shader.getTextureVO(this._mask);\n\t\t\tshader.uvDependencies++;\n\t\t}\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitConstants(shader:ShaderBase, methodVO:MethodVO)\n\t{\n\t\tshader.fragmentConstantData[methodVO.fragmentConstantsIndex + 3] = 1;\n\t}\n\n\t/**\n\t * An optional texture to modulate the reflectivity of the surface.\n\t */\n\tpublic get mask():TextureBase\n\t{\n\t\treturn this._mask;\n\t}\n\n\tpublic set mask(value:TextureBase)\n\t{\n\t\tif (this._mask == value)\n\t\t\treturn;\n\t\t\n\t\tthis._mask = value;\n\n\t\tthis.iInvalidateShaderProgram();\n\t}\n\n\t/**\n\t * The power used in the Fresnel equation. Higher values make the fresnel effect more pronounced. Defaults to 5.\n\t */\n\tpublic get fresnelPower():number\n\t{\n\t\treturn this._fresnelPower;\n\t}\n\n\tpublic set fresnelPower(value:number)\n\t{\n\t\tthis._fresnelPower = value;\n\t}\n\n\t/**\n\t * The cubic environment map containing the reflected scene.\n\t */\n\tpublic get envMap():TextureBase\n\t{\n\t\treturn this._envMap;\n\t}\n\n\tpublic set envMap(value:TextureBase)\n\t{\n\t\tthis._envMap = value;\n\t}\n\n\t/**\n\t * The reflectivity of the surface.\n\t */\n\tpublic get alpha():number\n\t{\n\t\treturn this._alpha;\n\t}\n\n\tpublic set alpha(value:number)\n\t{\n\t\tthis._alpha = value;\n\t}\n\n\t/**\n\t * The minimum amount of reflectance, ie the reflectance when the view direction is normal to the surface or light direction.\n\t */\n\tpublic get normalReflectance():number\n\t{\n\t\treturn this._normalReflectance;\n\t}\n\n\tpublic set normalReflectance(value:number)\n\t{\n\t\tthis._normalReflectance = value;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iActivate(shader:ShaderBase, methodVO:MethodVO, stage:Stage)\n\t{\n\t\tvar data:Array<number> = shader.fragmentConstantData;\n\t\tvar index:number /*int*/ = methodVO.fragmentConstantsIndex;\n\t\tdata[index] = this._alpha;\n\t\tdata[index + 1] = this._normalReflectance;\n\t\tdata[index + 2] = this._fresnelPower;\n\n\t\tmethodVO.textureVO.activate(shader);\n\n\t\tif (this._mask)\n\t\t\tmethodVO.secondaryTextureVO.activate(shader);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentCode(shader:ShaderBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar dataRegister:ShaderRegisterElement = registerCache.getFreeFragmentConstant();\n\t\tvar code:string = \"\";\n\t\tvar viewDirReg:ShaderRegisterElement = sharedRegisters.viewDirFragment;\n\t\tvar normalReg:ShaderRegisterElement = sharedRegisters.normalFragment;\n\n\t\tmethodVO.fragmentConstantsIndex = dataRegister.index*4;\n\n\t\tvar temp:ShaderRegisterElement = registerCache.getFreeFragmentVectorTemp();\n\t\tregisterCache.addFragmentTempUsages(temp, 1);\n\t\tvar temp2:ShaderRegisterElement = registerCache.getFreeFragmentVectorTemp();\n\t\tregisterCache.addFragmentTempUsages(temp2, 1);\n\n\t\tmethodVO.textureVO._iInitRegisters(shader, registerCache);\n\n\t\t// r = V - 2(V.N)*N\n\t\tcode += \"dp3 \" + temp + \".w, \" + viewDirReg + \".xyz, \" + normalReg + \".xyz\\n\" +\n\t\t\t\t\"add \" + temp + \".w, \" + temp + \".w, \" + temp + \".w\\n\" +\n\t\t\t\t\"mul \" + temp + \".xyz, \" + normalReg + \".xyz, \" + temp + \".w\\n\" +\n\t\t\t\t\"sub \" + temp + \".xyz, \" + temp + \".xyz, \" + viewDirReg + \".xyz\\n\" +\n\t\t\tmethodVO.textureVO._iGetFragmentCode(shader, temp, registerCache, temp) +\n\t\t\t\t\"sub \" + temp2 + \".w, \" + temp + \".w, fc0.x\\n\" +               \t// -.5\n\t\t\t\t\"kil \" + temp2 + \".w\\n\" +\t// used for real time reflection mapping - if alpha is not 1 (mock texture) kil output\n\t\t\t\t\"sub \" + temp + \", \" + temp + \", \" + targetReg + \"\\n\";\n\n\t\t// calculate fresnel term\n\t\tcode += \"dp3 \" + viewDirReg + \".w, \" + viewDirReg + \".xyz, \" + normalReg + \".xyz\\n\" +  // dot(V, H)\n\t\t\t\t\"sub \" + viewDirReg + \".w, \" + dataRegister + \".w, \" + viewDirReg + \".w\\n\" +       // base = 1-dot(V, H)\n\t\t\t\t\"pow \" + viewDirReg + \".w, \" + viewDirReg + \".w, \" + dataRegister + \".z\\n\" +       // exp = pow(base, 5)\n\t\t\t\t\"sub \" + normalReg + \".w, \" + dataRegister + \".w, \" + viewDirReg + \".w\\n\" +        // 1 - exp\n\t\t\t\t\"mul \" + normalReg + \".w, \" + dataRegister + \".y, \" + normalReg + \".w\\n\" +         // f0*(1 - exp)\n\t\t\t\t\"add \" + viewDirReg + \".w, \" + viewDirReg + \".w, \" + normalReg + \".w\\n\" +          // exp + f0*(1 - exp)\n\n\t\t\t\t// total alpha\n\t\t\t\t\"mul \" + viewDirReg + \".w, \" + dataRegister + \".x, \" + viewDirReg + \".w\\n\";\n\n\t\tif (this._mask) {\n\t\t\tmethodVO.secondaryTextureVO._iInitRegisters(shader, registerCache);\n\n\t\t\tcode += methodVO.secondaryTextureVO._iGetFragmentCode(shader, temp2, registerCache, sharedRegisters.uvVarying) +\n\t\t\t\t\"mul \" + viewDirReg + \".w, \" + temp2 + \".x, \" + viewDirReg + \".w\\n\";\n\t\t}\n\n\t\t// blend\n\t\tcode += \"mul \" + temp + \", \" + temp + \", \" + viewDirReg + \".w\\n\" +\n\t\t\t\t\"add \" + targetReg + \", \" + targetReg + \", \" + temp + \"\\n\";\n\n\t\tregisterCache.removeFragmentTempUsage(temp);\n\t\tregisterCache.removeFragmentTempUsage(temp2);\n\n\t\treturn code;\n\t}\n}\n\nexport = EffectFresnelEnvMapMethod;",
    "import TextureBase\t\t\t\t\t\t= require(\"awayjs-display/lib/textures/TextureBase\");\n\nimport Stage\t\t\t\t\t\t\t= require(\"awayjs-stagegl/lib/base/Stage\");\n\nimport ShaderBase\t\t\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderBase\");\nimport ShaderRegisterCache\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterCache\");\nimport ShaderRegisterData\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterData\");\nimport ShaderRegisterElement\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterElement\");\n\nimport MethodVO\t\t\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/data/MethodVO\");\nimport EffectMethodBase\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/methods/EffectMethodBase\");\n\n/**\n * EffectLightMapMethod provides a method that allows applying a light map texture to the calculated pixel colour.\n * It is different from DiffuseLightMapMethod in that the latter only modulates the diffuse shading value rather\n * than the whole pixel colour.\n */\nclass EffectLightMapMethod extends EffectMethodBase\n{\n\t/**\n\t * Indicates the light map should be multiplied with the calculated shading result.\n\t */\n\tpublic static MULTIPLY:string = \"multiply\";\n\n\t/**\n\t * Indicates the light map should be added into the calculated shading result.\n\t */\n\tpublic static ADD:string = \"add\";\n\n\tprivate _lightMap:TextureBase;\n\n\tprivate _blendMode:string;\n\tprivate _useSecondaryUV:boolean;\n\n\t/**\n\t * Creates a new EffectLightMapMethod object.\n\t *\n\t * @param lightMap The texture containing the light map.\n\t * @param blendMode The blend mode with which the light map should be applied to the lighting result.\n\t * @param useSecondaryUV Indicates whether the secondary UV set should be used to map the light map.\n\t */\n\tconstructor(lightMap:TextureBase, blendMode:string = \"multiply\", useSecondaryUV:boolean = false)\n\t{\n\t\tsuper();\n\n\t\tif (blendMode != EffectLightMapMethod.ADD && blendMode != EffectLightMapMethod.MULTIPLY)\n\t\t\tthrow new Error(\"Unknown blendmode!\");\n\n\t\tthis._lightMap = lightMap;\n\t\tthis._blendMode = blendMode;\n\t\tthis._useSecondaryUV = useSecondaryUV;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitVO(shader:ShaderBase, methodVO:MethodVO)\n\t{\n\t\tmethodVO.textureVO = shader.getTextureVO(this._lightMap);\n\n\t\tif (this._useSecondaryUV)\n\t\t\tshader.secondaryUVDependencies++;\n\t\telse\n\t\t\tshader.uvDependencies++;\n\t}\n\n\t/**\n\t * The blend mode with which the light map should be applied to the lighting result.\n\t *\n\t * @see EffectLightMapMethod.ADD\n\t * @see EffectLightMapMethod.MULTIPLY\n\t */\n\tpublic get blendMode():string\n\t{\n\t\treturn this._blendMode;\n\t}\n\n\tpublic set blendMode(value:string)\n\t{\n\t\tif (this._blendMode == value)\n\t\t\treturn;\n\n\t\tif (value != EffectLightMapMethod.ADD && value != EffectLightMapMethod.MULTIPLY)\n\t\t\tthrow new Error(\"Unknown blendmode!\");\n\n\t\tthis._blendMode = value;\n\n\t\tthis.iInvalidateShaderProgram();\n\t}\n\n\t/**\n\t * The lightMap containing the light map.\n\t */\n\tpublic get lightMap():TextureBase\n\t{\n\t\treturn this._lightMap;\n\t}\n\n\tpublic set lightMap(value:TextureBase)\n\t{\n\t\tif (this._lightMap == value)\n\t\t\treturn;\n\n\t\tthis._lightMap = value;\n\n\t\tthis.iInvalidateShaderProgram();\n\t}\n\n\t/**\n\t * Indicates whether the secondary UV set should be used to map the light map.\n\t */\n\tpublic get useSecondaryUV():boolean\n\t{\n\t\treturn this._useSecondaryUV;\n\t}\n\n\tpublic set useSecondaryUV(value:boolean)\n\t{\n\t\tif (this._useSecondaryUV == value)\n\t\t\treturn;\n\n\t\tthis._useSecondaryUV = value;\n\n\t\tthis.iInvalidateShaderProgram();\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentCode(shader:ShaderBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string;\n\t\tvar temp:ShaderRegisterElement = registerCache.getFreeFragmentVectorTemp();\n\n\t\tcode = methodVO.secondaryTextureVO._iGetFragmentCode(shader, temp, registerCache, this._useSecondaryUV? sharedRegisters.secondaryUVVarying : sharedRegisters.uvVarying);\n\n\t\tswitch (this._blendMode) {\n\t\t\tcase EffectLightMapMethod.MULTIPLY:\n\t\t\t\tcode += \"mul \" + targetReg + \", \" + targetReg + \", \" + temp + \"\\n\";\n\t\t\t\tbreak;\n\t\t\tcase EffectLightMapMethod.ADD:\n\t\t\t\tcode += \"add \" + targetReg + \", \" + targetReg + \", \" + temp + \"\\n\";\n\t\t\t\tbreak;\n\t\t}\n\n\t\treturn code;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iActivate(shader:ShaderBase, methodVO:MethodVO, stage:Stage)\n\t{\n\t\tsuper.iActivate(shader, methodVO, stage);\n\n\t\tmethodVO.textureVO.activate(shader);\n\t}\n}\n\nexport = EffectLightMapMethod;",
    "import IAsset\t\t\t\t\t\t= require(\"awayjs-core/lib/library/IAsset\");\nimport AbstractMethodError\t\t\t= require(\"awayjs-core/lib/errors/AbstractMethodError\");\n\nimport ShaderBase\t\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderBase\");\nimport ShaderRegisterCache\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterCache\");\nimport ShaderRegisterData\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterData\");\nimport ShaderRegisterElement\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterElement\");\n\nimport MethodVO\t\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/data/MethodVO\");\nimport ShadingMethodBase\t\t\t= require(\"awayjs-methodmaterials/lib/methods/ShadingMethodBase\");\n\n/**\n * EffectMethodBase forms an abstract base class for shader methods that are not dependent on light sources,\n * and are in essence post-process effects on the materials.\n */\nclass EffectMethodBase extends ShadingMethodBase implements IAsset\n{\n\tpublic static assetType:string = \"[asset EffectMethod]\";\n\n\tconstructor()\n\t{\n\t\tsuper();\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic get assetType():string\n\t{\n\t\treturn EffectMethodBase.assetType;\n\t}\n\n\t/**\n\t * Get the fragment shader code that should be added after all per-light code. Usually composits everything to the target register.\n\t * @param methodVO The MethodVO object containing the method data for the currently compiled material pass.\n\t * @param regCache The register cache used during the compilation.\n\t * @param targetReg The register that will be containing the method's output.\n\t * @private\n\t */\n\tpublic iGetFragmentCode(shader:ShaderBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tthrow new AbstractMethodError();\n\t\treturn \"\";\n\t}\n}\n\nexport = EffectMethodBase;",
    "import TextureBase\t\t\t\t\t\t= require(\"awayjs-display/lib/textures/TextureBase\");\n\nimport Stage\t\t\t\t\t\t\t= require(\"awayjs-stagegl/lib/base/Stage\");\n\nimport ShaderBase\t\t\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderBase\");\nimport ShaderRegisterCache\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterCache\");\nimport ShaderRegisterData\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterData\");\nimport ShaderRegisterElement\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterElement\");\n\nimport MethodVO\t\t\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/data/MethodVO\");\nimport EffectMethodBase\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/methods/EffectMethodBase\");\n\n/**\n * EffectRefractionEnvMapMethod provides a method to add refracted transparency based on cube maps.\n */\nclass EffectRefractionEnvMapMethod extends EffectMethodBase\n{\n\tprivate _envMap:TextureBase;\n\n\tprivate _dispersionR:number = 0;\n\tprivate _dispersionG:number = 0;\n\tprivate _dispersionB:number = 0;\n\tprivate _useDispersion:boolean;\n\tprivate _refractionIndex:number;\n\tprivate _alpha:number = 1;\n\n\t/**\n\t * Creates a new EffectRefractionEnvMapMethod object. Example values for dispersion are: dispersionR: -0.03, dispersionG: -0.01, dispersionB: = .0015\n\t *\n\t * @param envMap The environment map containing the refracted scene.\n\t * @param refractionIndex The refractive index of the material.\n\t * @param dispersionR The amount of chromatic dispersion of the red channel. Defaults to 0 (none).\n\t * @param dispersionG The amount of chromatic dispersion of the green channel. Defaults to 0 (none).\n\t * @param dispersionB The amount of chromatic dispersion of the blue channel. Defaults to 0 (none).\n\t */\n\tconstructor(envMap:TextureBase, refractionIndex:number = .1, dispersionR:number = 0, dispersionG:number = 0, dispersionB:number = 0)\n\t{\n\t\tsuper();\n\t\tthis._envMap = envMap;\n\t\tthis._dispersionR = dispersionR;\n\t\tthis._dispersionG = dispersionG;\n\t\tthis._dispersionB = dispersionB;\n\t\tthis._useDispersion = !(this._dispersionR == this._dispersionB && this._dispersionR == this._dispersionG);\n\t\tthis._refractionIndex = refractionIndex;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitConstants(shader:ShaderBase, methodVO:MethodVO)\n\t{\n\t\tvar index:number /*int*/ = methodVO.fragmentConstantsIndex;\n\t\tvar data:Array<number> = shader.fragmentConstantData;\n\t\tdata[index + 4] = 1;\n\t\tdata[index + 5] = 0;\n\t\tdata[index + 7] = 1;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitVO(shader:ShaderBase, methodVO:MethodVO)\n\t{\n\t\tmethodVO.needsNormals = true;\n\t\tmethodVO.needsView = true;\n\n\t\tmethodVO.textureVO = shader.getTextureVO(this._envMap);\n\t}\n\n\t/**\n\t * The cube environment map to use for the refraction.\n\t */\n\tpublic get envMap():TextureBase\n\t{\n\t\treturn this._envMap;\n\t}\n\n\tpublic set envMap(value:TextureBase)\n\t{\n\t\tthis._envMap = value;\n\t}\n\n\t/**\n\t * The refractive index of the material.\n\t */\n\tpublic get refractionIndex():number\n\t{\n\t\treturn this._refractionIndex;\n\t}\n\n\tpublic set refractionIndex(value:number)\n\t{\n\t\tthis._refractionIndex = value;\n\t}\n\n\t/**\n\t * The amount of chromatic dispersion of the red channel. Defaults to 0 (none).\n\t */\n\tpublic get dispersionR():number\n\t{\n\t\treturn this._dispersionR;\n\t}\n\n\tpublic set dispersionR(value:number)\n\t{\n\t\tthis._dispersionR = value;\n\n\t\tvar useDispersion:boolean = !(this._dispersionR == this._dispersionB && this._dispersionR == this._dispersionG);\n\t\tif (this._useDispersion != useDispersion) {\n\t\t\tthis.iInvalidateShaderProgram();\n\t\t\tthis._useDispersion = useDispersion;\n\t\t}\n\t}\n\n\t/**\n\t * The amount of chromatic dispersion of the green channel. Defaults to 0 (none).\n\t */\n\tpublic get dispersionG():number\n\t{\n\t\treturn this._dispersionG;\n\t}\n\n\tpublic set dispersionG(value:number)\n\t{\n\t\tthis._dispersionG = value;\n\n\t\tvar useDispersion:boolean = !(this._dispersionR == this._dispersionB && this._dispersionR == this._dispersionG);\n\t\tif (this._useDispersion != useDispersion) {\n\t\t\tthis.iInvalidateShaderProgram();\n\t\t\tthis._useDispersion = useDispersion;\n\t\t}\n\t}\n\n\t/**\n\t * The amount of chromatic dispersion of the blue channel. Defaults to 0 (none).\n\t */\n\tpublic get dispersionB():number\n\t{\n\t\treturn this._dispersionB;\n\t}\n\n\tpublic set dispersionB(value:number)\n\t{\n\t\tthis._dispersionB = value;\n\n\t\tvar useDispersion:boolean = !(this._dispersionR == this._dispersionB && this._dispersionR == this._dispersionG);\n\t\tif (this._useDispersion != useDispersion) {\n\t\t\tthis.iInvalidateShaderProgram();\n\t\t\tthis._useDispersion = useDispersion;\n\t\t}\n\t}\n\n\t/**\n\t * The amount of transparency of the object. Warning: the alpha applies to the refracted color, not the actual\n\t * material. A value of 1 will make it appear fully transparent.\n\t */\n\tpublic get alpha():number\n\t{\n\t\treturn this._alpha;\n\t}\n\n\tpublic set alpha(value:number)\n\t{\n\t\tthis._alpha = value;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iActivate(shader:ShaderBase, methodVO:MethodVO, stage:Stage)\n\t{\n\t\tvar index:number /*int*/ = methodVO.fragmentConstantsIndex;\n\t\tvar data:Array<number> = shader.fragmentConstantData;\n\n\t\tdata[index] = this._dispersionR + this._refractionIndex;\n\n\t\tif (this._useDispersion) {\n\t\t\tdata[index + 1] = this._dispersionG + this._refractionIndex;\n\t\t\tdata[index + 2] = this._dispersionB + this._refractionIndex;\n\t\t}\n\t\tdata[index + 3] = this._alpha;\n\n\t\tmethodVO.textureVO.activate(shader);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentCode(shader:ShaderBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\t// todo: data2.x could use common reg, so only 1 reg is used\n\t\tvar data:ShaderRegisterElement = registerCache.getFreeFragmentConstant();\n\t\tvar data2:ShaderRegisterElement = registerCache.getFreeFragmentConstant();\n\t\tvar code:string = \"\";\n\t\tvar refractionDir:ShaderRegisterElement;\n\t\tvar refractionColor:ShaderRegisterElement;\n\t\tvar temp:ShaderRegisterElement;\n\n\t\tmethodVO.fragmentConstantsIndex = data.index*4;\n\n\t\trefractionDir = registerCache.getFreeFragmentVectorTemp();\n\t\tregisterCache.addFragmentTempUsages(refractionDir, 1);\n\t\trefractionColor = registerCache.getFreeFragmentVectorTemp();\n\t\tregisterCache.addFragmentTempUsages(refractionColor, 1);\n\t\ttemp = registerCache.getFreeFragmentVectorTemp();\n\t\tregisterCache.addFragmentTempUsages(temp, 1);\n\n\t\tvar viewDirReg:ShaderRegisterElement = sharedRegisters.viewDirFragment;\n\t\tvar normalReg:ShaderRegisterElement = sharedRegisters.normalFragment;\n\n\t\tmethodVO.textureVO._iInitRegisters(shader, registerCache);\n\n\t\tcode += \"neg \" + viewDirReg + \".xyz, \" + viewDirReg + \".xyz\\n\";\n\n\t\tcode += \"dp3 \" + temp + \".x, \" + viewDirReg + \".xyz, \" + normalReg + \".xyz\\n\" +\n\t\t\t\"mul \" + temp + \".w, \" + temp + \".x, \" + temp + \".x\\n\" +\n\t\t\t\"sub \" + temp + \".w, \" + data2 + \".x, \" + temp + \".w\\n\" +\n\t\t\t\"mul \" + temp + \".w, \" + data + \".x, \" + temp + \".w\\n\" +\n\t\t\t\"mul \" + temp + \".w, \" + data + \".x, \" + temp + \".w\\n\" +\n\t\t\t\"sub \" + temp + \".w, \" + data2 + \".x, \" + temp + \".w\\n\" +\n\t\t\t\"sqt \" + temp + \".y, \" + temp + \".w\\n\" +\n\n\t\t\t\"mul \" + temp + \".x, \" + data + \".x, \" + temp + \".x\\n\" +\n\t\t\t\"add \" + temp + \".x, \" + temp + \".x, \" + temp + \".y\\n\" +\n\t\t\t\"mul \" + temp + \".xyz, \" + temp + \".x, \" + normalReg + \".xyz\\n\" +\n\n\t\t\t\"mul \" + refractionDir + \", \" + data + \".x, \" + viewDirReg + \"\\n\" +\n\t\t\t\"sub \" + refractionDir + \".xyz, \" + refractionDir + \".xyz, \" + temp + \".xyz\\n\" +\n\t\t\t\"nrm \" + refractionDir + \".xyz, \" + refractionDir + \".xyz\\n\" +\n\t\tmethodVO.textureVO._iGetFragmentCode(shader, refractionColor, registerCache, refractionDir) +\n\t\t\t\"sub \" + refractionColor + \".w, \" + refractionColor + \".w, fc0.x\t\\n\" +\n\t\t\t\"kil \" + refractionColor + \".w\\n\";\n\n\t\tif (this._useDispersion) {\n\t\t\t// GREEN\n\t\t\tcode += \"dp3 \" + temp + \".x, \" + viewDirReg + \".xyz, \" + normalReg + \".xyz\\n\" +\n\t\t\t\t\"mul \" + temp + \".w, \" + temp + \".x, \" + temp + \".x\\n\" +\n\t\t\t\t\"sub \" + temp + \".w, \" + data2 + \".x, \" + temp + \".w\\n\" +\n\t\t\t\t\"mul \" + temp + \".w, \" + data + \".y, \" + temp + \".w\\n\" +\n\t\t\t\t\"mul \" + temp + \".w, \" + data + \".y, \" + temp + \".w\\n\" +\n\t\t\t\t\"sub \" + temp + \".w, \" + data2 + \".x, \" + temp + \".w\\n\" +\n\t\t\t\t\"sqt \" + temp + \".y, \" + temp + \".w\\n\" +\n\n\t\t\t\t\"mul \" + temp + \".x, \" + data + \".y, \" + temp + \".x\\n\" +\n\t\t\t\t\"add \" + temp + \".x, \" + temp + \".x, \" + temp + \".y\\n\" +\n\t\t\t\t\"mul \" + temp + \".xyz, \" + temp + \".x, \" + normalReg + \".xyz\\n\" +\n\n\t\t\t\t\"mul \" + refractionDir + \", \" + data + \".y, \" + viewDirReg + \"\\n\" +\n\t\t\t\t\"sub \" + refractionDir + \".xyz, \" + refractionDir + \".xyz, \" + temp + \".xyz\\n\" +\n\t\t\t\t\"nrm \" + refractionDir + \".xyz, \" + refractionDir + \".xyz\\n\" +\n\t\t\tmethodVO.textureVO._iGetFragmentCode(shader, temp, registerCache, refractionDir) +\n\t\t\t\t\"mov \" + refractionColor + \".y, \" + temp + \".y\\n\";\n\n\t\t\t// BLUE\n\t\t\tcode += \"dp3 \" + temp + \".x, \" + viewDirReg + \".xyz, \" + normalReg + \".xyz\\n\" +\n\t\t\t\t\"mul \" + temp + \".w, \" + temp + \".x, \" + temp + \".x\\n\" +\n\t\t\t\t\"sub \" + temp + \".w, \" + data2 + \".x, \" + temp + \".w\\n\" +\n\t\t\t\t\"mul \" + temp + \".w, \" + data + \".z, \" + temp + \".w\\n\" +\n\t\t\t\t\"mul \" + temp + \".w, \" + data + \".z, \" + temp + \".w\\n\" +\n\t\t\t\t\"sub \" + temp + \".w, \" + data2 + \".x, \" + temp + \".w\\n\" +\n\t\t\t\t\"sqt \" + temp + \".y, \" + temp + \".w\\n\" +\n\n\t\t\t\t\"mul \" + temp + \".x, \" + data + \".z, \" + temp + \".x\\n\" +\n\t\t\t\t\"add \" + temp + \".x, \" + temp + \".x, \" + temp + \".y\\n\" +\n\t\t\t\t\"mul \" + temp + \".xyz, \" + temp + \".x, \" + normalReg + \".xyz\\n\" +\n\n\t\t\t\t\"mul \" + refractionDir + \", \" + data + \".z, \" + viewDirReg + \"\\n\" +\n\t\t\t\t\"sub \" + refractionDir + \".xyz, \" + refractionDir + \".xyz, \" + temp + \".xyz\\n\" +\n\t\t\t\t\"nrm \" + refractionDir + \".xyz, \" + refractionDir + \".xyz\\n\" +\n\t\t\tmethodVO.textureVO._iGetFragmentCode(shader, temp, registerCache, refractionDir) +\n\t\t\t\t\"mov \" + refractionColor + \".z, \" + temp + \".z\\n\";\n\t\t}\n\n\t\tcode += \"sub \" + refractionColor + \".xyz, \" + refractionColor + \".xyz, \" + targetReg + \".xyz\\n\" +\n\t\t\t\"mul \" + refractionColor + \".xyz, \" + refractionColor + \".xyz, \" + data + \".w\\n\" +\n\t\t\t\"add \" + targetReg + \".xyz, \" + targetReg + \".xyz, \" + refractionColor + \".xyz\\n\";\n\n\t\tregisterCache.removeFragmentTempUsage(temp);\n\t\tregisterCache.removeFragmentTempUsage(refractionDir);\n\t\tregisterCache.removeFragmentTempUsage(refractionColor);\n\n\t\t// restore\n\t\tcode += \"neg \" + viewDirReg + \".xyz, \" + viewDirReg + \".xyz\\n\";\n\n\t\treturn code;\n\t}\n}\n\nexport = EffectRefractionEnvMapMethod;",
    "import Stage\t\t\t\t\t\t\t= require(\"awayjs-stagegl/lib/base/Stage\");\n\nimport ShaderBase\t\t\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderBase\");\nimport ShaderRegisterCache\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterCache\");\nimport ShaderRegisterData\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterData\");\nimport ShaderRegisterElement\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterElement\");\n\nimport MethodVO\t\t\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/data/MethodVO\");\nimport EffectMethodBase\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/methods/EffectMethodBase\");\n\n/**\n * EffectRimLightMethod provides a method to add rim lighting to a material. This adds a glow-like effect to edges of objects.\n */\nclass EffectRimLightMethod extends EffectMethodBase\n{\n\tpublic static ADD:string = \"add\";\n\tpublic static MULTIPLY:string = \"multiply\";\n\tpublic static MIX:string = \"mix\";\n\n\tprivate _color:number /*uint*/;\n\tprivate _blendMode:string;\n\tprivate _colorR:number;\n\tprivate _colorG:number;\n\tprivate _colorB:number;\n\tprivate _strength:number;\n\tprivate _power:number;\n\n\t/**\n\t * Creates a new <code>EffectRimLightMethod</code> object.\n\t *\n\t * @param color The colour of the rim light.\n\t * @param strength The strength of the rim light.\n\t * @param power The power of the rim light. Higher values will result in a higher edge fall-off.\n\t * @param blend The blend mode with which to add the light to the object.\n\t */\n\tconstructor(color:number /*uint*/ = 0xffffff, strength:number = .4, power:number = 2, blend:string = \"mix\")\n\t{\n\t\tsuper();\n\n\t\tthis._blendMode = blend;\n\t\tthis._strength = strength;\n\t\tthis._power = power;\n\n\t\tthis.color = color;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitConstants(shader:ShaderBase, methodVO:MethodVO)\n\t{\n\t\tshader.fragmentConstantData[methodVO.fragmentConstantsIndex + 3] = 1;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitVO(shader:ShaderBase, methodVO:MethodVO)\n\t{\n\t\tmethodVO.needsNormals = true;\n\t\tmethodVO.needsView = true;\n\t}\n\n\n\t/**\n\t * The blend mode with which to add the light to the object.\n\t *\n\t * EffectRimLightMethod.MULTIPLY multiplies the rim light with the material's colour.\n\t * EffectRimLightMethod.ADD adds the rim light with the material's colour.\n\t * EffectRimLightMethod.MIX provides normal alpha blending.\n\t */\n\tpublic get blendMode():string\n\t{\n\t\treturn this._blendMode;\n\t}\n\n\tpublic set blendMode(value:string)\n\t{\n\t\tif (this._blendMode == value)\n\t\t\treturn;\n\n\t\tthis._blendMode = value;\n\n\t\tthis.iInvalidateShaderProgram();\n\t}\n\n\t/**\n\t * The color of the rim light.\n\t */\n\tpublic get color():number /*uint*/\n\t{\n\t\treturn this._color;\n\t}\n\n\tpublic set color(value:number /*uint*/)\n\t{\n\t\tthis._color = value;\n\t\tthis._colorR = ((value >> 16) & 0xff)/0xff;\n\t\tthis._colorG = ((value >> 8) & 0xff)/0xff;\n\t\tthis._colorB = (value & 0xff)/0xff;\n\t}\n\n\t/**\n\t * The strength of the rim light.\n\t */\n\tpublic get strength():number\n\t{\n\t\treturn this._strength;\n\t}\n\n\tpublic set strength(value:number)\n\t{\n\t\tthis._strength = value;\n\t}\n\n\t/**\n\t * The power of the rim light. Higher values will result in a higher edge fall-off.\n\t */\n\tpublic get power():number\n\t{\n\t\treturn this._power;\n\t}\n\n\tpublic set power(value:number)\n\t{\n\t\tthis._power = value;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iActivate(shader:ShaderBase, methodVO:MethodVO, stage:Stage)\n\t{\n\t\tvar index:number /*int*/ = methodVO.fragmentConstantsIndex;\n\t\tvar data:Array<number> = shader.fragmentConstantData;\n\t\tdata[index] = this._colorR;\n\t\tdata[index + 1] = this._colorG;\n\t\tdata[index + 2] = this._colorB;\n\t\tdata[index + 4] = this._strength;\n\t\tdata[index + 5] = this._power;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentCode(shader:ShaderBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar dataRegister:ShaderRegisterElement = registerCache.getFreeFragmentConstant();\n\t\tvar dataRegister2:ShaderRegisterElement = registerCache.getFreeFragmentConstant();\n\t\tvar temp:ShaderRegisterElement = registerCache.getFreeFragmentVectorTemp();\n\t\tvar code:string = \"\";\n\n\t\tmethodVO.fragmentConstantsIndex = dataRegister.index*4;\n\n\t\tcode += \"dp3 \" + temp + \".x, \" + sharedRegisters.viewDirFragment + \".xyz, \" + sharedRegisters.normalFragment + \".xyz\\n\" +\n\t\t\t\"sat \" + temp + \".x, \" + temp + \".x\\n\" +\n\t\t\t\"sub \" + temp + \".x, \" + dataRegister + \".w, \" + temp + \".x\\n\" +\n\t\t\t\"pow \" + temp + \".x, \" + temp + \".x, \" + dataRegister2 + \".y\\n\" +\n\t\t\t\"mul \" + temp + \".x, \" + temp + \".x, \" + dataRegister2 + \".x\\n\" +\n\t\t\t\"sub \" + temp + \".x, \" + dataRegister + \".w, \" + temp + \".x\\n\" +\n\t\t\t\"mul \" + targetReg + \".xyz, \" + targetReg + \".xyz, \" + temp + \".x\\n\" +\n\t\t\t\"sub \" + temp + \".w, \" + dataRegister + \".w, \" + temp + \".x\\n\";\n\n\t\tif (this._blendMode == EffectRimLightMethod.ADD) {\n\t\t\tcode += \"mul \" + temp + \".xyz, \" + temp + \".w, \" + dataRegister + \".xyz\\n\" +\n\t\t\t\t\"add \" + targetReg + \".xyz, \" + targetReg + \".xyz, \" + temp + \".xyz\\n\";\n\t\t} else if (this._blendMode == EffectRimLightMethod.MULTIPLY) {\n\t\t\tcode += \"mul \" + temp + \".xyz, \" + temp + \".w, \" + dataRegister + \".xyz\\n\" +\n\t\t\t\t\"mul \" + targetReg + \".xyz, \" + targetReg + \".xyz, \" + temp + \".xyz\\n\";\n\t\t} else {\n\t\t\tcode += \"sub \" + temp + \".xyz, \" + dataRegister + \".xyz, \" + targetReg + \".xyz\\n\" +\n\t\t\t\t\"mul \" + temp + \".xyz, \" + temp + \".xyz, \" + temp + \".w\\n\" +\n\t\t\t\t\"add \" + targetReg + \".xyz, \" + targetReg + \".xyz, \" + temp + \".xyz\\n\";\n\t\t}\n\n\t\treturn code;\n\t}\n}\n\nexport = EffectRimLightMethod;",
    "import ShaderBase\t\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderBase\");\nimport LightingShader\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/LightingShader\");\nimport ShaderRegisterCache\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterCache\");\nimport ShaderRegisterData\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterData\");\nimport ShaderRegisterElement\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterElement\");\n\nimport MethodVO\t\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/data/MethodVO\");\nimport ShadingMethodBase\t\t\t= require(\"awayjs-methodmaterials/lib/methods/ShadingMethodBase\");\n\n/**\n * LightingMethodBase provides an abstract base method for shading methods that uses lights.\n * Used for diffuse and specular shaders only.\n */\nclass LightingMethodBase extends ShadingMethodBase\n{\n\t/**\n\t * A method that is exposed to wrappers in case the strength needs to be controlled\n\t */\n\tpublic _iModulateMethod:(shader:ShaderBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData) => string;\n\n\t/**\n\t * Creates a new LightingMethodBase.\n\t */\n\tconstructor()\n\t{\n\t\tsuper();\n\t}\n\n\t/**\n\t * Get the fragment shader code that will be needed before any per-light code is added.\n\t * @param methodVO The MethodVO object containing the method data for the currently compiled material pass.\n\t * @param regCache The register cache used during the compilation.\n\t * @private\n\t */\n\tpublic iGetFragmentPreLightingCode(shader:LightingShader, methodVO:MethodVO, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\treturn \"\";\n\t}\n\n\t/**\n\t * Get the fragment shader code that will generate the code relevant to a single light.\n\t *\n\t * @param methodVO The MethodVO object containing the method data for the currently compiled material pass.\n\t * @param lightDirReg The register containing the light direction vector.\n\t * @param lightColReg The register containing the light colour.\n\t * @param regCache The register cache used during the compilation.\n\t */\n\tpublic iGetFragmentCodePerLight(shader:LightingShader, methodVO:MethodVO, lightDirReg:ShaderRegisterElement, lightColReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\treturn \"\";\n\t}\n\n\t/**\n\t * Get the fragment shader code that will generate the code relevant to a single light probe object.\n\t *\n\t * @param methodVO The MethodVO object containing the method data for the currently compiled material pass.\n\t * @param cubeMapReg The register containing the cube map for the current probe\n\t * @param weightRegister A string representation of the register + component containing the current weight\n\t * @param regCache The register cache providing any necessary registers to the shader\n\t */\n\tpublic iGetFragmentCodePerProbe(shader:LightingShader, methodVO:MethodVO, cubeMapReg:ShaderRegisterElement, weightRegister:string, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\treturn \"\";\n\t}\n\n\t/**\n\t * Get the fragment shader code that should be added after all per-light code. Usually composits everything to the target register.\n\t *\n\t * @param methodVO The MethodVO object containing the method data for the currently compiled material pass.\n\t * @param regCache The register cache used during the compilation.\n\t * @param targetReg The register containing the final shading output.\n\t * @private\n\t */\n\tpublic iGetFragmentPostLightingCode(shader:LightingShader, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\treturn \"\";\n\t}\n}\n\nexport = LightingMethodBase;",
    "import TextureBase\t\t\t\t\t= require(\"awayjs-display/lib/textures/TextureBase\");\n\nimport Stage\t\t\t\t\t\t= require(\"awayjs-stagegl/lib/base/Stage\");\n\nimport ShaderBase\t\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderBase\");\nimport ShaderRegisterCache\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterCache\");\nimport ShaderRegisterData\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterData\");\nimport ShaderRegisterElement\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterElement\");\n\nimport MethodVO\t\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/data/MethodVO\");\nimport ShadingMethodBase\t\t\t= require(\"awayjs-methodmaterials/lib/methods/ShadingMethodBase\");\n\n/**\n * NormalBasicMethod is the default method for standard tangent-space normal mapping.\n */\nclass NormalBasicMethod extends ShadingMethodBase\n{\n\tprivate _normalMap:TextureBase;\n\n\t/**\n\t * Creates a new NormalBasicMethod object.\n\t */\n\tconstructor(normalMap:TextureBase = null)\n\t{\n\t\tsuper();\n\n\t\tthis._normalMap = normalMap;\n\t}\n\n\tpublic iIsUsed(shader:ShaderBase):boolean\n\t{\n\t\tif (this._normalMap && shader.normalDependencies)\n\t\t\treturn true;\n\n\t\treturn false;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitVO(shader:ShaderBase, methodVO:MethodVO)\n\t{\n\t\tif (this._normalMap) {\n\t\t\tmethodVO.textureVO = shader.getTextureVO(this._normalMap);\n\t\t\tshader.uvDependencies++;\n\t\t}\n\t}\n\n\t/**\n\t * Indicates whether or not this method outputs normals in tangent space. Override for object-space normals.\n\t */\n\tpublic iOutputsTangentNormals():boolean\n\t{\n\t\treturn true;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic copyFrom(method:ShadingMethodBase)\n\t{\n\t\tvar s:any = method;\n\t\tvar bnm:NormalBasicMethod = <NormalBasicMethod> method;\n\n\t\tif (bnm.normalMap != null)\n\t\t\tthis.normalMap = bnm.normalMap;\n\t}\n\n\t/**\n\t * The texture containing the normals per pixel.\n\t */\n\tpublic get normalMap():TextureBase\n\t{\n\t\treturn this._normalMap;\n\t}\n\n\tpublic set normalMap(value:TextureBase)\n\t{\n\t\tif (this._normalMap == value)\n\t\t\treturn;\n\n\t\tthis._normalMap = value;\n\n\t\tthis.iInvalidateShaderProgram();\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic dispose()\n\t{\n\t\tif (this._normalMap)\n\t\t\tthis._normalMap = null;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iActivate(shader:ShaderBase, methodVO:MethodVO, stage:Stage)\n\t{\n\t\tif (this._normalMap)\n\t\t\tmethodVO.textureVO.activate(shader);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentCode(shader:ShaderBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = \"\";\n\n\t\tif (this._normalMap) {\n\t\t\tmethodVO.textureVO._iInitRegisters(shader, registerCache);\n\n\t\t\tcode += methodVO.textureVO._iGetFragmentCode(shader, targetReg, registerCache, sharedRegisters.uvVarying);\n\t\t}\n\n\t\tcode += \"sub \" + targetReg + \".xyz, \" + targetReg + \".xyz, \" + sharedRegisters.commons + \".xxx\\n\" +\n\t\t\t\"nrm \" + targetReg + \".xyz, \" + targetReg + \"\\n\";\n\n\t\treturn code;\n\t}\n}\n\nexport = NormalBasicMethod;",
    "import TextureBase\t\t\t\t\t\t= require(\"awayjs-display/lib/textures/TextureBase\");\n\nimport ShaderBase\t\t\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderBase\");\nimport ShaderRegisterCache\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterCache\");\nimport ShaderRegisterData\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterData\");\nimport ShaderRegisterElement\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterElement\");\n\nimport MethodVO\t\t\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/data/MethodVO\");\nimport NormalBasicMethod\t\t\t\t= require(\"awayjs-methodmaterials/lib/methods/NormalBasicMethod\");\nimport ShadingMethodBase\t\t\t\t= require(\"awayjs-methodmaterials/lib/methods/ShadingMethodBase\");\n\n/**\n * NormalHeightMapMethod provides a normal map method that uses a height map to calculate the normals.\n */\nclass NormalHeightMapMethod extends NormalBasicMethod\n{\n\tprivate _worldXYRatio:number;\n\tprivate _worldXZRatio:number;\n\n\t/**\n\t * Creates a new NormalHeightMapMethod method.\n\t *\n\t * @param heightMap The texture containing the height data. 0 means low, 1 means high.\n\t * @param worldWidth The width of the 'world'. This is used to map uv coordinates' u component to scene dimensions.\n\t * @param worldHeight The height of the 'world'. This is used to map the height map values to scene dimensions.\n\t * @param worldDepth The depth of the 'world'. This is used to map uv coordinates' v component to scene dimensions.\n\t */\n\tconstructor(heightMap:TextureBase, worldWidth:number, worldHeight:number, worldDepth:number)\n\t{\n\t\tsuper();\n\n\t\tthis.normalMap = heightMap;\n\t\tthis._worldXYRatio = worldWidth/worldHeight;\n\t\tthis._worldXZRatio = worldDepth/worldHeight;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitConstants(shader:ShaderBase, methodVO:MethodVO)\n\t{\n\t\tvar index:number /*int*/ = methodVO.fragmentConstantsIndex;\n\t\tvar data:Array<number> = shader.fragmentConstantData;\n\t\tdata[index] = 1/this.normalMap.width;\n\t\tdata[index + 1] = 1/this.normalMap.height;\n\t\tdata[index + 2] = 0;\n\t\tdata[index + 3] = 1;\n\t\tdata[index + 4] = this._worldXYRatio;\n\t\tdata[index + 5] = this._worldXZRatio;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic get tangentSpace():boolean\n\t{\n\t\treturn false;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic copyFrom(method:ShadingMethodBase)\n\t{\n\t\tsuper.copyFrom(method);\n\n\t\tthis._worldXYRatio = (<NormalHeightMapMethod> method)._worldXYRatio;\n\t\tthis._worldXZRatio = (<NormalHeightMapMethod> method)._worldXZRatio;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentCode(shader:ShaderBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = \"\";\n\t\tvar temp:ShaderRegisterElement = registerCache.getFreeFragmentVectorTemp();\n\t\tregisterCache.addFragmentTempUsages(temp, 1);\n\n\t\tvar dataReg:ShaderRegisterElement = registerCache.getFreeFragmentConstant();\n\t\tvar dataReg2:ShaderRegisterElement = registerCache.getFreeFragmentConstant();\n\n\t\tmethodVO.fragmentConstantsIndex = dataReg.index*4;\n\n\t\tcode+= methodVO.textureVO._iGetFragmentCode(shader, targetReg, registerCache, sharedRegisters.uvVarying) +\n\n\t\t\t\"add \" + temp + \", \" + sharedRegisters.uvVarying + \", \" + dataReg + \".xzzz\\n\" +\n\n\t\tmethodVO.textureVO._iGetFragmentCode(shader, temp, registerCache, temp) +\n\n\t\t\t\"sub \" + targetReg + \".x, \" + targetReg + \".x, \" + temp + \".x\\n\" +\n\t\t\t\"add \" + temp + \", \" + sharedRegisters.uvVarying + \", \" + dataReg + \".zyzz\\n\" +\n\n\t\tmethodVO.textureVO._iGetFragmentCode(shader, temp, registerCache, temp) +\n\n\t\t\t\"sub \" + targetReg + \".z, \" + targetReg + \".z, \" + temp + \".x\\n\" +\n\t\t\t\"mov \" + targetReg + \".y, \" + dataReg + \".w\\n\" +\n\t\t\t\"mul \" + targetReg + \".xz, \" + targetReg + \".xz, \" + dataReg2 + \".xy\\n\" +\n\t\t\t\"nrm \" + targetReg + \".xyz, \" + targetReg + \".xyz\\n\";\n\n\t\tregisterCache.removeFragmentTempUsage(temp);\n\n\t\treturn code;\n\t}\n}\n\nexport = NormalHeightMapMethod;",
    "import TextureBase\t\t\t\t\t\t= require(\"awayjs-display/lib/textures/TextureBase\");\n\nimport Stage\t\t\t\t\t\t\t= require(\"awayjs-stagegl/lib/base/Stage\");\n\nimport ShaderBase\t\t\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderBase\");\nimport ShaderRegisterCache\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterCache\");\nimport ShaderRegisterData\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterData\");\nimport ShaderRegisterElement\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterElement\");\n\nimport MethodVO\t\t\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/data/MethodVO\");\nimport NormalBasicMethod\t\t\t\t= require(\"awayjs-methodmaterials/lib/methods/NormalBasicMethod\");\n\n/**\n * NormalSimpleWaterMethod provides a basic normal map method to create water ripples by translating two wave normal maps.\n */\nclass NormalSimpleWaterMethod extends NormalBasicMethod\n{\n\tprivate _secondaryNormalMap:TextureBase;\n\tprivate _water1OffsetX:number = 0;\n\tprivate _water1OffsetY:number = 0;\n\tprivate _water2OffsetX:number = 0;\n\tprivate _water2OffsetY:number = 0;\n\n\t/**\n\t * Creates a new NormalSimpleWaterMethod object.\n\t * @param waveMap1 A normal map containing one layer of a wave structure.\n\t * @param waveMap2 A normal map containing a second layer of a wave structure.\n\t */\n\tconstructor(normalMap:TextureBase = null, secondaryNormalMap:TextureBase = null)\n\t{\n\t\tsuper(normalMap);\n\n\t\tthis._secondaryNormalMap = secondaryNormalMap;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitConstants(shader:ShaderBase, methodVO:MethodVO)\n\t{\n\t\tvar index:number = methodVO.fragmentConstantsIndex;\n\t\tvar data:Array<number> = shader.fragmentConstantData;\n\t\tdata[index] = .5;\n\t\tdata[index + 1] = 0;\n\t\tdata[index + 2] = 0;\n\t\tdata[index + 3] = 1;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitVO(shader:ShaderBase, methodVO:MethodVO)\n\t{\n\t\tsuper.iInitVO(shader, methodVO);\n\t\t\n\t\tif (this._secondaryNormalMap) {\n\t\t\tmethodVO.secondaryTextureVO = shader.getTextureVO(this._secondaryNormalMap);\n\t\t\tshader.uvDependencies++;\n\t\t}\n\t}\n\n\t/**\n\t * The translation of the first wave layer along the X-axis.\n\t */\n\tpublic get water1OffsetX():number\n\t{\n\t\treturn this._water1OffsetX;\n\t}\n\n\tpublic set water1OffsetX(value:number)\n\t{\n\t\tthis._water1OffsetX = value;\n\t}\n\n\t/**\n\t * The translation of the first wave layer along the Y-axis.\n\t */\n\tpublic get water1OffsetY():number\n\t{\n\t\treturn this._water1OffsetY;\n\t}\n\n\tpublic set water1OffsetY(value:number)\n\t{\n\t\tthis._water1OffsetY = value;\n\t}\n\n\t/**\n\t * The translation of the second wave layer along the X-axis.\n\t */\n\tpublic get water2OffsetX():number\n\t{\n\t\treturn this._water2OffsetX;\n\t}\n\n\tpublic set water2OffsetX(value:number)\n\t{\n\t\tthis._water2OffsetX = value;\n\t}\n\n\t/**\n\t * The translation of the second wave layer along the Y-axis.\n\t */\n\tpublic get water2OffsetY():number\n\t{\n\t\treturn this._water2OffsetY;\n\t}\n\n\tpublic set water2OffsetY(value:number)\n\t{\n\t\tthis._water2OffsetY = value;\n\t}\n\n\t/**\n\t * A second normal map that will be combined with the first to create a wave-like animation pattern.\n\t */\n\tpublic get secondaryNormalMap():TextureBase\n\t{\n\t\treturn this._secondaryNormalMap;\n\t}\n\n\tpublic set secondaryNormalMap(value:TextureBase)\n\t{\n\t\tif (this._secondaryNormalMap == value)\n\t\t\treturn;\n\n\t\tthis._secondaryNormalMap = value;\n\n\t\tthis.iInvalidateShaderProgram();\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic dispose()\n\t{\n\t\tsuper.dispose();\n\n\t\tthis._secondaryNormalMap = null;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iActivate(shader:ShaderBase, methodVO:MethodVO, stage:Stage)\n\t{\n\t\tsuper.iActivate(shader, methodVO, stage);\n\n\t\tvar data:Array<number> = shader.fragmentConstantData;\n\t\tvar index:number = methodVO.fragmentConstantsIndex;\n\n\t\tdata[index + 4] = this._water1OffsetX;\n\t\tdata[index + 5] = this._water1OffsetY;\n\t\tdata[index + 6] = this._water2OffsetX;\n\t\tdata[index + 7] = this._water2OffsetY;\n\n\t\tif (this._secondaryNormalMap)\n\t\t\tmethodVO.secondaryTextureVO.activate(shader);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentCode(shader:ShaderBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = \"\";\n\t\tvar temp:ShaderRegisterElement = registerCache.getFreeFragmentVectorTemp();\n\t\tregisterCache.addFragmentTempUsages(temp, 1);\n\n\t\tvar dataReg:ShaderRegisterElement = registerCache.getFreeFragmentConstant();\n\t\tvar dataReg2:ShaderRegisterElement = registerCache.getFreeFragmentConstant();\n\t\tmethodVO.fragmentConstantsIndex = dataReg.index*4;\n\n\t\tcode += \"add \" + temp + \", \" + sharedRegisters.uvVarying + \", \" + dataReg2 + \".xyxy\\n\";\n\n\t\tif (this.normalMap) {\n\t\t\tmethodVO.textureVO._iInitRegisters(shader, registerCache);\n\n\t\t\tcode += methodVO.textureVO._iGetFragmentCode(shader, targetReg, registerCache, temp);\n\t\t}\n\n\t\tcode += \"add \" + temp + \", \" + sharedRegisters.uvVarying + \", \" + dataReg2 + \".zwzw\\n\";\n\n\t\tif (this._secondaryNormalMap) {\n\t\t\tmethodVO.secondaryTextureVO._iInitRegisters(shader, registerCache);\n\n\t\t\tcode += methodVO.secondaryTextureVO._iGetFragmentCode(shader, temp, registerCache, temp);\n\t\t}\n\n\t\tcode +=\t\"add \" + targetReg + \", \" + targetReg + \", \" + temp + \"\t\t\\n\" +\n\t\t\t\"mul \" + targetReg + \", \" + targetReg + \", \" + dataReg + \".x\t\\n\" +\n\t\t\t\"sub \" + targetReg + \".xyz, \" + targetReg + \".xyz, \" + sharedRegisters.commons + \".xxx\t\\n\" +\n\t\t\t\"nrm \" + targetReg + \".xyz, \" + targetReg + \".xyz\t\t\t\t\t\t\t\\n\";\n\n\t\treturn code;\n\t}\n}\n\nexport = NormalSimpleWaterMethod;",
    "import AssetBase\t\t\t\t\t= require(\"awayjs-core/lib/library/AssetBase\");\n\nimport Camera\t\t\t\t\t\t= require(\"awayjs-display/lib/entities/Camera\");\n\nimport Stage\t\t\t\t\t\t= require(\"awayjs-stagegl/lib/base/Stage\");\n\nimport RenderableBase\t\t\t\t= require(\"awayjs-renderergl/lib/renderables/RenderableBase\");\nimport ShadingMethodEvent\t\t\t= require(\"awayjs-renderergl/lib/events/ShadingMethodEvent\");\nimport ShaderBase\t\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderBase\");\nimport ShaderRegisterCache\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterCache\");\nimport ShaderRegisterData\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterData\");\nimport ShaderRegisterElement\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterElement\");\n\nimport MethodVO\t\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/data/MethodVO\");\n\n\n/**\n * ShadingMethodBase provides an abstract base method for shading methods, used by compiled passes to compile\n * the final shading program.\n */\nclass ShadingMethodBase extends AssetBase\n{\n\tpublic static assetType:string = \"[asset ShadingMethod]\";\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic get assetType():string\n\t{\n\t\treturn ShadingMethodBase.assetType;\n\t}\n\n\t/**\n\t * Create a new ShadingMethodBase object.\n\t */\n\tconstructor()\n\t{\n\t\tsuper();\n\t}\n\n\tpublic iIsUsed(shader:ShaderBase):boolean\n\t{\n\t\treturn true;\n\t}\n\n\t/**\n\t * Initializes the properties for a MethodVO, including register and texture indices.\n\t *\n\t * @param methodVO The MethodVO object linking this method with the pass currently being compiled.\n\t *\n\t * @internal\n\t */\n\tpublic iInitVO(shader:ShaderBase, methodVO:MethodVO)\n\t{\n\n\t}\n\n\t/**\n\t * Initializes unchanging shader constants using the data from a MethodVO.\n\t *\n\t * @param methodVO The MethodVO object linking this method with the pass currently being compiled.\n\t *\n\t * @internal\n\t */\n\tpublic iInitConstants(shader:ShaderBase, methodVO:MethodVO)\n\t{\n\n\n\t}\n\n\t/**\n\t * Indicates whether or not this method expects normals in tangent space. Override for object-space normals.\n\t */\n\tpublic iUsesTangentSpace():boolean\n\t{\n\t\treturn true;\n\t}\n\n\t/**\n\t * Cleans up any resources used by the current object.\n\t */\n\tpublic dispose()\n\t{\n\n\t}\n\n\t/**\n\t * Resets the compilation state of the method.\n\t *\n\t * @internal\n\t */\n\tpublic iReset()\n\t{\n\t\tthis.iCleanCompilationData();\n\t}\n\n\t/**\n\t * Resets the method's state for compilation.\n\t *\n\t * @internal\n\t */\n\tpublic iCleanCompilationData()\n\t{\n\t}\n\n\t/**\n\t * Get the vertex shader code for this method.\n\t * @param vo The MethodVO object linking this method with the pass currently being compiled.\n\t * @param regCache The register cache used during the compilation.\n\t *\n\t * @internal\n\t */\n\tpublic iGetVertexCode(shader:ShaderBase, methodVO:MethodVO, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\treturn \"\";\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentCode(shader:ShaderBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\treturn null;\n\t}\n\n\t/**\n\t * Sets the render state for this method.\n\t *\n\t * @param methodVO The MethodVO object linking this method with the pass currently being compiled.\n\t * @param stage The Stage object currently used for rendering.\n\t *\n\t * @internal\n\t */\n\tpublic iActivate(shader:ShaderBase, methodVO:MethodVO, stage:Stage)\n\t{\n\n\t}\n\n\t/**\n\t * Sets the render state for a single renderable.\n\t *\n\t * @param vo The MethodVO object linking this method with the pass currently being compiled.\n\t * @param renderable The renderable currently being rendered.\n\t * @param stage The Stage object currently used for rendering.\n\t * @param camera The camera from which the scene is currently rendered.\n\t *\n\t * @internal\n\t */\n\tpublic iSetRenderState(shader:ShaderBase, methodVO:MethodVO, renderable:RenderableBase, stage:Stage, camera:Camera)\n\t{\n\n\t}\n\n\t/**\n\t * Clears the render state for this method.\n\t * @param vo The MethodVO object linking this method with the pass currently being compiled.\n\t * @param stage The Stage object currently used for rendering.\n\t *\n\t * @internal\n\t */\n\tpublic iDeactivate(shader:ShaderBase, methodVO:MethodVO, stage:Stage)\n\t{\n\n\t}\n\n\t/**\n\t * Marks the shader program as invalid, so it will be recompiled before the next render.\n\t *\n\t * @internal\n\t */\n\tpublic iInvalidateShaderProgram()\n\t{\n\t\tthis.dispatchEvent(new ShadingMethodEvent(ShadingMethodEvent.SHADER_INVALIDATED));\n\t}\n\n\t/**\n\t * Copies the state from a ShadingMethodBase object into the current object.\n\t */\n\tpublic copyFrom(method:ShadingMethodBase)\n\t{\n\t}\n}\n\nexport = ShadingMethodBase;",
    "import Event\t\t\t\t\t\t\t= require(\"awayjs-core/lib/events/Event\");\n\nimport Camera\t\t\t\t\t\t\t= require(\"awayjs-display/lib/entities/Camera\");\nimport DirectionalLight\t\t\t\t\t= require(\"awayjs-display/lib/entities/DirectionalLight\");\nimport CascadeShadowMapper\t\t\t\t= require(\"awayjs-display/lib/materials/shadowmappers/CascadeShadowMapper\");\nimport TextureBase\t\t\t\t\t\t= require(\"awayjs-display/lib/textures/TextureBase\");\n\nimport Stage\t\t\t\t\t\t\t= require(\"awayjs-stagegl/lib/base/Stage\");\n\nimport RenderableBase\t\t\t\t\t= require(\"awayjs-renderergl/lib/renderables/RenderableBase\");\nimport ShadingMethodEvent\t\t\t\t= require(\"awayjs-renderergl/lib/events/ShadingMethodEvent\");\nimport LightingShader\t\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/LightingShader\");\nimport ShaderBase\t\t\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderBase\");\nimport ShaderRegisterCache\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterCache\");\nimport ShaderRegisterData\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterData\");\nimport ShaderRegisterElement\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterElement\");\n\nimport MethodVO\t\t\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/data/MethodVO\");\nimport ShadowMapMethodBase\t\t\t\t= require(\"awayjs-methodmaterials/lib/methods/ShadowMapMethodBase\");\nimport ShadowMethodBase\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/methods/ShadowMethodBase\");\n\n/**\n * ShadowCascadeMethod is a shadow map method to apply cascade shadow mapping on materials.\n * Must be used with a DirectionalLight with a CascadeShadowMapper assigned to its shadowMapper property.\n *\n * @see away.lights.CascadeShadowMapper\n */\nclass ShadowCascadeMethod extends ShadowMapMethodBase\n{\n\tprivate _baseMethod:ShadowMethodBase;\n\tprivate _cascadeShadowMapper:CascadeShadowMapper;\n\tprivate _depthMapCoordVaryings:Array<ShaderRegisterElement>;\n\tprivate _cascadeProjections:Array<ShaderRegisterElement>;\n\n\t/**\n\t * Creates a new ShadowCascadeMethod object.\n\t *\n\t * @param shadowMethodBase The shadow map sampling method used to sample individual cascades (fe: ShadowHardMethod, ShadowSoftMethod)\n\t */\n\tconstructor(shadowMethodBase:ShadowMethodBase)\n\t{\n\t\tsuper(shadowMethodBase.castingLight);\n\n\t\tthis._baseMethod = shadowMethodBase;\n\t\tif (!(this._pCastingLight instanceof DirectionalLight))\n\t\t\tthrow new Error(\"ShadowCascadeMethod is only compatible with DirectionalLight\");\n\n\t\tthis._cascadeShadowMapper = <CascadeShadowMapper> this._pCastingLight.shadowMapper;\n\n\t\tif (!this._cascadeShadowMapper)\n\t\t\tthrow new Error(\"ShadowCascadeMethod requires a light that has a CascadeShadowMapper instance assigned to shadowMapper.\");\n\n\t\tthis._cascadeShadowMapper.addEventListener(Event.CHANGE, (event:Event) => this.onCascadeChange(event));\n\t\tthis._baseMethod.addEventListener(ShadingMethodEvent.SHADER_INVALIDATED, (event:ShadingMethodEvent) => this.onShaderInvalidated(event));\n\t}\n\n\t/**\n\t * The shadow map sampling method used to sample individual cascades. These are typically those used in conjunction\n\t * with a DirectionalShadowMapper.\n\t *\n\t * @see ShadowHardMethod\n\t * @see ShadowSoftMethod\n\t */\n\tpublic get baseMethod():ShadowMethodBase\n\t{\n\t\treturn this._baseMethod;\n\t}\n\n\tpublic set baseMethod(value:ShadowMethodBase)\n\t{\n\t\tif (this._baseMethod == value)\n\t\t\treturn;\n\n\t\tthis._baseMethod.removeEventListener(ShadingMethodEvent.SHADER_INVALIDATED, (event:ShadingMethodEvent) => this.onShaderInvalidated(event));\n\n\t\tthis._baseMethod = value;\n\n\t\tthis._baseMethod.addEventListener(ShadingMethodEvent.SHADER_INVALIDATED, (event:ShadingMethodEvent) => this.onShaderInvalidated(event));\n\n\t\tthis.iInvalidateShaderProgram();\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitVO(shader:LightingShader, methodVO:MethodVO)\n\t{\n\t\tvar tempVO:MethodVO = new MethodVO(this._baseMethod);\n\t\tthis._baseMethod.iInitVO(shader, tempVO);\n\n\t\tmethodVO.needsGlobalVertexPos = true;\n\t\tmethodVO.needsProjection = true;\n\n\t\tmethodVO.textureVO = shader.getTextureVO(this._pCastingLight.shadowMapper.depthMap);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitConstants(shader:ShaderBase, methodVO:MethodVO)\n\t{\n\t\tvar fragmentData:Array<number> = shader.fragmentConstantData;\n\t\tvar vertexData:Array<number> = shader.vertexConstantData;\n\t\tvar index:number = methodVO.fragmentConstantsIndex;\n\t\tfragmentData[index] = 1.0;\n\t\tfragmentData[index + 1] = 1/255.0;\n\t\tfragmentData[index + 2] = 1/65025.0;\n\t\tfragmentData[index + 3] = 1/16581375.0;\n\n\t\tfragmentData[index + 6] = .5;\n\t\tfragmentData[index + 7] = -.5;\n\n\t\tindex = methodVO.vertexConstantsIndex;\n\t\tvertexData[index] = .5;\n\t\tvertexData[index + 1] = -.5;\n\t\tvertexData[index + 2] = 0;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iCleanCompilationData()\n\t{\n\t\tsuper.iCleanCompilationData();\n\t\tthis._cascadeProjections = null;\n\t\tthis._depthMapCoordVaryings = null;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetVertexCode(shader:ShaderBase, methodVO:MethodVO, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = \"\";\n\t\tvar dataReg:ShaderRegisterElement = registerCache.getFreeVertexConstant();\n\n\t\tthis.initProjectionsRegs(registerCache);\n\t\tmethodVO.vertexConstantsIndex = dataReg.index*4;\n\n\t\tvar temp:ShaderRegisterElement = registerCache.getFreeVertexVectorTemp();\n\n\t\tfor (var i:number = 0; i < this._cascadeShadowMapper.numCascades; ++i) {\n\t\t\tcode += \"m44 \" + temp + \", \" + sharedRegisters.globalPositionVertex + \", \" + this._cascadeProjections[i] + \"\\n\" +\n\t\t\t\t\"add \" + this._depthMapCoordVaryings[i] + \", \" + temp + \", \" + dataReg + \".zzwz\\n\";\n\t\t}\n\n\t\treturn code;\n\t}\n\n\t/**\n\t * Creates the registers for the cascades' projection coordinates.\n\t */\n\tprivate initProjectionsRegs(registerCache:ShaderRegisterCache)\n\t{\n\t\tthis._cascadeProjections = new Array<ShaderRegisterElement>(this._cascadeShadowMapper.numCascades);\n\t\tthis._depthMapCoordVaryings = new Array<ShaderRegisterElement>(this._cascadeShadowMapper.numCascades);\n\n\t\tfor (var i:number = 0; i < this._cascadeShadowMapper.numCascades; ++i) {\n\t\t\tthis._depthMapCoordVaryings[i] = registerCache.getFreeVarying();\n\t\t\tthis._cascadeProjections[i] = registerCache.getFreeVertexConstant();\n\t\t\tregisterCache.getFreeVertexConstant();\n\t\t\tregisterCache.getFreeVertexConstant();\n\t\t\tregisterCache.getFreeVertexConstant();\n\t\t}\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentCode(shader:ShaderBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar numCascades:number = this._cascadeShadowMapper.numCascades;\n\t\tvar decReg:ShaderRegisterElement = registerCache.getFreeFragmentConstant();\n\t\tvar dataReg:ShaderRegisterElement = registerCache.getFreeFragmentConstant();\n\t\tvar planeDistanceReg:ShaderRegisterElement = registerCache.getFreeFragmentConstant();\n\t\tvar planeDistances:Array<string> = Array<string>( planeDistanceReg + \".x\", planeDistanceReg + \".y\", planeDistanceReg + \".z\", planeDistanceReg + \".w\" );\n\t\tvar code:string;\n\n\t\tmethodVO.fragmentConstantsIndex = decReg.index*4;\n\n\t\tvar inQuad:ShaderRegisterElement = registerCache.getFreeFragmentVectorTemp();\n\t\tregisterCache.addFragmentTempUsages(inQuad, 1);\n\t\tvar uvCoord:ShaderRegisterElement = registerCache.getFreeFragmentVectorTemp();\n\t\tregisterCache.addFragmentTempUsages(uvCoord, 1);\n\n\t\t// assume lowest partition is selected, will be overwritten later otherwise\n\t\tcode = \"mov \" + uvCoord + \", \" + this._depthMapCoordVaryings[numCascades - 1] + \"\\n\";\n\n\t\tfor (var i:number = numCascades - 2; i >= 0; --i) {\n\t\t\tvar uvProjection:ShaderRegisterElement = this._depthMapCoordVaryings[i];\n\n\t\t\t// calculate if in texturemap (result == 0 or 1, only 1 for a single partition)\n\t\t\tcode += \"slt \" + inQuad + \".z, \" + sharedRegisters.projectionFragment + \".z, \" + planeDistances[i] + \"\\n\"; // z = x > minX, w = y > minY\n\n\t\t\tvar temp:ShaderRegisterElement = registerCache.getFreeFragmentVectorTemp();\n\n\t\t\t// linearly interpolate between old and new uv coords using predicate value == conditional toggle to new value if predicate == 1 (true)\n\t\t\tcode += \"sub \" + temp + \", \" + uvProjection + \", \" + uvCoord + \"\\n\" +\n\t\t\t\t\"mul \" + temp + \", \" + temp + \", \" + inQuad + \".z\\n\" +\n\t\t\t\t\"add \" + uvCoord + \", \" + uvCoord + \", \" + temp + \"\\n\";\n\t\t}\n\n\t\tregisterCache.removeFragmentTempUsage(inQuad);\n\n\t\tcode += \"div \" + uvCoord + \", \" + uvCoord + \", \" + uvCoord + \".w\\n\" +\n\t\t\t\"mul \" + uvCoord + \".xy, \" + uvCoord + \".xy, \" + dataReg + \".zw\\n\" +\n\t\t\t\"add \" + uvCoord + \".xy, \" + uvCoord + \".xy, \" + dataReg + \".zz\\n\";\n\n\t\tcode += this._baseMethod._iGetCascadeFragmentCode(shader, methodVO, decReg, uvCoord, targetReg, registerCache, sharedRegisters) +\n\t\t\t\"add \" + targetReg + \".w, \" + targetReg + \".w, \" + dataReg + \".y\\n\";\n\n\t\tregisterCache.removeFragmentTempUsage(uvCoord);\n\n\t\treturn code;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iActivate(shader:ShaderBase, methodVO:MethodVO, stage:Stage)\n\t{\n\t\tmethodVO.textureVO.activate(shader);\n\n\t\tvar vertexData:Array<number> = shader.vertexConstantData;\n\t\tvar vertexIndex:number = methodVO.vertexConstantsIndex;\n\n\t\tshader.vertexConstantData[methodVO.vertexConstantsIndex + 3] = -1/(this._cascadeShadowMapper.depth*this._pEpsilon);\n\n\t\tvar numCascades:number = this._cascadeShadowMapper.numCascades;\n\t\tvertexIndex += 4;\n\t\tfor (var k:number = 0; k < numCascades; ++k) {\n\t\t\tthis._cascadeShadowMapper.getDepthProjections(k).copyRawDataTo(vertexData, vertexIndex, true);\n\t\t\tvertexIndex += 16;\n\t\t}\n\n\t\tvar fragmentData:Array<number> = shader.fragmentConstantData;\n\t\tvar fragmentIndex:number = methodVO.fragmentConstantsIndex;\n\t\tfragmentData[fragmentIndex + 5] = 1 - this._pAlpha;\n\n\t\tvar nearPlaneDistances:Array<number> = this._cascadeShadowMapper._iNearPlaneDistances;\n\n\t\tfragmentIndex += 8;\n\t\tfor (var i:number = 0; i < numCascades; ++i)\n\t\t\tfragmentData[fragmentIndex + i] = nearPlaneDistances[i];\n\n\t\tthis._baseMethod.iActivateForCascade(shader, methodVO, stage);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iSetRenderState(shader:ShaderBase, methodVO:MethodVO, renderable:RenderableBase, stage:Stage, camera:Camera)\n\t{\n\t}\n\n\t/**\n\t * Called when the shadow mappers cascade configuration changes.\n\t */\n\tprivate onCascadeChange(event:Event)\n\t{\n\t\tthis.iInvalidateShaderProgram();\n\t}\n\n\t/**\n\t * Called when the base method's shader code is invalidated.\n\t */\n\tprivate onShaderInvalidated(event:ShadingMethodEvent)\n\t{\n\t\tthis.iInvalidateShaderProgram();\n\t}\n}\n\nexport = ShadowCascadeMethod;",
    "import BitmapImage2D\t\t\t\t\t= require(\"awayjs-core/lib/data/BitmapImage2D\");\n\nimport DirectionalLight\t\t\t\t\t= require(\"awayjs-display/lib/entities/DirectionalLight\");\nimport Single2DTexture\t\t\t\t\t= require(\"awayjs-display/lib/textures/Single2DTexture\");\n\nimport Stage\t\t\t\t\t\t\t= require(\"awayjs-stagegl/lib/base/Stage\");\n\nimport LightingShader\t\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/LightingShader\");\nimport ShaderBase\t\t\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderBase\");\nimport ShaderRegisterCache\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterCache\");\nimport ShaderRegisterData\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterData\");\nimport ShaderRegisterElement\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterElement\");\n\nimport MethodVO\t\t\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/data/MethodVO\");\nimport ShadowMethodBase\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/methods/ShadowMethodBase\");\n\n/**\n * ShadowDitheredMethod provides a soft shadowing technique by randomly distributing sample points differently for each fragment.\n */\nclass ShadowDitheredMethod extends ShadowMethodBase\n{\n\tprivate static _grainTexture:Single2DTexture;\n\tprivate static _grainUsages:number /*int*/;\n\tprivate static _grainBitmapImage2D:BitmapImage2D;\n\tprivate _depthMapSize:number /*int*/;\n\tprivate _range:number;\n\tprivate _numSamples:number /*int*/;\n\n\t/**\n\t * Creates a new ShadowDitheredMethod object.\n\t * @param castingLight The light casting the shadows\n\t * @param numSamples The amount of samples to take for dithering. Minimum 1, maximum 24.\n\t */\n\tconstructor(castingLight:DirectionalLight, numSamples:number /*int*/ = 4, range:number = 1)\n\t{\n\t\tsuper(castingLight);\n\n\t\tthis._depthMapSize = this._pCastingLight.shadowMapper.depthMapSize;\n\n\t\tthis.numSamples = numSamples;\n\t\tthis.range = range;\n\n\t\t++ShadowDitheredMethod._grainUsages;\n\n\t\tif (!ShadowDitheredMethod._grainTexture)\n\t\t\tthis.initGrainTexture();\n\t}\n\n\t/**\n\t * The amount of samples to take for dithering. Minimum 1, maximum 24. The actual maximum may depend on the\n\t * complexity of the shader.\n\t */\n\tpublic get numSamples():number /*int*/\n\t{\n\t\treturn this._numSamples;\n\t}\n\n\tpublic set numSamples(value:number /*int*/)\n\t{\n\t\tif (value < 1)\n\t\t\tvalue = 1;\n\t\telse if (value > 24)\n\t\t\tvalue = 24;\n\n\t\tif (this._numSamples == value)\n\t\t\treturn;\n\n\t\tthis._numSamples = value;\n\n\t\tthis.iInvalidateShaderProgram();\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitVO(shader:LightingShader, methodVO:MethodVO)\n\t{\n\t\tsuper.iInitVO(shader, methodVO);\n\n\t\tmethodVO.needsProjection = true;\n\n\t\tmethodVO.secondaryTextureVO = shader.getTextureVO(ShadowDitheredMethod._grainTexture);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitConstants(shader:ShaderBase, methodVO:MethodVO)\n\t{\n\t\tsuper.iInitConstants(shader, methodVO);\n\n\t\tvar fragmentData:Array<number> = shader.fragmentConstantData;\n\t\tvar index:number /*int*/ = methodVO.fragmentConstantsIndex;\n\t\tfragmentData[index + 8] = 1/this._numSamples;\n\t}\n\n\t/**\n\t * The range in the shadow map in which to distribute the samples.\n\t */\n\tpublic get range():number\n\t{\n\t\treturn this._range*2;\n\t}\n\n\tpublic set range(value:number)\n\t{\n\t\tthis._range = value/2;\n\t}\n\n\t/**\n\t * Creates a texture containing the dithering noise texture.\n\t */\n\tprivate initGrainTexture()\n\t{\n\t\tShadowDitheredMethod._grainBitmapImage2D = new BitmapImage2D(64, 64, false);\n\t\tvar vec:Array<number> /*uint*/ = new Array<number>();\n\t\tvar len:number /*uint*/ = 4096;\n\t\tvar step:number = 1/(this._depthMapSize*this._range);\n\t\tvar r:number, g:number;\n\n\t\tfor (var i:number /*uint*/ = 0; i < len; ++i) {\n\t\t\tr = 2*(Math.random() - .5);\n\t\t\tg = 2*(Math.random() - .5);\n\t\t\tif (r < 0)\n\t\t\t\tr -= step; else\n\t\t\t\tr += step;\n\t\t\tif (g < 0)\n\t\t\t\tg -= step; else\n\t\t\t\tg += step;\n\t\t\tif (r > 1)\n\t\t\t\tr = 1; else if (r < -1)\n\t\t\t\tr = -1;\n\t\t\tif (g > 1)\n\t\t\t\tg = 1; else if (g < -1)\n\t\t\t\tg = -1;\n\t\t\tvec[i] = (Math.floor((r*.5 + .5)*0xff) << 16) | (Math.floor((g*.5 + .5)*0xff) << 8);\n\t\t}\n\n\t\tShadowDitheredMethod._grainBitmapImage2D.setArray(ShadowDitheredMethod._grainBitmapImage2D.rect, vec);\n\t\tShadowDitheredMethod._grainTexture = new Single2DTexture(ShadowDitheredMethod._grainBitmapImage2D);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic dispose()\n\t{\n\t\tif (--ShadowDitheredMethod._grainUsages == 0) {\n\t\t\tShadowDitheredMethod._grainTexture.dispose();\n\t\t\tShadowDitheredMethod._grainBitmapImage2D.dispose();\n\t\t\tShadowDitheredMethod._grainTexture = null;\n\t\t}\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iActivate(shader:ShaderBase, methodVO:MethodVO, stage:Stage)\n\t{\n\t\tsuper.iActivate(shader, methodVO, stage);\n\n\t\tvar data:Array<number> = shader.fragmentConstantData;\n\t\tvar index:number /*uint*/ = methodVO.fragmentConstantsIndex;\n\t\tdata[index + 9] = (stage.width - 1)/63;\n\t\tdata[index + 10] = (stage.height - 1)/63;\n\t\tdata[index + 11] = 2*this._range/this._depthMapSize;\n\n\t\tmethodVO.secondaryTextureVO.activate(shader);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic _pGetPlanarFragmentCode(shader:ShaderBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, regCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar decReg:ShaderRegisterElement = regCache.getFreeFragmentConstant();\n\t\tvar dataReg:ShaderRegisterElement = regCache.getFreeFragmentConstant();\n\t\tvar customDataReg:ShaderRegisterElement = regCache.getFreeFragmentConstant();\n\n\t\tmethodVO.fragmentConstantsIndex = decReg.index*4;\n\n\t\treturn this.getSampleCode(shader, methodVO, customDataReg, decReg, targetReg, regCache, sharedRegisters);\n\t}\n\n\t/**\n\t * Get the actual shader code for shadow mapping\n\t * @param regCache The register cache managing the registers.\n\t * @param depthMapRegister The texture register containing the depth map.\n\t * @param decReg The register containing the depth map decoding data.\n\t * @param targetReg The target register to add the shadow coverage.\n\t */\n\tprivate getSampleCode(shader:ShaderBase, methodVO:MethodVO, customDataReg:ShaderRegisterElement, decReg:ShaderRegisterElement, targetReg:ShaderRegisterElement, regCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = \"\";\n\t\tvar numSamples:number /*int*/ = this._numSamples;\n\t\tvar uvReg:ShaderRegisterElement = regCache.getFreeFragmentVectorTemp();\n\t\tregCache.addFragmentTempUsages(uvReg, 1);\n\t\tvar temp:ShaderRegisterElement = regCache.getFreeFragmentVectorTemp();\n\t\tregCache.addFragmentTempUsages(temp, 1);\n\n\t\tvar projectionReg:ShaderRegisterElement = sharedRegisters.projectionFragment;\n\n\t\tmethodVO.textureVO._iInitRegisters(shader, regCache);\n\t\tmethodVO.secondaryTextureVO._iInitRegisters(shader, regCache);\n\n\t\tcode += \"div \" + uvReg + \", \" + projectionReg + \", \" + projectionReg + \".w\\n\" +\n\t\t\t\"mul \" + uvReg + \".xy, \" + uvReg + \".xy, \" + customDataReg + \".yz\\n\";\n\n\t\twhile (numSamples > 0) {\n\t\t\tif (numSamples == this._numSamples) {\n\t\t\t\tcode += methodVO.secondaryTextureVO._iGetFragmentCode(shader, uvReg, regCache, uvReg);\n\t\t\t} else {\n\t\t\t\tcode += \"mov \" + temp + \", \" + uvReg + \".zwxy \\n\" +\n\t\t\t\t\tmethodVO.secondaryTextureVO._iGetFragmentCode(shader, uvReg, regCache, temp);\n\t\t\t}\n\n\t\t\t// keep grain in uvReg.zw\n\t\t\tcode += \"sub \" + uvReg + \".zw, \" + uvReg + \".xy, fc0.xx\\n\" + // uv-.5\n\t\t\t\t\"mul \" + uvReg + \".zw, \" + uvReg + \".zw, \" + customDataReg + \".w\\n\"; // (tex unpack scale and tex scale in one)\n\n\t\t\tif (numSamples == this._numSamples) {\n\t\t\t\t// first sample\n\t\t\t\tcode += \"add \" + uvReg + \".xy, \" + uvReg + \".zw, \" + this._pDepthMapCoordReg + \".xy\\n\" +\n\t\t\t\t\tmethodVO.textureVO._iGetFragmentCode(shader, temp, regCache, uvReg) +\n\t\t\t\t\t\"dp4 \" + temp + \".z, \" + temp + \", \" + decReg + \"\\n\" +\n\t\t\t\t\t\"slt \" + targetReg + \".w, \" + this._pDepthMapCoordReg + \".z, \" + temp + \".z\\n\"; // 0 if in shadow\n\t\t\t} else {\n\t\t\t\tcode += this.addSample(shader, methodVO, uvReg, decReg, targetReg, regCache);\n\t\t\t}\n\n\t\t\tif (numSamples > 4)\n\t\t\t\tcode += \"add \" + uvReg + \".xy, \" + uvReg + \".xy, \" + uvReg + \".zw\\n\" + this.addSample(shader, methodVO, uvReg, decReg, targetReg, regCache);\n\n\t\t\tif (numSamples > 1)\n\t\t\t\tcode += \"sub \" + uvReg + \".xy, \" + this._pDepthMapCoordReg + \".xy, \" + uvReg + \".zw\\n\" + this.addSample(shader, methodVO, uvReg, decReg, targetReg, regCache);\n\n\t\t\tif (numSamples > 5)\n\t\t\t\tcode += \"sub \" + uvReg + \".xy, \" + uvReg + \".xy, \" + uvReg + \".zw\\n\" + this.addSample(shader, methodVO, uvReg, decReg, targetReg, regCache);\n\n\t\t\tif (numSamples > 2) {\n\t\t\t\tcode += \"neg \" + uvReg + \".w, \" + uvReg + \".w\\n\"; // will be rotated 90 degrees when being accessed as wz\n\t\t\t\tcode += \"add \" + uvReg + \".xy, \" + uvReg + \".wz, \" + this._pDepthMapCoordReg + \".xy\\n\" + this.addSample(shader, methodVO, uvReg, decReg, targetReg, regCache);\n\t\t\t}\n\n\t\t\tif (numSamples > 6)\n\t\t\t\tcode += \"add \" + uvReg + \".xy, \" + uvReg + \".xy, \" + uvReg + \".wz\\n\" + this.addSample(shader, methodVO, uvReg, decReg, targetReg, regCache);\n\n\t\t\tif (numSamples > 3)\n\t\t\t\tcode += \"sub \" + uvReg + \".xy, \" + this._pDepthMapCoordReg + \".xy, \" + uvReg + \".wz\\n\" + this.addSample(shader, methodVO, uvReg, decReg, targetReg, regCache);\n\n\t\t\tif (numSamples > 7)\n\t\t\t\tcode += \"sub \" + uvReg + \".xy, \" + uvReg + \".xy, \" + uvReg + \".wz\\n\" + this.addSample(shader, methodVO, uvReg, decReg, targetReg, regCache);\n\n\t\t\tnumSamples -= 8;\n\t\t}\n\n\t\tregCache.removeFragmentTempUsage(temp);\n\t\tregCache.removeFragmentTempUsage(uvReg);\n\t\tcode += \"mul \" + targetReg + \".w, \" + targetReg + \".w, \" + customDataReg + \".x\\n\"; // average\n\t\treturn code;\n\t}\n\n\t/**\n\t * Adds the code for another tap to the shader code.\n\t * @param uvReg The uv register for the tap.\n\t * @param depthMapRegister The texture register containing the depth map.\n\t * @param decReg The register containing the depth map decoding data.\n\t * @param targetReg The target register to add the tap comparison result.\n\t * @param regCache The register cache managing the registers.\n\t * @return\n\t */\n\tprivate addSample(shader:ShaderBase, methodVO:MethodVO, uvReg:ShaderRegisterElement, decReg:ShaderRegisterElement, targetReg:ShaderRegisterElement, regCache:ShaderRegisterCache):string\n\t{\n\t\tvar temp:ShaderRegisterElement = regCache.getFreeFragmentVectorTemp();\n\n\t\treturn methodVO.textureVO._iGetFragmentCode(shader, temp, regCache, uvReg) +\n\t\t\t\"dp4 \" + temp + \".z, \" + temp + \", \" + decReg + \"\\n\" +\n\t\t\t\"slt \" + temp + \".z, \" + this._pDepthMapCoordReg + \".z, \" + temp + \".z\\n\" + // 0 if in shadow\n\t\t\t\"add \" + targetReg + \".w, \" + targetReg + \".w, \" + temp + \".z\\n\";\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iActivateForCascade(shader:ShaderBase, methodVO:MethodVO, stage:Stage)\n\t{\n\t\tvar data:Array<number> = shader.fragmentConstantData;\n\t\tvar index:number /*uint*/ = methodVO.secondaryFragmentConstantsIndex;\n\t\tdata[index] = 1/this._numSamples;\n\t\tdata[index + 1] = (stage.width - 1)/63;\n\t\tdata[index + 2] = (stage.height - 1)/63;\n\t\tdata[index + 3] = 2*this._range/this._depthMapSize;\n\n\t\tmethodVO.secondaryTextureVO.activate(shader);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic _iGetCascadeFragmentCode(shader:ShaderBase, methodVO:MethodVO, decodeRegister:ShaderRegisterElement, depthProjection:ShaderRegisterElement, targetRegister:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tthis._pDepthMapCoordReg = depthProjection;\n\n\t\tvar dataReg:ShaderRegisterElement = registerCache.getFreeFragmentConstant();\n\t\tmethodVO.secondaryFragmentConstantsIndex = dataReg.index*4;\n\n\t\treturn this.getSampleCode(shader, methodVO, dataReg, decodeRegister, targetRegister, registerCache, sharedRegisters);\n\t}\n}\n\nexport = ShadowDitheredMethod;",
    "import DirectionalLight\t\t\t\t\t= require(\"awayjs-display/lib/entities/DirectionalLight\");\n\nimport Stage\t\t\t\t\t\t\t= require(\"awayjs-stagegl/lib/base/Stage\");\n\nimport LightingShader\t\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/LightingShader\");\nimport ShaderBase\t\t\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderBase\");\nimport ShaderRegisterCache\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterCache\");\nimport ShaderRegisterData\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterData\");\nimport ShaderRegisterElement\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterElement\");\n\nimport MethodVO\t\t\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/data/MethodVO\");\nimport ShadowMethodBase\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/methods/ShadowMethodBase\");\n\n/**\n * ShadowFilteredMethod provides a softened shadowing technique by bilinearly interpolating shadow comparison\n * results of neighbouring pixels.\n */\nclass ShadowFilteredMethod extends ShadowMethodBase\n{\n\t/**\n\t * Creates a new DiffuseBasicMethod object.\n\t *\n\t * @param castingLight The light casting the shadow\n\t */\n\tconstructor(castingLight:DirectionalLight)\n\t{\n\t\tsuper(castingLight);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitConstants(shader:LightingShader, methodVO:MethodVO)\n\t{\n\t\tsuper.iInitConstants(shader, methodVO);\n\n\t\tvar fragmentData:Array<number> = shader.fragmentConstantData;\n\t\tvar index:number /*int*/ = methodVO.fragmentConstantsIndex;\n\t\tfragmentData[index + 8] = .5;\n\t\tvar size:number /*int*/ = this.castingLight.shadowMapper.depthMapSize;\n\t\tfragmentData[index + 9] = size;\n\t\tfragmentData[index + 10] = 1/size;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic _pGetPlanarFragmentCode(shader:ShaderBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, regCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = \"\";\n\t\tvar decReg:ShaderRegisterElement = regCache.getFreeFragmentConstant();\n\t\tregCache.getFreeFragmentConstant();\n\t\tvar customDataReg:ShaderRegisterElement = regCache.getFreeFragmentConstant();\n\n\t\tmethodVO.fragmentConstantsIndex = decReg.index*4;\n\n\t\tvar depthCol:ShaderRegisterElement = regCache.getFreeFragmentVectorTemp();\n\t\tregCache.addFragmentTempUsages(depthCol, 1);\n\t\tvar uvReg:ShaderRegisterElement = regCache.getFreeFragmentVectorTemp();\n\t\tregCache.addFragmentTempUsages(uvReg, 1);\n\n\t\tmethodVO.textureVO._iInitRegisters(shader, regCache);\n\n\t\tcode += \"mov \" + uvReg + \", \" + this._pDepthMapCoordReg + \"\\n\" +\n\n\t\t\tmethodVO.textureVO._iGetFragmentCode(shader, depthCol, regCache, this._pDepthMapCoordReg) +\n\t\t\t\"dp4 \" + depthCol + \".z, \" + depthCol + \", \" + decReg + \"\\n\" +\n\t\t\t\"slt \" + uvReg + \".z, \" + this._pDepthMapCoordReg + \".z, \" + depthCol + \".z\\n\" +   // 0 if in shadow\n\n\t\t\t\"add \" + uvReg + \".x, \" + this._pDepthMapCoordReg + \".x, \" + customDataReg + \".z\\n\" + \t// (1, 0)\n\t\t\tmethodVO.textureVO._iGetFragmentCode(shader, depthCol, regCache, uvReg) +\n\t\t\t\"dp4 \" + depthCol + \".z, \" + depthCol + \", \" + decReg + \"\\n\" +\n\t\t\t\"slt \" + uvReg + \".w, \" + this._pDepthMapCoordReg + \".z, \" + depthCol + \".z\\n\" +   // 0 if in shadow\n\n\t\t\t\"mul \" + depthCol + \".x, \" + this._pDepthMapCoordReg + \".x, \" + customDataReg + \".y\\n\" +\n\t\t\t\"frc \" + depthCol + \".x, \" + depthCol + \".x\\n\" +\n\t\t\t\"sub \" + uvReg + \".w, \" + uvReg + \".w, \" + uvReg + \".z\\n\" +\n\t\t\t\"mul \" + uvReg + \".w, \" + uvReg + \".w, \" + depthCol + \".x\\n\" +\n\t\t\t\"add \" + targetReg + \".w, \" + uvReg + \".z, \" + uvReg + \".w\\n\" +\n\n\t\t\t\"mov \" + uvReg + \".x, \" + this._pDepthMapCoordReg + \".x\\n\" +\n\t\t\t\"add \" + uvReg + \".y, \" + this._pDepthMapCoordReg + \".y, \" + customDataReg + \".z\\n\" +\t// (0, 1)\n\t\t\tmethodVO.textureVO._iGetFragmentCode(shader, depthCol, regCache, uvReg) +\n\t\t\t\"dp4 \" + depthCol + \".z, \" + depthCol + \", \" + decReg + \"\\n\" +\n\t\t\t\"slt \" + uvReg + \".z, \" + this._pDepthMapCoordReg + \".z, \" + depthCol + \".z\\n\" +   // 0 if in shadow\n\n\t\t\t\"add \" + uvReg + \".x, \" + this._pDepthMapCoordReg + \".x, \" + customDataReg + \".z\\n\" +\t// (1, 1)\n\t\t\tmethodVO.textureVO._iGetFragmentCode(shader, depthCol, regCache, uvReg) +\n\t\t\t\"dp4 \" + depthCol + \".z, \" + depthCol + \", \" + decReg + \"\\n\" +\n\t\t\t\"slt \" + uvReg + \".w, \" + this._pDepthMapCoordReg + \".z, \" + depthCol + \".z\\n\" +   // 0 if in shadow\n\n\t\t\t// recalculate fraction, since we ran out of registers :(\n\t\t\t\"mul \" + depthCol + \".x, \" + this._pDepthMapCoordReg + \".x, \" + customDataReg + \".y\\n\" +\n\t\t\t\"frc \" + depthCol + \".x, \" + depthCol + \".x\\n\" + \"sub \" + uvReg + \".w, \" + uvReg + \".w, \" + uvReg + \".z\\n\" +\n\t\t\t\"mul \" + uvReg + \".w, \" + uvReg + \".w, \" + depthCol + \".x\\n\" +\n\t\t\t\"add \" + uvReg + \".w, \" + uvReg + \".z, \" + uvReg + \".w\\n\" +\n\n\t\t\t\"mul \" + depthCol + \".x, \" + this._pDepthMapCoordReg + \".y, \" + customDataReg + \".y\\n\" +\n\t\t\t\"frc \" + depthCol + \".x, \" + depthCol + \".x\\n\" +\n\t\t\t\"sub \" + uvReg + \".w, \" + uvReg + \".w, \" + targetReg + \".w\\n\" +\n\t\t\t\"mul \" + uvReg + \".w, \" + uvReg + \".w, \" + depthCol + \".x\\n\" +\n\t\t\t\"add \" + targetReg + \".w, \" + targetReg + \".w, \" + uvReg + \".w\\n\";\n\n\t\tregCache.removeFragmentTempUsage(depthCol);\n\t\tregCache.removeFragmentTempUsage(uvReg);\n\n\t\treturn code;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iActivateForCascade(shader:ShaderBase, methodVO:MethodVO, stage:Stage)\n\t{\n\t\tvar size:number /*int*/ = this.castingLight.shadowMapper.depthMapSize;\n\t\tvar index:number /*int*/ = methodVO.secondaryFragmentConstantsIndex;\n\t\tvar data:Array<number> = shader.fragmentConstantData;\n\t\tdata[index] = size;\n\t\tdata[index + 1] = 1/size;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic _iGetCascadeFragmentCode(shader:ShaderBase, methodVO:MethodVO, decodeRegister:ShaderRegisterElement, depthProjection:ShaderRegisterElement, targetRegister:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string;\n\t\tvar dataReg:ShaderRegisterElement = registerCache.getFreeFragmentConstant();\n\t\tmethodVO.secondaryFragmentConstantsIndex = dataReg.index*4;\n\n\t\tvar temp:ShaderRegisterElement = registerCache.getFreeFragmentVectorTemp();\n\t\tregisterCache.addFragmentTempUsages(temp, 1);\n\t\tvar predicate:ShaderRegisterElement = registerCache.getFreeFragmentVectorTemp();\n\t\tregisterCache.addFragmentTempUsages(predicate, 1);\n\n\t\tmethodVO.textureVO._iInitRegisters(shader, registerCache);\n\n\t\tcode = methodVO.textureVO._iGetFragmentCode(shader, temp, registerCache, depthProjection) +\n\t\t\t\"dp4 \" + temp + \".z, \" + temp + \", \" + decodeRegister + \"\\n\" +\n\t\t\t\"slt \" + predicate + \".x, \" + depthProjection + \".z, \" + temp + \".z\\n\" +\n\n\t\t\t\"add \" + depthProjection + \".x, \" + depthProjection + \".x, \" + dataReg + \".y\\n\" +\n\t\t\tmethodVO.textureVO._iGetFragmentCode(shader, temp, registerCache, depthProjection) +\n\t\t\t\"dp4 \" + temp + \".z, \" + temp + \", \" + decodeRegister + \"\\n\" +\n\t\t\t\"slt \" + predicate + \".z, \" + depthProjection + \".z, \" + temp + \".z\\n\" +\n\n\t\t\t\"add \" + depthProjection + \".y, \" + depthProjection + \".y, \" + dataReg + \".y\\n\" +\n\t\t\tmethodVO.textureVO._iGetFragmentCode(shader, temp, registerCache, depthProjection) +\n\t\t\t\"dp4 \" + temp + \".z, \" + temp + \", \" + decodeRegister + \"\\n\" +\n\t\t\t\"slt \" + predicate + \".w, \" + depthProjection + \".z, \" + temp + \".z\\n\" +\n\n\t\t\t\"sub \" + depthProjection + \".x, \" + depthProjection + \".x, \" + dataReg + \".y\\n\" +\n\t\t\tmethodVO.textureVO._iGetFragmentCode(shader, temp, registerCache, depthProjection) +\n\t\t\t\"dp4 \" + temp + \".z, \" + temp + \", \" + decodeRegister + \"\\n\" +\n\t\t\t\"slt \" + predicate + \".y, \" + depthProjection + \".z, \" + temp + \".z\\n\" +\n\n\t\t\t\"mul \" + temp + \".xy, \" + depthProjection + \".xy, \" + dataReg + \".x\\n\" +\n\t\t\t\"frc \" + temp + \".xy, \" + temp + \".xy\\n\" +\n\n\t\t\t// some strange register juggling to prevent agal bugging out\n\t\t\t\"sub \" + depthProjection + \", \" + predicate + \".xyzw, \" + predicate + \".zwxy\\n\" +\n\t\t\t\"mul \" + depthProjection + \", \" + depthProjection + \", \" + temp + \".x\\n\" +\n\n\t\t\t\"add \" + predicate + \".xy, \" + predicate + \".xy, \" + depthProjection + \".zw\\n\" +\n\n\t\t\t\"sub \" + predicate + \".y, \" + predicate + \".y, \" + predicate + \".x\\n\" +\n\t\t\t\"mul \" + predicate + \".y, \" + predicate + \".y, \" + temp + \".y\\n\" +\n\t\t\t\"add \" + targetRegister + \".w, \" + predicate + \".x, \" + predicate + \".y\\n\";\n\n\t\tregisterCache.removeFragmentTempUsage(temp);\n\t\tregisterCache.removeFragmentTempUsage(predicate);\n\t\treturn code;\n\t}\n}\n\nexport = ShadowFilteredMethod;",
    "import LightBase\t\t\t\t\t= require(\"awayjs-display/lib/base/LightBase\");\n\nimport Stage\t\t\t\t\t\t= require(\"awayjs-stagegl/lib/base/Stage\");\n\nimport ShaderBase\t\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderBase\");\nimport ShaderRegisterCache\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterCache\");\nimport ShaderRegisterData\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterData\");\nimport ShaderRegisterElement\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterElement\");\n\nimport MethodVO\t\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/data/MethodVO\");\nimport ShadowMethodBase\t\t\t\t= require(\"awayjs-methodmaterials/lib/methods/ShadowMethodBase\");\n\n/**\n * ShadowHardMethod provides the cheapest shadow map method by using a single tap without any filtering.\n */\nclass ShadowHardMethod extends ShadowMethodBase\n{\n\t/**\n\t * Creates a new ShadowHardMethod object.\n\t */\n\tconstructor(castingLight:LightBase)\n\t{\n\t\tsuper(castingLight);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic _pGetPlanarFragmentCode(shader:ShaderBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, regCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = \"\";\n\t\tvar decReg:ShaderRegisterElement = regCache.getFreeFragmentConstant();\n\t\tregCache.getFreeFragmentConstant();\n\n\t\tvar depthCol:ShaderRegisterElement = regCache.getFreeFragmentVectorTemp();\n\n\t\tmethodVO.fragmentConstantsIndex = decReg.index*4;\n\n\t\tmethodVO.textureVO._iInitRegisters(shader, regCache);\n\n\t\tcode += methodVO.textureVO._iGetFragmentCode(shader, depthCol, regCache, this._pDepthMapCoordReg) +\n\t\t\t\"dp4 \" + depthCol + \".z, \" + depthCol + \", \" + decReg + \"\\n\" +\n\t\t\t\"slt \" + targetReg + \".w, \" + this._pDepthMapCoordReg + \".z, \" + depthCol + \".z\\n\"; // 0 if in shadow\n\n\t\treturn code;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic _pGetPointFragmentCode(shader:ShaderBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, regCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = \"\";\n\t\tvar decReg:ShaderRegisterElement = regCache.getFreeFragmentConstant();\n\t\tvar epsReg:ShaderRegisterElement = regCache.getFreeFragmentConstant();\n\t\tvar posReg:ShaderRegisterElement = regCache.getFreeFragmentConstant();\n\t\tvar depthSampleCol:ShaderRegisterElement = regCache.getFreeFragmentVectorTemp();\n\t\tregCache.addFragmentTempUsages(depthSampleCol, 1);\n\t\tvar lightDir:ShaderRegisterElement = regCache.getFreeFragmentVectorTemp();\n\t\tregCache.addFragmentTempUsages(lightDir, 1);\n\n\t\tmethodVO.fragmentConstantsIndex = decReg.index*4;\n\n\t\tmethodVO.textureVO._iInitRegisters(shader, regCache);\n\n\t\tcode += \"sub \" + lightDir + \", \" + sharedRegisters.globalPositionVarying + \", \" + posReg + \"\\n\" +\n\t\t\t\"dp3 \" + lightDir + \".w, \" + lightDir + \".xyz, \" + lightDir + \".xyz\\n\" +\n\t\t\t\"mul \" + lightDir + \".w, \" + lightDir + \".w, \" + posReg + \".w\\n\" +\n\t\t\t\"nrm \" + lightDir + \".xyz, \" + lightDir + \".xyz\\n\" +\n\n\t\t\tmethodVO.textureVO._iGetFragmentCode(shader, depthSampleCol, regCache, lightDir) +\n\t\t\t\"dp4 \" + depthSampleCol + \".z, \" + depthSampleCol + \", \" + decReg + \"\\n\" +\n\t\t\t\"add \" + targetReg + \".w, \" + lightDir + \".w, \" + epsReg + \".x\\n\" +    // offset by epsilon\n\n\t\t\t\"slt \" + targetReg + \".w, \" + targetReg + \".w, \" + depthSampleCol + \".z\\n\"; // 0 if in shadow\n\n\t\tregCache.removeFragmentTempUsage(lightDir);\n\t\tregCache.removeFragmentTempUsage(depthSampleCol);\n\n\t\treturn code;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic _iGetCascadeFragmentCode(shader:ShaderBase, methodVO:MethodVO, decodeRegister:ShaderRegisterElement, depthProjection:ShaderRegisterElement, targetRegister:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar temp:ShaderRegisterElement = registerCache.getFreeFragmentVectorTemp();\n\t\treturn methodVO.textureVO._iGetFragmentCode(shader, temp, registerCache, depthProjection) +\n\t\t\t\"dp4 \" + temp + \".z, \" + temp + \", \" + decodeRegister + \"\\n\" +\n\t\t\t\"slt \" + targetRegister + \".w, \" + depthProjection + \".z, \" + temp + \".z\\n\"; // 0 if in shadow\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iActivateForCascade(shader:ShaderBase, methodVO:MethodVO, stage:Stage)\n\t{\n\t}\n}\n\nexport = ShadowHardMethod;",
    "import IAsset\t\t\t\t\t\t= require(\"awayjs-core/lib/library/IAsset\");\n\nimport LightBase\t\t\t\t\t= require(\"awayjs-display/lib/base/LightBase\");\nimport ShadowMapperBase\t\t\t\t= require(\"awayjs-display/lib/materials/shadowmappers/ShadowMapperBase\");\n\nimport ShadingMethodBase\t\t\t= require(\"awayjs-methodmaterials/lib/methods/ShadingMethodBase\");\n\n/**\n * ShadowMapMethodBase provides an abstract base method for shadow map methods.\n */\nclass ShadowMapMethodBase extends ShadingMethodBase implements IAsset\n{\n\tpublic static assetType:string = \"[asset ShadowMapMethod]\";\n\n\tpublic _pCastingLight:LightBase;\n\tpublic _pShadowMapper:ShadowMapperBase;\n\n\tpublic _pEpsilon:number = .02;\n\tpublic _pAlpha:number = 1;\n\n\t/**\n\t * Creates a new ShadowMapMethodBase object.\n\t * @param castingLight The light used to cast shadows.\n\t */\n\tconstructor(castingLight:LightBase)\n\t{\n\t\tsuper();\n\t\tthis._pCastingLight = castingLight;\n\t\tcastingLight.castsShadows = true;\n\t\tthis._pShadowMapper = castingLight.shadowMapper;\n\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic get assetType():string\n\t{\n\t\treturn ShadowMapMethodBase.assetType;\n\t}\n\n\t/**\n\t * The \"transparency\" of the shadows. This allows making shadows less strong.\n\t */\n\tpublic get alpha():number\n\t{\n\t\treturn this._pAlpha;\n\t}\n\n\tpublic set alpha(value:number)\n\t{\n\t\tthis._pAlpha = value;\n\t}\n\n\t/**\n\t * The light casting the shadows.\n\t */\n\tpublic get castingLight():LightBase\n\t{\n\t\treturn this._pCastingLight;\n\t}\n\n\t/**\n\t * A small value to counter floating point precision errors when comparing values in the shadow map with the\n\t * calculated depth value. Increase this if shadow banding occurs, decrease it if the shadow seems to be too detached.\n\t */\n\tpublic get epsilon():number\n\t{\n\t\treturn this._pEpsilon;\n\t}\n\n\tpublic set epsilon(value:number)\n\t{\n\t\tthis._pEpsilon = value;\n\t}\n}\n\nexport = ShadowMapMethodBase;",
    "import Vector3D\t\t\t\t\t\t= require(\"awayjs-core/lib/geom/Vector3D\");\nimport AbstractMethodError\t\t\t= require(\"awayjs-core/lib/errors/AbstractMethodError\");\n\nimport LightBase\t\t\t\t\t= require(\"awayjs-display/lib/base/LightBase\");\nimport Camera\t\t\t\t\t\t= require(\"awayjs-display/lib/entities/Camera\");\nimport DirectionalLight\t\t\t\t= require(\"awayjs-display/lib/entities/DirectionalLight\");\nimport PointLight\t\t\t\t\t= require(\"awayjs-display/lib/entities/PointLight\");\nimport DirectionalShadowMapper\t\t= require(\"awayjs-display/lib/materials/shadowmappers/DirectionalShadowMapper\");\nimport TextureBase\t\t\t\t\t= require(\"awayjs-display/lib/textures/TextureBase\");\n\nimport Stage\t\t\t\t\t\t= require(\"awayjs-stagegl/lib/base/Stage\");\n\nimport RenderableBase\t\t\t\t= require(\"awayjs-renderergl/lib/renderables/RenderableBase\");\nimport LightingShader\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/LightingShader\");\nimport ShaderBase\t\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderBase\");\nimport ShaderRegisterCache\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterCache\");\nimport ShaderRegisterData\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterData\");\nimport ShaderRegisterElement\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterElement\");\n\nimport MethodVO\t\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/data/MethodVO\");\nimport ShadowMapMethodBase\t\t\t= require(\"awayjs-methodmaterials/lib/methods/ShadowMapMethodBase\");\n\n/**\n * ShadowMethodBase provides an abstract method for simple (non-wrapping) shadow map methods.\n */\nclass ShadowMethodBase extends ShadowMapMethodBase\n{\n\tpublic _pDepthMapCoordReg:ShaderRegisterElement;\n\tpublic _pUsePoint:boolean;\n\n\t/**\n\t * Creates a new ShadowMethodBase object.\n\t * @param castingLight The light used to cast shadows.\n\t */\n\tconstructor(castingLight:LightBase)\n\t{\n\t\tthis._pUsePoint = (castingLight instanceof PointLight);\n\n\t\tsuper(castingLight);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitVO(shader:LightingShader, methodVO:MethodVO)\n\t{\n\t\tmethodVO.needsView = true;\n\t\tmethodVO.needsGlobalVertexPos = true;\n\t\tmethodVO.needsGlobalFragmentPos = this._pUsePoint;\n\t\tmethodVO.needsNormals = shader.numLights > 0;\n\n\t\tmethodVO.textureVO = shader.getTextureVO(this._pCastingLight.shadowMapper.depthMap);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitConstants(shader:ShaderBase, methodVO:MethodVO)\n\t{\n\t\tvar fragmentData:Array<number> = shader.fragmentConstantData;\n\t\tvar vertexData:Array<number> = shader.vertexConstantData;\n\t\tvar index:number /*int*/ = methodVO.fragmentConstantsIndex;\n\t\tfragmentData[index] = 1.0;\n\t\tfragmentData[index + 1] = 1/255.0;\n\t\tfragmentData[index + 2] = 1/65025.0;\n\t\tfragmentData[index + 3] = 1/16581375.0;\n\n\t\tfragmentData[index + 6] = 0;\n\t\tfragmentData[index + 7] = 1;\n\n\t\tif (this._pUsePoint) {\n\t\t\tfragmentData[index + 8] = 0;\n\t\t\tfragmentData[index + 9] = 0;\n\t\t\tfragmentData[index + 10] = 0;\n\t\t\tfragmentData[index + 11] = 1;\n\t\t}\n\n\t\tindex = methodVO.vertexConstantsIndex;\n\t\tif (index != -1) {\n\t\t\tvertexData[index] = .5;\n\t\t\tvertexData[index + 1] = .5;\n\t\t\tvertexData[index + 2] = 0.0;\n\t\t\tvertexData[index + 3] = 1.0;\n\t\t}\n\t}\n\n\t/**\n\t * Wrappers that override the vertex shader need to set this explicitly\n\t */\n\tpublic get _iDepthMapCoordReg():ShaderRegisterElement\n\t{\n\t\treturn this._pDepthMapCoordReg;\n\t}\n\n\tpublic set _iDepthMapCoordReg(value:ShaderRegisterElement)\n\t{\n\t\tthis._pDepthMapCoordReg = value;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iCleanCompilationData()\n\t{\n\t\tsuper.iCleanCompilationData();\n\n\t\tthis._pDepthMapCoordReg = null;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetVertexCode(shader:ShaderBase, methodVO:MethodVO, regCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\treturn this._pUsePoint? this._pGetPointVertexCode(methodVO, regCache, sharedRegisters):this.pGetPlanarVertexCode(methodVO, regCache, sharedRegisters);\n\t}\n\n\t/**\n\t * Gets the vertex code for shadow mapping with a point light.\n\t *\n\t * @param methodVO The MethodVO object linking this method with the pass currently being compiled.\n\t * @param regCache The register cache used during the compilation.\n\t */\n\tpublic _pGetPointVertexCode(methodVO:MethodVO, regCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tmethodVO.vertexConstantsIndex = -1;\n\t\treturn \"\";\n\t}\n\n\t/**\n\t * Gets the vertex code for shadow mapping with a planar shadow map (fe: directional lights).\n\t *\n\t * @param methodVO The MethodVO object linking this method with the pass currently being compiled.\n\t * @param regCache The register cache used during the compilation.\n\t */\n\tpublic pGetPlanarVertexCode(methodVO:MethodVO, regCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = \"\";\n\t\tvar temp:ShaderRegisterElement = regCache.getFreeVertexVectorTemp();\n\t\tvar dataReg:ShaderRegisterElement = regCache.getFreeVertexConstant();\n\t\tvar depthMapProj:ShaderRegisterElement = regCache.getFreeVertexConstant();\n\t\tregCache.getFreeVertexConstant();\n\t\tregCache.getFreeVertexConstant();\n\t\tregCache.getFreeVertexConstant();\n\t\tthis._pDepthMapCoordReg = regCache.getFreeVarying();\n\t\tmethodVO.vertexConstantsIndex = dataReg.index*4;\n\n\t\t// todo: can epsilon be applied here instead of fragment shader?\n\n\t\tcode += \"m44 \" + temp + \", \" + sharedRegisters.globalPositionVertex + \", \" + depthMapProj + \"\\n\" +\n\t\t\t\"div \" + temp + \", \" + temp + \", \" + temp + \".w\\n\" +\n\t\t\t\"mul \" + temp + \".xy, \" + temp + \".xy, \" + dataReg + \".xy\\n\" +\n\t\t\t\"add \" + this._pDepthMapCoordReg + \", \" + temp + \", \" + dataReg + \".xxwz\\n\";\n\t\t//\"sub \" + this._pDepthMapCoordReg + \".z, \" + this._pDepthMapCoordReg + \".z, \" + this._pDepthMapCoordReg + \".w\\n\";\n\n\t\treturn code;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentCode(shader:ShaderBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = this._pUsePoint? this._pGetPointFragmentCode(shader, methodVO, targetReg, registerCache, sharedRegisters) : this._pGetPlanarFragmentCode(shader, methodVO, targetReg, registerCache, sharedRegisters);\n\t\tcode += \"add \" + targetReg + \".w, \" + targetReg + \".w, fc\" + (methodVO.fragmentConstantsIndex/4 + 1) + \".y\\n\" +\n\t\t\t\"sat \" + targetReg + \".w, \" + targetReg + \".w\\n\";\n\t\treturn code;\n\t}\n\n\t/**\n\t * Gets the fragment code for shadow mapping with a planar shadow map.\n\t * @param methodVO The MethodVO object linking this method with the pass currently being compiled.\n\t * @param regCache The register cache used during the compilation.\n\t * @param targetReg The register to contain the shadow coverage\n\t * @return\n\t */\n\tpublic _pGetPlanarFragmentCode(shader:ShaderBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, regCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tthrow new AbstractMethodError();\n\t\treturn \"\";\n\t}\n\n\t/**\n\t * Gets the fragment code for shadow mapping with a point light.\n\t * @param methodVO The MethodVO object linking this method with the pass currently being compiled.\n\t * @param regCache The register cache used during the compilation.\n\t * @param targetReg The register to contain the shadow coverage\n\t * @return\n\t */\n\tpublic _pGetPointFragmentCode(shader:ShaderBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, regCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tthrow new AbstractMethodError();\n\t\treturn \"\";\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iSetRenderState(shader:ShaderBase, methodVO:MethodVO, renderable:RenderableBase, stage:Stage, camera:Camera)\n\t{\n\t\tif (!this._pUsePoint)\n\t\t\t(<DirectionalShadowMapper> this._pShadowMapper).iDepthProjection.copyRawDataTo(shader.vertexConstantData, methodVO.vertexConstantsIndex + 4, true);\n\t}\n\n\t/**\n\t * Gets the fragment code for combining this method with a cascaded shadow map method.\n\t * @param methodVO The MethodVO object linking this method with the pass currently being compiled.\n\t * @param regCache The register cache used during the compilation.\n\t * @param decodeRegister The register containing the data to decode the shadow map depth value.\n\t * @param depthTexture The texture containing the shadow map.\n\t * @param depthProjection The projection of the fragment relative to the light.\n\t * @param targetRegister The register to contain the shadow coverage\n\t * @return\n\t */\n\tpublic _iGetCascadeFragmentCode(shader:ShaderBase, methodVO:MethodVO, decodeRegister:ShaderRegisterElement, depthProjection:ShaderRegisterElement, targetRegister:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tthrow new Error(\"This shadow method is incompatible with cascade shadows\");\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iActivate(shader:ShaderBase, methodVO:MethodVO, stage:Stage)\n\t{\n\t\tvar fragmentData:Array<number> = shader.fragmentConstantData;\n\t\tvar index:number /*int*/ = methodVO.fragmentConstantsIndex;\n\n\t\tif (this._pUsePoint)\n\t\t\tfragmentData[index + 4] = -Math.pow(1/((<PointLight> this._pCastingLight).fallOff*this._pEpsilon), 2);\n\t\telse\n\t\t\tshader.vertexConstantData[methodVO.vertexConstantsIndex + 3] = -1/((<DirectionalShadowMapper> this._pShadowMapper).depth*this._pEpsilon);\n\n\t\tfragmentData[index + 5] = 1 - this._pAlpha;\n\n\t\tif (this._pUsePoint) {\n\t\t\tvar pos:Vector3D = this._pCastingLight.scenePosition;\n\t\t\tfragmentData[index + 8] = pos.x;\n\t\t\tfragmentData[index + 9] = pos.y;\n\t\t\tfragmentData[index + 10] = pos.z;\n\t\t\t// used to decompress distance\n\t\t\tvar f:number = (<PointLight> this._pCastingLight).fallOff;\n\t\t\tfragmentData[index + 11] = 1/(2*f*f);\n\t\t}\n\n\t\tmethodVO.textureVO.activate(shader);\n\t}\n\n\t/**\n\t * Sets the method state for cascade shadow mapping.\n\t */\n\tpublic iActivateForCascade(shader:ShaderBase, methodVO:MethodVO, stage:Stage)\n\t{\n\t\tthrow new Error(\"This shadow method is incompatible with cascade shadows\");\n\t}\n}\n\nexport = ShadowMethodBase;",
    "import NearDirectionalShadowMapper\t\t= require(\"awayjs-display/lib/materials/shadowmappers/NearDirectionalShadowMapper\");\nimport Camera\t\t\t\t\t\t\t= require(\"awayjs-display/lib/entities/Camera\");\n\nimport Stage\t\t\t\t\t\t\t= require(\"awayjs-stagegl/lib/base/Stage\");\n\nimport RenderableBase\t\t\t\t\t= require(\"awayjs-renderergl/lib/renderables/RenderableBase\");\nimport ShadingMethodEvent\t\t\t\t= require(\"awayjs-renderergl/lib/events/ShadingMethodEvent\");\nimport LightingShader\t\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/LightingShader\");\nimport ShaderBase\t\t\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderBase\");\nimport ShaderRegisterCache\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterCache\");\nimport ShaderRegisterData\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterData\");\nimport ShaderRegisterElement\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterElement\");\n\nimport MethodVO\t\t\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/data/MethodVO\");\nimport ShadowMethodBase\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/methods/ShadowMethodBase\");\n\n// TODO: shadow mappers references in materials should be an interface so that this class should NOT extend ShadowMapMethodBase just for some delegation work\n/**\n * ShadowNearMethod provides a shadow map method that restricts the shadowed area near the camera to optimize\n * shadow map usage. This method needs to be used in conjunction with a NearDirectionalShadowMapper.\n *\n * @see away.lights.NearDirectionalShadowMapper\n */\nclass ShadowNearMethod extends ShadowMethodBase\n{\n\tprivate _baseMethod:ShadowMethodBase;\n\n\tprivate _fadeRatio:number;\n\tprivate _nearShadowMapper:NearDirectionalShadowMapper;\n\n\tprivate _onShaderInvalidatedDelegate:Function;\n\n\t/**\n\t * Creates a new ShadowNearMethod object.\n\t * @param baseMethod The shadow map sampling method used to sample individual cascades (fe: ShadowHardMethod, ShadowSoftMethod)\n\t * @param fadeRatio The amount of shadow fading to the outer shadow area. A value of 1 would mean the shadows start fading from the camera's near plane.\n\t */\n\tconstructor(baseMethod:ShadowMethodBase, fadeRatio:number = .1)\n\t{\n\t\tsuper(baseMethod.castingLight);\n\n\t\tthis._onShaderInvalidatedDelegate = (event:ShadingMethodEvent) => this.onShaderInvalidated(event);\n\n\t\tthis._baseMethod = baseMethod;\n\t\tthis._fadeRatio = fadeRatio;\n\t\tthis._nearShadowMapper = <NearDirectionalShadowMapper> this._pCastingLight.shadowMapper;\n\t\tif (!this._nearShadowMapper)\n\t\t\tthrow new Error(\"ShadowNearMethod requires a light that has a NearDirectionalShadowMapper instance assigned to shadowMapper.\");\n\t\tthis._baseMethod.addEventListener(ShadingMethodEvent.SHADER_INVALIDATED, this._onShaderInvalidatedDelegate);\n\t}\n\n\t/**\n\t * The base shadow map method on which this method's shading is based.\n\t */\n\tpublic get baseMethod():ShadowMethodBase\n\t{\n\t\treturn this._baseMethod;\n\t}\n\n\tpublic set baseMethod(value:ShadowMethodBase)\n\t{\n\t\tif (this._baseMethod == value)\n\t\t\treturn;\n\n\t\tthis._baseMethod.removeEventListener(ShadingMethodEvent.SHADER_INVALIDATED, this._onShaderInvalidatedDelegate);\n\n\t\tthis._baseMethod = value;\n\n\t\tthis._baseMethod.addEventListener(ShadingMethodEvent.SHADER_INVALIDATED, this._onShaderInvalidatedDelegate);\n\n\t\tthis.iInvalidateShaderProgram();\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitConstants(shader:ShaderBase, methodVO:MethodVO)\n\t{\n\t\tsuper.iInitConstants(shader, methodVO);\n\t\tthis._baseMethod.iInitConstants(shader, methodVO);\n\n\t\tvar fragmentData:Array<number> = shader.fragmentConstantData;\n\t\tvar index:number /*int*/ = methodVO.secondaryFragmentConstantsIndex;\n\t\tfragmentData[index + 2] = 0;\n\t\tfragmentData[index + 3] = 1;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitVO(shader:LightingShader, methodVO:MethodVO)\n\t{\n\t\tthis._baseMethod.iInitVO(shader, methodVO);\n\n\t\tmethodVO.needsProjection = true;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic dispose()\n\t{\n\t\tthis._baseMethod.removeEventListener(ShadingMethodEvent.SHADER_INVALIDATED, this._onShaderInvalidatedDelegate);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic get alpha():number\n\t{\n\t\treturn this._baseMethod.alpha;\n\t}\n\n\tpublic set alpha(value:number)\n\t{\n\t\tthis._baseMethod.alpha = value;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic get epsilon():number\n\t{\n\t\treturn this._baseMethod.epsilon;\n\t}\n\n\tpublic set epsilon(value:number)\n\t{\n\t\tthis._baseMethod.epsilon = value;\n\t}\n\n\t/**\n\t * The amount of shadow fading to the outer shadow area. A value of 1 would mean the shadows start fading from the camera's near plane.\n\t */\n\tpublic get fadeRatio():number\n\t{\n\t\treturn this._fadeRatio;\n\t}\n\n\tpublic set fadeRatio(value:number)\n\t{\n\t\tthis._fadeRatio = value;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentCode(shader:ShaderBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = this._baseMethod.iGetFragmentCode(shader, methodVO, targetReg, registerCache, sharedRegisters);\n\n\t\tvar dataReg:ShaderRegisterElement = registerCache.getFreeFragmentConstant();\n\t\tvar temp:ShaderRegisterElement = registerCache.getFreeFragmentSingleTemp();\n\t\tmethodVO.secondaryFragmentConstantsIndex = dataReg.index*4;\n\n\t\tcode += \"abs \" + temp + \", \" + sharedRegisters.projectionFragment + \".w\\n\" +\n\t\t\t\"sub \" + temp + \", \" + temp + \", \" + dataReg + \".x\\n\" +\n\t\t\t\"mul \" + temp + \", \" + temp + \", \" + dataReg + \".y\\n\" +\n\t\t\t\"sat \" + temp + \", \" + temp + \"\\n\" +\n\t\t\t\"sub \" + temp + \", \" + dataReg + \".w,\" + temp + \"\\n\" +\n\t\t\t\"sub \" + targetReg + \".w, \" + dataReg + \".w,\" + targetReg + \".w\\n\" +\n\t\t\t\"mul \" + targetReg + \".w, \" + targetReg + \".w, \" + temp + \"\\n\" +\n\t\t\t\"sub \" + targetReg + \".w, \" + dataReg + \".w,\" + targetReg + \".w\\n\";\n\n\t\treturn code;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iActivate(shader:ShaderBase, methodVO:MethodVO, stage:Stage)\n\t{\n\t\tthis._baseMethod.iActivate(shader, methodVO, stage);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iDeactivate(shader:ShaderBase, methodVO:MethodVO, stage:Stage)\n\t{\n\t\tthis._baseMethod.iDeactivate(shader, methodVO, stage);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iSetRenderState(shader:ShaderBase, methodVO:MethodVO, renderable:RenderableBase, stage:Stage, camera:Camera)\n\t{\n\t\t// todo: move this to activate (needs camera)\n\t\tvar near:number = camera.projection.near;\n\t\tvar d:number = camera.projection.far - near;\n\t\tvar maxDistance:number = this._nearShadowMapper.coverageRatio;\n\t\tvar minDistance:number = maxDistance*(1 - this._fadeRatio);\n\n\t\tmaxDistance = near + maxDistance*d;\n\t\tminDistance = near + minDistance*d;\n\n\t\tvar fragmentData:Array<number> = shader.fragmentConstantData;\n\t\tvar index:number /*int*/ = methodVO.secondaryFragmentConstantsIndex;\n\t\tfragmentData[index] = minDistance;\n\t\tfragmentData[index + 1] = 1/(maxDistance - minDistance);\n\n\t\tthis._baseMethod.iSetRenderState(shader, methodVO, renderable, stage, camera);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetVertexCode(shader:ShaderBase, methodVO:MethodVO, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\treturn this._baseMethod.iGetVertexCode(shader, methodVO, registerCache, sharedRegisters);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iReset()\n\t{\n\t\tthis._baseMethod.iReset();\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iCleanCompilationData()\n\t{\n\t\tsuper.iCleanCompilationData();\n\t\tthis._baseMethod.iCleanCompilationData();\n\t}\n\n\t/**\n\t * Called when the base method's shader code is invalidated.\n\t */\n\tprivate onShaderInvalidated(event:ShadingMethodEvent)\n\t{\n\t\tthis.iInvalidateShaderProgram();\n\t}\n}\n\nexport = ShadowNearMethod;",
    "import PoissonLookup\t\t\t\t\t= require(\"awayjs-core/lib/geom/PoissonLookup\");\n\nimport DirectionalLight\t\t\t\t\t= require(\"awayjs-display/lib/entities/DirectionalLight\");\n\nimport Stage\t\t\t\t\t\t\t= require(\"awayjs-stagegl/lib/base/Stage\");\n\nimport ShaderBase\t\t\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderBase\");\nimport ShaderRegisterCache\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterCache\");\nimport ShaderRegisterData\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterData\");\nimport ShaderRegisterElement\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterElement\");\n\nimport MethodVO\t\t\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/data/MethodVO\");\nimport ShadowMethodBase\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/methods/ShadowMethodBase\");\n\n/**\n * ShadowSoftMethod provides a soft shadowing technique by randomly distributing sample points.\n */\nclass ShadowSoftMethod extends ShadowMethodBase\n{\n\tprivate _range:number = 1;\n\tprivate _numSamples:number /*int*/;\n\tprivate _offsets:Array<number>;\n\n\t/**\n\t * Creates a new DiffuseBasicMethod object.\n\t *\n\t * @param castingLight The light casting the shadows\n\t * @param numSamples The amount of samples to take for dithering. Minimum 1, maximum 32.\n\t */\n\tconstructor(castingLight:DirectionalLight, numSamples:number /*int*/ = 5, range:number = 1)\n\t{\n\t\tsuper(castingLight);\n\n\t\tthis.numSamples = numSamples;\n\t\tthis.range = range;\n\t}\n\n\t/**\n\t * The amount of samples to take for dithering. Minimum 1, maximum 32. The actual maximum may depend on the\n\t * complexity of the shader.\n\t */\n\tpublic get numSamples():number /*int*/\n\t{\n\t\treturn this._numSamples;\n\t}\n\n\tpublic set numSamples(value:number /*int*/)\n\t{\n\t\tthis._numSamples = value;\n\t\t\n\t\tif (this._numSamples < 1)\n\t\t\tthis._numSamples = 1;\n\t\telse if (this._numSamples > 32)\n\t\t\tthis._numSamples = 32;\n\n\t\tthis._offsets = PoissonLookup.getDistribution(this._numSamples);\n\t\t\n\t\tthis.iInvalidateShaderProgram();\n\t}\n\n\t/**\n\t * The range in the shadow map in which to distribute the samples.\n\t */\n\tpublic get range():number\n\t{\n\t\treturn this._range;\n\t}\n\n\tpublic set range(value:number)\n\t{\n\t\tthis._range = value;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitConstants(shader:ShaderBase, methodVO:MethodVO)\n\t{\n\t\tsuper.iInitConstants(shader, methodVO);\n\n\t\tshader.fragmentConstantData[methodVO.fragmentConstantsIndex + 8] = 1/this._numSamples;\n\t\tshader.fragmentConstantData[methodVO.fragmentConstantsIndex + 9] = 0;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iActivate(shader:ShaderBase, methodVO:MethodVO, stage:Stage)\n\t{\n\t\tsuper.iActivate(shader, methodVO, stage);\n\n\t\tvar texRange:number = .5*this._range/this._pCastingLight.shadowMapper.depthMapSize;\n\t\tvar data:Array<number> = shader.fragmentConstantData;\n\t\tvar index:number /*uint*/ = methodVO.fragmentConstantsIndex + 10;\n\t\tvar len:number /*uint*/ = this._numSamples << 1;\n\n\t\tfor (var i:number /*int*/ = 0; i < len; ++i)\n\t\t\tdata[index + i] = this._offsets[i]*texRange;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic _pGetPlanarFragmentCode(shader:ShaderBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, regCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\t// todo: move some things to super\n\t\tvar decReg:ShaderRegisterElement = regCache.getFreeFragmentConstant();\n\t\tregCache.getFreeFragmentConstant();\n\t\tvar dataReg:ShaderRegisterElement = regCache.getFreeFragmentConstant();\n\n\t\tmethodVO.fragmentConstantsIndex = decReg.index*4;\n\n\t\tmethodVO.textureVO._iInitRegisters(shader, regCache);\n\n\t\treturn this.getSampleCode(shader, methodVO, decReg, targetReg, regCache, dataReg);\n\t}\n\n\t/**\n\t * Adds the code for another tap to the shader code.\n\t * @param uv The uv register for the tap.\n\t * @param texture The texture register containing the depth map.\n\t * @param decode The register containing the depth map decoding data.\n\t * @param target The target register to add the tap comparison result.\n\t * @param regCache The register cache managing the registers.\n\t * @return\n\t */\n\tprivate addSample(shader:ShaderBase, methodVO:MethodVO, decodeRegister:ShaderRegisterElement, targetRegister:ShaderRegisterElement, registerCache:ShaderRegisterCache, uvReg:ShaderRegisterElement):string\n\t{\n\t\tvar temp:ShaderRegisterElement = registerCache.getFreeFragmentVectorTemp();\n\t\treturn methodVO.textureVO._iGetFragmentCode(shader, temp, registerCache, uvReg) +\n\t\t\t\"dp4 \" + temp + \".z, \" + temp + \", \" + decodeRegister + \"\\n\" +\n\t\t\t\"slt \" + uvReg + \".w, \" + this._pDepthMapCoordReg + \".z, \" + temp + \".z\\n\" + // 0 if in shadow\n\t\t\t\"add \" + targetRegister + \".w, \" + targetRegister + \".w, \" + uvReg + \".w\\n\";\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iActivateForCascade(shader:ShaderBase, methodVO:MethodVO, stage:Stage)\n\t{\n\t\tsuper.iActivate(shader, methodVO, stage);\n\n\t\tvar texRange:number = this._range/this._pCastingLight.shadowMapper.depthMapSize;\n\t\tvar data:Array<number> = shader.fragmentConstantData;\n\t\tvar index:number /*uint*/ = methodVO.secondaryFragmentConstantsIndex;\n\t\tvar len:number /*uint*/ = this._numSamples << 1;\n\t\tdata[index] = 1/this._numSamples;\n\t\tdata[index + 1] = 0;\n\t\tindex += 2;\n\n\t\tfor (var i:number /*int*/ = 0; i < len; ++i)\n\t\t\tdata[index + i] = this._offsets[i]*texRange;\n\n\t\tif (len%4 == 0) {\n\t\t\tdata[index + len] = 0;\n\t\t\tdata[index + len + 1] = 0;\n\t\t}\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic _iGetCascadeFragmentCode(shader:ShaderBase, methodVO:MethodVO, decodeRegister:ShaderRegisterElement, depthProjection:ShaderRegisterElement, targetRegister:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tthis._pDepthMapCoordReg = depthProjection;\n\n\t\tvar dataReg:ShaderRegisterElement = registerCache.getFreeFragmentConstant();\n\t\tmethodVO.secondaryFragmentConstantsIndex = dataReg.index*4;\n\n\t\treturn this.getSampleCode(shader, methodVO, decodeRegister, targetRegister, registerCache, dataReg);\n\t}\n\n\t/**\n\t * Get the actual shader code for shadow mapping\n\t * @param regCache The register cache managing the registers.\n\t * @param depthTexture The texture register containing the depth map.\n\t * @param decodeRegister The register containing the depth map decoding data.\n\t * @param targetReg The target register to add the shadow coverage.\n\t * @param dataReg The register containing additional data.\n\t */\n\tprivate getSampleCode(shader:ShaderBase, methodVO:MethodVO, decodeRegister:ShaderRegisterElement, targetRegister:ShaderRegisterElement, registerCache:ShaderRegisterCache, dataReg:ShaderRegisterElement):string\n\t{\n\t\tvar code:string;\n\t\tvar uvReg:ShaderRegisterElement = registerCache.getFreeFragmentVectorTemp();\n\t\tregisterCache.addFragmentTempUsages(uvReg, 1);\n\n\t\tvar offsets:Array<string> = new Array<string>(dataReg + \".zw\");\n\t\tvar numRegs:number /*int*/ = this._numSamples >> 1;\n\n\t\tfor (var i:number /*int*/ = 0; i < numRegs; ++i) {\n\t\t\tvar reg:ShaderRegisterElement = registerCache.getFreeFragmentConstant();\n\t\t\toffsets.push(reg + \".xy\");\n\t\t\toffsets.push(reg + \".zw\");\n\t\t}\n\n\t\tfor (i = 0; i < this._numSamples; ++i) {\n\t\t\tif (i == 0) {\n\t\t\t\tvar temp:ShaderRegisterElement = registerCache.getFreeFragmentVectorTemp();\n\n\t\t\t\tcode = \"add \" + uvReg + \", \" + this._pDepthMapCoordReg + \", \" + dataReg + \".zwyy\\n\" +\n\t\t\t\t\tmethodVO.textureVO._iGetFragmentCode(shader, temp, registerCache, uvReg) +\n\t\t\t\t\t\"dp4 \" + temp + \".z, \" + temp + \", \" + decodeRegister + \"\\n\" +\n\t\t\t\t\t\"slt \" + targetRegister + \".w, \" + this._pDepthMapCoordReg + \".z, \" + temp + \".z\\n\"; // 0 if in shadow;\n\t\t\t} else {\n\t\t\t\tcode += \"add \" + uvReg + \".xy, \" + this._pDepthMapCoordReg + \".xy, \" + offsets[i] + \"\\n\" +\n\t\t\t\t\tthis.addSample(shader, methodVO, decodeRegister, targetRegister, registerCache, uvReg);\n\t\t\t}\n\t\t}\n\n\t\tregisterCache.removeFragmentTempUsage(uvReg);\n\n\t\tcode += \"mul \" + targetRegister + \".w, \" + targetRegister + \".w, \" + dataReg + \".x\\n\"; // average\n\n\t\treturn code;\n\t}\n}\n\nexport = ShadowSoftMethod;",
    "import LightingShader\t\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/LightingShader\");\nimport ShaderRegisterCache\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterCache\");\nimport ShaderRegisterData\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterData\");\nimport ShaderRegisterElement\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterElement\");\n\nimport MethodVO\t\t\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/data/MethodVO\");\nimport SpecularBasicMethod\t\t\t\t= require(\"awayjs-methodmaterials/lib/methods/SpecularBasicMethod\");\n\n/**\n * SpecularAnisotropicMethod provides a specular method resulting in anisotropic highlights. These are typical for\n * surfaces with microfacet details such as tiny grooves. In particular, this uses the Heidrich-Seidel distrubution.\n * The tangent vectors are used as the surface groove directions.\n */\nclass SpecularAnisotropicMethod extends SpecularBasicMethod\n{\n\t/**\n\t * Creates a new SpecularAnisotropicMethod object.\n\t */\n\tconstructor()\n\t{\n\t\tsuper();\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitVO(shader:LightingShader, methodVO:MethodVO)\n\t{\n\t\tmethodVO.needsTangents = true;\n\t\tmethodVO.needsView = true;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentCodePerLight(shader:LightingShader, methodVO:MethodVO, lightDirReg:ShaderRegisterElement, lightColReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = \"\";\n\t\tvar t:ShaderRegisterElement;\n\n\t\tif (this._pIsFirstLight)\n\t\t\tt = this._pTotalLightColorReg;\n\t\telse {\n\t\t\tt = registerCache.getFreeFragmentVectorTemp();\n\t\t\tregisterCache.addFragmentTempUsages(t, 1);\n\t\t}\n\n\t\t// (sin(l,t) * sin(v,t) - cos(l,t)*cos(v,t)) ^ k\n\n\t\tcode += \"nrm \" + t + \".xyz, \" + sharedRegisters.tangentVarying + \".xyz\\n\" +\n\t\t\t\"dp3 \" + t + \".w, \" + t + \".xyz, \" + lightDirReg + \".xyz\\n\" +\n\t\t\t\"dp3 \" + t + \".z, \" + t + \".xyz, \" + sharedRegisters.viewDirFragment + \".xyz\\n\";\n\n\t\t// (sin(t.w) * sin(t.z) - cos(t.w)*cos(t.z)) ^ k\n\t\tcode += \"sin \" + t + \".x, \" + t + \".w\\n\" +\n\t\t\t\"sin \" + t + \".y, \" + t + \".z\\n\" +\n\t\t\t// (t.x * t.y - cos(t.w)*cos(t.z)) ^ k\n\t\t\t\"mul \" + t + \".x, \" + t + \".x, \" + t + \".y\\n\" +\n\t\t\t// (t.x - cos(t.w)*cos(t.z)) ^ k\n\t\t\t\"cos \" + t + \".z, \" + t + \".z\\n\" +\n\t\t\t\"cos \" + t + \".w, \" + t + \".w\\n\" +\n\t\t\t// (t.x - t.w*t.z) ^ k\n\t\t\t\"mul \" + t + \".w, \" + t + \".w, \" + t + \".z\\n\" +\n\t\t\t// (t.x - t.w) ^ k\n\t\t\t\"sub \" + t + \".w, \" + t + \".x, \" + t + \".w\\n\";\n\n\t\tif (this.texture) {\n\t\t\t// apply gloss modulation from texture\n\t\t\tcode += \"mul \" + this._pSpecularTexData + \".w, \" + this._pSpecularTexData + \".y, \" + this._pSpecularDataRegister + \".w\\n\" +\n\t\t\t\t\"pow \" + t + \".w, \" + t + \".w, \" + this._pSpecularTexData + \".w\\n\";\n\t\t} else\n\t\t\tcode += \"pow \" + t + \".w, \" + t + \".w, \" + this._pSpecularDataRegister + \".w\\n\";\n\n\t\t// attenuate\n\t\tcode += \"mul \" + t + \".w, \" + t + \".w, \" + lightDirReg + \".w\\n\";\n\n\t\tif (this._iModulateMethod != null)\n\t\t\tcode += this._iModulateMethod(shader, methodVO, t, registerCache, sharedRegisters);\n\n\t\tcode += \"mul \" + t + \".xyz, \" + lightColReg + \".xyz, \" + t + \".w\\n\";\n\n\t\tif (!this._pIsFirstLight) {\n\t\t\tcode += \"add \" + this._pTotalLightColorReg + \".xyz, \" + this._pTotalLightColorReg + \".xyz, \" + t + \".xyz\\n\";\n\t\t\tregisterCache.removeFragmentTempUsage(t);\n\t\t}\n\n\t\tthis._pIsFirstLight = false;\n\n\t\treturn code;\n\t}\n}\n\nexport = SpecularAnisotropicMethod;",
    "import TextureBase\t\t\t\t\t= require(\"awayjs-display/lib/textures/TextureBase\");\n\nimport Stage\t\t\t\t\t\t= require(\"awayjs-stagegl/lib/base/Stage\");\n\nimport LightingShader\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/LightingShader\");\nimport ShaderRegisterCache\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterCache\");\nimport ShaderRegisterData\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterData\");\nimport ShaderRegisterElement\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterElement\");\n\nimport MethodVO\t\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/data/MethodVO\");\nimport LightingMethodBase\t\t\t= require(\"awayjs-methodmaterials/lib/methods/LightingMethodBase\");\nimport ShadingMethodBase\t\t\t= require(\"awayjs-methodmaterials/lib/methods/ShadingMethodBase\");\n\n/**\n * SpecularBasicMethod provides the default shading method for Blinn-Phong specular highlights (an optimized but approximated\n * version of Phong specularity).\n */\nclass SpecularBasicMethod extends LightingMethodBase\n{\n\tpublic _pTotalLightColorReg:ShaderRegisterElement;\n\tpublic _pSpecularTexData:ShaderRegisterElement;\n\tpublic _pSpecularDataRegister:ShaderRegisterElement;\n\n\tprivate _texture:TextureBase;\n\n\tprivate _gloss:number = 50;\n\tprivate _specular:number = 1;\n\tprivate _specularColor:number = 0xffffff;\n\tpublic _iSpecularR:number = 1;\n\tpublic _iSpecularG:number = 1;\n\tpublic _iSpecularB:number = 1;\n\tpublic _pIsFirstLight:boolean;\n\n\t/**\n\t * Creates a new SpecularBasicMethod object.\n\t */\n\tconstructor()\n\t{\n\t\tsuper();\n\t}\n\n\tpublic iIsUsed(shader:LightingShader):boolean\n\t{\n\t\tif (!shader.numLights)\n\t\t\treturn false;\n\n\t\treturn true;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitVO(shader:LightingShader, methodVO:MethodVO)\n\t{\n\t\tmethodVO.needsNormals = shader.numLights > 0;\n\t\tmethodVO.needsView = shader.numLights > 0;\n\n\t\tif (this._texture) {\n\t\t\tmethodVO.textureVO = shader.getTextureVO(this._texture);\n\t\t\tshader.uvDependencies++;\n\t\t} else if (methodVO.textureVO) {\n\t\t\tmethodVO.textureVO.dispose();\n\t\t\tmethodVO.textureVO = null;\n\t\t}\n\t}\n\n\t/**\n\t * The sharpness of the specular highlight.\n\t */\n\tpublic get gloss():number\n\t{\n\t\treturn this._gloss;\n\t}\n\n\tpublic set gloss(value:number)\n\t{\n\t\tthis._gloss = value;\n\t}\n\n\t/**\n\t * The overall strength of the specular highlights.\n\t */\n\tpublic get specular():number\n\t{\n\t\treturn this._specular;\n\t}\n\n\tpublic set specular(value:number)\n\t{\n\t\tif (value == this._specular)\n\t\t\treturn;\n\n\t\tthis._specular = value;\n\t\tthis.updateSpecular();\n\t}\n\n\t/**\n\t * The colour of the specular reflection of the surface.\n\t */\n\tpublic get specularColor():number\n\t{\n\t\treturn this._specularColor;\n\t}\n\n\tpublic set specularColor(value:number)\n\t{\n\t\tif (this._specularColor == value)\n\t\t\treturn;\n\n\t\t// specular is now either enabled or disabled\n\t\tif (this._specularColor == 0 || value == 0)\n\t\t\tthis.iInvalidateShaderProgram();\n\n\t\tthis._specularColor = value;\n\t\tthis.updateSpecular();\n\t}\n\n\t/**\n\t * The bitmapData that encodes the specular highlight strength per texel in the red channel, and the sharpness\n\t * in the green channel. You can use SpecularTextureBase if you want to easily set specular and gloss maps\n\t * from grayscale images, but prepared images are preferred.\n\t */\n\tpublic get texture():TextureBase\n\t{\n\t\treturn this._texture;\n\t}\n\n\tpublic set texture(value:TextureBase)\n\t{\n\t\tif (this._texture == value)\n\t\t\treturn;\n\n\t\tthis._texture = value;\n\n\t\tthis.iInvalidateShaderProgram();\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic copyFrom(method:ShadingMethodBase)\n\t{\n\n\t\tvar m:any = method;\n\t\tvar bsm:SpecularBasicMethod = <SpecularBasicMethod> method;\n\n\t\tvar spec:SpecularBasicMethod = bsm;//SpecularBasicMethod(method);\n\t\tthis.texture = spec.texture;\n\t\tthis.specular = spec.specular;\n\t\tthis.specularColor = spec.specularColor;\n\t\tthis.gloss = spec.gloss;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iCleanCompilationData()\n\t{\n\t\tsuper.iCleanCompilationData();\n\t\tthis._pTotalLightColorReg = null;\n\t\tthis._pSpecularTexData = null;\n\t\tthis._pSpecularDataRegister = null;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentPreLightingCode(shader:LightingShader, methodVO:MethodVO, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = \"\";\n\n\t\tthis._pIsFirstLight = true;\n\n\t\tthis._pSpecularDataRegister = registerCache.getFreeFragmentConstant();\n\t\tmethodVO.fragmentConstantsIndex = this._pSpecularDataRegister.index*4;\n\n\t\tif (this._texture) {\n\n\t\t\tthis._pSpecularTexData = registerCache.getFreeFragmentVectorTemp();\n\t\t\tregisterCache.addFragmentTempUsages(this._pSpecularTexData, 1);\n\n\t\t\tmethodVO.textureVO._iInitRegisters(shader, registerCache);\n\n\t\t\tcode += methodVO.textureVO._iGetFragmentCode(shader, this._pSpecularTexData, registerCache, sharedRegisters.uvVarying);\n\t\t}\n\n\t\tthis._pTotalLightColorReg = registerCache.getFreeFragmentVectorTemp();\n\t\tregisterCache.addFragmentTempUsages(this._pTotalLightColorReg, 1);\n\n\t\treturn code;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentCodePerLight(shader:LightingShader, methodVO:MethodVO, lightDirReg:ShaderRegisterElement, lightColReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = \"\";\n\t\tvar t:ShaderRegisterElement;\n\n\t\tif (this._pIsFirstLight) {\n\t\t\tt = this._pTotalLightColorReg;\n\t\t} else {\n\t\t\tt = registerCache.getFreeFragmentVectorTemp();\n\t\t\tregisterCache.addFragmentTempUsages(t, 1);\n\t\t}\n\n\t\tvar viewDirReg:ShaderRegisterElement = sharedRegisters.viewDirFragment;\n\t\tvar normalReg:ShaderRegisterElement = sharedRegisters.normalFragment;\n\n\t\t// blinn-phong half vector model\n\t\tcode += \"add \" + t + \", \" + lightDirReg + \", \" + viewDirReg + \"\\n\" +\n\t\t\t\t\"nrm \" + t + \".xyz, \" + t + \"\\n\" +\n\t\t\t\t\"dp3 \" + t + \".w, \" + normalReg + \", \" + t + \"\\n\" +\n\t\t\t\t\"sat \" + t + \".w, \" + t + \".w\\n\";\n\n\t\tif (this._texture) {\n\t\t\t// apply gloss modulation from texture\n\t\t\tcode += \"mul \" + this._pSpecularTexData + \".w, \" + this._pSpecularTexData + \".y, \" + this._pSpecularDataRegister + \".w\\n\" +\n\t\t\t\t\t\"pow \" + t + \".w, \" + t + \".w, \" + this._pSpecularTexData + \".w\\n\";\n\t\t} else {\n\t\t\tcode += \"pow \" + t + \".w, \" + t + \".w, \" + this._pSpecularDataRegister + \".w\\n\";\n\t\t}\n\n\t\t// attenuate\n\t\tif (shader.usesLightFallOff)\n\t\t\tcode += \"mul \" + t + \".w, \" + t + \".w, \" + lightDirReg + \".w\\n\";\n\n\t\tif (this._iModulateMethod != null)\n\t\t\tcode += this._iModulateMethod(shader, methodVO, t, registerCache, sharedRegisters);\n\n\t\tcode += \"mul \" + t + \".xyz, \" + lightColReg + \", \" + t + \".w\\n\";\n\n\t\tif (!this._pIsFirstLight) {\n\t\t\tcode += \"add \" + this._pTotalLightColorReg + \".xyz, \" + this._pTotalLightColorReg + \", \" + t + \"\\n\";\n\t\t\tregisterCache.removeFragmentTempUsage(t);\n\t\t}\n\n\t\tthis._pIsFirstLight = false;\n\n\t\treturn code;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentCodePerProbe(shader:LightingShader, methodVO:MethodVO, cubeMapReg:ShaderRegisterElement, weightRegister:string, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = \"\";\n\t\tvar t:ShaderRegisterElement;\n\n\t\t// write in temporary if not first light, so we can add to total diffuse colour\n\t\tif (this._pIsFirstLight) {\n\t\t\tt = this._pTotalLightColorReg;\n\t\t} else {\n\t\t\tt = registerCache.getFreeFragmentVectorTemp();\n\t\t\tregisterCache.addFragmentTempUsages(t, 1);\n\t\t}\n\n\t\tvar normalReg:ShaderRegisterElement = sharedRegisters.normalFragment;\n\t\tvar viewDirReg:ShaderRegisterElement = sharedRegisters.viewDirFragment;\n\n\t\tcode += \"dp3 \" + t + \".w, \" + normalReg + \", \" + viewDirReg + \"\\n\" +\n\t\t\t\t\"add \" + t + \".w, \" + t + \".w, \" + t + \".w\\n\" +\n\t\t\t\t\"mul \" + t + \", \" + t + \".w, \" + normalReg + \"\\n\" +\n\t\t\t\t\"sub \" + t + \", \" + t + \", \" + viewDirReg + \"\\n\" +\n\t\t\t\t\"tex \" + t + \", \" + t + \", \" + cubeMapReg + \" <cube,\" + (shader.useSmoothTextures? \"linear\":\"nearest\") + \",miplinear>\\n\" +\n\t\t\t\t\"mul \" + t + \".xyz, \" + t + \", \" + weightRegister + \"\\n\";\n\n\t\tif (this._iModulateMethod != null)\n\t\t\tcode += this._iModulateMethod(shader, methodVO, t, registerCache, sharedRegisters);\n\n\t\tif (!this._pIsFirstLight) {\n\t\t\tcode += \"add \" + this._pTotalLightColorReg + \".xyz, \" + this._pTotalLightColorReg + \", \" + t + \"\\n\";\n\t\t\tregisterCache.removeFragmentTempUsage(t);\n\t\t}\n\n\t\tthis._pIsFirstLight = false;\n\n\t\treturn code;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentPostLightingCode(shader:LightingShader, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = \"\";\n\n\t\tif (sharedRegisters.shadowTarget)\n\t\t\tcode += \"mul \" + this._pTotalLightColorReg + \".xyz, \" + this._pTotalLightColorReg + \", \" + sharedRegisters.shadowTarget + \".w\\n\";\n\n\t\tif (this._texture) {\n\t\t\t// apply strength modulation from texture\n\t\t\tcode += \"mul \" + this._pTotalLightColorReg + \".xyz, \" + this._pTotalLightColorReg + \", \" + this._pSpecularTexData + \".x\\n\";\n\t\t\tregisterCache.removeFragmentTempUsage(this._pSpecularTexData);\n\t\t}\n\n\t\t// apply material's specular reflection\n\t\tcode += \"mul \" + this._pTotalLightColorReg + \".xyz, \" + this._pTotalLightColorReg + \", \" + this._pSpecularDataRegister + \"\\n\" +\n\t\t\t\"add \" + targetReg + \".xyz, \" + targetReg + \", \" + this._pTotalLightColorReg + \"\\n\";\n\t\tregisterCache.removeFragmentTempUsage(this._pTotalLightColorReg);\n\n\t\treturn code;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iActivate(shader:LightingShader, methodVO:MethodVO, stage:Stage)\n\t{\n\t\tif (this._texture)\n\t\t\tmethodVO.textureVO.activate(shader);\n\n\t\tvar index:number = methodVO.fragmentConstantsIndex;\n\t\tvar data:Array<number> = shader.fragmentConstantData;\n\t\tdata[index] = this._iSpecularR;\n\t\tdata[index + 1] = this._iSpecularG;\n\t\tdata[index + 2] = this._iSpecularB;\n\t\tdata[index + 3] = this._gloss;\n\t}\n\n\t/**\n\t * Updates the specular color data used by the render state.\n\t */\n\tprivate updateSpecular()\n\t{\n\t\tthis._iSpecularR = (( this._specularColor >> 16) & 0xff)/0xff*this._specular;\n\t\tthis._iSpecularG = (( this._specularColor >> 8) & 0xff)/0xff*this._specular;\n\t\tthis._iSpecularB = ( this._specularColor & 0xff)/0xff*this._specular;\n\t}\n}\n\nexport = SpecularBasicMethod;",
    "import Stage\t\t\t\t\t\t\t= require(\"awayjs-stagegl/lib/base/Stage\");\n\nimport LightingShader\t\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/LightingShader\");\nimport ShaderBase\t\t\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderBase\");\nimport ShaderRegisterCache\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterCache\");\nimport ShaderRegisterData\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterData\");\nimport ShaderRegisterElement\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterElement\");\n\nimport MethodVO\t\t\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/data/MethodVO\");\nimport SpecularBasicMethod\t\t\t\t= require(\"awayjs-methodmaterials/lib/methods/SpecularBasicMethod\");\nimport SpecularCompositeMethod\t\t\t= require(\"awayjs-methodmaterials/lib/methods/SpecularCompositeMethod\");\n\n/**\n * SpecularCelMethod provides a shading method to add specular cel (cartoon) shading.\n */\nclass SpecularCelMethod extends SpecularCompositeMethod\n{\n\tprivate _dataReg:ShaderRegisterElement;\n\tprivate _smoothness:number = .1;\n\tprivate _specularCutOff:number = .1;\n\n\t/**\n\t * Creates a new SpecularCelMethod object.\n\t * @param specularCutOff The threshold at which the specular highlight should be shown.\n\t * @param baseMethod An optional specular method on which the cartoon shading is based. If ommitted, SpecularBasicMethod is used.\n\t */\n\tconstructor(specularCutOff:number = .5, baseMethod:SpecularBasicMethod = null)\n\t{\n\t\tsuper(null, baseMethod);\n\n\t\tthis.baseMethod._iModulateMethod = (shader:ShaderBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData) => this.clampSpecular(shader, methodVO, targetReg, registerCache, sharedRegisters);\n\n\t\tthis._specularCutOff = specularCutOff;\n\t}\n\n\t/**\n\t * The smoothness of the highlight edge.\n\t */\n\tpublic get smoothness():number\n\t{\n\t\treturn this._smoothness;\n\t}\n\n\tpublic set smoothness(value:number)\n\t{\n\t\tthis._smoothness = value;\n\t}\n\n\t/**\n\t * The threshold at which the specular highlight should be shown.\n\t */\n\tpublic get specularCutOff():number\n\t{\n\t\treturn this._specularCutOff;\n\t}\n\n\tpublic set specularCutOff(value:number)\n\t{\n\t\tthis._specularCutOff = value;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iActivate(shader:LightingShader, methodVO:MethodVO, stage:Stage)\n\t{\n\t\tsuper.iActivate(shader, methodVO, stage);\n\n\t\tvar index:number /*int*/ = methodVO.secondaryFragmentConstantsIndex;\n\t\tvar data:Array<number> = shader.fragmentConstantData;\n\t\tdata[index] = this._smoothness;\n\t\tdata[index + 1] = this._specularCutOff;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iCleanCompilationData()\n\t{\n\t\tsuper.iCleanCompilationData();\n\t\tthis._dataReg = null;\n\t}\n\n\t/**\n\t * Snaps the specular shading strength of the wrapped method to zero or one, depending on whether or not it exceeds the specularCutOff\n\t * @param vo The MethodVO used to compile the current shader.\n\t * @param t The register containing the specular strength in the \"w\" component, and either the half-vector or the reflection vector in \"xyz\".\n\t * @param regCache The register cache used for the shader compilation.\n\t * @param sharedRegisters The shared register data for this shader.\n\t * @return The AGAL fragment code for the method.\n\t */\n\tprivate clampSpecular(shader:ShaderBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\treturn \"sub \" + targetReg + \".y, \" + targetReg + \".w, \" + this._dataReg + \".y\\n\" + // x - cutoff\n\t\t\t\"div \" + targetReg + \".y, \" + targetReg + \".y, \" + this._dataReg + \".x\\n\" + // (x - cutoff)/epsilon\n\t\t\t\"sat \" + targetReg + \".y, \" + targetReg + \".y\\n\" +\n\t\t\t\"sge \" + targetReg + \".w, \" + targetReg + \".w, \" + this._dataReg + \".y\\n\" +\n\t\t\t\"mul \" + targetReg + \".w, \" + targetReg + \".w, \" + targetReg + \".y\\n\";\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentPreLightingCode(shader:LightingShader, methodVO:MethodVO, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tthis._dataReg = registerCache.getFreeFragmentConstant();\n\t\tmethodVO.secondaryFragmentConstantsIndex = this._dataReg.index*4;\n\n\t\treturn super.iGetFragmentPreLightingCode(shader, methodVO, registerCache, sharedRegisters);\n\t}\n}\n\nexport = SpecularCelMethod;",
    "import Camera\t\t\t\t\t\t\t= require(\"awayjs-display/lib/entities/Camera\");\nimport TextureBase\t\t\t\t\t\t= require(\"awayjs-display/lib/textures/TextureBase\");\n\nimport Stage\t\t\t\t\t\t\t= require(\"awayjs-stagegl/lib/base/Stage\");\n\nimport RenderableBase\t\t\t\t\t= require(\"awayjs-renderergl/lib/renderables/RenderableBase\");\nimport ShadingMethodEvent\t\t\t\t= require(\"awayjs-renderergl/lib/events/ShadingMethodEvent\");\nimport LightingShader\t\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/LightingShader\");\nimport ShaderBase\t\t\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderBase\");\nimport ShaderRegisterCache\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterCache\");\nimport ShaderRegisterData\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterData\");\nimport ShaderRegisterElement\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterElement\");\n\nimport MethodVO\t\t\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/data/MethodVO\");\nimport SpecularBasicMethod\t\t\t\t= require(\"awayjs-methodmaterials/lib/methods/SpecularBasicMethod\");\n\n/**\n * SpecularCompositeMethod provides a base class for specular methods that wrap a specular method to alter the\n * calculated specular reflection strength.\n */\nclass SpecularCompositeMethod extends SpecularBasicMethod\n{\n\tprivate _baseMethod:SpecularBasicMethod;\n\n\tprivate _onShaderInvalidatedDelegate:Function;\n\n\t/**\n\t * Creates a new <code>SpecularCompositeMethod</code> object.\n\t *\n\t * @param modulateMethod The method which will add the code to alter the base method's strength. It needs to have the signature modSpecular(t:ShaderRegisterElement, regCache:ShaderRegisterCache):string, in which t.w will contain the specular strength and t.xyz will contain the half-vector or the reflection vector.\n\t * @param baseMethod The base specular method on which this method's shading is based.\n\t */\n\tconstructor(modulateMethod:(shader:ShaderBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData) => string, baseMethod:SpecularBasicMethod = null)\n\t{\n\t\tsuper();\n\n\t\tthis._onShaderInvalidatedDelegate = (event:ShadingMethodEvent) => this.onShaderInvalidated(event);\n\n\t\tthis._baseMethod = baseMethod || new SpecularBasicMethod();\n\t\tthis._baseMethod._iModulateMethod = modulateMethod;\n\t\tthis._baseMethod.addEventListener(ShadingMethodEvent.SHADER_INVALIDATED, this._onShaderInvalidatedDelegate);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitVO(shader:LightingShader, methodVO:MethodVO)\n\t{\n\t\tthis._baseMethod.iInitVO(shader, methodVO);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitConstants(shader:ShaderBase, methodVO:MethodVO)\n\t{\n\t\tthis._baseMethod.iInitConstants(shader, methodVO);\n\t}\n\n\t/**\n\t * The base specular method on which this method's shading is based.\n\t */\n\tpublic get baseMethod():SpecularBasicMethod\n\t{\n\t\treturn this._baseMethod;\n\t}\n\n\tpublic set baseMethod(value:SpecularBasicMethod)\n\t{\n\t\tif (this._baseMethod == value)\n\t\t\treturn;\n\n\t\tthis._baseMethod.removeEventListener(ShadingMethodEvent.SHADER_INVALIDATED, this._onShaderInvalidatedDelegate);\n\n\t\tthis._baseMethod = value;\n\n\t\tthis._baseMethod.addEventListener(ShadingMethodEvent.SHADER_INVALIDATED, this._onShaderInvalidatedDelegate);\n\n\t\tthis.iInvalidateShaderProgram();\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic get gloss():number\n\t{\n\t\treturn this._baseMethod.gloss;\n\t}\n\n\tpublic set gloss(value:number)\n\t{\n\t\tthis._baseMethod.gloss = value;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic get specular():number\n\t{\n\t\treturn this._baseMethod.specular;\n\t}\n\n\tpublic set specular(value:number)\n\t{\n\t\tthis._baseMethod.specular = value;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic dispose()\n\t{\n\t\tthis._baseMethod.removeEventListener(ShadingMethodEvent.SHADER_INVALIDATED, this._onShaderInvalidatedDelegate);\n\t\tthis._baseMethod.dispose();\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic get texture():TextureBase\n\t{\n\t\treturn this._baseMethod.texture;\n\t}\n\n\tpublic set texture(value:TextureBase)\n\t{\n\t\tthis._baseMethod.texture = value;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iActivate(shader:LightingShader, methodVO:MethodVO, stage:Stage)\n\t{\n\t\tthis._baseMethod.iActivate(shader, methodVO, stage);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iSetRenderState(shader:LightingShader, methodVO:MethodVO, renderable:RenderableBase, stage:Stage, camera:Camera)\n\t{\n\t\tthis._baseMethod.iSetRenderState(shader, methodVO, renderable, stage, camera);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iDeactivate(shader:ShaderBase, methodVO:MethodVO, stage:Stage)\n\t{\n\t\tthis._baseMethod.iDeactivate(shader, methodVO, stage);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetVertexCode(shader:ShaderBase, methodVO:MethodVO, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\treturn this._baseMethod.iGetVertexCode(shader, methodVO, registerCache, sharedRegisters);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentPreLightingCode(shader:LightingShader, methodVO:MethodVO, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\treturn this._baseMethod.iGetFragmentPreLightingCode(shader, methodVO, registerCache, sharedRegisters);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentCodePerLight(shader:LightingShader, methodVO:MethodVO, lightDirReg:ShaderRegisterElement, lightColReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\treturn this._baseMethod.iGetFragmentCodePerLight(shader, methodVO, lightDirReg, lightColReg, registerCache, sharedRegisters);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t * @return\n\t */\n\tpublic iGetFragmentCodePerProbe(shader:LightingShader, methodVO:MethodVO, cubeMapReg:ShaderRegisterElement, weightRegister:string, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\treturn this._baseMethod.iGetFragmentCodePerProbe(shader, methodVO, cubeMapReg, weightRegister, registerCache, sharedRegisters);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentPostLightingCode(shader:LightingShader, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\treturn this._baseMethod.iGetFragmentPostLightingCode(shader, methodVO, targetReg, registerCache, sharedRegisters);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iReset()\n\t{\n\t\tthis._baseMethod.iReset();\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iCleanCompilationData()\n\t{\n\t\tsuper.iCleanCompilationData();\n\t\tthis._baseMethod.iCleanCompilationData();\n\t}\n\n\t/**\n\t * Called when the base method's shader code is invalidated.\n\t */\n\tprivate onShaderInvalidated(event:ShadingMethodEvent)\n\t{\n\t\tthis.iInvalidateShaderProgram();\n\t}\n}\n\nexport = SpecularCompositeMethod;",
    "import Camera\t\t\t\t\t\t\t= require(\"awayjs-display/lib/entities/Camera\");\n\nimport Stage\t\t\t\t\t\t\t= require(\"awayjs-stagegl/lib/base/Stage\");\n\nimport LightingShader\t\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/LightingShader\");\nimport ShaderBase\t\t\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderBase\");\nimport ShaderRegisterCache\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterCache\");\nimport ShaderRegisterData\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterData\");\nimport ShaderRegisterElement\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterElement\");\n\nimport MethodVO\t\t\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/data/MethodVO\");\nimport SpecularBasicMethod\t\t\t\t= require(\"awayjs-methodmaterials/lib/methods/SpecularBasicMethod\");\nimport SpecularCompositeMethod\t\t\t= require(\"awayjs-methodmaterials/lib/methods/SpecularCompositeMethod\");\n\n/**\n * SpecularFresnelMethod provides a specular shading method that causes stronger highlights on grazing view angles.\n */\nclass SpecularFresnelMethod extends SpecularCompositeMethod\n{\n\tprivate _dataReg:ShaderRegisterElement;\n\tprivate _incidentLight:boolean;\n\tprivate _fresnelPower:number = 5;\n\tprivate _normalReflectance:number = .028; // default value for skin\n\n\t/**\n\t * Creates a new SpecularFresnelMethod object.\n\t * @param basedOnSurface Defines whether the fresnel effect should be based on the view angle on the surface (if true), or on the angle between the light and the view.\n\t * @param baseMethod The specular method to which the fresnel equation. Defaults to SpecularBasicMethod.\n\t */\n\tconstructor(basedOnSurface:boolean = true, baseMethod:SpecularBasicMethod = null)\n\t{\n\t\t// may want to offer diff speculars\n\t\tsuper(null, baseMethod);\n\n\t\tthis.baseMethod._iModulateMethod = (shader:ShaderBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData) => this.modulateSpecular(shader, methodVO, targetReg, registerCache, sharedRegisters);\n\n\t\tthis._incidentLight = !basedOnSurface;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitConstants(shader:ShaderBase, methodVO:MethodVO)\n\t{\n\n\t\tvar index:number = methodVO.secondaryFragmentConstantsIndex;\n\t\tshader.fragmentConstantData[index + 2] = 1;\n\t\tshader.fragmentConstantData[index + 3] = 0;\n\t}\n\n\t/**\n\t * Defines whether the fresnel effect should be based on the view angle on the surface (if true), or on the angle between the light and the view.\n\t */\n\tpublic get basedOnSurface():boolean\n\t{\n\t\treturn !this._incidentLight;\n\t}\n\n\tpublic set basedOnSurface(value:boolean)\n\t{\n\t\tif (this._incidentLight != value)\n\t\t\treturn;\n\n\t\tthis._incidentLight = !value;\n\n\t\tthis.iInvalidateShaderProgram();\n\t}\n\n\t/**\n\t * The power used in the Fresnel equation. Higher values make the fresnel effect more pronounced. Defaults to 5.\n\t */\n\tpublic get fresnelPower():number\n\t{\n\t\treturn this._fresnelPower;\n\t}\n\n\tpublic set fresnelPower(value:number)\n\t{\n\t\tthis._fresnelPower = value;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iCleanCompilationData()\n\t{\n\t\tsuper.iCleanCompilationData();\n\t\tthis._dataReg = null;\n\t}\n\n\t/**\n\t * The minimum amount of reflectance, ie the reflectance when the view direction is normal to the surface or light direction.\n\t */\n\tpublic get normalReflectance():number\n\t{\n\t\treturn this._normalReflectance;\n\t}\n\n\tpublic set normalReflectance(value:number)\n\t{\n\t\tthis._normalReflectance = value;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iActivate(shader:LightingShader, methodVO:MethodVO, stage:Stage)\n\t{\n\t\tsuper.iActivate(shader, methodVO, stage);\n\n\t\tvar fragmentData:Array<number> = shader.fragmentConstantData;\n\n\t\tvar index:number = methodVO.secondaryFragmentConstantsIndex;\n\t\tfragmentData[index] = this._normalReflectance;\n\t\tfragmentData[index + 1] = this._fresnelPower;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentPreLightingCode(shader:LightingShader, methodVO:MethodVO, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tthis._dataReg = registerCache.getFreeFragmentConstant();\n\n\t\tmethodVO.secondaryFragmentConstantsIndex = this._dataReg.index*4;\n\n\t\treturn super.iGetFragmentPreLightingCode(shader, methodVO, registerCache, sharedRegisters);\n\t}\n\n\t/**\n\t * Applies the fresnel effect to the specular strength.\n\t *\n\t * @param vo The MethodVO object containing the method data for the currently compiled material pass.\n\t * @param target The register containing the specular strength in the \"w\" component, and the half-vector/reflection vector in \"xyz\".\n\t * @param regCache The register cache used for the shader compilation.\n\t * @param sharedRegisters The shared registers created by the compiler.\n\t * @return The AGAL fragment code for the method.\n\t */\n\tprivate modulateSpecular(shader:ShaderBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string;\n\n\t\tcode = \"dp3 \" + targetReg + \".y, \" + sharedRegisters.viewDirFragment + \".xyz, \" + (this._incidentLight? targetReg : sharedRegisters.normalFragment) + \".xyz\\n\" +   // dot(V, H)\n\t\t\t\"sub \" + targetReg + \".y, \" + this._dataReg + \".z, \" + targetReg + \".y\\n\" +             // base = 1-dot(V, H)\n\t\t\t\"pow \" + targetReg + \".x, \" + targetReg + \".y, \" + this._dataReg + \".y\\n\" +             // exp = pow(base, 5)\n\t\t\t\"sub \" + targetReg + \".y, \" + this._dataReg + \".z, \" + targetReg + \".y\\n\" +             // 1 - exp\n\t\t\t\"mul \" + targetReg + \".y, \" + this._dataReg + \".x, \" + targetReg + \".y\\n\" +             // f0*(1 - exp)\n\t\t\t\"add \" + targetReg + \".y, \" + targetReg + \".x, \" + targetReg + \".y\\n\" +          // exp + f0*(1 - exp)\n\t\t\t\"mul \" + targetReg + \".w, \" + targetReg + \".w, \" + targetReg + \".y\\n\";\n\n\t\treturn code;\n\t}\n\n}\n\nexport = SpecularFresnelMethod;",
    "import LightingShader\t\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/LightingShader\");\nimport ShaderRegisterCache\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterCache\");\nimport ShaderRegisterData\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterData\");\nimport ShaderRegisterElement\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterElement\");\n\nimport MethodVO\t\t\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/data/MethodVO\");\nimport SpecularBasicMethod\t\t\t\t= require(\"awayjs-methodmaterials/lib/methods/SpecularBasicMethod\");\n\n/**\n * SpecularPhongMethod provides a specular method that provides Phong highlights.\n */\nclass SpecularPhongMethod extends SpecularBasicMethod\n{\n\t/**\n\t * Creates a new SpecularPhongMethod object.\n\t */\n\tconstructor()\n\t{\n\t\tsuper();\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentCodePerLight(shader:LightingShader, methodVO:MethodVO, lightDirReg:ShaderRegisterElement, lightColReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = \"\";\n\t\tvar t:ShaderRegisterElement;\n\n\t\tif (this._pIsFirstLight) {\n\t\t\tt = this._pTotalLightColorReg;\n\t\t} else {\n\t\t\tt = registerCache.getFreeFragmentVectorTemp();\n\t\t\tregisterCache.addFragmentTempUsages(t, 1);\n\t\t}\n\n\t\tvar viewDirReg:ShaderRegisterElement =sharedRegisters.viewDirFragment;\n\t\tvar normalReg:ShaderRegisterElement =sharedRegisters.normalFragment;\n\n\t\t// phong model\n\t\tcode += \"dp3 \" + t + \".w, \" + lightDirReg + \", \" + normalReg + \"\\n\" + // sca1 = light.normal\n\n\t\t\t//find the reflected light vector R\n\t\t\t\"add \" + t + \".w, \" + t + \".w, \" + t + \".w\\n\" + // sca1 = sca1*2\n\t\t\t\"mul \" + t + \".xyz, \" + normalReg + \", \" + t + \".w\\n\" + // vec1 = normal*sca1\n\t\t\t\"sub \" + t + \".xyz, \" + t + \", \" + lightDirReg + \"\\n\" + // vec1 = vec1 - light (light vector is negative)\n\n\t\t\t//smooth the edge as incidence angle approaches 90\n\t\t\t\"add \" + t + \".w, \" + t + \".w, \" +sharedRegisters.commons + \".w\\n\" + // sca1 = sca1 + smoothtep;\n\t\t\t\"sat \" + t + \".w, \" + t + \".w\\n\" + // sca1 range 0 - 1\n\t\t\t\"mul \" + t + \".xyz, \" + t + \", \" + t + \".w\\n\" + // vec1 = vec1*sca1\n\n\t\t\t//find the dot product between R and V\n\t\t\t\"dp3 \" + t + \".w, \" + t + \", \" + viewDirReg + \"\\n\" + // sca1 = vec1.view\n\t\t\t\"sat \" + t + \".w, \" + t + \".w\\n\";\n\n\t\tif (this.texture) {\n\t\t\t// apply gloss modulation from texture\n\t\t\tcode += \"mul \" + this._pSpecularTexData + \".w, \" + this._pSpecularTexData + \".y, \" + this._pSpecularDataRegister + \".w\\n\" +\n\t\t\t\t\"pow \" + t + \".w, \" + t + \".w, \" + this._pSpecularTexData + \".w\\n\";\n\t\t} else\n\t\t\tcode += \"pow \" + t + \".w, \" + t + \".w, \" + this._pSpecularDataRegister + \".w\\n\";\n\n\t\t// attenuate\n\t\tif (shader.usesLightFallOff)\n\t\t\tcode += \"mul \" + t + \".w, \" + t + \".w, \" + lightDirReg + \".w\\n\";\n\n\t\tif (this._iModulateMethod != null)\n\t\t\tcode += this._iModulateMethod(shader, methodVO, t, registerCache, sharedRegisters);\n\n\t\tcode += \"mul \" + t + \".xyz, \" + lightColReg + \".xyz, \" + t + \".w\\n\";\n\n\t\tif (!this._pIsFirstLight) {\n\t\t\tcode += \"add \" + this._pTotalLightColorReg + \".xyz, \" + this._pTotalLightColorReg + \".xyz, \" + t + \".xyz\\n\";\n\t\t\tregisterCache.removeFragmentTempUsage(t);\n\t\t}\n\n\t\tthis._pIsFirstLight = false;\n\n\t\treturn code;\n\t}\n}\n\nexport = SpecularPhongMethod;",
    "import BlendMode\t\t\t\t\t\t= require(\"awayjs-core/lib/data/BlendMode\");\nimport ColorTransform\t\t\t\t\t= require(\"awayjs-core/lib/geom/ColorTransform\");\nimport Matrix\t\t\t\t\t\t\t= require(\"awayjs-core/lib/geom/Matrix\");\nimport Matrix3D\t\t\t\t\t\t\t= require(\"awayjs-core/lib/geom/Matrix3D\");\nimport Matrix3DUtils\t\t\t\t\t= require(\"awayjs-core/lib/geom/Matrix3DUtils\");\nimport Vector3D\t\t\t\t\t\t\t= require(\"awayjs-core/lib/geom/Vector3D\");\nimport AbstractMethodError\t\t\t\t= require(\"awayjs-core/lib/errors/AbstractMethodError\");\n\nimport Camera\t\t\t\t\t\t\t= require(\"awayjs-display/lib/entities/Camera\");\nimport IRenderOwner\t\t\t\t\t\t= require(\"awayjs-display/lib/base/IRenderOwner\");\nimport StaticLightPicker\t\t\t\t= require(\"awayjs-display/lib/materials/lightpickers/StaticLightPicker\");\n\nimport Stage\t\t\t\t\t\t\t= require(\"awayjs-stagegl/lib/base/Stage\");\nimport ContextGLCompareMode\t\t\t\t= require(\"awayjs-stagegl/lib/base/ContextGLCompareMode\");\n\nimport RendererBase\t\t\t\t\t\t= require(\"awayjs-renderergl/lib/RendererBase\");\nimport ShaderBase\t\t\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderBase\");\nimport ShadingMethodEvent\t\t\t\t= require(\"awayjs-renderergl/lib/events/ShadingMethodEvent\");\nimport RenderableBase\t\t\t\t\t= require(\"awayjs-renderergl/lib/renderables/RenderableBase\");\nimport IRenderableClass\t\t\t\t\t= require(\"awayjs-renderergl/lib/renderables/IRenderableClass\");\nimport RenderBase\t\t\t\t\t\t= require(\"awayjs-renderergl/lib/render/RenderBase\");\nimport RenderPool\t\t\t\t\t\t= require(\"awayjs-renderergl/lib/render/RenderPool\");\n\nimport MethodMaterial\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/MethodMaterial\");\nimport MethodMaterialMode\t\t\t\t= require(\"awayjs-methodmaterials/lib/MethodMaterialMode\");\nimport MethodPassMode\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/render/passes/MethodPassMode\");\nimport MethodPass\t\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/render/passes/MethodPass\");\nimport AmbientBasicMethod\t\t\t\t= require(\"awayjs-methodmaterials/lib/methods/AmbientBasicMethod\");\nimport DiffuseBasicMethod\t\t\t\t= require(\"awayjs-methodmaterials/lib/methods/DiffuseBasicMethod\");\nimport EffectColorTransformMethod\t\t= require(\"awayjs-methodmaterials/lib/methods/EffectColorTransformMethod\");\nimport EffectMethodBase\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/methods/EffectMethodBase\");\nimport LightingMethodBase\t\t\t\t= require(\"awayjs-methodmaterials/lib/methods/LightingMethodBase\");\nimport NormalBasicMethod\t\t\t\t= require(\"awayjs-methodmaterials/lib/methods/NormalBasicMethod\");\nimport ShadowMapMethodBase\t\t\t\t= require(\"awayjs-methodmaterials/lib/methods/ShadowMapMethodBase\");\nimport SpecularBasicMethod\t\t\t\t= require(\"awayjs-methodmaterials/lib/methods/SpecularBasicMethod\");\n\n/**\n * CompiledPass forms an abstract base class for the default compiled pass materials provided by Away3D,\n * using material methods to define their appearance.\n */\nclass MethodMaterialRender extends RenderBase\n{\n\tprivate _material:MethodMaterial;\n\tprivate _pass:MethodPass;\n\tprivate _casterLightPass:MethodPass;\n\tprivate _nonCasterLightPasses:Array<MethodPass>;\n\t\n\t/**\n\t * The maximum total number of lights provided by the light picker.\n\t */\n\tprivate get numLights():number\n\t{\n\t\treturn this._material.lightPicker? this._material.lightPicker.numLightProbes + this._material.lightPicker.numDirectionalLights + this._material.lightPicker.numPointLights + this._material.lightPicker.numCastingDirectionalLights + this._material.lightPicker.numCastingPointLights : 0;\n\t}\n\n\t/**\n\t * The amount of lights that don't cast shadows.\n\t */\n\tprivate get numNonCasters():number\n\t{\n\t\treturn this._material.lightPicker? this._material.lightPicker.numLightProbes + this._material.lightPicker.numDirectionalLights + this._material.lightPicker.numPointLights : 0;\n\t}\n\n\t/**\n\t * Creates a new CompiledPass object.\n\t *\n\t * @param material The material to which this pass belongs.\n\t */\n\tconstructor(pool:RenderPool, material:MethodMaterial, renderableClass:IRenderableClass, stage:Stage)\n\t{\n\t\tsuper(pool, material, renderableClass, stage);\n\n\t\tthis._material = material;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic _pUpdateRender()\n\t{\n\t\tsuper._pUpdateRender();\n\n\t\tthis.initPasses();\n\n\t\tthis.setBlendAndCompareModes();\n\n\t\tthis._pClearPasses();\n\n\t\tif (this._material.mode == MethodMaterialMode.MULTI_PASS) {\n\t\t\tif (this._casterLightPass)\n\t\t\t\tthis._pAddPass(this._casterLightPass);\n\n\t\t\tif (this._nonCasterLightPasses)\n\t\t\t\tfor (var i:number = 0; i < this._nonCasterLightPasses.length; ++i)\n\t\t\t\t\tthis._pAddPass(this._nonCasterLightPasses[i]);\n\t\t}\n\n\t\tif (this._pass)\n\t\t\tthis._pAddPass(this._pass);\n\t}\n\n\t/**\n\t * Initializes all the passes and their dependent passes.\n\t */\n\tprivate initPasses()\n\t{\n\t\t// let the effects pass handle everything if there are no lights, when there are effect methods applied\n\t\t// after shading, or when the material mode is single pass.\n\t\tif (this.numLights == 0 || this._material.numEffectMethods > 0 || this._material.mode == MethodMaterialMode.SINGLE_PASS)\n\t\t\tthis.initEffectPass();\n\t\telse if (this._pass)\n\t\t\tthis.removeEffectPass();\n\n\t\t// only use a caster light pass if shadows need to be rendered\n\t\tif (this._material.shadowMethod && this._material.mode == MethodMaterialMode.MULTI_PASS)\n\t\t\tthis.initCasterLightPass();\n\t\telse if (this._casterLightPass)\n\t\t\tthis.removeCasterLightPass();\n\n\t\t// only use non caster light passes if there are lights that don't cast\n\t\tif (this.numNonCasters > 0 && this._material.mode == MethodMaterialMode.MULTI_PASS)\n\t\t\tthis.initNonCasterLightPasses();\n\t\telse if (this._nonCasterLightPasses)\n\t\t\tthis.removeNonCasterLightPasses();\n\t}\n\n\t/**\n\t * Sets up the various blending modes for all screen passes, based on whether or not there are previous passes.\n\t */\n\tprivate setBlendAndCompareModes()\n\t{\n\t\tvar forceSeparateMVP:boolean = Boolean(this._casterLightPass || this._pass);\n\n\t\t// caster light pass is always first if it exists, hence it uses normal blending\n\t\tif (this._casterLightPass) {\n\t\t\tthis._casterLightPass.forceSeparateMVP = forceSeparateMVP;\n\t\t\tthis._casterLightPass.shader.setBlendMode(BlendMode.NORMAL);\n\t\t\tthis._casterLightPass.shader.depthCompareMode = this._material.depthCompareMode;\n\t\t}\n\n\t\tif (this._nonCasterLightPasses) {\n\t\t\tvar firstAdditiveIndex:number = 0;\n\n\t\t\t// if there's no caster light pass, the first non caster light pass will be the first\n\t\t\t// and should use normal blending\n\t\t\tif (!this._casterLightPass) {\n\t\t\t\tthis._nonCasterLightPasses[0].forceSeparateMVP = forceSeparateMVP;\n\t\t\t\tthis._nonCasterLightPasses[0].shader.setBlendMode(BlendMode.NORMAL);\n\t\t\t\tthis._nonCasterLightPasses[0].shader.depthCompareMode = this._material.depthCompareMode;\n\t\t\t\tfirstAdditiveIndex = 1;\n\t\t\t}\n\n\t\t\t// all lighting passes following the first light pass should use additive blending\n\t\t\tfor (var i:number = firstAdditiveIndex; i < this._nonCasterLightPasses.length; ++i) {\n\t\t\t\tthis._nonCasterLightPasses[i].forceSeparateMVP = forceSeparateMVP;\n\t\t\t\tthis._nonCasterLightPasses[i].shader.setBlendMode(BlendMode.ADD);\n\t\t\t\tthis._nonCasterLightPasses[i].shader.depthCompareMode = ContextGLCompareMode.LESS_EQUAL;\n\t\t\t}\n\t\t}\n\n\t\tif (this._casterLightPass || this._nonCasterLightPasses) {\n\t\t\t//cannot be blended by blendmode property if multipass enabled\n\t\t\tthis._pRequiresBlending = false;\n\n\t\t\t// there are light passes, so this should be blended in\n\t\t\tif (this._pass) {\n\t\t\t\tthis._pass.mode = MethodPassMode.EFFECTS;\n\t\t\t\tthis._pass.forceSeparateMVP = forceSeparateMVP;\n\t\t\t\tthis._pass.shader.depthCompareMode = ContextGLCompareMode.LESS_EQUAL;\n\t\t\t\tthis._pass.shader.setBlendMode(BlendMode.LAYER);\n\t\t\t}\n\n\t\t} else if (this._pass) {\n\t\t\tthis._pRequiresBlending = (this._material.blendMode != BlendMode.NORMAL || this._material.alphaBlending || (this._material.colorTransform && this._material.colorTransform.alphaMultiplier < 1));\n\t\t\t// effects pass is the only pass, so it should just blend normally\n\t\t\tthis._pass.mode = MethodPassMode.SUPER_SHADER;\n\t\t\tthis._pass.preserveAlpha = this._pRequiresBlending;\n\t\t\tthis._pass.forceSeparateMVP = false;\n\t\t\tthis._pass.colorTransform = this._material.colorTransform;\n\t\t\tthis._pass.shader.setBlendMode((this._material.blendMode == BlendMode.NORMAL && this._pRequiresBlending)? BlendMode.LAYER : this._material.blendMode);\n\t\t\tthis._pass.shader.depthCompareMode = this._material.depthCompareMode;\n\t\t}\n\t}\n\n\tprivate initCasterLightPass()\n\t{\n\n\t\tif (this._casterLightPass == null)\n\t\t\tthis._casterLightPass = new MethodPass(MethodPassMode.LIGHTING, this, this._material, this._renderableClass, this._stage);\n\n\t\tthis._casterLightPass.lightPicker = new StaticLightPicker([this._material.shadowMethod.castingLight]);\n\t\tthis._casterLightPass.shadowMethod = this._material.shadowMethod;\n\t\tthis._casterLightPass.diffuseMethod = this._material.diffuseMethod;\n\t\tthis._casterLightPass.ambientMethod = this._material.ambientMethod;\n\t\tthis._casterLightPass.normalMethod = this._material.normalMethod;\n\t\tthis._casterLightPass.specularMethod = this._material.specularMethod;\n\t}\n\n\tprivate removeCasterLightPass()\n\t{\n\t\tthis._casterLightPass.dispose();\n\t\tthis._pRemovePass(this._casterLightPass);\n\t\tthis._casterLightPass = null;\n\t}\n\n\tprivate initNonCasterLightPasses()\n\t{\n\t\tthis.removeNonCasterLightPasses();\n\t\tvar pass:MethodPass;\n\t\tvar numDirLights:number = this._material.lightPicker.numDirectionalLights;\n\t\tvar numPointLights:number = this._material.lightPicker.numPointLights;\n\t\tvar numLightProbes:number = this._material.lightPicker.numLightProbes;\n\t\tvar dirLightOffset:number = 0;\n\t\tvar pointLightOffset:number = 0;\n\t\tvar probeOffset:number = 0;\n\n\t\tif (!this._casterLightPass) {\n\t\t\tnumDirLights += this._material.lightPicker.numCastingDirectionalLights;\n\t\t\tnumPointLights += this._material.lightPicker.numCastingPointLights;\n\t\t}\n\n\t\tthis._nonCasterLightPasses = new Array<MethodPass>();\n\n\t\twhile (dirLightOffset < numDirLights || pointLightOffset < numPointLights || probeOffset < numLightProbes) {\n\t\t\tpass = new MethodPass(MethodPassMode.LIGHTING, this, this._material, this._renderableClass, this._stage);\n\t\t\tpass.includeCasters = this._material.shadowMethod == null;\n\t\t\tpass.directionalLightsOffset = dirLightOffset;\n\t\t\tpass.pointLightsOffset = pointLightOffset;\n\t\t\tpass.lightProbesOffset = probeOffset;\n\t\t\tpass.lightPicker = this._material.lightPicker;\n\t\t\tpass.diffuseMethod = this._material.diffuseMethod;\n\t\t\tpass.ambientMethod = this._material.ambientMethod;\n\t\t\tpass.normalMethod = this._material.normalMethod;\n\t\t\tpass.specularMethod = this._material.specularMethod;\n\t\t\tthis._nonCasterLightPasses.push(pass);\n\n\t\t\tdirLightOffset += pass.numDirectionalLights;\n\t\t\tpointLightOffset += pass.numPointLights;\n\t\t\tprobeOffset += pass.numLightProbes;\n\t\t}\n\t}\n\n\tprivate removeNonCasterLightPasses()\n\t{\n\t\tif (!this._nonCasterLightPasses)\n\t\t\treturn;\n\n\t\tfor (var i:number = 0; i < this._nonCasterLightPasses.length; ++i)\n\t\t\tthis._pRemovePass(this._nonCasterLightPasses[i]);\n\n\t\tthis._nonCasterLightPasses = null;\n\t}\n\n\tprivate removeEffectPass()\n\t{\n\t\tif (this._pass.ambientMethod != this._material.ambientMethod)\n\t\t\tthis._pass.ambientMethod.dispose();\n\n\t\tif (this._pass.diffuseMethod != this._material.diffuseMethod)\n\t\t\tthis._pass.diffuseMethod.dispose();\n\n\t\tif (this._pass.specularMethod != this._material.specularMethod)\n\t\t\tthis._pass.specularMethod.dispose();\n\n\t\tif (this._pass.normalMethod != this._material.normalMethod)\n\t\t\tthis._pass.normalMethod.dispose();\n\n\t\tthis._pRemovePass(this._pass);\n\t\tthis._pass = null;\n\t}\n\n\tprivate initEffectPass()\n\t{\n\t\tif (this._pass == null)\n\t\t\tthis._pass = new MethodPass(MethodPassMode.SUPER_SHADER, this, this._material, this._renderableClass, this._stage);\n\n\t\tif (this._material.mode == MethodMaterialMode.SINGLE_PASS) {\n\t\t\tthis._pass.ambientMethod = this._material.ambientMethod;\n\t\t\tthis._pass.diffuseMethod = this._material.diffuseMethod;\n\t\t\tthis._pass.specularMethod = this._material.specularMethod;\n\t\t\tthis._pass.normalMethod = this._material.normalMethod;\n\t\t\tthis._pass.shadowMethod = this._material.shadowMethod;\n\t\t} else if (this._material.mode == MethodMaterialMode.MULTI_PASS) {\n\t\t\tif (this.numLights == 0) {\n\t\t\t\tthis._pass.ambientMethod = this._material.ambientMethod;\n\t\t\t} else {\n\t\t\t\tthis._pass.ambientMethod = null;\n\t\t\t}\n\n\t\t\tthis._pass.preserveAlpha = false;\n\t\t\tthis._pass.normalMethod = this._material.normalMethod;\n\t\t}\n\n\t\t//update effect methods\n\t\tvar i:number = 0;\n\t\tvar effectMethod:EffectMethodBase;\n\t\tvar len:number = Math.max(this._material.numEffectMethods, this._pass.numEffectMethods);\n\n\t\twhile (i < len) {\n\t\t\teffectMethod = this._material.getEffectMethodAt(i);\n\t\t\tif (effectMethod != this._pass.getEffectMethodAt(i)) {\n\t\t\t\tthis._pass.removeEffectMethodAt(i);\n\n\t\t\t\tif (effectMethod != null) {\n\t\t\t\t\tif (i < this._pass.numEffectMethods)\n\t\t\t\t\t\tthis._pass.addEffectMethodAt(effectMethod, i);\n\t\t\t\t\telse\n\t\t\t\t\t\tthis._pass.addEffectMethod(effectMethod);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\ti++;\n\t\t}\n\t}\n\t\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic dispose()\n\t{\n\t\tsuper.dispose();\n\n\t\t//TODO\n\t}\n}\n\nexport = MethodMaterialRender;",
    "class PassMode\n{\n\t/**\n\t *\n\t */\n\tpublic static EFFECTS:number = 0x01;\n\n\t/**\n\t *\n\t */\n\tpublic static LIGHTING:number = 0x02;\n\n\t/**\n\t *\n\t */\n\tpublic static SUPER_SHADER:number = 0x03;\n}\n\nexport = PassMode;",
    "import ColorTransform\t\t\t\t\t= require(\"awayjs-core/lib/geom/ColorTransform\");\nimport Matrix\t\t\t\t\t\t\t= require(\"awayjs-core/lib/geom/Matrix\");\nimport Matrix3D\t\t\t\t\t\t\t= require(\"awayjs-core/lib/geom/Matrix3D\");\nimport Matrix3DUtils\t\t\t\t\t= require(\"awayjs-core/lib/geom/Matrix3DUtils\");\nimport Vector3D\t\t\t\t\t\t\t= require(\"awayjs-core/lib/geom/Vector3D\");\nimport AbstractMethodError\t\t\t\t= require(\"awayjs-core/lib/errors/AbstractMethodError\");\nimport Event\t\t\t\t\t\t\t= require(\"awayjs-core/lib/events/Event\");\nimport MaterialBase\t\t\t\t\t\t= require(\"awayjs-display/lib/materials/MaterialBase\");\n\nimport Camera\t\t\t\t\t\t\t= require(\"awayjs-display/lib/entities/Camera\");\nimport IRenderOwner\t\t\t\t\t\t= require(\"awayjs-display/lib/base/IRenderOwner\");\nimport LightPickerBase\t\t\t\t\t= require(\"awayjs-display/lib/materials/lightpickers/LightPickerBase\");\nimport LightSources\t\t\t\t\t\t= require(\"awayjs-display/lib/materials/LightSources\");\n\nimport Stage\t\t\t\t\t\t\t= require(\"awayjs-stagegl/lib/base/Stage\");\n\nimport RendererBase\t\t\t\t\t\t= require(\"awayjs-renderergl/lib/RendererBase\");\nimport LightingShader\t\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/LightingShader\");\nimport ShadingMethodEvent\t\t\t\t= require(\"awayjs-renderergl/lib/events/ShadingMethodEvent\");\nimport ShaderBase\t\t\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderBase\");\nimport ShaderRegisterCache\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterCache\");\nimport ShaderRegisterData\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterData\");\nimport ShaderRegisterElement\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterElement\");\nimport RenderableBase\t\t\t\t\t= require(\"awayjs-renderergl/lib/renderables/RenderableBase\");\nimport PassBase\t\t\t\t\t\t\t= require(\"awayjs-renderergl/lib/render/passes/PassBase\");\nimport ILightingPass\t\t\t\t\t= require(\"awayjs-renderergl/lib/render/passes/ILightingPass\");\nimport IRenderableClass\t\t\t\t\t= require(\"awayjs-renderergl/lib/renderables/IRenderableClass\");\n\nimport MethodVO\t\t\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/data/MethodVO\");\nimport AmbientBasicMethod\t\t\t\t= require(\"awayjs-methodmaterials/lib/methods/AmbientBasicMethod\");\nimport DiffuseBasicMethod\t\t\t\t= require(\"awayjs-methodmaterials/lib/methods/DiffuseBasicMethod\");\nimport EffectColorTransformMethod\t\t= require(\"awayjs-methodmaterials/lib/methods/EffectColorTransformMethod\");\nimport EffectMethodBase\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/methods/EffectMethodBase\");\nimport LightingMethodBase\t\t\t\t= require(\"awayjs-methodmaterials/lib/methods/LightingMethodBase\");\nimport NormalBasicMethod\t\t\t\t= require(\"awayjs-methodmaterials/lib/methods/NormalBasicMethod\");\nimport ShadowMapMethodBase\t\t\t\t= require(\"awayjs-methodmaterials/lib/methods/ShadowMapMethodBase\");\nimport SpecularBasicMethod\t\t\t\t= require(\"awayjs-methodmaterials/lib/methods/SpecularBasicMethod\");\nimport MethodPassMode\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/render/passes/MethodPassMode\");\nimport MethodMaterialRender\t\t\t\t= require(\"awayjs-methodmaterials/lib/render/MethodMaterialRender\");\n\n/**\n * CompiledPass forms an abstract base class for the default compiled pass materials provided by Away3D,\n * using material methods to define their appearance.\n */\nclass MethodPass extends PassBase implements ILightingPass\n{\n\tprivate _maxLights:number = 3;\n\n\tprivate _mode:number = 0x03;\n\tprivate _material:MaterialBase;\n\tprivate _lightPicker:LightPickerBase;\n\n\tprivate _includeCasters:boolean = true;\n\n\tpublic _iColorTransformMethodVO:MethodVO;\n\tpublic _iNormalMethodVO:MethodVO;\n\tpublic _iAmbientMethodVO:MethodVO;\n\tpublic _iShadowMethodVO:MethodVO;\n\tpublic _iDiffuseMethodVO:MethodVO;\n\tpublic _iSpecularMethodVO:MethodVO;\n\tpublic _iMethodVOs:Array<MethodVO> = new Array<MethodVO>();\n\n\tpublic _numEffectDependencies:number = 0;\n\n\tprivate _onLightsChangeDelegate:(event:Event) => void;\n\tprivate _onMethodInvalidatedDelegate:(event:ShadingMethodEvent) => void;\n\n\tpublic numDirectionalLights:number = 0;\n\n\tpublic numPointLights:number = 0;\n\n\tpublic numLightProbes:number = 0;\n\n\tpublic pointLightsOffset:number = 0;\n\t\n\tpublic directionalLightsOffset:number= 0;\n\t\n\tpublic lightProbesOffset:number = 0;\n\t\n\t/**\n\t *\n\t */\n\tpublic get mode():number\n\t{\n\t\treturn this._mode;\n\t}\n\n\tpublic set mode(value:number)\n\t{\n\t\tif (this._mode == value)\n\t\t\treturn;\n\t\t\n\t\tthis._mode = value;\n\n\t\tthis._updateLights();\n\t}\n\n\t/**\n\t * Indicates whether or not shadow casting lights need to be included.\n\t */\n\tpublic get includeCasters():boolean\n\t{\n\t\treturn this._includeCasters;\n\t}\n\n\tpublic set includeCasters(value:boolean)\n\t{\n\t\tif (this._includeCasters == value)\n\t\t\treturn;\n\n\t\tthis._includeCasters = value;\n\n\t\tthis._updateLights();\n\t}\n\n\t/**\n\t * \n\t * @returns {LightPickerBase}\n\t */\n\tpublic get lightPicker():LightPickerBase\n\t{\n\t\treturn this._lightPicker;\n\t}\n\n\tpublic set lightPicker(value:LightPickerBase)\n\t{\n\t\t//if (this._lightPicker == value)\n\t\t//\treturn;\n\n\t\tif (this._lightPicker)\n\t\t\tthis._lightPicker.removeEventListener(Event.CHANGE, this._onLightsChangeDelegate);\n\n\t\tthis._lightPicker = value;\n\n\t\tif (this._lightPicker)\n\t\t\tthis._lightPicker.addEventListener(Event.CHANGE, this._onLightsChangeDelegate);\n\n\t\tthis._updateLights();\n\t}\n\t\n\t/**\n\t * Whether or not to use fallOff and radius properties for lights. This can be used to improve performance and\n\t * compatibility for constrained mode.\n\t */\n\tpublic get enableLightFallOff():boolean\n\t{\n\t\treturn this._material.enableLightFallOff;\n\t}\n\n\t/**\n\t * Define which light source types to use for diffuse reflections. This allows choosing between regular lights\n\t * and/or light probes for diffuse reflections.\n\t *\n\t * @see away3d.materials.LightSources\n\t */\n\tpublic get diffuseLightSources():number\n\t{\n\t\treturn this._material.diffuseLightSources;\n\t}\n\n\t/**\n\t * Define which light source types to use for specular reflections. This allows choosing between regular lights\n\t * and/or light probes for specular reflections.\n\t *\n\t * @see away3d.materials.LightSources\n\t */\n\tpublic get specularLightSources():number\n\t{\n\t\treturn this._material.specularLightSources;\n\t}\n\n\t/**\n\t * Creates a new CompiledPass object.\n\t *\n\t * @param material The material to which this pass belongs.\n\t */\n\tconstructor(mode:number, render:MethodMaterialRender, renderOwner:MaterialBase, renderableClass:IRenderableClass, stage:Stage)\n\t{\n\t\tsuper(render, renderOwner, renderableClass, stage);\n\n\t\tthis._mode = mode;\n\n\t\tthis._material = renderOwner;\n\n\t\tthis._onLightsChangeDelegate = (event:Event) => this.onLightsChange(event);\n\t\t\n\t\tthis._onMethodInvalidatedDelegate = (event:ShadingMethodEvent) => this.onMethodInvalidated(event);\n\n\t\tthis.lightPicker = renderOwner.lightPicker;\n\n\t\tif (this._shader == null)\n\t\t\tthis._updateShader();\n\t}\n\n\tprivate _updateShader()\n\t{\n\t\tif ((this.numDirectionalLights || this.numPointLights || this.numLightProbes) && !(this._shader instanceof LightingShader)) {\n\t\t\tif (this._shader != null)\n\t\t\t\tthis._shader.dispose();\n\n\t\t\tthis._shader = new LightingShader(this._renderableClass, this, this._stage);\n\t\t} else if (!(this._shader instanceof ShaderBase)) {\n\t\t\tif (this._shader != null)\n\t\t\t\tthis._shader.dispose();\n\n\t\t\tthis._shader = new ShaderBase(this._renderableClass, this, this._stage);\n\t\t}\n\t}\n\n\t/**\n\t * Initializes the unchanging constant data for this material.\n\t */\n\tpublic _iInitConstantData(shader:ShaderBase)\n\t{\n\t\tsuper._iInitConstantData(shader);\n\n\t\t//Updates method constants if they have changed.\n\t\tvar len:number = this._iMethodVOs.length;\n\t\tfor (var i:number = 0; i < len; ++i)\n\t\t\tthis._iMethodVOs[i].method.iInitConstants(shader, this._iMethodVOs[i]);\n\t}\n\n\t/**\n\t * The ColorTransform object to transform the colour of the material with. Defaults to null.\n\t */\n\tpublic get colorTransform():ColorTransform\n\t{\n\t\treturn this.colorTransformMethod? this.colorTransformMethod.colorTransform : null;\n\t}\n\n\tpublic set colorTransform(value:ColorTransform)\n\t{\n\t\tif (value) {\n\t\t\tif (this.colorTransformMethod == null)\n\t\t\t\tthis.colorTransformMethod = new EffectColorTransformMethod();\n\n\t\t\tthis.colorTransformMethod.colorTransform = value;\n\n\t\t} else if (!value) {\n\t\t\tif (this.colorTransformMethod)\n\t\t\t\tthis.colorTransformMethod = null;\n\t\t}\n\t}\n\n\t/**\n\t * The EffectColorTransformMethod object to transform the colour of the material with. Defaults to null.\n\t */\n\tpublic get colorTransformMethod():EffectColorTransformMethod\n\t{\n\t\treturn this._iColorTransformMethodVO? <EffectColorTransformMethod> this._iColorTransformMethodVO.method : null;\n\t}\n\n\tpublic set colorTransformMethod(value:EffectColorTransformMethod)\n\t{\n\t\tif (this._iColorTransformMethodVO && this._iColorTransformMethodVO.method == value)\n\t\t\treturn;\n\n\t\tif (this._iColorTransformMethodVO) {\n\t\t\tthis._removeDependency(this._iColorTransformMethodVO);\n\t\t\tthis._iColorTransformMethodVO = null;\n\t\t}\n\n\t\tif (value) {\n\t\t\tthis._iColorTransformMethodVO = new MethodVO(value);\n\t\t\tthis._addDependency(this._iColorTransformMethodVO);\n\t\t}\n\t}\n\n\tprivate _removeDependency(methodVO:MethodVO, effectsDependency:boolean = false)\n\t{\n\t\tvar index:number = this._iMethodVOs.indexOf(methodVO);\n\n\t\tif (!effectsDependency)\n\t\t\tthis._numEffectDependencies--;\n\n\t\tmethodVO.method.removeEventListener(ShadingMethodEvent.SHADER_INVALIDATED, this._onMethodInvalidatedDelegate);\n\t\tthis._iMethodVOs.splice(index, 1);\n\n\t\tthis.invalidatePass();\n\t}\n\n\tprivate _addDependency(methodVO:MethodVO, effectsDependency:boolean = false, index:number = -1)\n\t{\n\t\tmethodVO.method.addEventListener(ShadingMethodEvent.SHADER_INVALIDATED, this._onMethodInvalidatedDelegate);\n\n\t\tif (effectsDependency) {\n\t\t\tif (index != -1)\n\t\t\t\tthis._iMethodVOs.splice(index + this._iMethodVOs.length - this._numEffectDependencies, 0, methodVO);\n\t\t\telse\n\t\t\t\tthis._iMethodVOs.push(methodVO);\n\t\t\tthis._numEffectDependencies++;\n\t\t} else {\n\t\t\tthis._iMethodVOs.splice(this._iMethodVOs.length - this._numEffectDependencies, 0, methodVO);\n\t\t}\n\n\t\tthis.invalidatePass();\n\t}\n\n\t/**\n\t * Appends an \"effect\" shading method to the shader. Effect methods are those that do not influence the lighting\n\t * but modulate the shaded colour, used for fog, outlines, etc. The method will be applied to the result of the\n\t * methods added prior.\n\t */\n\tpublic addEffectMethod(method:EffectMethodBase)\n\t{\n\t\tthis._addDependency(new MethodVO(method), true);\n\t}\n\n\t/**\n\t * The number of \"effect\" methods added to the material.\n\t */\n\tpublic get numEffectMethods():number\n\t{\n\t\treturn this._numEffectDependencies;\n\t}\n\n\t/**\n\t * Queries whether a given effects method was added to the material.\n\t *\n\t * @param method The method to be queried.\n\t * @return true if the method was added to the material, false otherwise.\n\t */\n\tpublic hasEffectMethod(method:EffectMethodBase):boolean\n\t{\n\t\treturn this.getDependencyForMethod(method) != null;\n\t}\n\n\t/**\n\t * Returns the method added at the given index.\n\t * @param index The index of the method to retrieve.\n\t * @return The method at the given index.\n\t */\n\tpublic getEffectMethodAt(index:number):EffectMethodBase\n\t{\n\t\tif (index < 0 || index > this._numEffectDependencies - 1)\n\t\t\treturn null;\n\n\t\treturn <EffectMethodBase> this._iMethodVOs[index + this._iMethodVOs.length - this._numEffectDependencies].method;\n\t}\n\n\t/**\n\t * Adds an effect method at the specified index amongst the methods already added to the material. Effect\n\t * methods are those that do not influence the lighting but modulate the shaded colour, used for fog, outlines,\n\t * etc. The method will be applied to the result of the methods with a lower index.\n\t */\n\tpublic addEffectMethodAt(method:EffectMethodBase, index:number)\n\t{\n\t\tthis._addDependency(new MethodVO(method), true, index);\n\t}\n\n\t/**\n\t * Removes an effect method from the material.\n\t * @param method The method to be removed.\n\t */\n\tpublic removeEffectMethod(method:EffectMethodBase)\n\t{\n\t\tvar methodVO:MethodVO = this.getDependencyForMethod(method);\n\n\t\tif (methodVO != null)\n\t\t\tthis._removeDependency(methodVO, true);\n\t}\n\n\n\t/**\n\t * remove an effect method at the specified index from the material.\n\t */\n\tpublic removeEffectMethodAt(index:number)\n\t{\n\t\tif (index < 0 || index > this._numEffectDependencies - 1)\n\t\t\treturn;\n\n\t\tvar methodVO:MethodVO = this._iMethodVOs[index + this._iMethodVOs.length - this._numEffectDependencies];\n\n\t\tif (methodVO != null)\n\t\t\tthis._removeDependency(methodVO, true);\n\t}\n\n\n\tprivate getDependencyForMethod(method:EffectMethodBase):MethodVO\n\t{\n\t\tvar len:number = this._iMethodVOs.length;\n\t\tfor (var i:number = 0; i < len; ++i)\n\t\t\tif (this._iMethodVOs[i].method == method)\n\t\t\t\treturn this._iMethodVOs[i];\n\n\t\treturn null;\n\t}\n\n\t/**\n\t * The method used to generate the per-pixel normals. Defaults to NormalBasicMethod.\n\t */\n\tpublic get normalMethod():NormalBasicMethod\n\t{\n\t\treturn this._iNormalMethodVO? <NormalBasicMethod> this._iNormalMethodVO.method : null;\n\t}\n\n\tpublic set normalMethod(value:NormalBasicMethod)\n\t{\n\t\tif (this._iNormalMethodVO && this._iNormalMethodVO.method == value)\n\t\t\treturn;\n\n\t\tif (this._iNormalMethodVO) {\n\t\t\tthis._removeDependency(this._iNormalMethodVO);\n\t\t\tthis._iNormalMethodVO = null;\n\t\t}\n\n\t\tif (value) {\n\t\t\tthis._iNormalMethodVO = new MethodVO(value);\n\t\t\tthis._addDependency(this._iNormalMethodVO);\n\t\t}\n\t}\n\n\t/**\n\t * The method that provides the ambient lighting contribution. Defaults to AmbientBasicMethod.\n\t */\n\tpublic get ambientMethod():AmbientBasicMethod\n\t{\n\t\treturn this._iAmbientMethodVO? <AmbientBasicMethod> this._iAmbientMethodVO.method : null;\n\t}\n\n\tpublic set ambientMethod(value:AmbientBasicMethod)\n\t{\n\t\tif (this._iAmbientMethodVO && this._iAmbientMethodVO.method == value)\n\t\t\treturn;\n\n\t\tif (this._iAmbientMethodVO) {\n\t\t\tthis._removeDependency(this._iAmbientMethodVO);\n\t\t\tthis._iAmbientMethodVO = null;\n\t\t}\n\n\t\tif (value) {\n\t\t\tthis._iAmbientMethodVO = new MethodVO(value);\n\t\t\tthis._addDependency(this._iAmbientMethodVO);\n\t\t}\n\t}\n\n\t/**\n\t * The method used to render shadows cast on this surface, or null if no shadows are to be rendered. Defaults to null.\n\t */\n\tpublic get shadowMethod():ShadowMapMethodBase\n\t{\n\t\treturn this._iShadowMethodVO? <ShadowMapMethodBase> this._iShadowMethodVO.method : null;\n\t}\n\n\tpublic set shadowMethod(value:ShadowMapMethodBase)\n\t{\n\t\tif (this._iShadowMethodVO && this._iShadowMethodVO.method == value)\n\t\t\treturn;\n\n\t\tif (this._iShadowMethodVO) {\n\t\t\tthis._removeDependency(this._iShadowMethodVO);\n\t\t\tthis._iShadowMethodVO = null;\n\t\t}\n\n\t\tif (value) {\n\t\t\tthis._iShadowMethodVO = new MethodVO(value);\n\t\t\tthis._addDependency(this._iShadowMethodVO);\n\t\t}\n\t}\n\n\t/**\n\t * The method that provides the diffuse lighting contribution. Defaults to DiffuseBasicMethod.\n\t */\n\tpublic get diffuseMethod():DiffuseBasicMethod\n\t{\n\t\treturn this._iDiffuseMethodVO? <DiffuseBasicMethod> this._iDiffuseMethodVO.method : null;\n\t}\n\n\tpublic set diffuseMethod(value:DiffuseBasicMethod)\n\t{\n\t\tif (this._iDiffuseMethodVO && this._iDiffuseMethodVO.method == value)\n\t\t\treturn;\n\n\t\tif (this._iDiffuseMethodVO) {\n\t\t\tthis._removeDependency(this._iDiffuseMethodVO);\n\t\t\tthis._iDiffuseMethodVO = null;\n\t\t}\n\n\t\tif (value) {\n\t\t\tthis._iDiffuseMethodVO = new MethodVO(value);\n\t\t\tthis._addDependency(this._iDiffuseMethodVO);\n\t\t}\n\t}\n\n\t/**\n\t * The method that provides the specular lighting contribution. Defaults to SpecularBasicMethod.\n\t */\n\tpublic get specularMethod():SpecularBasicMethod\n\t{\n\t\treturn this._iSpecularMethodVO? <SpecularBasicMethod> this._iSpecularMethodVO.method : null;\n\t}\n\n\tpublic set specularMethod(value:SpecularBasicMethod)\n\t{\n\t\tif (this._iSpecularMethodVO && this._iSpecularMethodVO.method == value)\n\t\t\treturn;\n\n\t\tif (this._iSpecularMethodVO) {\n\t\t\tthis._removeDependency(this._iSpecularMethodVO);\n\t\t\tthis._iSpecularMethodVO = null;\n\t\t}\n\n\t\tif (value) {\n\t\t\tthis._iSpecularMethodVO = new MethodVO(value);\n\t\t\tthis._addDependency(this._iSpecularMethodVO);\n\t\t}\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic dispose()\n\t{\n\t\tsuper.dispose();\n\n\t\tif (this._lightPicker)\n\t\t\tthis._lightPicker.removeEventListener(Event.CHANGE, this._onLightsChangeDelegate);\n\t\t\n\t\twhile (this._iMethodVOs.length)\n\t\t\tthis._removeDependency(this._iMethodVOs[0]);\n\n\t\tthis._iMethodVOs = null;\n\t}\n\n\t/**\n\t * Called when any method's shader code is invalidated.\n\t */\n\tprivate onMethodInvalidated(event:ShadingMethodEvent)\n\t{\n\t\tthis.invalidatePass();\n\t}\n\n\t// RENDER LOOP\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic _iActivate(camera:Camera)\n\t{\n\t\tsuper._iActivate(camera);\n\n\t\tvar methodVO:MethodVO;\n\t\tvar len:number = this._iMethodVOs.length;\n\t\tfor (var i:number = 0; i < len; ++i) {\n\t\t\tmethodVO = this._iMethodVOs[i];\n\t\t\tif (methodVO.useMethod)\n\t\t\t\tmethodVO.method.iActivate(this._shader, methodVO, this._stage);\n\t\t}\n\t}\n\n\t/**\n\t *\n\t *\n\t * @param renderable\n\t * @param stage\n\t * @param camera\n\t */\n\tpublic _iRender(renderable:RenderableBase, camera:Camera, viewProjection:Matrix3D)\n\t{\n\t\tsuper._iRender(renderable, camera, viewProjection);\n\n\t\tvar methodVO:MethodVO;\n\t\tvar len:number = this._iMethodVOs.length;\n\t\tfor (var i:number = 0; i < len; ++i) {\n\t\t\tmethodVO = this._iMethodVOs[i];\n\t\t\tif (methodVO.useMethod)\n\t\t\t\tmethodVO.method.iSetRenderState(this._shader, methodVO, renderable, this._stage, camera);\n\t\t}\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic _iDeactivate()\n\t{\n\t\tsuper._iDeactivate();\n\n\t\tvar methodVO:MethodVO;\n\t\tvar len:number = this._iMethodVOs.length;\n\t\tfor (var i:number = 0; i < len; ++i) {\n\t\t\tmethodVO = this._iMethodVOs[i];\n\t\t\tif (methodVO.useMethod)\n\t\t\t\tmethodVO.method.iDeactivate(this._shader, methodVO, this._stage);\n\t\t}\n\t}\n\n\tpublic _iIncludeDependencies(shader:LightingShader)\n\t{\n\t\tsuper._iIncludeDependencies(shader);\n\n\t\t//TODO: fragment animtion should be compatible with lighting pass\n\t\tshader.usesFragmentAnimation = Boolean(this._mode == MethodPassMode.SUPER_SHADER);\n\n\t\tif (shader.useAlphaPremultiplied && shader.usesBlending)\n\t\t\tshader.usesCommonData = true;\n\n\t\tvar i:number;\n\t\tvar len:number = this._iMethodVOs.length;\n\t\tfor (i = 0; i < len; ++i)\n\t\t\tthis.setupAndCountDependencies(shader, this._iMethodVOs[i]);\n\n\t\tvar usesTangentSpace:boolean = true;\n\n\t\tvar methodVO:MethodVO;\n\t\tfor (i = 0; i < len; ++i) {\n\t\t\tmethodVO = this._iMethodVOs[i];\n\t\t\tif ((methodVO.useMethod = methodVO.method.iIsUsed(shader)) && !methodVO.method.iUsesTangentSpace())\n\t\t\t\tusesTangentSpace = false;\n\t\t}\n\n\t\tshader.outputsNormals = this._iNormalMethodVO && this._iNormalMethodVO.useMethod;\n\t\tshader.outputsTangentNormals = shader.outputsNormals && (<NormalBasicMethod> this._iNormalMethodVO.method).iOutputsTangentNormals();\n\t\tshader.usesTangentSpace = shader.outputsTangentNormals && !shader.usesProbes && usesTangentSpace;\n\n\t\tif (!shader.usesTangentSpace) {\n\t\t\tif (shader.viewDirDependencies > 0) {\n\t\t\t\tshader.globalPosDependencies++;\n\t\t\t} else if (this.numPointLights > 0 && shader.usesLights) {\n\t\t\t\tshader.globalPosDependencies++;\n\t\t\t\tif (Boolean(this._mode & MethodPassMode.EFFECTS))\n\t\t\t\t\tshader.usesGlobalPosFragment = true;\n\t\t\t}\n\t\t}\n\t}\n\n\n\t/**\n\t * Counts the dependencies for a given method.\n\t * @param method The method to count the dependencies for.\n\t * @param methodVO The method's data for this material.\n\t */\n\tprivate setupAndCountDependencies(shader:ShaderBase, methodVO:MethodVO)\n\t{\n\t\tmethodVO.reset();\n\n\t\tmethodVO.method.iInitVO(shader, methodVO);\n\n\t\tif (methodVO.needsProjection)\n\t\t\tshader.projectionDependencies++;\n\n\t\tif (methodVO.needsGlobalVertexPos || methodVO.needsGlobalFragmentPos) {\n\n\t\t\tshader.globalPosDependencies++;\n\n\t\t\tif (methodVO.needsGlobalFragmentPos)\n\t\t\t\tshader.usesGlobalPosFragment = true;\n\n\t\t}\n\n\t\tif (methodVO.needsNormals)\n\t\t\tshader.normalDependencies++;\n\n\t\tif (methodVO.needsTangents)\n\t\t\tshader.tangentDependencies++;\n\n\t\tif (methodVO.needsView)\n\t\t\tshader.viewDirDependencies++;\n\t}\n\n\tpublic _iGetPreLightingVertexCode(shader:ShaderBase, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = \"\";\n\n\t\tif (this._iAmbientMethodVO && this._iAmbientMethodVO.useMethod)\n\t\t\tcode += this._iAmbientMethodVO.method.iGetVertexCode(shader, this._iAmbientMethodVO, registerCache, sharedRegisters);\n\n\t\tif (this._iDiffuseMethodVO && this._iDiffuseMethodVO.useMethod)\n\t\t\tcode += this._iDiffuseMethodVO.method.iGetVertexCode(shader, this._iDiffuseMethodVO, registerCache, sharedRegisters);\n\n\t\tif (this._iSpecularMethodVO && this._iSpecularMethodVO.useMethod)\n\t\t\tcode += this._iSpecularMethodVO.method.iGetVertexCode(shader, this._iSpecularMethodVO, registerCache, sharedRegisters);\n\n\t\treturn code;\n\t}\n\n\tpublic _iGetPreLightingFragmentCode(shader:ShaderBase, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = \"\";\n\n\t\tif (this._iAmbientMethodVO && this._iAmbientMethodVO.useMethod) {\n\t\t\tcode += this._iAmbientMethodVO.method.iGetFragmentCode(shader, this._iAmbientMethodVO, sharedRegisters.shadedTarget, registerCache, sharedRegisters);\n\n\t\t\tif (this._iAmbientMethodVO.needsNormals)\n\t\t\t\tregisterCache.removeFragmentTempUsage(sharedRegisters.normalFragment);\n\n\t\t\tif (this._iAmbientMethodVO.needsView)\n\t\t\t\tregisterCache.removeFragmentTempUsage(sharedRegisters.viewDirFragment);\n\t\t}\n\n\t\tif (this._iDiffuseMethodVO && this._iDiffuseMethodVO.useMethod)\n\t\t\tcode += (<LightingMethodBase> this._iDiffuseMethodVO.method).iGetFragmentPreLightingCode(<LightingShader> shader, this._iDiffuseMethodVO, registerCache, sharedRegisters);\n\n\t\tif (this._iSpecularMethodVO && this._iSpecularMethodVO.useMethod)\n\t\t\tcode += (<LightingMethodBase> this._iSpecularMethodVO.method).iGetFragmentPreLightingCode(<LightingShader> shader, this._iSpecularMethodVO, registerCache, sharedRegisters);\n\n\t\treturn code;\n\t}\n\n\tpublic _iGetPerLightDiffuseFragmentCode(shader:LightingShader, lightDirReg:ShaderRegisterElement, diffuseColorReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\treturn (<LightingMethodBase> this._iDiffuseMethodVO.method).iGetFragmentCodePerLight(shader, this._iDiffuseMethodVO, lightDirReg, diffuseColorReg, registerCache, sharedRegisters);\n\t}\n\n\tpublic _iGetPerLightSpecularFragmentCode(shader:LightingShader, lightDirReg:ShaderRegisterElement, specularColorReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\treturn (<LightingMethodBase> this._iSpecularMethodVO.method).iGetFragmentCodePerLight(shader, this._iSpecularMethodVO, lightDirReg, specularColorReg, registerCache, sharedRegisters);\n\t}\n\n\tpublic _iGetPerProbeDiffuseFragmentCode(shader:LightingShader, texReg:ShaderRegisterElement, weightReg:string, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\treturn (<LightingMethodBase> this._iDiffuseMethodVO.method).iGetFragmentCodePerProbe(shader, this._iDiffuseMethodVO, texReg, weightReg, registerCache, sharedRegisters);\n\t}\n\n\tpublic _iGetPerProbeSpecularFragmentCode(shader:LightingShader, texReg:ShaderRegisterElement, weightReg:string, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\treturn (<LightingMethodBase> this._iSpecularMethodVO.method).iGetFragmentCodePerProbe(shader, this._iSpecularMethodVO, texReg, weightReg, registerCache, sharedRegisters);\n\t}\n\n\tpublic _iGetPostLightingVertexCode(shader:LightingShader, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = \"\";\n\n\t\tif (this._iShadowMethodVO)\n\t\t\tcode += this._iShadowMethodVO.method.iGetVertexCode(shader, this._iShadowMethodVO, registerCache, sharedRegisters);\n\n\t\treturn code;\n\t}\n\n\tpublic _iGetPostLightingFragmentCode(shader:LightingShader, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = \"\";\n\n\t\tif (shader.useAlphaPremultiplied && shader.usesBlending) {\n\t\t\tcode += \"add \" + sharedRegisters.shadedTarget + \".w, \" + sharedRegisters.shadedTarget + \".w, \" + sharedRegisters.commons + \".z\\n\" +\n\t\t\t\"div \" + sharedRegisters.shadedTarget + \".xyz, \" + sharedRegisters.shadedTarget + \", \" + sharedRegisters.shadedTarget + \".w\\n\" +\n\t\t\t\"sub \" + sharedRegisters.shadedTarget + \".w, \" + sharedRegisters.shadedTarget + \".w, \" + sharedRegisters.commons + \".z\\n\" +\n\t\t\t\"sat \" + sharedRegisters.shadedTarget + \".xyz, \" + sharedRegisters.shadedTarget + \"\\n\";\n\t\t}\n\n\t\tif (this._iShadowMethodVO)\n\t\t\tcode += this._iShadowMethodVO.method.iGetFragmentCode(shader, this._iShadowMethodVO, sharedRegisters.shadowTarget, registerCache, sharedRegisters);\n\n\t\tif (this._iDiffuseMethodVO && this._iDiffuseMethodVO.useMethod) {\n\t\t\tcode += (<LightingMethodBase> this._iDiffuseMethodVO.method).iGetFragmentPostLightingCode(shader, this._iDiffuseMethodVO, sharedRegisters.shadedTarget, registerCache, sharedRegisters);\n\n\t\t\t// resolve other dependencies as well?\n\t\t\tif (this._iDiffuseMethodVO.needsNormals)\n\t\t\t\tregisterCache.removeFragmentTempUsage(sharedRegisters.normalFragment);\n\n\t\t\tif (this._iDiffuseMethodVO.needsView)\n\t\t\t\tregisterCache.removeFragmentTempUsage(sharedRegisters.viewDirFragment);\n\t\t}\n\n\t\tif (this._iSpecularMethodVO && this._iSpecularMethodVO.useMethod) {\n\t\t\tcode += (<LightingMethodBase> this._iSpecularMethodVO.method).iGetFragmentPostLightingCode(shader, this._iSpecularMethodVO, sharedRegisters.shadedTarget, registerCache, sharedRegisters);\n\t\t\tif (this._iSpecularMethodVO.needsNormals)\n\t\t\t\tregisterCache.removeFragmentTempUsage(sharedRegisters.normalFragment);\n\t\t\tif (this._iSpecularMethodVO.needsView)\n\t\t\t\tregisterCache.removeFragmentTempUsage(sharedRegisters.viewDirFragment);\n\t\t}\n\n\t\tif (this._iShadowMethodVO)\n\t\t\tregisterCache.removeFragmentTempUsage(sharedRegisters.shadowTarget);\n\n\t\treturn code;\n\t}\n\n\n\tpublic _iGetNormalVertexCode(shader:ShaderBase, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\treturn this._iNormalMethodVO.method.iGetVertexCode(shader, this._iNormalMethodVO, registerCache, sharedRegisters);\n\t}\n\n\tpublic _iGetNormalFragmentCode(shader:ShaderBase, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = this._iNormalMethodVO.method.iGetFragmentCode(shader, this._iNormalMethodVO, sharedRegisters.normalFragment, registerCache, sharedRegisters);\n\n\t\tif (this._iNormalMethodVO.needsView)\n\t\t\tregisterCache.removeFragmentTempUsage(sharedRegisters.viewDirFragment);\n\n\t\tif (this._iNormalMethodVO.needsGlobalFragmentPos || this._iNormalMethodVO.needsGlobalVertexPos)\n\t\t\tregisterCache.removeVertexTempUsage(sharedRegisters.globalPositionVertex);\n\n\t\treturn code;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic _iGetVertexCode(shader:ShaderBase, regCache:ShaderRegisterCache, sharedReg:ShaderRegisterData):string\n\t{\n\t\tvar code:string = \"\";\n\t\tvar methodVO:MethodVO;\n\t\tvar len:number = this._iMethodVOs.length;\n\t\tfor (var i:number = len - this._numEffectDependencies; i < len; i++) {\n\t\t\tmethodVO = this._iMethodVOs[i];\n\t\t\tif (methodVO.useMethod) {\n\t\t\t\tcode += methodVO.method.iGetVertexCode(shader, methodVO, regCache, sharedReg);\n\n\t\t\t\tif (methodVO.needsGlobalVertexPos || methodVO.needsGlobalFragmentPos)\n\t\t\t\t\tregCache.removeVertexTempUsage(sharedReg.globalPositionVertex);\n\t\t\t}\n\t\t}\n\n\t\tif (this._iColorTransformMethodVO && this._iColorTransformMethodVO.useMethod)\n\t\t\tcode += this._iColorTransformMethodVO.method.iGetVertexCode(shader, this._iColorTransformMethodVO, regCache, sharedReg);\n\n\t\treturn code;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic _iGetFragmentCode(shader:ShaderBase, regCache:ShaderRegisterCache, sharedReg:ShaderRegisterData):string\n\t{\n\t\tvar code:string = \"\";\n\t\tvar alphaReg:ShaderRegisterElement;\n\n\t\tif (this.preserveAlpha && this._numEffectDependencies > 0) {\n\t\t\talphaReg = regCache.getFreeFragmentSingleTemp();\n\t\t\tregCache.addFragmentTempUsages(alphaReg, 1);\n\t\t\tcode += \"mov \" + alphaReg + \", \" + sharedReg.shadedTarget + \".w\\n\";\n\t\t}\n\n\t\tvar methodVO:MethodVO;\n\t\tvar len:number = this._iMethodVOs.length;\n\t\tfor (var i:number = len - this._numEffectDependencies; i < len; i++) {\n\t\t\tmethodVO = this._iMethodVOs[i];\n\t\t\tif (methodVO.useMethod) {\n\t\t\t\tcode += methodVO.method.iGetFragmentCode(shader, methodVO, sharedReg.shadedTarget, regCache, sharedReg);\n\n\t\t\t\tif (methodVO.needsNormals)\n\t\t\t\t\tregCache.removeFragmentTempUsage(sharedReg.normalFragment);\n\n\t\t\t\tif (methodVO.needsView)\n\t\t\t\t\tregCache.removeFragmentTempUsage(sharedReg.viewDirFragment);\n\n\t\t\t}\n\t\t}\n\n\t\tif (this.preserveAlpha && this._numEffectDependencies > 0) {\n\t\t\tcode += \"mov \" + sharedReg.shadedTarget + \".w, \" + alphaReg + \"\\n\";\n\t\t\tregCache.removeFragmentTempUsage(alphaReg);\n\t\t}\n\n\t\tif (this._iColorTransformMethodVO && this._iColorTransformMethodVO.useMethod)\n\t\t\tcode += this._iColorTransformMethodVO.method.iGetFragmentCode(shader, this._iColorTransformMethodVO, sharedReg.shadedTarget, regCache, sharedReg);\n\n\t\treturn code;\n\t}\n\t/**\n\t * Indicates whether the shader uses any shadows.\n\t */\n\tpublic _iUsesShadows(shader:ShaderBase):boolean\n\t{\n\t\treturn Boolean(this._iShadowMethodVO && (this._lightPicker.castingDirectionalLights.length > 0 || this._lightPicker.castingPointLights.length > 0));\n\t}\n\n\t/**\n\t * Indicates whether the shader uses any specular component.\n\t */\n\tpublic _iUsesSpecular(shader:ShaderBase):boolean\n\t{\n\t\treturn Boolean(this._iSpecularMethodVO);\n\t}\n\n\t/**\n\t * Indicates whether the shader uses any specular component.\n\t */\n\tpublic _iUsesDiffuse(shader:ShaderBase):boolean\n\t{\n\t\treturn Boolean(this._iDiffuseMethodVO);\n\t}\n\n\n\tprivate onLightsChange(event:Event)\n\t{\n\t\tthis._updateLights();\n\t}\n\n\tprivate _updateLights()\n\t{\n\t\tvar numDirectionalLightsOld:number = this.numDirectionalLights;\n\t\tvar numPointLightsOld:number = this.numPointLights;\n\t\tvar numLightProbesOld:number = this.numLightProbes;\n\n\t\tif (this._lightPicker && (this._mode & MethodPassMode.LIGHTING)) {\n\t\t\tthis.numDirectionalLights = this.calculateNumDirectionalLights(this._lightPicker.numDirectionalLights);\n\t\t\tthis.numPointLights = this.calculateNumPointLights(this._lightPicker.numPointLights);\n\t\t\tthis.numLightProbes = this.calculateNumProbes(this._lightPicker.numLightProbes);\n\n\t\t\tif (this._includeCasters) {\n\t\t\t\tthis.numDirectionalLights += this._lightPicker.numCastingDirectionalLights;\n\t\t\t\tthis.numPointLights += this._lightPicker.numCastingPointLights;\n\t\t\t}\n\n\t\t} else {\n\t\t\tthis.numDirectionalLights = 0;\n\t\t\tthis.numPointLights = 0;\n\t\t\tthis.numLightProbes = 0;\n\t\t}\n\n\t\tif (numDirectionalLightsOld != this.numDirectionalLights || numPointLightsOld != this.numPointLights || numLightProbesOld != this.numLightProbes) {\n\t\t\tthis._updateShader();\n\n\t\t\tthis.invalidatePass();\n\t\t}\n\t}\n\n\t/**\n\t * Calculates the amount of directional lights this material will support.\n\t * @param numDirectionalLights The maximum amount of directional lights to support.\n\t * @return The amount of directional lights this material will support, bounded by the amount necessary.\n\t */\n\tprivate calculateNumDirectionalLights(numDirectionalLights:number):number\n\t{\n\t\treturn Math.min(numDirectionalLights - this.directionalLightsOffset, this._maxLights);\n\t}\n\n\t/**\n\t * Calculates the amount of point lights this material will support.\n\t * @param numDirectionalLights The maximum amount of point lights to support.\n\t * @return The amount of point lights this material will support, bounded by the amount necessary.\n\t */\n\tprivate calculateNumPointLights(numPointLights:number):number\n\t{\n\t\tvar numFree:number = this._maxLights - this.numDirectionalLights;\n\t\treturn Math.min(numPointLights - this.pointLightsOffset, numFree);\n\t}\n\n\t/**\n\t * Calculates the amount of light probes this material will support.\n\t * @param numDirectionalLights The maximum amount of light probes to support.\n\t * @return The amount of light probes this material will support, bounded by the amount necessary.\n\t */\n\tprivate calculateNumProbes(numLightProbes:number):number\n\t{\n\t\tvar numChannels:number = 0;\n\n\t\tif ((this.specularLightSources & LightSources.PROBES) != 0)\n\t\t\t++numChannels;\n\n\t\tif ((this.diffuseLightSources & LightSources.PROBES) != 0)\n\t\t\t++numChannels;\n\n\t\t// 4 channels available\n\t\treturn Math.min(numLightProbes - this.lightProbesOffset, (4/numChannels) | 0);\n\t}\n}\n\nexport = MethodPass;",
    "import Image2D\t\t\t\t\t\t\t= require(\"awayjs-core/lib/data/Image2D\");\nimport Matrix3D\t\t\t\t\t\t\t= require(\"awayjs-core/lib/geom/Matrix3D\");\n\nimport LightBase\t\t\t\t\t\t= require(\"awayjs-display/lib/base/LightBase\");\nimport TriangleSubGeometry\t\t\t\t= require(\"awayjs-display/lib/base/TriangleSubGeometry\");\nimport Camera\t\t\t\t\t\t\t= require(\"awayjs-display/lib/entities/Camera\");\nimport MaterialBase\t\t\t\t\t\t= require(\"awayjs-display/lib/materials/MaterialBase\");\nimport IRenderOwner\t\t\t\t\t\t= require(\"awayjs-display/lib/base/IRenderOwner\");\nimport Single2DTexture\t\t\t\t\t= require(\"awayjs-display/lib/textures/Single2DTexture\");\nimport TextureBase\t\t\t\t\t\t= require(\"awayjs-display/lib/textures/TextureBase\");\n\nimport ContextGLDrawMode\t\t\t\t= require(\"awayjs-stagegl/lib/base/ContextGLDrawMode\");\nimport ContextGLProgramType\t\t\t\t= require(\"awayjs-stagegl/lib/base/ContextGLProgramType\");\nimport IContextGL\t\t\t\t\t\t= require(\"awayjs-stagegl/lib/base/IContextGL\");\nimport Stage\t\t\t\t\t\t\t= require(\"awayjs-stagegl/lib/base/Stage\");\n\nimport RendererBase\t\t\t\t\t\t= require(\"awayjs-renderergl/lib/RendererBase\");\nimport ShaderBase\t\t\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderBase\");\nimport ShaderRegisterCache\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterCache\");\nimport ShaderRegisterData\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterData\");\nimport PassBase\t\t\t\t\t\t\t= require(\"awayjs-renderergl/lib/render/passes/PassBase\");\nimport IRenderableClass\t\t\t\t\t= require(\"awayjs-renderergl/lib/renderables/IRenderableClass\");\nimport RenderableBase\t\t\t\t\t= require(\"awayjs-renderergl/lib/renderables/RenderableBase\");\nimport RenderBase\t\t\t\t\t\t= require(\"awayjs-renderergl/lib/render/RenderBase\");\nimport SubGeometryVOBase\t\t\t\t= require(\"awayjs-renderergl/lib/vos/SubGeometryVOBase\");\nimport SubGeometryVOPool\t\t\t\t= require(\"awayjs-renderergl/lib/vos/SubGeometryVOPool\");\n\n/**\n * The SingleObjectDepthPass provides a material pass that renders a single object to a depth map from the point\n * of view from a light.\n */\nclass SingleObjectDepthPass extends PassBase\n{\n\tprivate _subGeometryVOPool:SubGeometryVOPool;\n\tprivate _textures:Object;\n\tprivate _projections:Object;\n\tprivate _textureSize:number /*uint*/ = 512;\n\tprivate _polyOffset:Array<number> = Array<number>(15, 0, 0, 0);\n\tprivate _enc:Array<number>;\n\tprivate _projectionTexturesInvalid:Boolean = true;\n\n\t/**\n\t * The size of the depth map texture to render to.\n\t */\n\tpublic get textureSize():number\n\t{\n\t\treturn this._textureSize;\n\t}\n\n\tpublic set textureSize(value:number)\n\t{\n\t\tthis._textureSize = value;\n\t}\n\n\t/**\n\t * The amount by which the rendered object will be inflated, to prevent depth map rounding errors.\n\t */\n\tpublic get polyOffset():number\n\t{\n\t\treturn this._polyOffset[0];\n\t}\n\n\tpublic set polyOffset(value:number)\n\t{\n\t\tthis._polyOffset[0] = value;\n\t}\n\n\t/**\n\t * Creates a new SingleObjectDepthPass object.\n\t */\n\tconstructor(render:RenderBase, renderOwner:IRenderOwner, renderableClass:IRenderableClass, stage:Stage)\n\t{\n\t\tsuper(render, renderOwner, renderableClass, stage);\n\n\t\t//this._pNumUsedStreams = 2;\n\t\t//this._pNumUsedVertexConstants = 7;\n\t\t//this._enc = Array<number>(1.0, 255.0, 65025.0, 16581375.0, 1.0/255.0, 1.0/255.0, 1.0/255.0, 0.0);\n\t\t//\n\t\t//this._pAnimatableAttributes = Array<string>(\"va0\", \"va1\");\n\t\t//this._pAnimationTargetRegisters = Array<string>(\"vt0\", \"vt1\");\n\t\tthis._subGeometryVOPool = SubGeometryVOPool.getPool();\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic dispose()\n\t{\n\t\tif (this._textures) {\n\t\t\tfor (var key in this._textures) {\n\t\t\t\tvar texture:TextureBase = this._textures[key];\n\t\t\t\ttexture.dispose();\n\t\t\t}\n\t\t\tthis._textures = null;\n\t\t}\n\t}\n\n\t/**\n\t * Updates the projection textures used to contain the depth renders.\n\t */\n\tprivate updateProjectionTextures()\n\t{\n\t\tif (this._textures) {\n\t\t\tfor (var key in this._textures) {\n\t\t\t\tvar texture:TextureBase = this._textures[key];\n\t\t\t\ttexture.dispose();\n\t\t\t}\n\t\t}\n\n\t\tthis._textures = new Object();\n\t\tthis._projections = new Object();\n\t\tthis._projectionTexturesInvalid = false;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic _iGetVertexCode():string\n\t{\n\t\tvar code:string;\n\t\t// offset\n\t\tcode = \"mul vt7, vt1, vc4.x\t\\n\" +\n\t\t\t\t\"add vt7, vt7, vt0\\n\" +\n\t\t\t\t\"mov vt7.w, vt0.w\\n\";\n\t\t// project\n\t\tcode += \"m44 vt2, vt7, vc0\\n\" +\n\t\t\t\t\"mov op, vt2\\n\";\n\n\t\t// perspective divide\n\t\tcode += \"div v0, vt2, vt2.w\\n\";\n\n\t\treturn code;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic _iGetFragmentCode(shader:ShaderBase, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = \"\";\n\n\t\t// encode float -> rgba\n\t\tcode += \"mul ft0, fc0, v0.z\\n\" +\n\t\t\t\t\"frc ft0, ft0\\n\" +\n\t\t\t\t\"mul ft1, ft0.yzww, fc1\\n\" +\n\t\t\t\t\"sub ft0, ft0, ft1\\n\" +\n\t\t\t\t\"mov oc, ft0\\n\";\n\n\t\treturn code;\n\t}\n\n\t/**\n\t * Gets the depth maps rendered for this object from all lights.\n\t * @param renderable The renderable for which to retrieve the depth maps.\n\t * @param stage3DProxy The Stage3DProxy object currently used for rendering.\n\t * @return A list of depth map textures for all supported lights.\n\t */\n\tpublic _iGetDepthMap(renderable:RenderableBase):TextureBase\n\t{\n\t\treturn this._textures[renderable.renderableOwner.id];\n\t}\n\n\t/**\n\t * Retrieves the depth map projection maps for all lights.\n\t * @param renderable The renderable for which to retrieve the projection maps.\n\t * @return A list of projection maps for all supported lights.\n\t */\n\tpublic _iGetProjection(renderable:RenderableBase):Matrix3D\n\t{\n\t\treturn this._projections[renderable.renderableOwner.id];\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic _iRender(renderable:RenderableBase, camera:Camera, viewProjection:Matrix3D)\n\t{\n\t\tvar matrix:Matrix3D;\n\t\tvar context:IContextGL = this._stage.context;\n\t\tvar len:number /*uint*/;\n\t\tvar light:LightBase;\n\t\tvar lights:Array<LightBase> = this._renderOwner.lightPicker.allPickedLights;\n\t\tvar rId:number = renderable.renderableOwner.id;\n\n\t\tif (!this._textures[rId])\n\t\t\tthis._textures[rId] = new Single2DTexture(new Image2D(this._textureSize, this._textureSize));\n\n\t\tif (!this._projections[rId])\n\t\t\tthis._projections[rId] = new Matrix3D();\n\n\t\tlen = lights.length;\n\n\t\t// local position = enough\n\t\tlight = lights[0];\n\n\t\tmatrix = light.iGetObjectProjectionMatrix(renderable.sourceEntity, camera, this._projections[rId]);\n\n\t\tthis._stage.setRenderTarget(this._textures[rId], true);\n\t\tcontext.clear(1.0, 1.0, 1.0);\n\t\tcontext.setProgramConstantsFromMatrix(ContextGLProgramType.VERTEX, 0, matrix, true);\n\t\tcontext.setProgramConstantsFromArray(ContextGLProgramType.FRAGMENT, 0, this._enc, 2);\n\n\t\tvar subGeometryVO:SubGeometryVOBase = renderable.subGeometryVO;\n\t\tvar subGeom:TriangleSubGeometry = <TriangleSubGeometry> subGeometryVO.subGeometry;\n\n\t\tsubGeometryVO.activateVertexBufferVO(0, subGeom.positions, this._stage);\n\t\tsubGeometryVO.activateVertexBufferVO(1, subGeom.normals, this._stage);\n\t\tsubGeometryVO.getIndexBufferVO(this._stage).draw(ContextGLDrawMode.TRIANGLES, 0, subGeometryVO.subGeometry.numElements);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic _iActivate(camera:Camera)\n\t{\n\t\tif (this._projectionTexturesInvalid)\n\t\t\tthis.updateProjectionTextures();\n\n\t\t// never scale\n\t\tsuper._iActivate(camera);\n\n\t\tthis._stage.context.setProgramConstantsFromArray(ContextGLProgramType.VERTEX, 4, this._polyOffset, 1);\n\t}\n}\n\nexport = SingleObjectDepthPass;"
  ],
  "sourceRoot": ""
}