{
  "version": 3,
  "sources": [
    "node_modules/browserify/node_modules/browser-pack/_prelude.js",
    "awayjs-methodmaterials/methodmaterials.ts",
    "awayjs-methodmaterials.js",
    "awayjs-methodmaterials/lib/MethodMaterialMode.ts",
    "awayjs-methodmaterials/lib/MethodMaterial.ts",
    "awayjs-methodmaterials/lib/data/MethodVO.ts",
    "awayjs-methodmaterials/lib/methods/AmbientBasicMethod.ts",
    "awayjs-methodmaterials/lib/methods/AmbientEnvMapMethod.ts",
    "awayjs-methodmaterials/lib/methods/CurveBasicMethod.ts",
    "awayjs-methodmaterials/lib/methods/DiffuseBasicMethod.ts",
    "awayjs-methodmaterials/lib/methods/DiffuseCelMethod.ts",
    "awayjs-methodmaterials/lib/methods/DiffuseCompositeMethod.ts",
    "awayjs-methodmaterials/lib/methods/DiffuseDepthMethod.ts",
    "awayjs-methodmaterials/lib/methods/DiffuseGradientMethod.ts",
    "awayjs-methodmaterials/lib/methods/DiffuseLightMapMethod.ts",
    "awayjs-methodmaterials/lib/methods/DiffuseSubSurfaceMethod.ts",
    "awayjs-methodmaterials/lib/methods/DiffuseWrapMethod.ts",
    "awayjs-methodmaterials/lib/methods/EffectAlphaMaskMethod.ts",
    "awayjs-methodmaterials/lib/methods/EffectColorMatrixMethod.ts",
    "awayjs-methodmaterials/lib/methods/EffectColorTransformMethod.ts",
    "awayjs-methodmaterials/lib/methods/EffectEnvMapMethod.ts",
    "awayjs-methodmaterials/lib/methods/EffectFogMethod.ts",
    "awayjs-methodmaterials/lib/methods/EffectFresnelEnvMapMethod.ts",
    "awayjs-methodmaterials/lib/methods/EffectLightMapMethod.ts",
    "awayjs-methodmaterials/lib/methods/EffectMethodBase.ts",
    "awayjs-methodmaterials/lib/methods/EffectRefractionEnvMapMethod.ts",
    "awayjs-methodmaterials/lib/methods/EffectRimLightMethod.ts",
    "awayjs-methodmaterials/lib/methods/LightingMethodBase.ts",
    "awayjs-methodmaterials/lib/methods/NormalBasicMethod.ts",
    "awayjs-methodmaterials/lib/methods/NormalHeightMapMethod.ts",
    "awayjs-methodmaterials/lib/methods/NormalSimpleWaterMethod.ts",
    "awayjs-methodmaterials/lib/methods/ShadingMethodBase.ts",
    "awayjs-methodmaterials/lib/methods/ShadowCascadeMethod.ts",
    "awayjs-methodmaterials/lib/methods/ShadowDitheredMethod.ts",
    "awayjs-methodmaterials/lib/methods/ShadowFilteredMethod.ts",
    "awayjs-methodmaterials/lib/methods/ShadowHardMethod.ts",
    "awayjs-methodmaterials/lib/methods/ShadowMapMethodBase.ts",
    "awayjs-methodmaterials/lib/methods/ShadowMethodBase.ts",
    "awayjs-methodmaterials/lib/methods/ShadowNearMethod.ts",
    "awayjs-methodmaterials/lib/methods/ShadowSoftMethod.ts",
    "awayjs-methodmaterials/lib/methods/SpecularAnisotropicMethod.ts",
    "awayjs-methodmaterials/lib/methods/SpecularBasicMethod.ts",
    "awayjs-methodmaterials/lib/methods/SpecularCelMethod.ts",
    "awayjs-methodmaterials/lib/methods/SpecularCompositeMethod.ts",
    "awayjs-methodmaterials/lib/methods/SpecularFresnelMethod.ts",
    "awayjs-methodmaterials/lib/methods/SpecularPhongMethod.ts",
    "awayjs-methodmaterials/lib/render/MethodMaterialRender.ts",
    "awayjs-methodmaterials/lib/render/passes/MethodPassMode.ts",
    "awayjs-methodmaterials/lib/render/passes/MethodPass.ts",
    "awayjs-methodmaterials/lib/render/passes/SingleObjectDepthPass.ts"
  ],
  "names": [
    "require",
    "e",
    "t",
    "n",
    "r",
    "s",
    "o",
    "u",
    "a",
    "i",
    "f",
    "Error",
    "code",
    "l",
    "exports",
    "call",
    "length",
    "./methodmaterials.ts",
    "module",
    "RenderPool",
    "MethodMaterial",
    "MethodMaterialRender",
    "registerAbstraction",
    "methodmaterials",
    "awayjs-methodmaterials/lib/MethodMaterial",
    "awayjs-methodmaterials/lib/render/MethodMaterialRender",
    "awayjs-renderergl/lib/render/RenderPool",
    "undefined",
    "awayjs-methodmaterials/lib/MethodMaterialMode",
    "MethodMaterialMode",
    "SINGLE_PASS",
    "MULTI_PASS",
    "__extends",
    "this",
    "d",
    "b",
    "p",
    "hasOwnProperty",
    "__",
    "constructor",
    "prototype",
    "Image2D",
    "MaterialBase",
    "Single2DTexture",
    "TextureBase",
    "ContextGLCompareMode",
    "AmbientBasicMethod",
    "DiffuseBasicMethod",
    "NormalBasicMethod",
    "SpecularBasicMethod",
    "_super",
    "textureColor",
    "smoothAlpha",
    "repeat",
    "mipmap",
    "_effectMethods",
    "Array",
    "_ambientMethod",
    "_diffuseMethod",
    "_normalMethod",
    "_specularMethod",
    "_depthCompareMode",
    "LESS_EQUAL",
    "_mode",
    "texture",
    "smooth",
    "color",
    "Number",
    "alpha",
    "iAddOwner",
    "Object",
    "defineProperty",
    "get",
    "assetType",
    "enumerable",
    "configurable",
    "set",
    "value",
    "invalidate",
    "copyFrom",
    "iRemoveOwner",
    "_shadowMethod",
    "addEffectMethod",
    "method",
    "push",
    "getEffectMethodAt",
    "index",
    "addEffectMethodAt",
    "splice",
    "removeEffectMethod",
    "indexOf",
    "normalMap",
    "gloss",
    "ambient",
    "specular",
    "ambientColor",
    "diffuseColor",
    "specularColor",
    "awayjs-core/lib/image/Image2D",
    "awayjs-display/lib/materials/MaterialBase",
    "awayjs-display/lib/textures/Single2DTexture",
    "awayjs-display/lib/textures/TextureBase",
    "awayjs-methodmaterials/lib/methods/AmbientBasicMethod",
    "awayjs-methodmaterials/lib/methods/DiffuseBasicMethod",
    "awayjs-methodmaterials/lib/methods/NormalBasicMethod",
    "awayjs-methodmaterials/lib/methods/SpecularBasicMethod",
    "awayjs-stagegl/lib/base/ContextGLCompareMode",
    "awayjs-methodmaterials/lib/data/MethodVO",
    "MethodVO",
    "useMethod",
    "reset",
    "iReset",
    "vertexConstantsIndex",
    "secondaryVertexConstantsIndex",
    "fragmentConstantsIndex",
    "secondaryFragmentConstantsIndex",
    "needsProjection",
    "needsView",
    "needsNormals",
    "needsTangents",
    "needsGlobalVertexPos",
    "needsGlobalFragmentPos",
    "ShadingMethodBase",
    "_color",
    "_alpha",
    "_colorR",
    "_colorG",
    "_colorB",
    "_ambient",
    "iInitVO",
    "shader",
    "methodVO",
    "textureVO",
    "uvDependencies",
    "iInitConstants",
    "updateColor",
    "m",
    "iGetFragmentCode",
    "targetReg",
    "registerCache",
    "sharedRegisters",
    "_iGetFragmentCode",
    "uvVarying",
    "alphaThreshold",
    "cutOffReg",
    "getFreeFragmentConstant",
    "ambientInputRegister",
    "iActivate",
    "stage",
    "activate",
    "fragmentConstantData",
    "data",
    "iSetRenderState",
    "renderable",
    "camera",
    "_setRenderState",
    "awayjs-methodmaterials/lib/methods/ShadingMethodBase",
    "awayjs-methodmaterials/lib/methods/AmbientEnvMapMethod",
    "AmbientEnvMapMethod",
    "regCache",
    "normalFragment",
    "awayjs-methodmaterials/lib/methods/CurveBasicMethod",
    "CurveBasicMethod",
    "AssetEvent",
    "LightingMethodBase",
    "_multiply",
    "_diffuseColor",
    "_ambientColor",
    "_diffuseR",
    "_diffuseG",
    "_diffuseB",
    "_ambientR",
    "_ambientG",
    "_ambientB",
    "iIsUsed",
    "numLights",
    "iInvalidateShaderProgram",
    "_texture",
    "getAbstraction",
    "onClear",
    "CLEAR",
    "usesCommonData",
    "updateDiffuse",
    "updateAmbient",
    "iRemoveTexture",
    "iAddTexture",
    "dispose",
    "diff",
    "multiply",
    "iCleanCompilationData",
    "_pTotalLightColorReg",
    "iGetFragmentPreLightingCode",
    "_pIsFirstLight",
    "addFragmentTempUsages",
    "getFreeFragmentVectorTemp",
    "iGetFragmentCodePerLight",
    "lightDirReg",
    "lightColReg",
    "commons",
    "usesLightFallOff",
    "_iModulateMethod",
    "removeFragmentTempUsage",
    "iGetFragmentCodePerProbe",
    "cubeMapReg",
    "weightRegister",
    "iGetFragmentPostLightingCode",
    "albedo",
    "shadowTarget",
    "pApplyShadow",
    "ambientColorRegister",
    "diffuseInputRegister",
    "ambientR",
    "ambientG",
    "ambientB",
    "awayjs-core/lib/events/AssetEvent",
    "awayjs-methodmaterials/lib/methods/LightingMethodBase",
    "awayjs-methodmaterials/lib/methods/DiffuseCelMethod",
    "DiffuseCompositeMethod",
    "DiffuseCelMethod",
    "levels",
    "baseMethod",
    "_this",
    "_smoothness",
    "clampDiffuse",
    "_levels",
    "_dataReg",
    "awayjs-methodmaterials/lib/methods/DiffuseCompositeMethod",
    "ShadingMethodEvent",
    "modulateMethod",
    "_onShaderInvalidatedDelegate",
    "event",
    "onShaderInvalidated",
    "pBaseMethod",
    "addEventListener",
    "SHADER_INVALIDATED",
    "removeEventListener",
    "owner",
    "iDeactivate",
    "iGetVertexCode",
    "awayjs-renderergl/lib/events/ShadingMethodEvent",
    "awayjs-methodmaterials/lib/methods/DiffuseDepthMethod",
    "DiffuseDepthMethod",
    "temp",
    "decReg",
    "awayjs-methodmaterials/lib/methods/DiffuseGradientMethod",
    "DiffuseGradientMethod",
    "gradient",
    "_gradient",
    "secondaryTextureVO",
    "awayjs-methodmaterials/lib/methods/DiffuseLightMapMethod",
    "DiffuseLightMapMethod",
    "lightMap",
    "blendMode",
    "useSecondaryUV",
    "_useSecondaryUV",
    "_lightMap",
    "secondaryUVDependencies",
    "_blendMode",
    "ADD",
    "MULTIPLY",
    "secondaryUVVarying",
    "awayjs-methodmaterials/lib/methods/DiffuseSubSurfaceMethod",
    "DiffuseSubSurfaceMethod",
    "depthMapSize",
    "depthMapOffset",
    "_translucency",
    "_scatterColor",
    "_scatterR",
    "_scatterG",
    "_scatterB",
    "scatterLight",
    "_scattering",
    "vertexConstantData",
    "_lightProjVarying",
    "_propReg",
    "_lightColorReg",
    "_colorReg",
    "_decReg",
    "_targetReg",
    "scatterColor",
    "lightProjection",
    "toTexRegister",
    "getFreeVertexVectorTemp",
    "getFreeVertexConstant",
    "getFreeVarying",
    "viewDirFragment",
    "_depthPass",
    "_iGetDepthMap",
    "_iGetProjection",
    "copyRawDataTo",
    "awayjs-methodmaterials/lib/methods/DiffuseWrapMethod",
    "DiffuseWrapMethod",
    "wrapFactor",
    "_wrapDataRegister",
    "_wrapFactor",
    "awayjs-methodmaterials/lib/methods/EffectAlphaMaskMethod",
    "EffectMethodBase",
    "EffectAlphaMaskMethod",
    "awayjs-methodmaterials/lib/methods/EffectMethodBase",
    "awayjs-methodmaterials/lib/methods/EffectColorMatrixMethod",
    "EffectColorMatrixMethod",
    "matrix",
    "_matrix",
    "colorMultReg",
    "colorOffsetReg",
    "awayjs-methodmaterials/lib/methods/EffectColorTransformMethod",
    "EffectColorTransformMethod",
    "_colorTransform",
    "colorOffsReg",
    "inv",
    "redMultiplier",
    "greenMultiplier",
    "blueMultiplier",
    "alphaMultiplier",
    "redOffset",
    "greenOffset",
    "blueOffset",
    "alphaOffset",
    "awayjs-methodmaterials/lib/methods/EffectEnvMapMethod",
    "EffectEnvMapMethod",
    "envMap",
    "_envMap",
    "_mask",
    "dataRegister",
    "temp2",
    "awayjs-methodmaterials/lib/methods/EffectFogMethod",
    "EffectFogMethod",
    "minDistance",
    "maxDistance",
    "fogColor",
    "_minDistance",
    "_maxDistance",
    "_fogColor",
    "_fogR",
    "_fogG",
    "_fogB",
    "fogData",
    "projectionFragment",
    "awayjs-methodmaterials/lib/methods/EffectFresnelEnvMapMethod",
    "EffectFresnelEnvMapMethod",
    "_fresnelPower",
    "_normalReflectance",
    "viewDirReg",
    "normalReg",
    "awayjs-methodmaterials/lib/methods/EffectLightMapMethod",
    "EffectLightMapMethod",
    "AbstractMethodError",
    "awayjs-core/lib/errors/AbstractMethodError",
    "awayjs-methodmaterials/lib/methods/EffectRefractionEnvMapMethod",
    "EffectRefractionEnvMapMethod",
    "refractionIndex",
    "dispersionR",
    "dispersionG",
    "dispersionB",
    "_dispersionR",
    "_dispersionG",
    "_dispersionB",
    "_useDispersion",
    "_refractionIndex",
    "useDispersion",
    "data2",
    "refractionDir",
    "refractionColor",
    "awayjs-methodmaterials/lib/methods/EffectRimLightMethod",
    "EffectRimLightMethod",
    "strength",
    "power",
    "blend",
    "_strength",
    "_power",
    "dataRegister2",
    "MIX",
    "_normalMap",
    "normalDependencies",
    "iOutputsTangentNormals",
    "bnm",
    "awayjs-methodmaterials/lib/methods/NormalHeightMapMethod",
    "NormalHeightMapMethod",
    "heightMap",
    "worldWidth",
    "worldHeight",
    "worldDepth",
    "_worldXYRatio",
    "_worldXZRatio",
    "image2D",
    "width",
    "height",
    "dataReg",
    "dataReg2",
    "awayjs-methodmaterials/lib/methods/NormalSimpleWaterMethod",
    "NormalSimpleWaterMethod",
    "secondaryNormalMap",
    "_water1OffsetX",
    "_water1OffsetY",
    "_water2OffsetX",
    "_water2OffsetY",
    "_secondaryNormalMap",
    "AssetBase",
    "_textures",
    "_owners",
    "_counts",
    "iUsesTangentSpace",
    "len",
    "dispatchEvent",
    "awayjs-core/lib/library/AssetBase",
    "awayjs-methodmaterials/lib/methods/ShadowCascadeMethod",
    "DirectionalLight",
    "ShadowMapMethodBase",
    "ShadowCascadeMethod",
    "shadowMethodBase",
    "castingLight",
    "_baseMethod",
    "_pCastingLight",
    "_cascadeShadowMapper",
    "shadowMapper",
    "INVALIDATE",
    "onCascadeChange",
    "tempVO",
    "depthMap",
    "fragmentData",
    "vertexData",
    "_cascadeProjections",
    "_depthMapCoordVaryings",
    "initProjectionsRegs",
    "numCascades",
    "globalPositionVertex",
    "planeDistanceReg",
    "planeDistances",
    "inQuad",
    "uvCoord",
    "uvProjection",
    "_iGetCascadeFragmentCode",
    "vertexIndex",
    "depth",
    "_pEpsilon",
    "k",
    "getDepthProjections",
    "fragmentIndex",
    "_pAlpha",
    "nearPlaneDistances",
    "_iNearPlaneDistances",
    "iActivateForCascade",
    "awayjs-display/lib/entities/DirectionalLight",
    "awayjs-methodmaterials/lib/methods/ShadowMapMethodBase",
    "awayjs-methodmaterials/lib/methods/ShadowDitheredMethod",
    "BitmapImage2D",
    "ShadowMethodBase",
    "ShadowDitheredMethod",
    "numSamples",
    "range",
    "_depthMapSize",
    "_grainUsages",
    "_grainTexture",
    "initGrainTexture",
    "_numSamples",
    "_range",
    "_grainBitmapImage2D",
    "vec",
    "step",
    "g",
    "Math",
    "random",
    "floor",
    "setArray",
    "rect",
    "_pGetPlanarFragmentCode",
    "customDataReg",
    "getSampleCode",
    "uvReg",
    "projectionReg",
    "_pDepthMapCoordReg",
    "addSample",
    "decodeRegister",
    "depthProjection",
    "targetRegister",
    "awayjs-core/lib/image/BitmapImage2D",
    "awayjs-methodmaterials/lib/methods/ShadowMethodBase",
    "awayjs-methodmaterials/lib/methods/ShadowFilteredMethod",
    "ShadowFilteredMethod",
    "size",
    "depthCol",
    "predicate",
    "awayjs-methodmaterials/lib/methods/ShadowHardMethod",
    "ShadowHardMethod",
    "_pGetPointFragmentCode",
    "epsReg",
    "posReg",
    "depthSampleCol",
    "lightDir",
    "globalPositionVarying",
    "castsShadows",
    "_pShadowMapper",
    "PointLight",
    "_pUsePoint",
    "_pGetPointVertexCode",
    "pGetPlanarVertexCode",
    "depthMapProj",
    "iDepthProjection",
    "pow",
    "fallOff",
    "pos",
    "scenePosition",
    "x",
    "y",
    "z",
    "awayjs-display/lib/entities/PointLight",
    "awayjs-methodmaterials/lib/methods/ShadowNearMethod",
    "ShadowNearMethod",
    "fadeRatio",
    "_fadeRatio",
    "_nearShadowMapper",
    "epsilon",
    "getFreeFragmentSingleTemp",
    "near",
    "projection",
    "far",
    "coverageRatio",
    "awayjs-methodmaterials/lib/methods/ShadowSoftMethod",
    "PoissonLookup",
    "ShadowSoftMethod",
    "_offsets",
    "getDistribution",
    "texRange",
    "offsets",
    "numRegs",
    "reg",
    "awayjs-core/lib/geom/PoissonLookup",
    "awayjs-methodmaterials/lib/methods/SpecularAnisotropicMethod",
    "SpecularAnisotropicMethod",
    "tangentVarying",
    "_pSpecularTexData",
    "_pSpecularDataRegister",
    "_gloss",
    "_specular",
    "_specularColor",
    "_iSpecularR",
    "_iSpecularG",
    "_iSpecularB",
    "updateSpecular",
    "bsm",
    "spec",
    "useSmoothTextures",
    "awayjs-methodmaterials/lib/methods/SpecularCelMethod",
    "SpecularCompositeMethod",
    "SpecularCelMethod",
    "specularCutOff",
    "_specularCutOff",
    "clampSpecular",
    "awayjs-methodmaterials/lib/methods/SpecularCompositeMethod",
    "awayjs-methodmaterials/lib/methods/SpecularFresnelMethod",
    "SpecularFresnelMethod",
    "basedOnSurface",
    "modulateSpecular",
    "_incidentLight",
    "awayjs-methodmaterials/lib/methods/SpecularPhongMethod",
    "SpecularPhongMethod",
    "BlendMode",
    "StaticLightPicker",
    "RenderBase",
    "MethodPassMode",
    "MethodPass",
    "material",
    "renderableClass",
    "pool",
    "_material",
    "lightPicker",
    "numLightProbes",
    "numDirectionalLights",
    "numPointLights",
    "numCastingDirectionalLights",
    "numCastingPointLights",
    "_pUpdateRender",
    "initPasses",
    "setBlendAndCompareModes",
    "_pClearPasses",
    "mode",
    "_casterLightPass",
    "_pAddPass",
    "_nonCasterLightPasses",
    "_pass",
    "numEffectMethods",
    "initEffectPass",
    "removeEffectPass",
    "shadowMethod",
    "initCasterLightPass",
    "removeCasterLightPass",
    "numNonCasters",
    "initNonCasterLightPasses",
    "removeNonCasterLightPasses",
    "forceSeparateMVP",
    "Boolean",
    "setBlendMode",
    "NORMAL",
    "depthCompareMode",
    "firstAdditiveIndex",
    "_pRequiresBlending",
    "EFFECTS",
    "LAYER",
    "alphaBlending",
    "colorTransform",
    "SUPER_SHADER",
    "preserveAlpha",
    "LIGHTING",
    "_renderableClass",
    "_stage",
    "diffuseMethod",
    "ambientMethod",
    "normalMethod",
    "specularMethod",
    "_pRemovePass",
    "pass",
    "numDirLights",
    "dirLightOffset",
    "pointLightOffset",
    "probeOffset",
    "includeCasters",
    "directionalLightsOffset",
    "pointLightsOffset",
    "lightProbesOffset",
    "effectMethod",
    "max",
    "removeEffectMethodAt",
    "awayjs-core/lib/image/BlendMode",
    "awayjs-display/lib/materials/lightpickers/StaticLightPicker",
    "awayjs-methodmaterials/lib/render/passes/MethodPass",
    "awayjs-methodmaterials/lib/render/passes/MethodPassMode",
    "awayjs-renderergl/lib/render/RenderBase",
    "PassMode",
    "LightSources",
    "LightingShader",
    "ShaderBase",
    "PassBase",
    "render",
    "renderOwner",
    "_maxLights",
    "_includeCasters",
    "_iMethodVOs",
    "_numEffectDependencies",
    "_onLightsChangeDelegate",
    "onLightsChange",
    "_onMethodInvalidatedDelegate",
    "onMethodInvalidated",
    "_shader",
    "_updateShader",
    "_updateLights",
    "_lightPicker",
    "enableLightFallOff",
    "diffuseLightSources",
    "specularLightSources",
    "_iInitConstantData",
    "colorTransformMethod",
    "_iColorTransformMethodVO",
    "_removeDependency",
    "_addDependency",
    "effectsDependency",
    "hasEffectMethod",
    "getDependencyForMethod",
    "_iNormalMethodVO",
    "_iAmbientMethodVO",
    "_iShadowMethodVO",
    "_iDiffuseMethodVO",
    "_iSpecularMethodVO",
    "_iActivate",
    "_iRender",
    "viewProjection",
    "_iDeactivate",
    "_iIncludeDependencies",
    "usesFragmentAnimation",
    "useAlphaPremultiplied",
    "usesBlending",
    "setupAndCountDependencies",
    "usesTangentSpace",
    "outputsNormals",
    "outputsTangentNormals",
    "usesProbes",
    "viewDirDependencies",
    "globalPosDependencies",
    "usesLights",
    "usesGlobalPosFragment",
    "projectionDependencies",
    "tangentDependencies",
    "_iGetPreLightingVertexCode",
    "_iGetPreLightingFragmentCode",
    "shadedTarget",
    "_iGetPerLightDiffuseFragmentCode",
    "diffuseColorReg",
    "_iGetPerLightSpecularFragmentCode",
    "specularColorReg",
    "_iGetPerProbeDiffuseFragmentCode",
    "texReg",
    "weightReg",
    "_iGetPerProbeSpecularFragmentCode",
    "_iGetPostLightingVertexCode",
    "_iGetPostLightingFragmentCode",
    "_iGetNormalVertexCode",
    "_iGetNormalFragmentCode",
    "removeVertexTempUsage",
    "_iGetVertexCode",
    "sharedReg",
    "alphaReg",
    "_iUsesShadows",
    "castingDirectionalLights",
    "castingPointLights",
    "_iUsesSpecular",
    "_iUsesDiffuse",
    "numDirectionalLightsOld",
    "numPointLightsOld",
    "numLightProbesOld",
    "calculateNumDirectionalLights",
    "calculateNumPointLights",
    "calculateNumProbes",
    "min",
    "numFree",
    "numChannels",
    "PROBES",
    "awayjs-display/lib/materials/LightSources",
    "awayjs-renderergl/lib/render/passes/PassBase",
    "awayjs-renderergl/lib/shaders/LightingShader",
    "awayjs-renderergl/lib/shaders/ShaderBase",
    "awayjs-methodmaterials/lib/render/passes/SingleObjectDepthPass",
    "Matrix3D",
    "ContextGLDrawMode",
    "ContextGLProgramType",
    "SingleObjectDepthPass",
    "_textureSize",
    "_polyOffset",
    "Float32Array",
    "_projectionTexturesInvalid",
    "key",
    "updateProjectionTextures",
    "_projections",
    "renderableOwner",
    "id",
    "context",
    "light",
    "lights",
    "_renderOwner",
    "allPickedLights",
    "rId",
    "iGetObjectProjectionMatrix",
    "sourceEntity",
    "setRenderTarget",
    "clear",
    "setProgramConstantsFromMatrix",
    "VERTEX",
    "setProgramConstantsFromArray",
    "FRAGMENT",
    "_enc",
    "subGeometryVO",
    "subGeom",
    "subGeometry",
    "activateVertexBufferVO",
    "positions",
    "normals",
    "getIndexBufferVO",
    "draw",
    "TRIANGLES",
    "numElements",
    "awayjs-core/lib/geom/Matrix3D",
    "awayjs-stagegl/lib/base/ContextGLDrawMode",
    "awayjs-stagegl/lib/base/ContextGLProgramType"
  ],
  "mappings": "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",
  "file": "awayjs-methodmaterials.min.js",
  "sourcesContent": [
    "(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})",
    "import RenderPool\t\t\t\t\t= require(\"awayjs-renderergl/lib/render/RenderPool\");\n\nimport MethodMaterial\t\t\t\t= require(\"awayjs-methodmaterials/lib/MethodMaterial\");\nimport MethodMaterialRender\t\t\t= require(\"awayjs-methodmaterials/lib/render/MethodMaterialRender\");\n\nRenderPool.registerAbstraction(MethodMaterialRender, MethodMaterial);\n\n\n\n/**\n *\n * static shim\n */\nclass methodmaterials\n{\n\n}\n\nexport = methodmaterials;",
    null,
    "class MethodMaterialMode\n{\n\t/**\n\t *\n\t */\n\tpublic static SINGLE_PASS:string = \"singlePass\";\n\n\t/**\n\t *\n\t */\n\tpublic static MULTI_PASS:string = \"multiPass\";\n}\n\nexport = MethodMaterialMode;",
    "import Image2D\t\t\t\t\t\t= require(\"awayjs-core/lib/image/Image2D\");\n\nimport IRenderOwner\t\t\t\t\t= require(\"awayjs-display/lib/base/IRenderOwner\");\nimport Camera\t\t\t\t\t\t= require(\"awayjs-display/lib/entities/Camera\");\nimport StaticLightPicker\t\t\t= require(\"awayjs-display/lib/materials/lightpickers/StaticLightPicker\");\nimport MaterialBase\t\t\t\t\t= require(\"awayjs-display/lib/materials/MaterialBase\");\nimport Single2DTexture\t\t\t\t= require(\"awayjs-display/lib/textures/Single2DTexture\");\nimport TextureBase\t\t\t\t\t= require(\"awayjs-display/lib/textures/TextureBase\");\n\nimport ContextGLCompareMode\t\t\t= require(\"awayjs-stagegl/lib/base/ContextGLCompareMode\");\n\nimport RenderPool\t\t\t\t\t= require(\"awayjs-renderergl/lib/render/RenderPool\");\n\nimport MethodMaterialMode\t\t\t= require(\"awayjs-methodmaterials/lib/MethodMaterialMode\");\nimport AmbientBasicMethod\t\t\t= require(\"awayjs-methodmaterials/lib/methods/AmbientBasicMethod\");\nimport DiffuseBasicMethod\t\t\t= require(\"awayjs-methodmaterials/lib/methods/DiffuseBasicMethod\");\nimport EffectMethodBase\t\t\t\t= require(\"awayjs-methodmaterials/lib/methods/EffectMethodBase\");\nimport NormalBasicMethod\t\t\t= require(\"awayjs-methodmaterials/lib/methods/NormalBasicMethod\");\nimport ShadowMapMethodBase\t\t\t= require(\"awayjs-methodmaterials/lib/methods/ShadowMapMethodBase\");\nimport SpecularBasicMethod\t\t\t= require(\"awayjs-methodmaterials/lib/methods/SpecularBasicMethod\");\n\n/**\n * MethodMaterial forms an abstract base class for the default shaded materials provided by Stage,\n * using material methods to define their appearance.\n */\nclass MethodMaterial extends MaterialBase\n{\n\tpublic static assetType:string = \"[materials MethodMaterial]\";\n\n\tprivate _effectMethods:Array<EffectMethodBase> = new Array<EffectMethodBase>();\n\tprivate _mode:string;\n\n\tprivate _ambientMethod:AmbientBasicMethod = new AmbientBasicMethod();\n\tprivate _shadowMethod:ShadowMapMethodBase;\n\tprivate _diffuseMethod:DiffuseBasicMethod = new DiffuseBasicMethod();\n\tprivate _normalMethod:NormalBasicMethod = new NormalBasicMethod();\n\tprivate _specularMethod:SpecularBasicMethod = new SpecularBasicMethod();\n\n\n\tprivate _depthCompareMode:string = ContextGLCompareMode.LESS_EQUAL;\n\n\t/**\n\t *\n\t */\n\tpublic get assetType():string\n\t{\n\t\treturn MethodMaterial.assetType;\n\t}\n\n\t/**\n\t * Creates a new MethodMaterial object.\n\t *\n\t * @param texture The texture used for the material's albedo color.\n\t * @param smooth Indicates whether the texture should be filtered when sampled. Defaults to true.\n\t * @param repeat Indicates whether the texture should be tiled when sampled. Defaults to false.\n\t * @param mipmap Indicates whether or not any used textures should use mipmapping. Defaults to false.\n\t */\n\tconstructor(texture?:Image2D, smooth?:boolean, repeat?:boolean, mipmap?:boolean);\n\tconstructor(texture?:TextureBase, smooth?:boolean, repeat?:boolean, mipmap?:boolean);\n\tconstructor(color?:number, alpha?:number);\n\tconstructor(textureColor:any = null, smoothAlpha:any = null, repeat:boolean = false, mipmap:boolean = true)\n\t{\n\t\tsuper();\n\n\t\tthis._mode = MethodMaterialMode.SINGLE_PASS;\n\n\t\tif (textureColor instanceof Image2D)\n\t\t\ttextureColor = new Single2DTexture(textureColor);\n\n\t\tif (textureColor instanceof TextureBase) {\n\t\t\tthis.texture = <TextureBase> textureColor;\n\n\t\t\tthis.smooth = (smoothAlpha == null)? true : false;\n\t\t\tthis.repeat = repeat;\n\t\t\tthis.mipmap = mipmap;\n\t\t} else {\n\t\t\tthis.color = (textureColor == null)? 0xFFFFFF : Number(textureColor);\n\t\t\tthis.alpha = (smoothAlpha == null)? 1 : Number(smoothAlpha);\n\t\t}\n\n\t\t//add default methods owners\n\t\tthis._ambientMethod.iAddOwner(this);\n\t\tthis._diffuseMethod.iAddOwner(this);\n\t\tthis._normalMethod.iAddOwner(this);\n\t\tthis._specularMethod.iAddOwner(this);\n\t}\n\n\n\tpublic get mode():string\n\t{\n\t\treturn this._mode;\n\t}\n\n\tpublic set mode(value:string)\n\t{\n\t\tif (this._mode == value)\n\t\t\treturn;\n\n\t\tthis._mode = value;\n\n\t\tthis.invalidate();\n\t}\n\n\t/**\n\t * The depth compare mode used to render the renderables using this material.\n\t *\n\t * @see away.stagegl.ContextGLCompareMode\n\t */\n\n\tpublic get depthCompareMode():string\n\t{\n\t\treturn this._depthCompareMode;\n\t}\n\n\tpublic set depthCompareMode(value:string)\n\t{\n\t\tif (this._depthCompareMode == value)\n\t\t\treturn;\n\n\t\tthis._depthCompareMode = value;\n\n\t\tthis.invalidate();\n\t}\n\n\t/**\n\t * The texture object to use for the ambient colour.\n\t */\n\tpublic get diffuseTexture():TextureBase\n\t{\n\t\treturn this._diffuseMethod.texture;\n\t}\n\n\tpublic set diffuseTexture(value:TextureBase)\n\t{\n\t\tthis._diffuseMethod.texture = value;\n\t}\n\n\t/**\n\t * The method that provides the ambient lighting contribution. Defaults to AmbientBasicMethod.\n\t */\n\tpublic get ambientMethod():AmbientBasicMethod\n\t{\n\t\treturn this._ambientMethod;\n\t}\n\n\tpublic set ambientMethod(value:AmbientBasicMethod)\n\t{\n\t\tif (this._ambientMethod == value)\n\t\t\treturn;\n\n\t\tif (value && this._ambientMethod)\n\t\t\tvalue.copyFrom(this._ambientMethod);\n\n\t\tif (this._ambientMethod)\n\t\t\tthis._ambientMethod.iRemoveOwner(this);\n\n\t\tthis._ambientMethod = value;\n\n\t\tif (this._ambientMethod)\n\t\t\tthis._ambientMethod.iAddOwner(this);\n\n\t\tthis.invalidate();\n\t}\n\n\t/**\n\t * The method used to render shadows cast on this surface, or null if no shadows are to be rendered. Defaults to null.\n\t */\n\tpublic get shadowMethod():ShadowMapMethodBase\n\t{\n\t\treturn this._shadowMethod;\n\t}\n\n\tpublic set shadowMethod(value:ShadowMapMethodBase)\n\t{\n\t\tif (this._shadowMethod == value)\n\t\t\treturn;\n\n\t\tif (value && this._shadowMethod)\n\t\t\tvalue.copyFrom(this._shadowMethod);\n\n\t\tif (this._shadowMethod)\n\t\t\tthis._shadowMethod.iRemoveOwner(this);\n\n\t\tthis._shadowMethod = value;\n\n\t\tif (this._shadowMethod)\n\t\t\tthis._shadowMethod.iAddOwner(this);\n\n\t\tthis.invalidate();\n\t}\n\n\t/**\n\t * The method that provides the diffuse lighting contribution. Defaults to DiffuseBasicMethod.\n\t */\n\tpublic get diffuseMethod():DiffuseBasicMethod\n\t{\n\t\treturn this._diffuseMethod;\n\t}\n\n\tpublic set diffuseMethod(value:DiffuseBasicMethod)\n\t{\n\t\tif (this._diffuseMethod == value)\n\t\t\treturn;\n\n\t\tif (value && this._diffuseMethod)\n\t\t\tvalue.copyFrom(this._diffuseMethod);\n\n\t\tif (this._diffuseMethod)\n\t\t\tthis._diffuseMethod.iRemoveOwner(this);\n\n\t\tthis._diffuseMethod = value;\n\n\t\tif (this._diffuseMethod)\n\t\t\tthis._diffuseMethod.iAddOwner(this);\n\n\t\tthis.invalidate();\n\t}\n\n\t/**\n\t * The method that provides the specular lighting contribution. Defaults to SpecularBasicMethod.\n\t */\n\tpublic get specularMethod():SpecularBasicMethod\n\t{\n\t\treturn this._specularMethod;\n\t}\n\n\tpublic set specularMethod(value:SpecularBasicMethod)\n\t{\n\t\tif (this._specularMethod == value)\n\t\t\treturn;\n\n\t\tif (value && this._specularMethod)\n\t\t\tvalue.copyFrom(this._specularMethod);\n\n\t\tif (this._specularMethod)\n\t\t\tthis._specularMethod.iRemoveOwner(this);\n\n\t\tthis._specularMethod = value;\n\n\t\tif (this._specularMethod)\n\t\t\tthis._specularMethod.iAddOwner(this);\n\n\t\tthis.invalidate();\n\t}\n\n\t/**\n\t * The method used to generate the per-pixel normals. Defaults to NormalBasicMethod.\n\t */\n\tpublic get normalMethod():NormalBasicMethod\n\t{\n\t\treturn this._normalMethod;\n\t}\n\n\tpublic set normalMethod(value:NormalBasicMethod)\n\t{\n\t\tif (this._normalMethod == value)\n\t\t\treturn;\n\n\t\tif (value && this._normalMethod)\n\t\t\tvalue.copyFrom(this._normalMethod);\n\n\t\tif (this._normalMethod)\n\t\t\tthis._normalMethod.iRemoveOwner(this);\n\n\t\tthis._normalMethod = value;\n\n\t\tif (this._normalMethod)\n\t\t\tthis._normalMethod.iAddOwner(this);\n\n\t\tthis.invalidate();\n\t}\n\n\tpublic get numEffectMethods():number\n\t{\n\t\treturn this._effectMethods.length;\n\t}\n\n\t/**\n\t * Appends an \"effect\" shading method to the shader. Effect methods are those that do not influence the lighting\n\t * but modulate the shaded colour, used for fog, outlines, etc. The method will be applied to the result of the\n\t * methods added prior.\n\t */\n\tpublic addEffectMethod(method:EffectMethodBase)\n\t{\n\t\tmethod.iAddOwner(this);\n\n\t\tthis._effectMethods.push(method);\n\n\t\tthis.invalidate();\n\t}\n\n\t/**\n\t * Returns the method added at the given index.\n\t * @param index The index of the method to retrieve.\n\t * @return The method at the given index.\n\t */\n\tpublic getEffectMethodAt(index:number):EffectMethodBase\n\t{\n\t\treturn this._effectMethods[index];\n\t}\n\n\t/**\n\t * Adds an effect method at the specified index amongst the methods already added to the material. Effect\n\t * methods are those that do not influence the lighting but modulate the shaded colour, used for fog, outlines,\n\t * etc. The method will be applied to the result of the methods with a lower index.\n\t */\n\tpublic addEffectMethodAt(method:EffectMethodBase, index:number)\n\t{\n\t\tmethod.iAddOwner(this);\n\n\t\tthis._effectMethods.splice(index, 0, method);\n\n\t\tthis.invalidate();\n\t}\n\n\t/**\n\t * Removes an effect method from the material.\n\t * @param method The method to be removed.\n\t */\n\tpublic removeEffectMethod(method:EffectMethodBase)\n\t{\n\t\tmethod.iRemoveOwner(this);\n\n\t\tthis._effectMethods.splice(this._effectMethods.indexOf(method), 1);\n\n\t\tthis.invalidate();\n\t}\n\n\t/**\n\t * The normal map to modulate the direction of the surface for each texel. The default normal method expects\n\t * tangent-space normal maps, but others could expect object-space maps.\n\t */\n\tpublic get normalMap():TextureBase\n\t{\n\t\treturn this._normalMethod.normalMap;\n\t}\n\n\tpublic set normalMap(value:TextureBase)\n\t{\n\t\tthis._normalMethod.normalMap = value;\n\t}\n\n\t/**\n\t * A specular map that defines the strength of specular reflections for each texel in the red channel,\n\t * and the gloss factor in the green channel. You can use Specular2DTexture if you want to easily set\n\t * specular and gloss maps from grayscale images, but correctly authored images are preferred.\n\t */\n\tpublic get specularMap():TextureBase\n\t{\n\t\treturn this._specularMethod.texture;\n\t}\n\n\tpublic set specularMap(value:TextureBase)\n\t{\n\t\tthis._specularMethod.texture = value;\n\t}\n\n\t/**\n\t * The glossiness of the material (sharpness of the specular highlight).\n\t */\n\tpublic get gloss():number\n\t{\n\t\treturn this._specularMethod.gloss;\n\t}\n\n\tpublic set gloss(value:number)\n\t{\n\t\tthis._specularMethod.gloss = value;\n\t}\n\n\t/**\n\t * The strength of the ambient reflection.\n\t */\n\tpublic get ambient():number\n\t{\n\t\treturn this._ambientMethod.ambient;\n\t}\n\n\tpublic set ambient(value:number)\n\t{\n\t\tthis._ambientMethod.ambient = value;\n\t}\n\n\t/**\n\t * The overall strength of the specular reflection.\n\t */\n\tpublic get specular():number\n\t{\n\t\treturn this._specularMethod.specular;\n\t}\n\n\tpublic set specular(value:number)\n\t{\n\t\tthis._specularMethod.specular = value;\n\t}\n\n\t/**\n\t * The colour of the ambient reflection.\n\t */\n\tpublic get ambientColor():number\n\t{\n\t\treturn this._diffuseMethod.ambientColor;\n\t}\n\n\tpublic set ambientColor(value:number)\n\t{\n\t\tthis._diffuseMethod.ambientColor = value;\n\t}\n\n\t/**\n\t * The colour of the diffuse reflection.\n\t */\n\tpublic get diffuseColor():number\n\t{\n\t\treturn this._diffuseMethod.diffuseColor;\n\t}\n\n\tpublic set diffuseColor(value:number)\n\t{\n\t\tthis._diffuseMethod.diffuseColor = value;\n\t}\n\n\t/**\n\t * The colour of the specular reflection.\n\t */\n\tpublic get specularColor():number\n\t{\n\t\treturn this._specularMethod.specularColor;\n\t}\n\n\tpublic set specularColor(value:number)\n\t{\n\t\tthis._specularMethod.specularColor = value;\n\t}\n}\n\nexport = MethodMaterial;",
    "import TextureVOBase\t\t\t\t= require(\"awayjs-renderergl/lib/vos/TextureVOBase\");\n\nimport ShadingMethodBase\t\t\t= require(\"awayjs-methodmaterials/lib/methods/ShadingMethodBase\");\n\n/**\n * MethodVO contains data for a given shader object for the use within a single material.\n * This allows shader methods to be shared across materials while their non-public state differs.\n */\nclass MethodVO\n{\n\tpublic useMethod:boolean = true;\n\n\tpublic method:ShadingMethodBase;\n\n\t// public register indices\n\tpublic textureVO:TextureVOBase;\n\tpublic secondaryTextureVO:TextureVOBase; // sometimes needed for composites\n\tpublic vertexConstantsIndex:number;\n\tpublic secondaryVertexConstantsIndex:number; // sometimes needed for composites\n\tpublic fragmentConstantsIndex:number;\n\tpublic secondaryFragmentConstantsIndex:number; // sometimes needed for composites\n\n\t// internal stuff for the material to know before assembling code\n\tpublic needsProjection:boolean;\n\tpublic needsView:boolean;\n\tpublic needsNormals:boolean;\n\tpublic needsTangents:boolean;\n\tpublic needsGlobalVertexPos:boolean;\n\tpublic needsGlobalFragmentPos:boolean;\n\t/**\n\t * Creates a new MethodVO object.\n\t */\n\tconstructor(method:ShadingMethodBase)\n\t{\n\t\tthis.method = method;\n\t}\n\n\t/**\n\t * Resets the values of the value object to their \"unused\" state.\n\t */\n\tpublic reset()\n\t{\n\t\tthis.method.iReset();\n\n\t\tthis.vertexConstantsIndex = -1;\n\t\tthis.secondaryVertexConstantsIndex = -1;\n\t\tthis.fragmentConstantsIndex = -1;\n\t\tthis.secondaryFragmentConstantsIndex = -1;\n\n\t\tthis.needsProjection = false;\n\t\tthis.needsView = false;\n\t\tthis.needsNormals = false;\n\t\tthis.needsTangents = false;\n\t\tthis.needsGlobalVertexPos = false;\n\t\tthis.needsGlobalFragmentPos = false;\n\t}\n}\n\nexport = MethodVO;\n",
    "import Camera\t\t\t\t\t\t\t= require(\"awayjs-display/lib/entities/Camera\");\n\nimport Stage\t\t\t\t\t\t\t= require(\"awayjs-stagegl/lib/base/Stage\");\n\nimport RenderableBase\t\t\t\t\t= require(\"awayjs-renderergl/lib/renderables/RenderableBase\");\nimport ShaderBase\t\t\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderBase\");\nimport ShaderRegisterCache\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterCache\");\nimport ShaderRegisterData\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterData\");\nimport ShaderRegisterElement\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterElement\");\n\nimport MethodVO\t\t\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/data/MethodVO\");\nimport ShadingMethodBase\t\t\t\t= require(\"awayjs-methodmaterials/lib/methods/ShadingMethodBase\");\n\n/**\n * AmbientBasicMethod provides the default shading method for uniform ambient lighting.\n */\nclass AmbientBasicMethod extends ShadingMethodBase\n{\n\tprivate _color:number = 0xffffff;\n\tprivate _alpha:number = 1;\n\n\tprivate _colorR:number = 1;\n\tprivate _colorG:number = 1;\n\tprivate _colorB:number = 1;\n\n\tprivate _ambient:number = 1;\n\n\t/**\n\t * Creates a new AmbientBasicMethod object.\n\t */\n\tconstructor()\n\t{\n\t\tsuper();\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitVO(shader:ShaderBase, methodVO:MethodVO)\n\t{\n\t\tif (shader.textureVO)\n\t\t\tshader.uvDependencies++;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitConstants(shader:ShaderBase, methodVO:MethodVO)\n\t{\n\t\tif (!shader.textureVO) {\n\t\t\tthis._color = shader.color;\n\t\t\tthis.updateColor();\n\t\t}\n\t}\n\n\t/**\n\t * The strength of the ambient reflection of the surface.\n\t */\n\tpublic get ambient():number\n\t{\n\t\treturn this._ambient;\n\t}\n\n\tpublic set ambient(value:number)\n\t{\n\t\tif (this._ambient == value)\n\t\t\treturn;\n\n\t\tthis._ambient = value;\n\n\t\tthis.updateColor();\n\t}\n\n\t/**\n\t * The alpha component of the surface.\n\t */\n\tpublic get alpha():number\n\t{\n\t\treturn this._alpha;\n\t}\n\n\tpublic set alpha(value:number)\n\t{\n\t\tif (this._alpha == value)\n\t\t\treturn;\n\n\t\tthis._alpha = value;\n\n\t\tthis.updateColor();\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic copyFrom(method:ShadingMethodBase)\n\t{\n\t\tvar m:any = method;\n\t\tvar b:AmbientBasicMethod = <AmbientBasicMethod> m;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentCode(shader:ShaderBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = \"\";\n\n\t\tif (shader.textureVO) {\n\t\t\tcode += shader.textureVO._iGetFragmentCode(targetReg, registerCache, sharedRegisters, sharedRegisters.uvVarying);\n\n\t\t\tif (shader.alphaThreshold > 0) {\n\t\t\t\tvar cutOffReg:ShaderRegisterElement = registerCache.getFreeFragmentConstant();\n\t\t\t\tmethodVO.fragmentConstantsIndex = cutOffReg.index*4;\n\n\t\t\t\tcode += \"sub \" + targetReg + \".w, \" + targetReg + \".w, \" + cutOffReg + \".x\\n\" +\n\t\t\t\t\t\"kil \" + targetReg + \".w\\n\" +\n\t\t\t\t\t\"add \" + targetReg + \".w, \" + targetReg + \".w, \" + cutOffReg + \".x\\n\";\n\t\t\t}\n\n\t\t} else {\n\t\t\tvar ambientInputRegister:ShaderRegisterElement = registerCache.getFreeFragmentConstant();\n\t\t\tmethodVO.fragmentConstantsIndex = ambientInputRegister.index*4;\n\n\t\t\tcode += \"mov \" + targetReg + \", \" + ambientInputRegister + \"\\n\";\n\t\t}\n\n\t\treturn code;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iActivate(shader:ShaderBase, methodVO:MethodVO, stage:Stage)\n\t{\n\t\tif (shader.textureVO) {\n\t\t\tshader.textureVO.activate();\n\n\t\t\tif (shader.alphaThreshold > 0)\n\t\t\t\tshader.fragmentConstantData[methodVO.fragmentConstantsIndex] = shader.alphaThreshold;\n\t\t} else {\n\t\t\tvar index:number = methodVO.fragmentConstantsIndex;\n\t\t\tvar data:Float32Array = shader.fragmentConstantData;\n\t\t\tdata[index] = this._colorR;\n\t\t\tdata[index + 1] = this._colorG;\n\t\t\tdata[index + 2] = this._colorB;\n\t\t\tdata[index + 3] = this._alpha;\n\t\t}\n\t}\n\n\tpublic iSetRenderState(shader:ShaderBase, methodVO:MethodVO, renderable:RenderableBase, stage:Stage, camera:Camera)\n\t{\n\t\tif (shader.textureVO)\n\t\t\tshader.textureVO._setRenderState(renderable);\n\t}\n\n\t/**\n\t * Updates the ambient color data used by the render state.\n\t */\n\tprivate updateColor()\n\t{\n\t\tthis._colorR = ((this._color >> 16) & 0xff)/0xff*this._ambient;\n\t\tthis._colorG = ((this._color >> 8) & 0xff)/0xff*this._ambient;\n\t\tthis._colorB = (this._color & 0xff)/0xff*this._ambient;\n\t}\n}\n\nexport = AmbientBasicMethod;",
    "import ShaderBase\t\t\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderBase\");\nimport ShaderRegisterCache\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterCache\");\nimport ShaderRegisterData\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterData\");\nimport ShaderRegisterElement\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterElement\");\n\nimport MethodVO\t\t\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/data/MethodVO\");\nimport AmbientBasicMethod\t\t\t\t= require(\"awayjs-methodmaterials/lib/methods/AmbientBasicMethod\");\n\n/**\n * AmbientEnvMapMethod provides a diffuse shading method that uses a diffuse irradiance environment map to\n * approximate global lighting rather than lights.\n */\nclass AmbientEnvMapMethod extends AmbientBasicMethod\n{\n\t/**\n\t * Creates a new <code>AmbientEnvMapMethod</code> object.\n\t *\n\t * @param envMap The cube environment map to use for the ambient lighting.\n\t */\n\tconstructor()\n\t{\n\t\tsuper();\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitVO(shader:ShaderBase, methodVO:MethodVO)\n\t{\n\t\tmethodVO.needsNormals = true;\n\t}\n\t\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentCode(shader:ShaderBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, regCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\treturn shader.textureVO._iGetFragmentCode(targetReg, regCache, sharedRegisters, sharedRegisters.normalFragment);\n\t}\n}\n\nexport = AmbientEnvMapMethod;",
    "import Camera\t\t\t\t\t\t\t= require(\"awayjs-display/lib/entities/Camera\");\n\nimport Stage\t\t\t\t\t\t\t= require(\"awayjs-stagegl/lib/base/Stage\");\n\nimport RenderableBase\t\t\t\t\t= require(\"awayjs-renderergl/lib/renderables/RenderableBase\");\nimport ShaderBase\t\t\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderBase\");\nimport ShaderRegisterCache\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterCache\");\nimport ShaderRegisterData\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterData\");\nimport ShaderRegisterElement\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterElement\");\n\nimport MethodVO\t\t\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/data/MethodVO\");\nimport ShadingMethodBase\t\t\t\t= require(\"awayjs-methodmaterials/lib/methods/ShadingMethodBase\");\n\n/**\n * AmbientBasicMethod provides the default shading method for uniform ambient lighting.\n */\nclass CurveBasicMethod extends ShadingMethodBase\n{\n\tprivate _color:number = 0xffffff;\n\tprivate _alpha:number = 1;\n\n\tprivate _colorR:number = 1;\n\tprivate _colorG:number = 1;\n\tprivate _colorB:number = 1;\n\n\tprivate _ambient:number = 1;\n\n\t/**\n\t * Creates a new AmbientBasicMethod object.\n\t */\n\tconstructor()\n\t{\n\t\tsuper();\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitVO(shader:ShaderBase, methodVO:MethodVO)\n\t{\n\t\tif (shader.textureVO)\n\t\t\tshader.uvDependencies++;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitConstants(shader:ShaderBase, methodVO:MethodVO)\n\t{\n\t\tif (!shader.textureVO) {\n\t\t\tthis._color = shader.color;\n\t\t\tthis.updateColor();\n\t\t}\n\t}\n\n\t/**\n\t * The strength of the ambient reflection of the surface.\n\t */\n\tpublic get ambient():number\n\t{\n\t\treturn this._ambient;\n\t}\n\n\tpublic set ambient(value:number)\n\t{\n\t\tif (this._ambient == value)\n\t\t\treturn;\n\n\t\tthis._ambient = value;\n\n\t\tthis.updateColor();\n\t}\n\n\t/**\n\t * The alpha component of the surface.\n\t */\n\tpublic get alpha():number\n\t{\n\t\treturn this._alpha;\n\t}\n\n\tpublic set alpha(value:number)\n\t{\n\t\tif (this._alpha == value)\n\t\t\treturn;\n\n\t\tthis._alpha = value;\n\n\t\tthis.updateColor();\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic copyFrom(method:ShadingMethodBase)\n\t{\n\t\tvar m:any = method;\n\t\tvar b:CurveBasicMethod = <CurveBasicMethod> m;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n    /*\n    public iGeVertexCode(shader:ShaderBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string {\n        var code:string = \"\";\n        code = \"mov \" + sharedRegisters.uvVarying + \" \" + registerCache.uv +  \" \\n\";\n    }*/\n    public iGetFragmentCode(shader:ShaderBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = \"\";\n\t\tvar ambientInputRegister:ShaderRegisterElement;\n\n\t\tif (shader.textureVO) {\n\t\t\tcode += shader.textureVO._iGetFragmentCode(targetReg, registerCache, sharedRegisters, sharedRegisters.uvVarying);\n\n\t\t\tif (shader.alphaThreshold > 0) {\n\t\t\t\tvar cutOffReg:ShaderRegisterElement = registerCache.getFreeFragmentConstant();\n\t\t\t\tmethodVO.fragmentConstantsIndex = cutOffReg.index*4;\n\n\t\t\t\tcode += \"sub \" + targetReg + \".w, \" + targetReg + \".w, \" + cutOffReg + \".x\\n\" +\n\t\t\t\t\t\"kil \" + targetReg + \".w\\n\" +\n\t\t\t\t\t\"add \" + targetReg + \".w, \" + targetReg + \".w, \" + cutOffReg + \".x\\n\";\n\t\t\t}\n\n\t\t} else {\n\t\t\tambientInputRegister = registerCache.getFreeFragmentConstant();\n\t\t\tmethodVO.fragmentConstantsIndex = ambientInputRegister.index*4;\n\n\t\t\tcode += \"mov \" + targetReg + \", \" + ambientInputRegister + \"\\n\";\n\t\t}\n        code = \"mov \" + targetReg + \", \" + sharedRegisters.uvVarying + \"\\n\";\n\t\treturn code;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iActivate(shader:ShaderBase, methodVO:MethodVO, stage:Stage)\n\t{\n\t\tif (shader.textureVO) {\n\t\t\tshader.textureVO.activate();\n\n\t\t\tif (shader.alphaThreshold > 0)\n\t\t\t\tshader.fragmentConstantData[methodVO.fragmentConstantsIndex] = shader.alphaThreshold;\n\t\t} else {\n\t\t\tvar index:number = methodVO.fragmentConstantsIndex;\n\t\t\tvar data:Float32Array = shader.fragmentConstantData;\n\t\t\tdata[index] = this._colorR;\n\t\t\tdata[index + 1] = this._colorG;\n\t\t\tdata[index + 2] = this._colorB;\n\t\t\tdata[index + 3] = this._alpha;\n\t\t}\n\t}\n\n\tpublic iSetRenderState(shader:ShaderBase, methodVO:MethodVO, renderable:RenderableBase, stage:Stage, camera:Camera)\n\t{\n\t\tif (shader.textureVO)\n\t\t\tshader.textureVO._setRenderState(renderable);\n\t}\n\n\t/**\n\t * Updates the ambient color data used by the render state.\n\t */\n\tprivate updateColor()\n\t{\n\t\tthis._colorR = ((this._color >> 16) & 0xff)/0xff*this._ambient;\n\t\tthis._colorG = ((this._color >> 8) & 0xff)/0xff*this._ambient;\n\t\tthis._colorB = (this._color & 0xff)/0xff*this._ambient;\n\t}\n}\nexport = CurveBasicMethod;",
    "import AssetEvent\t\t\t\t\t\t= require(\"awayjs-core/lib/events/AssetEvent\");\n\nimport Camera\t\t\t\t\t\t\t= require(\"awayjs-display/lib/entities/Camera\");\nimport TextureBase\t\t\t\t\t\t= require(\"awayjs-display/lib/textures/TextureBase\");\n\nimport Stage\t\t\t\t\t\t\t= require(\"awayjs-stagegl/lib/base/Stage\");\n\nimport RenderableBase\t\t\t\t\t= require(\"awayjs-renderergl/lib/renderables/RenderableBase\");\nimport LightingShader\t\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/LightingShader\");\nimport ShaderRegisterCache\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterCache\");\nimport ShaderRegisterData\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterData\");\nimport ShaderRegisterElement\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterElement\");\n\nimport MethodVO\t\t\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/data/MethodVO\");\nimport ShadingMethodBase\t\t\t\t= require(\"awayjs-methodmaterials/lib/methods/ShadingMethodBase\");\nimport LightingMethodBase\t\t\t\t= require(\"awayjs-methodmaterials/lib/methods/LightingMethodBase\");\n\n/**\n * DiffuseBasicMethod provides the default shading method for Lambert (dot3) diffuse lighting.\n */\nclass DiffuseBasicMethod extends LightingMethodBase\n{\n\tprivate _multiply:boolean = true;\n\n\tpublic _pTotalLightColorReg:ShaderRegisterElement;\n\n\tpublic _texture:TextureBase;\n\tprivate _diffuseColor:number = 0xffffff;\n\tprivate _ambientColor:number = 0xffffff;\n\tprivate _diffuseR:number = 1;\n\tprivate _diffuseG:number = 1;\n\tprivate _diffuseB:number = 1;\n\tprivate _ambientR:number = 1;\n\tprivate _ambientG:number = 1;\n\tprivate _ambientB:number = 1;\n\n\tpublic _pIsFirstLight:boolean;\n\n\t/**\n\t * Creates a new DiffuseBasicMethod object.\n\t */\n\tconstructor()\n\t{\n\t\tsuper();\n\t}\n\n\tpublic iIsUsed(shader:LightingShader):boolean\n\t{\n\t\tif (!shader.numLights)\n\t\t\treturn false;\n\n\t\treturn true;\n\t}\n\n\t/**\n\t * Set internally if diffuse color component multiplies or replaces the ambient color\n\t */\n\tpublic get multiply():boolean\n\t{\n\t\treturn this._multiply;\n\t}\n\n\tpublic set multiply(value:boolean)\n\t{\n\t\tif (this._multiply == value)\n\t\t\treturn;\n\n\t\tthis._multiply = value;\n\n\t\tthis.iInvalidateShaderProgram();\n\t}\n\n\tpublic iInitVO(shader:LightingShader, methodVO:MethodVO)\n\t{\n\t\tif (this._texture) {\n\t\t\tmethodVO.textureVO = shader.getAbstraction(this._texture);\n\t\t\tshader.uvDependencies++;\n\t\t} else if (methodVO.textureVO) {\n\t\t\tmethodVO.textureVO.onClear(new AssetEvent(AssetEvent.CLEAR, null));\n\t\t\tmethodVO.textureVO = null;\n\t\t}\n\n\t\tif (shader.numLights > 0) {\n\t\t\tshader.usesCommonData = true;\n\t\t\tmethodVO.needsNormals = true;\n\t\t}\n\t}\n\n\t/**\n\t * The color of the diffuse reflection when not using a texture.\n\t */\n\tpublic get diffuseColor():number\n\t{\n\t\treturn this._diffuseColor;\n\t}\n\n\tpublic set diffuseColor(value:number)\n\t{\n\t\tif (this._diffuseColor == value)\n\t\t\treturn;\n\n\t\tthis._diffuseColor = value;\n\n\t\tthis.updateDiffuse();\n\t}\n\n\t/**\n\t * The color of the ambient reflection\n\t */\n\tpublic get ambientColor():number\n\t{\n\t\treturn this._ambientColor;\n\t}\n\n\tpublic set ambientColor(value:number)\n\t{\n\t\tif (this._ambientColor == value)\n\t\t\treturn;\n\n\t\tthis._ambientColor = value;\n\n\t\tthis.updateAmbient();\n\t}\n\n\n\t/**\n\t * The bitmapData to use to define the diffuse reflection color per texel.\n\t */\n\tpublic get texture():TextureBase\n\t{\n\t\treturn this._texture;\n\t}\n\n\tpublic set texture(value:TextureBase)\n\t{\n\t\tif (this._texture == value)\n\t\t\treturn;\n\n\t\tif (this._texture)\n\t\t\tthis.iRemoveTexture(this._texture);\n\n\t\tthis._texture = value;\n\n\t\tif (this._texture)\n\t\t\tthis.iAddTexture(this._texture);\n\n\t\tthis.iInvalidateShaderProgram();\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic dispose()\n\t{\n\t\tthis._texture = null;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic copyFrom(method:ShadingMethodBase)\n\t{\n\t\tvar diff:DiffuseBasicMethod = <DiffuseBasicMethod> method;\n\n\t\tthis.texture = diff.texture;\n\t\tthis.multiply = diff.multiply;\n\t\tthis.diffuseColor = diff.diffuseColor;\n\t\tthis.ambientColor = diff.ambientColor;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iCleanCompilationData()\n\t{\n\t\tsuper.iCleanCompilationData();\n\n\t\tthis._pTotalLightColorReg = null;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentPreLightingCode(shader:LightingShader, methodVO:MethodVO, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = \"\";\n\n\t\tthis._pIsFirstLight = true;\n\n\t\tregisterCache.addFragmentTempUsages(this._pTotalLightColorReg = registerCache.getFreeFragmentVectorTemp(), 1);\n\n\t\treturn code;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentCodePerLight(shader:LightingShader, methodVO:MethodVO, lightDirReg:ShaderRegisterElement, lightColReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = \"\";\n\t\tvar t:ShaderRegisterElement;\n\n\t\t// write in temporary if not first light, so we can add to total diffuse colour\n\t\tif (this._pIsFirstLight) {\n\t\t\tt = this._pTotalLightColorReg;\n\t\t} else {\n\t\t\tt = registerCache.getFreeFragmentVectorTemp();\n\t\t\tregisterCache.addFragmentTempUsages(t, 1);\n\t\t}\n\n\t\tcode += \"dp3 \" + t + \".x, \" + lightDirReg + \", \" + sharedRegisters.normalFragment + \"\\n\" +\n\t\t\t\t\"max \" + t + \".w, \" + t + \".x, \" + sharedRegisters.commons + \".y\\n\";\n\n\t\tif (shader.usesLightFallOff)\n\t\t\tcode += \"mul \" + t + \".w, \" + t + \".w, \" + lightDirReg + \".w\\n\";\n\n\t\tif (this._iModulateMethod != null)\n\t\t\tcode += this._iModulateMethod(shader, methodVO, t, registerCache, sharedRegisters);\n\n\t\tcode += \"mul \" + t + \", \" + t + \".w, \" + lightColReg + \"\\n\";\n\n\t\tif (!this._pIsFirstLight) {\n\t\t\tcode += \"add \" + this._pTotalLightColorReg + \".xyz, \" + this._pTotalLightColorReg + \", \" + t + \"\\n\";\n\t\t\tregisterCache.removeFragmentTempUsage(t);\n\t\t}\n\n\t\tthis._pIsFirstLight = false;\n\n\t\treturn code;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentCodePerProbe(shader:LightingShader, methodVO:MethodVO, cubeMapReg:ShaderRegisterElement, weightRegister:string, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = \"\";\n\t\tvar t:ShaderRegisterElement;\n\n\t\t// write in temporary if not first light, so we can add to total diffuse colour\n\t\tif (this._pIsFirstLight) {\n\t\t\tt = this._pTotalLightColorReg;\n\t\t} else {\n\t\t\tt = registerCache.getFreeFragmentVectorTemp();\n\t\t\tregisterCache.addFragmentTempUsages(t, 1);\n\t\t}\n\n\t\tcode += \"tex \" + t + \", \" + sharedRegisters.normalFragment + \", \" + cubeMapReg + \" <cube,linear,miplinear>\\n\" +\n\t\t\t\t\"mul \" + t + \".xyz, \" + t + \".xyz, \" + weightRegister + \"\\n\";\n\n\t\tif (this._iModulateMethod != null)\n\t\t\tcode += this._iModulateMethod(shader, methodVO, t, registerCache, sharedRegisters);\n\n\t\tif (!this._pIsFirstLight) {\n\t\t\tcode += \"add \" + this._pTotalLightColorReg + \".xyz, \" + this._pTotalLightColorReg + \", \" + t + \"\\n\";\n\t\t\tregisterCache.removeFragmentTempUsage(t);\n\t\t}\n\n\t\tthis._pIsFirstLight = false;\n\n\t\treturn code;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentPostLightingCode(shader:LightingShader, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = \"\";\n\n\t\tvar albedo:ShaderRegisterElement;\n\t\tvar cutOffReg:ShaderRegisterElement;\n\n\t\t// incorporate input from ambient\n\t\tif (sharedRegisters.shadowTarget)\n\t\t\tcode += this.pApplyShadow(shader, methodVO, registerCache, sharedRegisters);\n\n\t\tregisterCache.addFragmentTempUsages(albedo = registerCache.getFreeFragmentVectorTemp(), 1);\n\n\t\tvar ambientColorRegister:ShaderRegisterElement = registerCache.getFreeFragmentConstant();\n\t\tmethodVO.fragmentConstantsIndex = ambientColorRegister.index*4;\n\n\t\tif (this._texture) {\n\t\t\tcode += methodVO.textureVO._iGetFragmentCode(albedo, registerCache, sharedRegisters, sharedRegisters.uvVarying);\n\t\t} else {\n\t\t\tvar diffuseInputRegister:ShaderRegisterElement = registerCache.getFreeFragmentConstant();\n\n\t\t\tcode += \"mov \" + albedo + \", \" + diffuseInputRegister + \"\\n\";\n\t\t}\n\n\t\tcode += \"sat \" + this._pTotalLightColorReg + \", \" + this._pTotalLightColorReg + \"\\n\" +\n\t\t\t\"mul \" + albedo + \".xyz, \" + albedo + \", \" + this._pTotalLightColorReg + \"\\n\";\n\n\t\tif (this._multiply) {\n\t\t\tcode += \"add \" + albedo + \".xyz, \" + albedo + \", \" + ambientColorRegister + \"\\n\" +\n\t\t\t\t\"mul \" + targetReg + \".xyz, \" + targetReg + \", \" + albedo + \"\\n\";\n\t\t} else {\n\t\t\tcode += \"mul \" + targetReg + \".xyz, \" + targetReg + \", \" + ambientColorRegister + \"\\n\" +\n\t\t\t\t\"mul \" + this._pTotalLightColorReg + \".xyz, \" + targetReg + \", \" + this._pTotalLightColorReg + \"\\n\" +\n\t\t\t\t\"sub \" + targetReg + \".xyz, \" + targetReg + \", \" + this._pTotalLightColorReg + \"\\n\" +\n\t\t\t\t\"add \" + targetReg + \".xyz, \" + targetReg + \", \" + albedo + \"\\n\";\n\t\t}\n\n\t\tregisterCache.removeFragmentTempUsage(this._pTotalLightColorReg);\n\t\tregisterCache.removeFragmentTempUsage(albedo);\n\n\t\treturn code;\n\t}\n\n\t/**\n\t * Generate the code that applies the calculated shadow to the diffuse light\n\t * @param methodVO The MethodVO object for which the compilation is currently happening.\n\t * @param regCache The register cache the compiler is currently using for the register management.\n\t */\n\tpublic pApplyShadow(shader:LightingShader, methodVO:MethodVO, regCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\treturn \"mul \" + this._pTotalLightColorReg + \".xyz, \" + this._pTotalLightColorReg + \", \" + sharedRegisters.shadowTarget + \".w\\n\";\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iActivate(shader:LightingShader, methodVO:MethodVO, stage:Stage)\n\t{\n\t\tif (this._texture) {\n\t\t\tmethodVO.textureVO.activate();\n\t\t} else {\n\t\t\tvar index:number = methodVO.fragmentConstantsIndex;\n\t\t\tvar data:Float32Array = shader.fragmentConstantData;\n\t\t\tdata[index + 4] = this._diffuseR;\n\t\t\tdata[index + 5] = this._diffuseG;\n\t\t\tdata[index + 6] = this._diffuseB;\n\t\t\tdata[index + 7] = 1;\n\t\t}\n\t}\n\n\t/**\n\t * Updates the diffuse color data used by the render state.\n\t */\n\tprivate updateDiffuse()\n\t{\n\t\tthis._diffuseR = ((this._diffuseColor >> 16) & 0xff)/0xff;\n\t\tthis._diffuseG = ((this._diffuseColor >> 8) & 0xff)/0xff;\n\t\tthis._diffuseB = (this._diffuseColor & 0xff)/0xff;\n\t}\n\n\t/**\n\t * Updates the ambient color data used by the render state.\n\t */\n\tprivate updateAmbient()\n\t{\n\t\tthis._ambientR = ((this._ambientColor >> 16) & 0xff)/0xff;\n\t\tthis._ambientG = ((this._ambientColor >> 8) & 0xff)/0xff;\n\t\tthis._ambientB = (this._ambientColor & 0xff)/0xff;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iSetRenderState(shader:LightingShader, methodVO:MethodVO, renderable:RenderableBase, stage:Stage, camera:Camera)\n\t{\n\t\tif (this._texture)\n\t\t\tmethodVO.textureVO._setRenderState(renderable);\n\n\t\t//TODO move this to Activate (ambientR/G/B currently calc'd in render state)\n\t\tif (shader.numLights > 0) {\n\t\t\tvar index:number = methodVO.fragmentConstantsIndex;\n\t\t\tvar data:Float32Array = shader.fragmentConstantData;\n\t\t\tdata[index] = shader.ambientR*this._ambientR;\n\t\t\tdata[index + 1] = shader.ambientG*this._ambientG;\n\t\t\tdata[index + 2] = shader.ambientB*this._ambientB;\n\t\t\tdata[index + 3] = 1;\n\t\t}\n\t}\n}\n\nexport = DiffuseBasicMethod;",
    "import Stage\t\t\t\t\t\t\t= require(\"awayjs-stagegl/lib/base/Stage\");\n\nimport LightingShader\t\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/LightingShader\");\nimport ShaderBase\t\t\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderBase\");\nimport ShaderRegisterCache\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterCache\");\nimport ShaderRegisterData\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterData\");\nimport ShaderRegisterElement\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterElement\");\n\nimport MethodVO\t\t\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/data/MethodVO\");\nimport DiffuseBasicMethod\t\t\t\t= require(\"awayjs-methodmaterials/lib/methods/DiffuseBasicMethod\");\nimport DiffuseCompositeMethod\t\t\t= require(\"awayjs-methodmaterials/lib/methods/DiffuseCompositeMethod\");\n\n/**\n * DiffuseCelMethod provides a shading method to add diffuse cel (cartoon) shading.\n */\nclass DiffuseCelMethod extends DiffuseCompositeMethod\n{\n\tprivate _levels:number /*uint*/;\n\tprivate _dataReg:ShaderRegisterElement;\n\tprivate _smoothness:number = .1;\n\n\t/**\n\t * Creates a new DiffuseCelMethod object.\n\t * @param levels The amount of shadow gradations.\n\t * @param baseMethod An optional diffuse method on which the cartoon shading is based. If omitted, DiffuseBasicMethod is used.\n\t */\n\tconstructor(levels:number /*uint*/ = 3, baseMethod:DiffuseBasicMethod = null)\n\t{\n\t\tsuper(null, baseMethod);\n\n\t\tthis.baseMethod._iModulateMethod = (shader:ShaderBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData) => this.clampDiffuse(shader, methodVO, targetReg, registerCache, sharedRegisters);\n\n\t\tthis._levels = levels;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitConstants(shader:LightingShader, methodVO:MethodVO)\n\t{\n\t\tvar data:Float32Array = shader.fragmentConstantData;\n\t\tvar index:number /*int*/ = methodVO.secondaryFragmentConstantsIndex;\n\t\tsuper.iInitConstants(shader, methodVO);\n\t\tdata[index + 1] = 1;\n\t\tdata[index + 2] = 0;\n\t}\n\n\t/**\n\t * The amount of shadow gradations.\n\t */\n\tpublic get levels():number /*uint*/\n\t{\n\t\treturn this._levels;\n\t}\n\n\tpublic set levels(value:number /*uint*/)\n\t{\n\t\tthis._levels = value;\n\t}\n\n\t/**\n\t * The smoothness of the edge between 2 shading levels.\n\t */\n\tpublic get smoothness():number\n\t{\n\t\treturn this._smoothness;\n\t}\n\n\tpublic set smoothness(value:number)\n\t{\n\t\tthis._smoothness = value;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iCleanCompilationData()\n\t{\n\t\tsuper.iCleanCompilationData();\n\t\tthis._dataReg = null;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentPreLightingCode(shader:LightingShader, methodVO:MethodVO, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tthis._dataReg = registerCache.getFreeFragmentConstant();\n\t\tmethodVO.secondaryFragmentConstantsIndex = this._dataReg.index*4;\n\n\t\treturn super.iGetFragmentPreLightingCode(shader, methodVO, registerCache, sharedRegisters);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iActivate(shader:LightingShader, methodVO:MethodVO, stage:Stage)\n\t{\n\t\tsuper.iActivate(shader, methodVO, stage);\n\t\tvar data:Float32Array = shader.fragmentConstantData;\n\t\tvar index:number /*int*/ = methodVO.secondaryFragmentConstantsIndex;\n\t\tdata[index] = this._levels;\n\t\tdata[index + 3] = this._smoothness;\n\t}\n\n\t/**\n\t * Snaps the diffuse shading of the wrapped method to one of the levels.\n\t * @param vo The MethodVO used to compile the current shader.\n\t * @param t The register containing the diffuse strength in the \"w\" component.\n\t * @param regCache The register cache used for the shader compilation.\n\t * @param sharedRegisters The shared register data for this shader.\n\t * @return The AGAL fragment code for the method.\n\t */\n\tprivate clampDiffuse(shader:ShaderBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\treturn \"mul \" + targetReg + \".w, \" + targetReg + \".w, \" + this._dataReg + \".x\\n\" +\n\t\t\t\"frc \" + targetReg + \".z, \" + targetReg + \".w\\n\" +\n\t\t\t\"sub \" + targetReg + \".y, \" + targetReg + \".w, \" + targetReg + \".z\\n\" +\n\t\t\t\"mov \" + targetReg + \".x, \" + this._dataReg + \".x\\n\" +\n\t\t\t\"sub \" + targetReg + \".x, \" + targetReg + \".x, \" + this._dataReg + \".y\\n\" +\n\t\t\t\"rcp \" + targetReg + \".x,\" + targetReg + \".x\\n\" +\n\t\t\t\"mul \" + targetReg + \".w, \" + targetReg + \".y, \" + targetReg + \".x\\n\" +\n\n\t\t\t// previous clamped strength\n\t\t\t\"sub \" + targetReg + \".y, \" + targetReg + \".w, \" + targetReg + \".x\\n\" +\n\n\t\t\t// fract/epsilon (so 0 - epsilon will become 0 - 1)\n\t\t\t\"div \" + targetReg + \".z, \" + targetReg + \".z, \" + this._dataReg + \".w\\n\" +\n\t\t\t\"sat \" + targetReg + \".z, \" + targetReg + \".z\\n\" +\n\n\t\t\t\"mul \" + targetReg + \".w, \" + targetReg + \".w, \" + targetReg + \".z\\n\" +\n\t\t\t// 1-z\n\t\t\t\"sub \" + targetReg + \".z, \" + this._dataReg + \".y, \" + targetReg + \".z\\n\" +\n\t\t\t\"mul \" + targetReg + \".y, \" + targetReg + \".y, \" + targetReg + \".z\\n\" +\n\t\t\t\"add \" + targetReg + \".w, \" + targetReg + \".w, \" + targetReg + \".y\\n\" +\n\t\t\t\"sat \" + targetReg + \".w, \" + targetReg + \".w\\n\";\n\t}\n}\n\nexport = DiffuseCelMethod;",
    "import Camera\t\t\t\t\t\t\t= require(\"awayjs-display/lib/entities/Camera\");\nimport TextureBase\t\t\t\t\t\t= require(\"awayjs-display/lib/textures/TextureBase\");\nimport IRenderOwner\t\t\t\t\t\t= require(\"awayjs-display/lib/base/IRenderOwner\");\n\nimport Stage\t\t\t\t\t\t\t= require(\"awayjs-stagegl/lib/base/Stage\");\n\nimport LightingShader\t\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/LightingShader\");\nimport ShaderBase\t\t\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderBase\");\nimport ShaderRegisterCache\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterCache\");\nimport ShaderRegisterData\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterData\");\nimport ShaderRegisterElement\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterElement\");\nimport ShadingMethodEvent\t\t\t\t= require(\"awayjs-renderergl/lib/events/ShadingMethodEvent\");\nimport RenderableBase\t\t\t\t\t= require(\"awayjs-renderergl/lib/renderables/RenderableBase\");\n\nimport MethodVO\t\t\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/data/MethodVO\");\nimport DiffuseBasicMethod\t\t\t\t= require(\"awayjs-methodmaterials/lib/methods/DiffuseBasicMethod\");\n\n/**\n * DiffuseCompositeMethod provides a base class for diffuse methods that wrap a diffuse method to alter the\n * calculated diffuse reflection strength.\n */\nclass DiffuseCompositeMethod extends DiffuseBasicMethod\n{\n\tpublic pBaseMethod:DiffuseBasicMethod;\n\n\tprivate _onShaderInvalidatedDelegate:(event:ShadingMethodEvent) => void;\n\n\t/**\n\t * Creates a new <code>DiffuseCompositeMethod</code> object.\n\t *\n\t * @param modulateMethod The method which will add the code to alter the base method's strength. It needs to have the signature clampDiffuse(t:ShaderRegisterElement, regCache:ShaderRegisterCache):string, in which t.w will contain the diffuse strength.\n\t * @param baseMethod The base diffuse method on which this method's shading is based.\n\t */\n\tconstructor(modulateMethod:(shader:ShaderBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData) => string, baseMethod:DiffuseBasicMethod = null)\n\t{\n\t\tsuper();\n\n\t\tthis._onShaderInvalidatedDelegate = (event:ShadingMethodEvent) => this.onShaderInvalidated(event);\n\n\t\tthis.pBaseMethod = baseMethod || new DiffuseBasicMethod();\n\t\tthis.pBaseMethod._iModulateMethod = modulateMethod;\n\t\tthis.pBaseMethod.addEventListener(ShadingMethodEvent.SHADER_INVALIDATED, this._onShaderInvalidatedDelegate);\n\t}\n\n\t/**\n\t * The base diffuse method on which this method's shading is based.\n\t */\n\tpublic get baseMethod():DiffuseBasicMethod\n\t{\n\t\treturn this.pBaseMethod;\n\t}\n\n\tpublic set baseMethod(value:DiffuseBasicMethod)\n\t{\n\t\tif (this.pBaseMethod == value)\n\t\t\treturn;\n\n\t\tthis.pBaseMethod.removeEventListener(ShadingMethodEvent.SHADER_INVALIDATED, this._onShaderInvalidatedDelegate);\n\t\tthis.pBaseMethod = value;\n\t\tthis.pBaseMethod.addEventListener(ShadingMethodEvent.SHADER_INVALIDATED, this._onShaderInvalidatedDelegate);\n\t\tthis.iInvalidateShaderProgram();\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitVO(shader:LightingShader, methodVO:MethodVO)\n\t{\n\t\tthis.pBaseMethod.iInitVO(shader, methodVO);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitConstants(shader:LightingShader, methodVO:MethodVO)\n\t{\n\t\tthis.pBaseMethod.iInitConstants(shader, methodVO);\n\t}\n\n\tpublic iAddOwner(owner:IRenderOwner)\n\t{\n\t\tsuper.iAddOwner(owner);\n\n\t\tthis.pBaseMethod.iAddOwner(owner);\n\t}\n\n\tpublic iRemoveOwner(owner:IRenderOwner)\n\t{\n\t\tsuper.iRemoveOwner(owner);\n\n\t\tthis.pBaseMethod.iRemoveOwner(owner);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic dispose()\n\t{\n\t\tthis.pBaseMethod.removeEventListener(ShadingMethodEvent.SHADER_INVALIDATED, this._onShaderInvalidatedDelegate);\n\t\tthis.pBaseMethod.dispose();\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic get texture():TextureBase\n\t{\n\t\treturn this.pBaseMethod.texture;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic set texture(value:TextureBase)\n\t{\n\t\tthis.pBaseMethod.texture = value;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic get diffuseColor():number\n\t{\n\t\treturn this.pBaseMethod.diffuseColor;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic set diffuseColor(value:number)\n\t{\n\t\tthis.pBaseMethod.diffuseColor = value;\n\t}\n\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic get ambientColor():number\n\t{\n\t\treturn this.pBaseMethod.ambientColor;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic set ambientColor(value:number)\n\t{\n\t\tthis.pBaseMethod.ambientColor = value;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentPreLightingCode(shader:LightingShader, methodVO:MethodVO, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\treturn this.pBaseMethod.iGetFragmentPreLightingCode(shader, methodVO, registerCache, sharedRegisters);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentCodePerLight(shader:LightingShader, methodVO:MethodVO, lightDirReg:ShaderRegisterElement, lightColReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = this.pBaseMethod.iGetFragmentCodePerLight(shader, methodVO, lightDirReg, lightColReg, registerCache, sharedRegisters);\n\t\tthis._pTotalLightColorReg = this.pBaseMethod._pTotalLightColorReg;\n\t\treturn code;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentCodePerProbe(shader:LightingShader, methodVO:MethodVO, cubeMapReg:ShaderRegisterElement, weightRegister:string, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = this.pBaseMethod.iGetFragmentCodePerProbe(shader, methodVO, cubeMapReg, weightRegister, registerCache, sharedRegisters);\n\t\tthis._pTotalLightColorReg = this.pBaseMethod._pTotalLightColorReg;\n\t\treturn code;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iActivate(shader:LightingShader, methodVO:MethodVO, stage:Stage)\n\t{\n\t\tthis.pBaseMethod.iActivate(shader, methodVO, stage);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iSetRenderState(shader:LightingShader, methodVO:MethodVO, renderable:RenderableBase, stage:Stage, camera:Camera)\n\t{\n\t\tthis.pBaseMethod.iSetRenderState(shader, methodVO, renderable, stage, camera);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iDeactivate(shader:LightingShader, methodVO:MethodVO, stage:Stage)\n\t{\n\t\tthis.pBaseMethod.iDeactivate(shader, methodVO, stage);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetVertexCode(shader:ShaderBase, methodVO:MethodVO, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\treturn this.pBaseMethod.iGetVertexCode(shader, methodVO, registerCache, sharedRegisters);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentPostLightingCode(shader:LightingShader, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\treturn this.pBaseMethod.iGetFragmentPostLightingCode(shader, methodVO, targetReg, registerCache, sharedRegisters);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iReset()\n\t{\n\t\tthis.pBaseMethod.iReset();\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iCleanCompilationData()\n\t{\n\t\tsuper.iCleanCompilationData();\n\t\tthis.pBaseMethod.iCleanCompilationData();\n\t}\n\n\t/**\n\t * Called when the base method's shader code is invalidated.\n\t */\n\tprivate onShaderInvalidated(event:ShadingMethodEvent)\n\t{\n\t\tthis.iInvalidateShaderProgram();\n\t}\n}\n\nexport = DiffuseCompositeMethod;",
    "import RenderableBase\t\t\t\t\t= require(\"awayjs-renderergl/lib/renderables/RenderableBase\");\nimport LightingShader\t\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/LightingShader\");\nimport ShaderBase\t\t\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderBase\");\nimport ShaderRegisterCache\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterCache\");\nimport ShaderRegisterData\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterData\");\nimport ShaderRegisterElement\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterElement\");\n\nimport MethodVO\t\t\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/data/MethodVO\");\nimport DiffuseBasicMethod\t\t\t\t= require(\"awayjs-methodmaterials/lib/methods/DiffuseBasicMethod\");\n\n/**\n * DiffuseDepthMethod provides a debug method to visualise depth maps\n */\nclass DiffuseDepthMethod extends DiffuseBasicMethod\n{\n\t/**\n\t * Creates a new DiffuseBasicMethod object.\n\t */\n\tconstructor()\n\t{\n\t\tsuper();\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitConstants(shader:ShaderBase, methodVO:MethodVO)\n\t{\n\t\tvar data:Float32Array = shader.fragmentConstantData;\n\t\tvar index:number /*int*/ = methodVO.fragmentConstantsIndex;\n\t\tdata[index] = 1.0;\n\t\tdata[index + 1] = 1/255.0;\n\t\tdata[index + 2] = 1/65025.0;\n\t\tdata[index + 3] = 1/16581375.0;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentPostLightingCode(shader:LightingShader, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = \"\";\n\t\tvar temp:ShaderRegisterElement;\n\t\tvar decReg:ShaderRegisterElement;\n\n\t\tif (!this._texture)\n\t\t\tthrow new Error(\"DiffuseDepthMethod requires texture!\");\n\n\t\t// incorporate input from ambient\n\t\tif (shader.numLights > 0) {\n\t\t\tif (sharedRegisters.shadowTarget)\n\t\t\t\tcode += \"mul \" + this._pTotalLightColorReg + \".xyz, \" + this._pTotalLightColorReg + \".xyz, \" + sharedRegisters.shadowTarget + \".w\\n\";\n\t\t\tcode += \"add \" + targetReg + \".xyz, \" + this._pTotalLightColorReg + \".xyz, \" + targetReg + \".xyz\\n\" +\n\t\t\t\t\"sat \" + targetReg + \".xyz, \" + targetReg + \".xyz\\n\";\n\t\t\tregisterCache.removeFragmentTempUsage(this._pTotalLightColorReg);\n\t\t\tregisterCache.addFragmentTempUsages(temp = registerCache.getFreeFragmentVectorTemp(), 1);\n\t\t} else {\n\t\t\ttemp = targetReg;\n\t\t}\n\n\t\tdecReg = registerCache.getFreeFragmentConstant();\n\t\tmethodVO.fragmentConstantsIndex = decReg.index*4;\n\n\t\tcode += methodVO.textureVO._iGetFragmentCode(temp, registerCache, sharedRegisters, sharedRegisters.uvVarying) +\n\t\t\t\"dp4 \" + temp + \".x, \" + temp + \", \" + decReg + \"\\n\" +\n\t\t\t\"mov \" + temp + \".yz, \" + temp + \".xx\t\t\t\\n\" +\n\t\t\t\"mov \" + temp + \".w, \" + decReg + \".x\\n\" +\n\t\t\t\"sub \" + temp + \".xyz, \" + decReg + \".xxx, \" + temp + \".xyz\\n\";\n\n\t\tif (shader.numLights == 0)\n\t\t\treturn code;\n\n\t\tcode += \"mul \" + targetReg + \".xyz, \" + temp + \".xyz, \" + targetReg + \".xyz\\n\" +\n\t\t\t\"mov \" + targetReg + \".w, \" + temp + \".w\\n\";\n\n\t\tif (shader.numLights > 0)\n\t\t\tregisterCache.removeFragmentTempUsage(temp);\n\n\t\treturn code;\n\t}\n}\n\nexport = DiffuseDepthMethod;",
    "import Camera\t\t\t\t\t\t\t= require(\"awayjs-display/lib/entities/Camera\");\nimport TextureBase\t\t\t\t\t\t= require(\"awayjs-display/lib/textures/TextureBase\");\n\nimport Stage\t\t\t\t\t\t\t= require(\"awayjs-stagegl/lib/base/Stage\");\n\nimport RenderableBase\t\t\t\t\t= require(\"awayjs-renderergl/lib/renderables/RenderableBase\");\nimport LightingShader\t\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/LightingShader\");\nimport ShaderRegisterCache\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterCache\");\nimport ShaderRegisterData\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterData\");\nimport ShaderRegisterElement\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterElement\");\n\nimport MethodVO\t\t\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/data/MethodVO\");\nimport DiffuseBasicMethod\t\t\t\t= require(\"awayjs-methodmaterials/lib/methods/DiffuseBasicMethod\");\n\n/**\n * DiffuseGradientMethod is an alternative to DiffuseBasicMethod in which the shading can be modulated with a gradient\n * to introduce color-tinted shading as opposed to the single-channel diffuse strength. This can be used as a crude\n * approximation to subsurface scattering (for instance, the mid-range shading for skin can be tinted red to similate\n * scattered light within the skin attributing to the final colour)\n */\nclass DiffuseGradientMethod extends DiffuseBasicMethod\n{\n\tprivate _gradient:TextureBase;\n\n\t/**\n\t * Creates a new DiffuseGradientMethod object.\n\t * @param gradient A texture that contains the light colour based on the angle. This can be used to change\n\t * the light colour due to subsurface scattering when the surface faces away from the light.\n\t */\n\tconstructor(gradient:TextureBase)\n\t{\n\t\tsuper();\n\n\t\tthis._gradient = gradient;\n\n\t\tif (this._gradient)\n\t\t\tthis.iAddTexture(this._gradient);\n\t}\n\n\tpublic iInitVO(shader:LightingShader, methodVO:MethodVO)\n\t{\n\t\tsuper.iInitVO(shader, methodVO);\n\n\t\tmethodVO.secondaryTextureVO = shader.getAbstraction(this._gradient);\n\t}\n\n\t/**\n\t * A texture that contains the light colour based on the angle. This can be used to change the light colour\n\t * due to subsurface scattering when the surface faces away from the light.\n\t */\n\tpublic get gradient():TextureBase\n\t{\n\t\treturn this._gradient;\n\t}\n\n\tpublic set gradient(value:TextureBase)\n\t{\n\t\tif (this._gradient == value)\n\t\t\treturn;\n\n\t\tif (this._gradient)\n\t\t\tthis.iRemoveTexture(this._gradient);\n\n\t\tthis._gradient = value;\n\n\t\tif (this._gradient)\n\t\t\tthis.iAddTexture(this._gradient);\n\n\t\tthis.iInvalidateShaderProgram();\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iCleanCompilationData()\n\t{\n\t\tsuper.iCleanCompilationData();\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentPreLightingCode(shader:LightingShader, methodVO:MethodVO, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = super.iGetFragmentPreLightingCode(shader, methodVO, registerCache, sharedRegisters);\n\t\tthis._pIsFirstLight = true;\n\n\t\treturn code;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentCodePerLight(shader:LightingShader, methodVO:MethodVO, lightDirReg:ShaderRegisterElement, lightColReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = \"\";\n\t\tvar t:ShaderRegisterElement;\n\n\t\t// write in temporary if not first light, so we can add to total diffuse colour\n\t\tif (this._pIsFirstLight)\n\t\t\tt = this._pTotalLightColorReg;\n\t\telse {\n\t\t\tt = registerCache.getFreeFragmentVectorTemp();\n\t\t\tregisterCache.addFragmentTempUsages(t, 1);\n\t\t}\n\n\t\tcode += \"dp3 \" + t + \".w, \" + lightDirReg + \".xyz, \" + sharedRegisters.normalFragment + \".xyz\\n\" +\n\t\t\t\"mul \" + t + \".w, \" + t + \".w, \" + sharedRegisters.commons + \".x\\n\" +\n\t\t\t\"add \" + t + \".w, \" + t + \".w, \" + sharedRegisters.commons + \".x\\n\" +\n\t\t\t\"mul \" + t + \".xyz, \" + t + \".w, \" + lightDirReg + \".w\\n\";\n\n\t\tif (this._iModulateMethod != null)\n\t\t\tcode += this._iModulateMethod(shader, methodVO, t, registerCache, sharedRegisters);\n\n\t\tcode += methodVO.secondaryTextureVO._iGetFragmentCode(t, registerCache, sharedRegisters, t) +\n\t\t\t//\t\t\t\t\t\"mul \" + t + \".xyz, \" + t + \".xyz, \" + t + \".w\\n\" +\n\t\t\t\"mul \" + t + \".xyz, \" + t + \".xyz, \" + lightColReg + \".xyz\\n\";\n\n\t\tif (!this._pIsFirstLight) {\n\t\t\tcode += \"add \" + this._pTotalLightColorReg + \".xyz, \" + this._pTotalLightColorReg + \".xyz, \" + t + \".xyz\\n\";\n\t\t\tregisterCache.removeFragmentTempUsage(t);\n\t\t}\n\n\t\tthis._pIsFirstLight = false;\n\n\t\treturn code;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic pApplyShadow(shader:LightingShader, methodVO:MethodVO, regCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar t:ShaderRegisterElement = regCache.getFreeFragmentVectorTemp();\n\n\t\treturn \"mov \" + t + \", \" + sharedRegisters.shadowTarget + \".wwww\\n\" +\n\t\t\tmethodVO.secondaryTextureVO._iGetFragmentCode(t, regCache, sharedRegisters, sharedRegisters.uvVarying) +\n\t\t\t\"mul \" + this._pTotalLightColorReg + \".xyz, \" + this._pTotalLightColorReg + \", \" + t + \"\\n\";\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iActivate(shader:LightingShader, methodVO:MethodVO, stage:Stage)\n\t{\n\t\tsuper.iActivate(shader, methodVO, stage);\n\n\t\tmethodVO.secondaryTextureVO.activate();\n\t}\n\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iSetRenderState(shader:LightingShader, methodVO:MethodVO, renderable:RenderableBase, stage:Stage, camera:Camera)\n\t{\n\t\tsuper.iSetRenderState(shader, methodVO, renderable, stage, camera);\n\n\t\tif (shader.numLights > 0)\n\t\t\tmethodVO.secondaryTextureVO._setRenderState(renderable);\n\t}\n}\n\nexport = DiffuseGradientMethod;",
    "import Camera\t\t\t\t\t\t\t= require(\"awayjs-display/lib/entities/Camera\");\nimport TextureBase\t\t\t\t\t\t= require(\"awayjs-display/lib/textures/TextureBase\");\n\nimport Stage\t\t\t\t\t\t\t= require(\"awayjs-stagegl/lib/base/Stage\");\n\nimport RenderableBase\t\t\t\t\t= require(\"awayjs-renderergl/lib/renderables/RenderableBase\");\nimport LightingShader\t\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/LightingShader\");\nimport ShaderRegisterCache\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterCache\");\nimport ShaderRegisterData\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterData\");\nimport ShaderRegisterElement\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterElement\");\n\nimport MethodVO\t\t\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/data/MethodVO\");\nimport DiffuseBasicMethod\t\t\t\t= require(\"awayjs-methodmaterials/lib/methods/DiffuseBasicMethod\");\nimport DiffuseCompositeMethod\t\t\t= require(\"awayjs-methodmaterials/lib/methods/DiffuseCompositeMethod\");\n\n/**\n * DiffuseLightMapMethod provides a diffuse shading method that uses a light map to modulate the calculated diffuse\n * lighting. It is different from EffectLightMapMethod in that the latter modulates the entire calculated pixel color, rather\n * than only the diffuse lighting value.\n */\nclass DiffuseLightMapMethod extends DiffuseCompositeMethod\n{\n\t/**\n\t * Indicates the light map should be multiplied with the calculated shading result.\n\t * This can be used to add pre-calculated shadows or occlusion.\n\t */\n\tpublic static MULTIPLY:string = \"multiply\";\n\n\t/**\n\t * Indicates the light map should be added into the calculated shading result.\n\t * This can be used to add pre-calculated lighting or global illumination.\n\t */\n\tpublic static ADD:string = \"add\";\n\n\tprivate _lightMap:TextureBase;\n\tprivate _blendMode:string;\n\tprivate _useSecondaryUV:boolean;\n\n\t/**\n\t * Creates a new DiffuseLightMapMethod method.\n\t *\n\t * @param lightMap The texture containing the light map.\n\t * @param blendMode The blend mode with which the light map should be applied to the lighting result.\n\t * @param useSecondaryUV Indicates whether the secondary UV set should be used to map the light map.\n\t * @param baseMethod The diffuse method used to calculate the regular diffuse-based lighting.\n\t */\n\tconstructor(lightMap:TextureBase, blendMode:string = \"multiply\", useSecondaryUV:boolean = false, baseMethod:DiffuseBasicMethod = null)\n\t{\n\t\tsuper(null, baseMethod);\n\n\t\tthis._useSecondaryUV = useSecondaryUV;\n\t\tthis._lightMap = lightMap;\n\t\tthis.blendMode = blendMode;\n\n\t\tif (this._lightMap)\n\t\t\tthis.iAddTexture(this._lightMap);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitVO(shader:LightingShader, methodVO:MethodVO)\n\t{\n\t\tmethodVO.secondaryTextureVO = shader.getAbstraction(this._lightMap);\n\n\t\tif (this._useSecondaryUV)\n\t\t\tshader.secondaryUVDependencies++;\n\t\telse\n\t\t\tshader.uvDependencies++;\n\t}\n\n\t/**\n\t * The blend mode with which the light map should be applied to the lighting result.\n\t *\n\t * @see DiffuseLightMapMethod.ADD\n\t * @see DiffuseLightMapMethod.MULTIPLY\n\t */\n\tpublic get blendMode():string\n\t{\n\t\treturn this._blendMode;\n\t}\n\n\tpublic set blendMode(value:string)\n\t{\n\t\tif (value != DiffuseLightMapMethod.ADD && value != DiffuseLightMapMethod.MULTIPLY)\n\t\t\tthrow new Error(\"Unknown blendmode!\");\n\n\t\tif (this._blendMode == value)\n\t\t\treturn;\n\n\t\tthis._blendMode = value;\n\n\t\tthis.iInvalidateShaderProgram();\n\t}\n\n\t/**\n\t * The texture containing the light map data.\n\t */\n\tpublic get lightMap():TextureBase\n\t{\n\t\treturn this._lightMap;\n\t}\n\n\tpublic set lightMap(value:TextureBase)\n\t{\n\t\tif (this._lightMap == value)\n\t\t\treturn;\n\n\t\tif (this._lightMap)\n\t\t\tthis.iRemoveTexture(this._lightMap);\n\n\t\tthis._lightMap = value;\n\n\t\tif (this._lightMap)\n\t\t\tthis.iAddTexture(this._lightMap);\n\n\t\tthis.iInvalidateShaderProgram();\n\t}\n\n\t/**\n\t * Indicates whether the secondary UV set should be used to map the light map.\n\t */\n\tpublic get useSecondaryUV():boolean\n\t{\n\t\treturn this._useSecondaryUV;\n\t}\n\n\tpublic set useSecondaryUV(value:boolean)\n\t{\n\t\tif (this._useSecondaryUV == value)\n\t\t\treturn;\n\n\t\tthis._useSecondaryUV = value;\n\n\t\tthis.iInvalidateShaderProgram();\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentPostLightingCode(shader:LightingShader, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string;\n\t\tvar temp:ShaderRegisterElement = registerCache.getFreeFragmentVectorTemp();\n\n\t\tcode = methodVO.secondaryTextureVO._iGetFragmentCode(temp, registerCache, sharedRegisters, this._useSecondaryUV? sharedRegisters.secondaryUVVarying : sharedRegisters.uvVarying);\n\n\t\tswitch (this._blendMode) {\n\t\t\tcase DiffuseLightMapMethod.MULTIPLY:\n\t\t\t\tcode += \"mul \" + this._pTotalLightColorReg + \", \" + this._pTotalLightColorReg + \", \" + temp + \"\\n\";\n\t\t\t\tbreak;\n\t\t\tcase DiffuseLightMapMethod.ADD:\n\t\t\t\tcode += \"add \" + this._pTotalLightColorReg + \", \" + this._pTotalLightColorReg + \", \" + temp + \"\\n\";\n\t\t\t\tbreak;\n\t\t}\n\n\t\tcode += super.iGetFragmentPostLightingCode(shader, methodVO, targetReg, registerCache, sharedRegisters);\n\n\t\treturn code;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iActivate(shader:LightingShader, methodVO:MethodVO, stage:Stage)\n\t{\n\t\tsuper.iActivate(shader, methodVO, stage);\n\n\t\tmethodVO.secondaryTextureVO.activate();\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iSetRenderState(shader:LightingShader, methodVO:MethodVO, renderable:RenderableBase, stage:Stage, camera:Camera)\n\t{\n\t\tsuper.iSetRenderState(shader, methodVO, renderable, stage, camera);\n\n\t\tmethodVO.secondaryTextureVO._setRenderState(renderable);\n\t}\n}\n\nexport = DiffuseLightMapMethod;",
    "import Camera\t\t\t\t\t\t\t= require(\"awayjs-display/lib/entities/Camera\");\n\nimport Stage\t\t\t\t\t\t\t= require(\"awayjs-stagegl/lib/base/Stage\");\n\nimport RenderableBase\t\t\t\t\t= require(\"awayjs-renderergl/lib/renderables/RenderableBase\");\nimport LightingShader\t\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/LightingShader\");\nimport ShaderBase\t\t\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderBase\");\nimport ShaderRegisterCache\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterCache\");\nimport ShaderRegisterData\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterData\");\nimport ShaderRegisterElement\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterElement\");\n\nimport MethodVO\t\t\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/data/MethodVO\");\nimport DiffuseBasicMethod\t\t\t\t= require(\"awayjs-methodmaterials/lib/methods/DiffuseBasicMethod\");\nimport DiffuseCompositeMethod\t\t\t= require(\"awayjs-methodmaterials/lib/methods/DiffuseCompositeMethod\");\nimport SingleObjectDepthPass\t\t\t= require(\"awayjs-methodmaterials/lib/render/passes/SingleObjectDepthPass\");\n\n/**\n * DiffuseSubSurfaceMethod provides a depth map-based diffuse shading method that mimics the scattering of\n * light inside translucent surfaces. It allows light to shine through an object and to soften the diffuse shading.\n * It can be used for candle wax, ice, skin, ...\n */\nclass DiffuseSubSurfaceMethod extends DiffuseCompositeMethod\n{\n\tprivate _depthPass:SingleObjectDepthPass;\n\tprivate _lightProjVarying:ShaderRegisterElement;\n\tprivate _propReg:ShaderRegisterElement;\n\tprivate _scattering:number;\n\tprivate _translucency:number = 1;\n\tprivate _lightColorReg:ShaderRegisterElement;\n\tprivate _scatterColor:number /*uint*/ = 0xffffff;\n\tprivate _colorReg:ShaderRegisterElement;\n\tprivate _decReg:ShaderRegisterElement;\n\tprivate _scatterR:number = 1.0;\n\tprivate _scatterG:number = 1.0;\n\tprivate _scatterB:number = 1.0;\n\tprivate _targetReg:ShaderRegisterElement;\n\t\n\t/**\n\t * Creates a new <code>DiffuseSubSurfaceMethod</code> object.\n\t *\n\t * @param depthMapSize The size of the depth map used.\n\t * @param depthMapOffset The amount by which the rendered object will be inflated, to prevent depth map rounding errors.\n\t * @param baseMethod The diffuse method used to calculate the regular diffuse-based lighting.\n\t */\n\tconstructor(depthMapSize:number /*int*/ = 512, depthMapOffset:number = 15, baseMethod:DiffuseBasicMethod = null)\n\t{\n\t\tsuper(null, baseMethod);\n\n\t\tthis.pBaseMethod._iModulateMethod = (shader:ShaderBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData) => this.scatterLight(shader, methodVO, targetReg, registerCache, sharedRegisters);\n\n\t\t//this._passes = new Array<MaterialPassGLBase>();\n\t\t//this._depthPass = new SingleObjectDepthPass();\n\t\t//this._depthPass.textureSize = depthMapSize;\n\t\t//this._depthPass.polyOffset = depthMapOffset;\n\t\t//this._passes.push(this._depthPass);\n\t\tthis._scattering = 0.2;\n\t\tthis._translucency = 1;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitConstants(shader:LightingShader, methodVO:MethodVO)\n\t{\n\t\tsuper.iInitConstants(shader, methodVO);\n\n\t\tvar data:Float32Array = shader.vertexConstantData;\n\t\tvar index:number /*int*/ = methodVO.secondaryVertexConstantsIndex;\n\t\tdata[index] = .5;\n\t\tdata[index + 1] = -.5;\n\t\tdata[index + 2] = 0;\n\t\tdata[index + 3] = 1;\n\t\t\n\t\tdata = shader.fragmentConstantData;\n\t\tindex = methodVO.secondaryFragmentConstantsIndex;\n\t\tdata[index + 3] = 1.0;\n\t\tdata[index + 4] = 1.0;\n\t\tdata[index + 5] = 1/255;\n\t\tdata[index + 6] = 1/65025;\n\t\tdata[index + 7] = 1/16581375;\n\t\tdata[index + 10] = .5;\n\t\tdata[index + 11] = -.1;\n\t}\n\t\n\tpublic iCleanCompilationData()\n\t{\n\t\tsuper.iCleanCompilationData();\n\n\t\tthis._lightProjVarying = null;\n\t\tthis._propReg = null;\n\t\tthis._lightColorReg = null;\n\t\tthis._colorReg = null;\n\t\tthis._decReg = null;\n\t\tthis._targetReg = null;\n\t}\n\t\n\t/**\n\t * The amount by which the light scatters. It can be used to set the translucent surface's thickness. Use low\n\t * values for skin.\n\t */\n\tpublic get scattering():number\n\t{\n\t\treturn this._scattering;\n\t}\n\t\n\tpublic set scattering(value:number)\n\t{\n\t\tthis._scattering = value;\n\t}\n\t\n\t/**\n\t * The translucency of the object.\n\t */\n\tpublic get translucency():number\n\t{\n\t\treturn this._translucency;\n\t}\n\t\n\tpublic set translucency(value:number)\n\t{\n\t\tthis._translucency = value;\n\t}\n\t\n\t/**\n\t * The colour of the \"insides\" of the object, ie: the colour the light becomes after leaving the object.\n\t */\n\tpublic get scatterColor():number /*uint*/\n\t{\n\t\treturn this._scatterColor;\n\t}\n\t\n\tpublic set scatterColor(scatterColor:number /*uint*/)\n\t{\n\t\tthis._scatterColor = scatterColor;\n\t\tthis._scatterR = ((scatterColor >> 16) & 0xff)/0xff;\n\t\tthis._scatterG = ((scatterColor >> 8) & 0xff)/0xff;\n\t\tthis._scatterB = (scatterColor & 0xff)/0xff;\n\t}\n\t\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetVertexCode(shader:ShaderBase, methodVO:MethodVO, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = super.iGetVertexCode(shader, methodVO, registerCache, sharedRegisters);\n\t\tvar lightProjection:ShaderRegisterElement;\n\t\tvar toTexRegister:ShaderRegisterElement;\n\t\tvar temp:ShaderRegisterElement = registerCache.getFreeVertexVectorTemp();\n\t\t\n\t\ttoTexRegister = registerCache.getFreeVertexConstant();\n\t\tmethodVO.secondaryVertexConstantsIndex = toTexRegister.index*4;\n\n\t\tthis._lightProjVarying = registerCache.getFreeVarying();\n\t\tlightProjection = registerCache.getFreeVertexConstant();\n\t\tregisterCache.getFreeVertexConstant();\n\t\tregisterCache.getFreeVertexConstant();\n\t\tregisterCache.getFreeVertexConstant();\n\t\t\n\t\tcode += \"m44 \" + temp + \", vt0, \" + lightProjection + \"\\n\" +\n\t\t\t\"div \" + temp + \".xyz, \" + temp + \".xyz, \" + temp + \".w\\n\" +\n\t\t\t\"mul \" + temp + \".xy, \" + temp + \".xy, \" + toTexRegister + \".xy\\n\" +\n\t\t\t\"add \" + temp + \".xy, \" + temp + \".xy, \" + toTexRegister + \".xx\\n\" +\n\t\t\t\"mov \" + this._lightProjVarying + \".xyz, \" + temp + \".xyz\\n\" +\n\t\t\t\"mov \" + this._lightProjVarying + \".w, va0.w\\n\";\n\t\t\n\t\treturn code;\n\t}\n\t\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentPreLightingCode(shader:LightingShader, methodVO:MethodVO, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tthis._colorReg = registerCache.getFreeFragmentConstant();\n\t\tthis._decReg = registerCache.getFreeFragmentConstant();\n\t\tthis._propReg = registerCache.getFreeFragmentConstant();\n\t\tmethodVO.secondaryFragmentConstantsIndex = this._colorReg.index*4;\n\t\t\n\t\treturn super.iGetFragmentPreLightingCode(shader, methodVO, registerCache, sharedRegisters);\n\t}\n\t\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentCodePerLight(shader:LightingShader, methodVO:MethodVO, lightDirReg:ShaderRegisterElement, lightColReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tthis._pIsFirstLight = true;\n\t\tthis._lightColorReg = lightColReg;\n\t\treturn super.iGetFragmentCodePerLight(shader, methodVO, lightDirReg, lightColReg, registerCache, sharedRegisters);\n\t}\n\t\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentPostLightingCode(shader:LightingShader, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = super.iGetFragmentPostLightingCode(shader, methodVO, targetReg, registerCache, sharedRegisters);\n\t\tvar temp:ShaderRegisterElement = registerCache.getFreeFragmentVectorTemp();\n\t\t\n\t\tcode += \"mul \" + temp + \".xyz, \" + this._lightColorReg + \".xyz, \" + this._targetReg + \".w\\n\" +\n\t\t\t\"mul \" + temp + \".xyz, \" + temp + \".xyz, \" + this._colorReg + \".xyz\\n\" +\n\t\t\t\"add \" + targetReg + \".xyz, \" + targetReg + \".xyz, \" + temp + \".xyz\\n\";\n\t\t\n\t\tif (this._targetReg != sharedRegisters.viewDirFragment)\n\t\t\tregisterCache.removeFragmentTempUsage(targetReg);\n\t\t\n\t\treturn code;\n\t}\n\t\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iActivate(shader:LightingShader, methodVO:MethodVO, stage:Stage)\n\t{\n\t\tsuper.iActivate(shader, methodVO, stage);\n\n\t\tvar index:number /*int*/ = methodVO.secondaryFragmentConstantsIndex;\n\t\tvar data:Float32Array = shader.fragmentConstantData;\n\t\tdata[index] = this._scatterR;\n\t\tdata[index + 1] = this._scatterG;\n\t\tdata[index + 2] = this._scatterB;\n\t\tdata[index + 8] = this._scattering;\n\t\tdata[index + 9] = this._translucency;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iSetRenderState(shader:ShaderBase, methodVO:MethodVO, renderable:RenderableBase, stage:Stage, camera:Camera)\n\t{\n\t\tmethodVO.secondaryTextureVO = shader.getAbstraction(this._depthPass._iGetDepthMap(renderable));\n\t\tmethodVO.secondaryTextureVO._setRenderState(renderable);\n\n\t\tthis._depthPass._iGetProjection(renderable).copyRawDataTo(shader.vertexConstantData, methodVO.secondaryVertexConstantsIndex + 4, true);\n\t}\n\t\n\t/**\n\t * Generates the code for this method\n\t */\n\tprivate scatterLight(shader:ShaderBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\t// only scatter first light\n\t\tif (!this._pIsFirstLight)\n\t\t\treturn \"\";\n\n\t\tthis._pIsFirstLight = false;\n\n\t\tvar code:string = \"\";\n\n\t\tif (sharedRegisters.viewDirFragment)\n\t\t\tthis._targetReg = sharedRegisters.viewDirFragment;\n\t\telse\n\t\t\tregisterCache.addFragmentTempUsages(this._targetReg = registerCache.getFreeFragmentVectorTemp(), 1);\n\n\t\tvar temp:ShaderRegisterElement = registerCache.getFreeFragmentVectorTemp();\n\n\t\tcode += methodVO.secondaryTextureVO._iGetFragmentCode(temp, registerCache, sharedRegisters, this._lightProjVarying) +\n\t\t\t// reencode RGBA\n\t\t\t\"dp4 \" + targetReg + \".z, \" + temp + \", \" + this._decReg + \"\\n\";\n\t\t// currentDistanceToLight - closestDistanceToLight\n\t\tcode += \"sub \" + targetReg + \".z, \" + this._lightProjVarying + \".z, \" + targetReg + \".z\\n\" +\n\t\t\t\n\t\t\t\"sub \" + targetReg + \".z, \" + this._propReg + \".x, \" + targetReg + \".z\\n\" +\n\t\t\t\"mul \" + targetReg + \".z, \" + this._propReg + \".y, \" + targetReg + \".z\\n\" +\n\t\t\t\"sat \" + targetReg + \".z, \" + targetReg + \".z\\n\" +\n\t\t\t\n\t\t\t// targetReg.x contains dot(lightDir, normal)\n\t\t\t// modulate according to incident light angle (scatter = scatter*(-.5*dot(light, normal) + .5)\n\t\t\t\"neg \" + targetReg + \".y, \" + targetReg + \".x\\n\" +\n\t\t\t\"mul \" + targetReg + \".y, \" + targetReg + \".y, \" + this._propReg + \".z\\n\" +\n\t\t\t\"add \" + targetReg + \".y, \" + targetReg + \".y, \" + this._propReg + \".z\\n\" +\n\t\t\t\"mul \" + this._targetReg + \".w, \" + targetReg + \".z, \" + targetReg + \".y\\n\" +\n\t\t\t\n\t\t\t// blend diffuse: d' = (1-s)*d + s*1\n\t\t\t\"sub \" + targetReg + \".y, \" + this._colorReg + \".w, \" + this._targetReg + \".w\\n\" +\n\t\t\t\"mul \" + targetReg + \".w, \" + targetReg + \".w, \" + targetReg + \".y\\n\";\n\t\t\n\t\treturn code;\n\t}\n}\n\nexport = DiffuseSubSurfaceMethod;",
    "import Stage\t\t\t\t\t\t\t= require(\"awayjs-stagegl/lib/base/Stage\");\n\nimport LightingShader\t\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/LightingShader\");\nimport ShaderRegisterCache\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterCache\");\nimport ShaderRegisterData\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterData\");\nimport ShaderRegisterElement\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterElement\");\n\nimport MethodVO\t\t\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/data/MethodVO\");\nimport DiffuseBasicMethod\t\t\t\t= require(\"awayjs-methodmaterials/lib/methods/DiffuseBasicMethod\");\n\n/**\n * DiffuseWrapMethod is an alternative to DiffuseBasicMethod in which the light is allowed to be \"wrapped around\" the normally dark area, to some extent.\n * It can be used as a crude approximation to Oren-Nayar or simple subsurface scattering.\n */\nclass DiffuseWrapMethod extends DiffuseBasicMethod\n{\n\tprivate _wrapDataRegister:ShaderRegisterElement;\n\tprivate _wrapFactor:number;\n\n\t/**\n\t * Creates a new DiffuseWrapMethod object.\n\t * @param wrapFactor A factor to indicate the amount by which the light is allowed to wrap\n\t */\n\tconstructor(wrapFactor:number = .5)\n\t{\n\t\tsuper();\n\n\t\tthis.wrapFactor = wrapFactor;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iCleanCompilationData()\n\t{\n\t\tsuper.iCleanCompilationData();\n\n\t\tthis._wrapDataRegister = null;\n\t}\n\n\t/**\n\t * A factor to indicate the amount by which the light is allowed to wrap.\n\t */\n\tpublic get wrapFactor():number\n\t{\n\t\treturn this._wrapFactor;\n\t}\n\n\tpublic set wrapFactor(value:number)\n\t{\n\t\tthis._wrapFactor = value;\n\t\tthis._wrapFactor = 1/(value + 1);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentPreLightingCode(shader:LightingShader, methodVO:MethodVO, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = super.iGetFragmentPreLightingCode(shader, methodVO, registerCache, sharedRegisters);\n\t\tthis._pIsFirstLight = true;\n\t\tthis._wrapDataRegister = registerCache.getFreeFragmentConstant();\n\t\tmethodVO.secondaryFragmentConstantsIndex = this._wrapDataRegister.index*4;\n\n\t\treturn code;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentCodePerLight(shader:LightingShader, methodVO:MethodVO, lightDirReg:ShaderRegisterElement, lightColReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = \"\";\n\t\tvar t:ShaderRegisterElement;\n\n\t\t// write in temporary if not first light, so we can add to total diffuse colour\n\t\tif (this._pIsFirstLight) {\n\t\t\tt = this._pTotalLightColorReg;\n\t\t} else {\n\t\t\tt = registerCache.getFreeFragmentVectorTemp();\n\t\t\tregisterCache.addFragmentTempUsages(t, 1);\n\t\t}\n\n\t\tcode += \"dp3 \" + t + \".x, \" + lightDirReg + \".xyz, \" + sharedRegisters.normalFragment + \".xyz\\n\" +\n\t\t\t\"add \" + t + \".y, \" + t + \".x, \" + this._wrapDataRegister + \".x\\n\" +\n\t\t\t\"mul \" + t + \".y, \" + t + \".y, \" + this._wrapDataRegister + \".y\\n\" +\n\t\t\t\"sat \" + t + \".w, \" + t + \".y\\n\" +\n\t\t\t\"mul \" + t + \".xz, \" + t + \".w, \" + lightDirReg + \".wz\\n\";\n\n\t\tif (this._iModulateMethod != null)\n\t\t\tcode += this._iModulateMethod(shader, methodVO, lightDirReg, registerCache, sharedRegisters);\n\n\t\tcode += \"mul \" + t + \", \" + t + \".x, \" + lightColReg + \"\\n\";\n\n\t\tif (!this._pIsFirstLight) {\n\t\t\tcode += \"add \" + this._pTotalLightColorReg + \".xyz, \" + this._pTotalLightColorReg + \".xyz, \" + t + \".xyz\\n\";\n\t\t\tregisterCache.removeFragmentTempUsage(t);\n\t\t}\n\n\t\tthis._pIsFirstLight = false;\n\n\t\treturn code;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iActivate(shader:LightingShader, methodVO:MethodVO, stage:Stage)\n\t{\n\t\tsuper.iActivate(shader, methodVO, stage);\n\n\t\tvar index:number /*int*/ = methodVO.secondaryFragmentConstantsIndex;\n\t\tvar data:Float32Array = shader.fragmentConstantData;\n\t\tdata[index] = this._wrapFactor;\n\t\tdata[index + 1] = 1/(this._wrapFactor + 1);\n\t}\n}\n\nexport = DiffuseWrapMethod;",
    "import Camera\t\t\t\t\t\t\t= require(\"awayjs-display/lib/entities/Camera\");\nimport TextureBase\t\t\t\t\t\t= require(\"awayjs-display/lib/textures/TextureBase\");\n\nimport Stage\t\t\t\t\t\t\t= require(\"awayjs-stagegl/lib/base/Stage\");\n\nimport RenderableBase\t\t\t\t\t= require(\"awayjs-renderergl/lib/renderables/RenderableBase\");\nimport LightingShader\t\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/LightingShader\");\nimport ShaderBase\t\t\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderBase\");\nimport ShaderRegisterCache\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterCache\");\nimport ShaderRegisterData\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterData\");\nimport ShaderRegisterElement\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterElement\");\n\nimport MethodVO\t\t\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/data/MethodVO\");\nimport EffectMethodBase\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/methods/EffectMethodBase\");\n\n/**\n * EffectAlphaMaskMethod allows the use of an additional texture to specify the alpha value of the material. When used\n * with the secondary uv set, it allows for a tiled main texture with independently varying alpha (useful for water\n * etc).\n */\nclass EffectAlphaMaskMethod extends EffectMethodBase\n{\n\tprivate _texture:TextureBase;\n\tprivate _useSecondaryUV:boolean;\n\n\t/**\n\t * Creates a new EffectAlphaMaskMethod object.\n\t *\n\t * @param texture The texture to use as the alpha mask.\n\t * @param useSecondaryUV Indicated whether or not the secondary uv set for the mask. This allows mapping alpha independently.\n\t */\n\tconstructor(texture:TextureBase, useSecondaryUV:boolean = false)\n\t{\n\t\tsuper();\n\n\t\tthis._texture = texture;\n\t\tthis._useSecondaryUV = useSecondaryUV;\n\n\t\tif (this._texture)\n\t\t\tthis.iAddTexture(this._texture);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitVO(shader:ShaderBase, methodVO:MethodVO)\n\t{\n\t\tmethodVO.textureVO = shader.getAbstraction(this._texture);\n\n\t\tif (this._useSecondaryUV)\n\t\t\tshader.secondaryUVDependencies++;\n\t\telse\n\t\t\tshader.uvDependencies++;\n\t}\n\n\t/**\n\t * Indicated whether or not the secondary uv set for the mask. This allows mapping alpha independently, for\n\t * instance to tile the main texture and normal map while providing untiled alpha, for example to define the\n\t * transparency over a tiled water surface.\n\t */\n\tpublic get useSecondaryUV():boolean\n\t{\n\t\treturn this._useSecondaryUV;\n\t}\n\n\tpublic set useSecondaryUV(value:boolean)\n\t{\n\t\tif (this._useSecondaryUV == value)\n\t\t\treturn;\n\n\t\tthis._useSecondaryUV = value;\n\n\t\tthis.iInvalidateShaderProgram();\n\t}\n\n\t/**\n\t * The texture to use as the alpha mask.\n\t */\n\tpublic get texture():TextureBase\n\t{\n\t\treturn this._texture;\n\t}\n\n\tpublic set texture(value:TextureBase)\n\t{\n\t\tif (this._texture == value)\n\t\t\treturn;\n\n\t\tif (this._texture)\n\t\t\tthis.iRemoveTexture(this._texture);\n\n\t\tthis._texture = value;\n\n\t\tif (this._texture)\n\t\t\tthis.iAddTexture(this._texture);\n\n\t\tthis.iInvalidateShaderProgram();\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentCode(shader:ShaderBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar temp:ShaderRegisterElement = registerCache.getFreeFragmentVectorTemp();\n\n\t\treturn methodVO.textureVO._iGetFragmentCode(temp, registerCache, sharedRegisters, this._useSecondaryUV? sharedRegisters.secondaryUVVarying : sharedRegisters.uvVarying) +\n\t\t\t\"mul \" + targetReg + \", \" + targetReg + \", \" + temp + \".x\\n\";\n\t}\n\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iActivate(shader:LightingShader, methodVO:MethodVO, stage:Stage)\n\t{\n\t\tsuper.iActivate(shader, methodVO, stage);\n\n\t\tmethodVO.textureVO.activate();\n\t}\n\n\n\tpublic iSetRenderState(shader:ShaderBase, methodVO:MethodVO, renderable:RenderableBase, stage:Stage, camera:Camera)\n\t{\n\t\tmethodVO.textureVO._setRenderState(renderable);\n\t}\n}\n\nexport = EffectAlphaMaskMethod;",
    "import Stage\t\t\t\t\t\t\t= require(\"awayjs-stagegl/lib/base/Stage\");\n\nimport ShaderBase\t\t\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderBase\");\nimport ShaderRegisterCache\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterCache\");\nimport ShaderRegisterData\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterData\");\nimport ShaderRegisterElement\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterElement\");\n\nimport MethodVO\t\t\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/data/MethodVO\");\nimport EffectMethodBase\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/methods/EffectMethodBase\");\n\n/**\n * EffectColorMatrixMethod provides a shading method that changes the colour of a material analogous to a ColorMatrixFilter.\n */\nclass EffectColorMatrixMethod extends EffectMethodBase\n{\n\tprivate _matrix:Array<number>;\n\n\t/**\n\t * Creates a new EffectColorTransformMethod.\n\t *\n\t * @param matrix An array of 20 items for 4 x 5 color transform.\n\t */\n\tconstructor(matrix:Array<number>)\n\t{\n\t\tsuper();\n\n\t\tif (matrix.length != 20)\n\t\t\tthrow new Error(\"Matrix length must be 20!\");\n\n\t\tthis._matrix = matrix;\n\t}\n\n\t/**\n\t * The 4 x 5 matrix to transform the color of the material.\n\t */\n\tpublic get colorMatrix():Array<number>\n\t{\n\t\treturn this._matrix;\n\t}\n\n\tpublic set colorMatrix(value:Array<number>)\n\t{\n\t\tthis._matrix = value;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentCode(shader:ShaderBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = \"\";\n\t\tvar colorMultReg:ShaderRegisterElement = registerCache.getFreeFragmentConstant();\n\t\tregisterCache.getFreeFragmentConstant();\n\t\tregisterCache.getFreeFragmentConstant();\n\t\tregisterCache.getFreeFragmentConstant();\n\n\t\tvar colorOffsetReg:ShaderRegisterElement = registerCache.getFreeFragmentConstant();\n\n\t\tmethodVO.fragmentConstantsIndex = colorMultReg.index*4;\n\n\t\tvar temp:ShaderRegisterElement = registerCache.getFreeFragmentVectorTemp();\n\n\t\tcode += \"m44 \" + temp + \", \" + targetReg + \", \" + colorMultReg + \"\\n\" +\n\t\t\t\t\"add \" + targetReg + \", \" + temp + \", \" + colorOffsetReg + \"\\n\";\n\n\t\treturn code;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iActivate(shader:ShaderBase, methodVO:MethodVO, stage:Stage)\n\t{\n\t\tvar matrix:Array<number> = this._matrix;\n\t\tvar index:number /*int*/ = methodVO.fragmentConstantsIndex;\n\t\tvar data:Float32Array = shader.fragmentConstantData;\n\n\t\t// r\n\t\tdata[index] = matrix[0];\n\t\tdata[index + 1] = matrix[1];\n\t\tdata[index + 2] = matrix[2];\n\t\tdata[index + 3] = matrix[3];\n\n\t\t// g\n\t\tdata[index + 4] = matrix[5];\n\t\tdata[index + 5] = matrix[6];\n\t\tdata[index + 6] = matrix[7];\n\t\tdata[index + 7] = matrix[8];\n\n\t\t// b\n\t\tdata[index + 8] = matrix[10];\n\t\tdata[index + 9] = matrix[11];\n\t\tdata[index + 10] = matrix[12];\n\t\tdata[index + 11] = matrix[13];\n\n\t\t// a\n\t\tdata[index + 12] = matrix[15];\n\t\tdata[index + 13] = matrix[16];\n\t\tdata[index + 14] = matrix[17];\n\t\tdata[index + 15] = matrix[18];\n\n\t\t// rgba offset\n\t\tdata[index + 16] = matrix[4];\n\t\tdata[index + 17] = matrix[9];\n\t\tdata[index + 18] = matrix[14];\n\t\tdata[index + 19] = matrix[19];\n\t}\n}\n\nexport = EffectColorMatrixMethod;",
    "import ColorTransform\t\t\t\t= require(\"awayjs-core/lib/geom/ColorTransform\");\n\nimport Stage\t\t\t\t\t\t= require(\"awayjs-stagegl/lib/base/Stage\");\n\nimport ShaderBase\t\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderBase\");\nimport ShaderRegisterCache\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterCache\");\nimport ShaderRegisterData\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterData\");\nimport ShaderRegisterElement\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterElement\");\n\nimport MethodVO\t\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/data/MethodVO\");\nimport EffectMethodBase\t\t\t\t= require(\"awayjs-methodmaterials/lib/methods/EffectMethodBase\");\n\n/**\n * EffectColorTransformMethod provides a shading method that changes the colour of a material analogous to a\n * ColorTransform object.\n */\nclass EffectColorTransformMethod extends EffectMethodBase\n{\n\tprivate _colorTransform:ColorTransform;\n\n\t/**\n\t * Creates a new EffectColorTransformMethod.\n\t */\n\tconstructor()\n\t{\n\t\tsuper();\n\t}\n\n\t/**\n\t * The ColorTransform object to transform the colour of the material with.\n\t */\n\tpublic get colorTransform():ColorTransform\n\t{\n\t\treturn this._colorTransform;\n\t}\n\n\tpublic set colorTransform(value:ColorTransform)\n\t{\n\t\tthis._colorTransform = value;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentCode(shader:ShaderBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = \"\";\n\t\tvar colorMultReg:ShaderRegisterElement = registerCache.getFreeFragmentConstant();\n\t\tvar colorOffsReg:ShaderRegisterElement = registerCache.getFreeFragmentConstant();\n\n\t\tmethodVO.fragmentConstantsIndex = colorMultReg.index*4;\n\n\t\t//TODO: AGAL <> GLSL\n\n\t\tcode += \"mul \" + targetReg + \", \" + targetReg + \", \" + colorMultReg + \"\\n\" + \"add \" + targetReg + \", \" + targetReg + \", \" + colorOffsReg + \"\\n\";\n\n\t\treturn code;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iActivate(shader:ShaderBase, methodVO:MethodVO, stage:Stage)\n\t{\n\t\tvar inv:number = 1/0xff;\n\t\tvar index:number = methodVO.fragmentConstantsIndex;\n\t\tvar data:Float32Array = shader.fragmentConstantData;\n\n\t\tdata[index] = this._colorTransform.redMultiplier;\n\t\tdata[index + 1] = this._colorTransform.greenMultiplier;\n\t\tdata[index + 2] = this._colorTransform.blueMultiplier;\n\t\tdata[index + 3] = this._colorTransform.alphaMultiplier;\n\t\tdata[index + 4] = this._colorTransform.redOffset*inv;\n\t\tdata[index + 5] = this._colorTransform.greenOffset*inv;\n\t\tdata[index + 6] = this._colorTransform.blueOffset*inv;\n\t\tdata[index + 7] = this._colorTransform.alphaOffset*inv;\n\n\t}\n}\n\nexport = EffectColorTransformMethod;",
    "import Camera\t\t\t\t\t\t\t= require(\"awayjs-display/lib/entities/Camera\");\nimport TextureBase\t\t\t\t\t\t= require(\"awayjs-display/lib/textures/TextureBase\");\n\nimport Stage\t\t\t\t\t\t\t= require(\"awayjs-stagegl/lib/base/Stage\");\n\nimport RenderableBase\t\t\t\t\t= require(\"awayjs-renderergl/lib/renderables/RenderableBase\");\nimport ShaderBase\t\t\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderBase\");\nimport ShaderRegisterCache\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterCache\");\nimport ShaderRegisterData\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterData\");\nimport ShaderRegisterElement\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterElement\");\n\nimport MethodVO\t\t\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/data/MethodVO\");\nimport EffectMethodBase\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/methods/EffectMethodBase\");\n\n/**\n * EffectEnvMapMethod provides a material method to perform reflection mapping using cube maps.\n */\nclass EffectEnvMapMethod extends EffectMethodBase\n{\n\tprivate _envMap:TextureBase;\n\tprivate _alpha:number;\n\tprivate _mask:TextureBase;\n\n\t/**\n\t * Creates an EffectEnvMapMethod object.\n\t * @param envMap The environment map containing the reflected scene.\n\t * @param alpha The reflectivity of the surface.\n\t */\n\tconstructor(envMap:TextureBase, alpha:number = 1)\n\t{\n\t\tsuper();\n\t\tthis._envMap = envMap;\n\t\tthis._alpha = alpha;\n\n\t\tif (this._envMap)\n\t\t\tthis.iAddTexture(this._envMap);\n\t}\n\n\t/**\n\t * An optional texture to modulate the reflectivity of the surface.\n\t */\n\tpublic get mask():TextureBase\n\t{\n\t\treturn this._mask;\n\t}\n\n\tpublic set mask(value:TextureBase)\n\t{\n\t\tif (value == this._mask)\n\t\t\treturn;\n\n\t\tif (this._mask)\n\t\t\tthis.iRemoveTexture(this._mask);\n\n\t\tthis._mask = value;\n\n\t\tif (this._mask)\n\t\t\tthis.iAddTexture(this._mask);\n\n\t\tthis.iInvalidateShaderProgram();\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitVO(shader:ShaderBase, methodVO:MethodVO)\n\t{\n\t\tmethodVO.needsNormals = true;\n\t\tmethodVO.needsView = true;\n\n\t\tif (this._envMap)\n\t\t\tmethodVO.textureVO = shader.getAbstraction(this._envMap);\n\n\t\tif (this._mask) {\n\t\t\tmethodVO.secondaryTextureVO = shader.getAbstraction(this._mask);\n\t\t\tshader.uvDependencies++;\n\t\t}\n\t}\n\n\t/**\n\t * The cubic environment map containing the reflected scene.\n\t */\n\tpublic get envMap():TextureBase\n\t{\n\t\treturn this._envMap;\n\t}\n\n\tpublic set envMap(value:TextureBase)\n\t{\n\t\tif (this._envMap == value)\n\t\t\treturn;\n\n\t\tif (this._envMap)\n\t\t\tthis.iRemoveTexture(this._envMap);\n\n\t\tthis._envMap = value;\n\n\t\tif (this._envMap)\n\t\t\tthis.iAddTexture(this._envMap);\n\n\t\tthis.iInvalidateShaderProgram();\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic dispose()\n\t{\n\t}\n\n\t/**\n\t * The reflectivity of the surface.\n\t */\n\tpublic get alpha():number\n\t{\n\t\treturn this._alpha;\n\t}\n\n\tpublic set alpha(value:number)\n\t{\n\t\tthis._alpha = value;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iActivate(shader:ShaderBase, methodVO:MethodVO, stage:Stage)\n\t{\n\t\tshader.fragmentConstantData[methodVO.fragmentConstantsIndex] = this._alpha;\n\n\t\tmethodVO.textureVO.activate();\n\n\t\tif (this._mask)\n\t\t\tmethodVO.secondaryTextureVO.activate();\n\t}\n\n\tpublic iSetRenderState(shader:ShaderBase, methodVO:MethodVO, renderable:RenderableBase, stage:Stage, camera:Camera)\n\t{\n\t\tmethodVO.textureVO._setRenderState(renderable);\n\n\t\tif (this._mask)\n\t\t\tmethodVO.secondaryTextureVO._setRenderState(renderable);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentCode(shader:ShaderBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar dataRegister:ShaderRegisterElement = registerCache.getFreeFragmentConstant();\n\t\tvar code:string = \"\";\n\n\t\tmethodVO.fragmentConstantsIndex = dataRegister.index*4;\n\n\t\tvar temp:ShaderRegisterElement = registerCache.getFreeFragmentVectorTemp();\n\t\tregisterCache.addFragmentTempUsages(temp, 1);\n\t\tvar temp2:ShaderRegisterElement = registerCache.getFreeFragmentVectorTemp();\n\t\tregisterCache.addFragmentTempUsages(temp2, 1);\n\n\t\t// r = I - 2(I.N)*N\n\t\tcode += \"dp3 \" + temp + \".w, \" + sharedRegisters.viewDirFragment + \".xyz, \" + sharedRegisters.normalFragment + \".xyz\\n\" +\n\t\t\t\"add \" + temp + \".w, \" + temp + \".w, \" + temp + \".w\\n\" +\n\t\t\t\"mul \" + temp + \".xyz, \" + sharedRegisters.normalFragment + \".xyz, \" + temp + \".w\\n\" +\n\t\t\t\"sub \" + temp + \".xyz, \" + temp + \".xyz, \" + sharedRegisters.viewDirFragment + \".xyz\\n\" +\n\t\t\tmethodVO.textureVO._iGetFragmentCode(temp, registerCache, sharedRegisters, temp) +\n\t\t\t\"sub \" + temp2 + \".w, \" + temp + \".w, fc0.x\\n\" + // -.5\n\t\t\t\"kil \" + temp2 + \".w\\n\" +\t// used for real time reflection mapping - if alpha is not 1 (mock texture) kil output\n\t\t\t\"sub \" + temp + \", \" + temp + \", \" + targetReg + \"\\n\";\n\n\t\tif (this._mask) {\n\t\t\tcode += methodVO.secondaryTextureVO._iGetFragmentCode(temp2, registerCache, sharedRegisters, sharedRegisters.uvVarying) +\n\t\t\t\t\"mul \" + temp + \", \" + temp2 + \", \" + temp + \"\\n\";\n\t\t}\n\n\t\tcode += \"mul \" + temp + \", \" + temp + \", \" + dataRegister + \".x\\n\" +\n\t\t\t\t\"add \" + targetReg + \", \" + targetReg + \", \" + temp + \"\\n\";\n\n\t\tregisterCache.removeFragmentTempUsage(temp);\n\t\tregisterCache.removeFragmentTempUsage(temp2);\n\n\t\treturn code;\n\t}\n}\n\nexport = EffectEnvMapMethod;",
    "import Stage\t\t\t\t\t\t\t= require(\"awayjs-stagegl/lib/base/Stage\");\n\nimport LightingShader\t\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/LightingShader\");\nimport ShaderBase\t\t\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderBase\");\nimport ShaderRegisterCache\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterCache\");\nimport ShaderRegisterData\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterData\");\nimport ShaderRegisterElement\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterElement\");\n\nimport MethodVO\t\t\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/data/MethodVO\");\nimport EffectMethodBase\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/methods/EffectMethodBase\");\n\n/**\n * EffectFogMethod provides a method to add distance-based fog to a material.\n */\nclass EffectFogMethod extends EffectMethodBase\n{\n\tprivate _minDistance:number = 0;\n\tprivate _maxDistance:number = 1000;\n\tprivate _fogColor:number /*uint*/;\n\tprivate _fogR:number;\n\tprivate _fogG:number;\n\tprivate _fogB:number;\n\n\t/**\n\t * Creates a new EffectFogMethod object.\n\t * @param minDistance The distance from which the fog starts appearing.\n\t * @param maxDistance The distance at which the fog is densest.\n\t * @param fogColor The colour of the fog.\n\t */\n\tconstructor(minDistance:number, maxDistance:number, fogColor:number /*uint*/ = 0x808080)\n\t{\n\t\tsuper();\n\t\tthis.minDistance = minDistance;\n\t\tthis.maxDistance = maxDistance;\n\t\tthis.fogColor = fogColor;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitVO(shader:LightingShader, methodVO:MethodVO)\n\t{\n\t\tmethodVO.needsProjection = true;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitConstants(shader:ShaderBase, methodVO:MethodVO)\n\t{\n\t\tvar data:Float32Array = shader.fragmentConstantData;\n\t\tvar index:number /*int*/ = methodVO.fragmentConstantsIndex;\n\t\tdata[index + 3] = 1;\n\t\tdata[index + 6] = 0;\n\t\tdata[index + 7] = 0;\n\t}\n\n\t/**\n\t * The distance from which the fog starts appearing.\n\t */\n\tpublic get minDistance():number\n\t{\n\t\treturn this._minDistance;\n\t}\n\n\tpublic set minDistance(value:number)\n\t{\n\t\tthis._minDistance = value;\n\t}\n\n\t/**\n\t * The distance at which the fog is densest.\n\t */\n\tpublic get maxDistance():number\n\t{\n\t\treturn this._maxDistance;\n\t}\n\n\tpublic set maxDistance(value:number)\n\t{\n\t\tthis._maxDistance = value;\n\t}\n\n\t/**\n\t * The colour of the fog.\n\t */\n\tpublic get fogColor():number /*uint*/\n\t{\n\t\treturn this._fogColor;\n\t}\n\n\tpublic set fogColor(value:number/*uint*/)\n\t{\n\t\tthis._fogColor = value;\n\t\tthis._fogR = ((value >> 16) & 0xff)/0xff;\n\t\tthis._fogG = ((value >> 8) & 0xff)/0xff;\n\t\tthis._fogB = (value & 0xff)/0xff;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iActivate(shader:ShaderBase, methodVO:MethodVO, stage:Stage)\n\t{\n\t\tvar data:Float32Array = shader.fragmentConstantData;\n\t\tvar index:number /*int*/ = methodVO.fragmentConstantsIndex;\n\t\tdata[index] = this._fogR;\n\t\tdata[index + 1] = this._fogG;\n\t\tdata[index + 2] = this._fogB;\n\t\tdata[index + 4] = this._minDistance;\n\t\tdata[index + 5] = 1/(this._maxDistance - this._minDistance);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentCode(shader:ShaderBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar fogColor:ShaderRegisterElement = registerCache.getFreeFragmentConstant();\n\t\tvar fogData:ShaderRegisterElement = registerCache.getFreeFragmentConstant();\n\t\tvar temp:ShaderRegisterElement = registerCache.getFreeFragmentVectorTemp();\n\t\tregisterCache.addFragmentTempUsages(temp, 1);\n\t\tvar temp2:ShaderRegisterElement = registerCache.getFreeFragmentVectorTemp();\n\t\tvar code:string = \"\";\n\t\tmethodVO.fragmentConstantsIndex = fogColor.index*4;\n\n\t\tcode += \"sub \" + temp2 + \".w, \" + sharedRegisters.projectionFragment + \".z, \" + fogData + \".x\\n\" +\n\t\t\t\t\"mul \" + temp2 + \".w, \" + temp2 + \".w, \" + fogData + \".y\\n\" +\n\t\t\t\t\"sat \" + temp2 + \".w, \" + temp2 + \".w\\n\" +\n\t\t\t\t\"sub \" + temp + \", \" + fogColor + \", \" + targetReg + \"\\n\" + // (fogColor- col)\n\t\t\t\t\"mul \" + temp + \", \" + temp + \", \" + temp2 + \".w\\n\" + // (fogColor- col)*fogRatio\n\t\t\t\t\"add \" + targetReg + \", \" + targetReg + \", \" + temp + \"\\n\"; // fogRatio*(fogColor- col) + col\n\n\t\tregisterCache.removeFragmentTempUsage(temp);\n\n\t\treturn code;\n\t}\n}\n\nexport = EffectFogMethod;",
    "import Camera\t\t\t\t\t\t\t= require(\"awayjs-display/lib/entities/Camera\");\nimport TextureBase\t\t\t\t\t\t= require(\"awayjs-display/lib/textures/TextureBase\");\n\nimport Stage\t\t\t\t\t\t\t= require(\"awayjs-stagegl/lib/base/Stage\");\n\nimport RenderableBase\t\t\t\t\t= require(\"awayjs-renderergl/lib/renderables/RenderableBase\");\nimport ShaderBase\t\t\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderBase\");\nimport ShaderRegisterCache\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterCache\");\nimport ShaderRegisterData\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterData\");\nimport ShaderRegisterElement\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterElement\");\n\nimport MethodVO\t\t\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/data/MethodVO\");\nimport EffectMethodBase\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/methods/EffectMethodBase\");\n\n/**\n * EffectFresnelEnvMapMethod provides a method to add fresnel-based reflectivity to an object using cube maps, which gets\n * stronger as the viewing angle becomes more grazing.\n */\nclass EffectFresnelEnvMapMethod extends EffectMethodBase\n{\n\tprivate _envMap:TextureBase;\n\tprivate _fresnelPower:number = 5;\n\tprivate _normalReflectance:number = 0;\n\tprivate _alpha:number;\n\tprivate _mask:TextureBase;\n\n\t/**\n\t * Creates a new <code>EffectFresnelEnvMapMethod</code> object.\n\t *\n\t * @param envMap The environment map containing the reflected scene.\n\t * @param alpha The reflectivity of the material.\n\t */\n\tconstructor(envMap:TextureBase, alpha:number = 1)\n\t{\n\t\tsuper();\n\n\t\tthis._envMap = envMap;\n\t\tthis._alpha = alpha;\n\n\t\tif (this._envMap)\n\t\t\tthis.iAddTexture(this._envMap);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitVO(shader:ShaderBase, methodVO:MethodVO)\n\t{\n\t\tmethodVO.needsNormals = true;\n\t\tmethodVO.needsView = true;\n\n\t\tmethodVO.textureVO = shader.getAbstraction(this._envMap);\n\n\t\tif (this._mask != null) {\n\t\t\tmethodVO.secondaryTextureVO = shader.getAbstraction(this._mask);\n\t\t\tshader.uvDependencies++;\n\t\t}\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitConstants(shader:ShaderBase, methodVO:MethodVO)\n\t{\n\t\tshader.fragmentConstantData[methodVO.fragmentConstantsIndex + 3] = 1;\n\t}\n\n\t/**\n\t * An optional texture to modulate the reflectivity of the surface.\n\t */\n\tpublic get mask():TextureBase\n\t{\n\t\treturn this._mask;\n\t}\n\n\tpublic set mask(value:TextureBase)\n\t{\n\t\tif (this._mask == value)\n\t\t\treturn;\n\n\t\tif (this._mask)\n\t\t\tthis.iRemoveTexture(this._mask);\n\n\t\tthis._mask = value;\n\n\t\tif (this._mask)\n\t\t\tthis.iAddTexture(this._mask);\n\n\t\tthis.iInvalidateShaderProgram();\n\t}\n\n\t/**\n\t * The power used in the Fresnel equation. Higher values make the fresnel effect more pronounced. Defaults to 5.\n\t */\n\tpublic get fresnelPower():number\n\t{\n\t\treturn this._fresnelPower;\n\t}\n\n\tpublic set fresnelPower(value:number)\n\t{\n\t\tthis._fresnelPower = value;\n\t}\n\n\t/**\n\t * The cubic environment map containing the reflected scene.\n\t */\n\tpublic get envMap():TextureBase\n\t{\n\t\treturn this._envMap;\n\t}\n\n\tpublic set envMap(value:TextureBase)\n\t{\n\t\tif (this._envMap == value)\n\t\t\treturn;\n\n\t\tif (this._envMap)\n\t\t\tthis.iRemoveTexture(this._envMap);\n\n\t\tthis._envMap = value;\n\n\t\tif (this._envMap)\n\t\t\tthis.iAddTexture(this._envMap);\n\t}\n\n\t/**\n\t * The reflectivity of the surface.\n\t */\n\tpublic get alpha():number\n\t{\n\t\treturn this._alpha;\n\t}\n\n\tpublic set alpha(value:number)\n\t{\n\t\tthis._alpha = value;\n\t}\n\n\t/**\n\t * The minimum amount of reflectance, ie the reflectance when the view direction is normal to the surface or light direction.\n\t */\n\tpublic get normalReflectance():number\n\t{\n\t\treturn this._normalReflectance;\n\t}\n\n\tpublic set normalReflectance(value:number)\n\t{\n\t\tthis._normalReflectance = value;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iActivate(shader:ShaderBase, methodVO:MethodVO, stage:Stage)\n\t{\n\t\tvar data:Float32Array = shader.fragmentConstantData;\n\t\tvar index:number /*int*/ = methodVO.fragmentConstantsIndex;\n\t\tdata[index] = this._alpha;\n\t\tdata[index + 1] = this._normalReflectance;\n\t\tdata[index + 2] = this._fresnelPower;\n\n\t\tmethodVO.textureVO.activate();\n\n\t\tif (this._mask)\n\t\t\tmethodVO.secondaryTextureVO.activate();\n\t}\n\n\tpublic iSetRenderState(shader:ShaderBase, methodVO:MethodVO, renderable:RenderableBase, stage:Stage, camera:Camera)\n\t{\n\t\tmethodVO.textureVO._setRenderState(renderable);\n\n\t\tif (this._mask)\n\t\t\tmethodVO.secondaryTextureVO._setRenderState(renderable);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentCode(shader:ShaderBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar dataRegister:ShaderRegisterElement = registerCache.getFreeFragmentConstant();\n\t\tvar code:string = \"\";\n\t\tvar viewDirReg:ShaderRegisterElement = sharedRegisters.viewDirFragment;\n\t\tvar normalReg:ShaderRegisterElement = sharedRegisters.normalFragment;\n\n\t\tmethodVO.fragmentConstantsIndex = dataRegister.index*4;\n\n\t\tvar temp:ShaderRegisterElement = registerCache.getFreeFragmentVectorTemp();\n\t\tregisterCache.addFragmentTempUsages(temp, 1);\n\t\tvar temp2:ShaderRegisterElement = registerCache.getFreeFragmentVectorTemp();\n\t\tregisterCache.addFragmentTempUsages(temp2, 1);\n\n\t\t// r = V - 2(V.N)*N\n\t\tcode += \"dp3 \" + temp + \".w, \" + viewDirReg + \".xyz, \" + normalReg + \".xyz\\n\" +\n\t\t\t\t\"add \" + temp + \".w, \" + temp + \".w, \" + temp + \".w\\n\" +\n\t\t\t\t\"mul \" + temp + \".xyz, \" + normalReg + \".xyz, \" + temp + \".w\\n\" +\n\t\t\t\t\"sub \" + temp + \".xyz, \" + temp + \".xyz, \" + viewDirReg + \".xyz\\n\" +\n\t\t\tmethodVO.textureVO._iGetFragmentCode(temp, registerCache, sharedRegisters, temp) +\n\t\t\t\t\"sub \" + temp2 + \".w, \" + temp + \".w, fc0.x\\n\" +               \t// -.5\n\t\t\t\t\"kil \" + temp2 + \".w\\n\" +\t// used for real time reflection mapping - if alpha is not 1 (mock texture) kil output\n\t\t\t\t\"sub \" + temp + \", \" + temp + \", \" + targetReg + \"\\n\";\n\n\t\t// calculate fresnel term\n\t\tcode += \"dp3 \" + viewDirReg + \".w, \" + viewDirReg + \".xyz, \" + normalReg + \".xyz\\n\" +  // dot(V, H)\n\t\t\t\t\"sub \" + viewDirReg + \".w, \" + dataRegister + \".w, \" + viewDirReg + \".w\\n\" +       // base = 1-dot(V, H)\n\t\t\t\t\"pow \" + viewDirReg + \".w, \" + viewDirReg + \".w, \" + dataRegister + \".z\\n\" +       // exp = pow(base, 5)\n\t\t\t\t\"sub \" + normalReg + \".w, \" + dataRegister + \".w, \" + viewDirReg + \".w\\n\" +        // 1 - exp\n\t\t\t\t\"mul \" + normalReg + \".w, \" + dataRegister + \".y, \" + normalReg + \".w\\n\" +         // f0*(1 - exp)\n\t\t\t\t\"add \" + viewDirReg + \".w, \" + viewDirReg + \".w, \" + normalReg + \".w\\n\" +          // exp + f0*(1 - exp)\n\n\t\t\t\t// total alpha\n\t\t\t\t\"mul \" + viewDirReg + \".w, \" + dataRegister + \".x, \" + viewDirReg + \".w\\n\";\n\n\t\tif (this._mask) {\n\t\t\tcode += methodVO.secondaryTextureVO._iGetFragmentCode(temp2, registerCache, sharedRegisters, sharedRegisters.uvVarying) +\n\t\t\t\t\"mul \" + viewDirReg + \".w, \" + temp2 + \".x, \" + viewDirReg + \".w\\n\";\n\t\t}\n\n\t\t// blend\n\t\tcode += \"mul \" + temp + \", \" + temp + \", \" + viewDirReg + \".w\\n\" +\n\t\t\t\t\"add \" + targetReg + \", \" + targetReg + \", \" + temp + \"\\n\";\n\n\t\tregisterCache.removeFragmentTempUsage(temp);\n\t\tregisterCache.removeFragmentTempUsage(temp2);\n\n\t\treturn code;\n\t}\n}\n\nexport = EffectFresnelEnvMapMethod;",
    "import Camera\t\t\t\t\t\t\t= require(\"awayjs-display/lib/entities/Camera\");\nimport TextureBase\t\t\t\t\t\t= require(\"awayjs-display/lib/textures/TextureBase\");\n\nimport Stage\t\t\t\t\t\t\t= require(\"awayjs-stagegl/lib/base/Stage\");\n\nimport RenderableBase\t\t\t\t\t= require(\"awayjs-renderergl/lib/renderables/RenderableBase\");\nimport ShaderBase\t\t\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderBase\");\nimport ShaderRegisterCache\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterCache\");\nimport ShaderRegisterData\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterData\");\nimport ShaderRegisterElement\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterElement\");\n\nimport MethodVO\t\t\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/data/MethodVO\");\nimport EffectMethodBase\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/methods/EffectMethodBase\");\n\n/**\n * EffectLightMapMethod provides a method that allows applying a light map texture to the calculated pixel colour.\n * It is different from DiffuseLightMapMethod in that the latter only modulates the diffuse shading value rather\n * than the whole pixel colour.\n */\nclass EffectLightMapMethod extends EffectMethodBase\n{\n\t/**\n\t * Indicates the light map should be multiplied with the calculated shading result.\n\t */\n\tpublic static MULTIPLY:string = \"multiply\";\n\n\t/**\n\t * Indicates the light map should be added into the calculated shading result.\n\t */\n\tpublic static ADD:string = \"add\";\n\n\tprivate _lightMap:TextureBase;\n\n\tprivate _blendMode:string;\n\tprivate _useSecondaryUV:boolean;\n\n\t/**\n\t * Creates a new EffectLightMapMethod object.\n\t *\n\t * @param lightMap The texture containing the light map.\n\t * @param blendMode The blend mode with which the light map should be applied to the lighting result.\n\t * @param useSecondaryUV Indicates whether the secondary UV set should be used to map the light map.\n\t */\n\tconstructor(lightMap:TextureBase, blendMode:string = \"multiply\", useSecondaryUV:boolean = false)\n\t{\n\t\tsuper();\n\n\t\tif (blendMode != EffectLightMapMethod.ADD && blendMode != EffectLightMapMethod.MULTIPLY)\n\t\t\tthrow new Error(\"Unknown blendmode!\");\n\n\t\tthis._lightMap = lightMap;\n\t\tthis._blendMode = blendMode;\n\t\tthis._useSecondaryUV = useSecondaryUV;\n\n\t\tif (this._lightMap)\n\t\t\tthis.iAddTexture(this._lightMap);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitVO(shader:ShaderBase, methodVO:MethodVO)\n\t{\n\t\tmethodVO.textureVO = shader.getAbstraction(this._lightMap);\n\n\t\tif (this._useSecondaryUV)\n\t\t\tshader.secondaryUVDependencies++;\n\t\telse\n\t\t\tshader.uvDependencies++;\n\t}\n\n\t/**\n\t * The blend mode with which the light map should be applied to the lighting result.\n\t *\n\t * @see EffectLightMapMethod.ADD\n\t * @see EffectLightMapMethod.MULTIPLY\n\t */\n\tpublic get blendMode():string\n\t{\n\t\treturn this._blendMode;\n\t}\n\n\tpublic set blendMode(value:string)\n\t{\n\t\tif (this._blendMode == value)\n\t\t\treturn;\n\n\t\tif (value != EffectLightMapMethod.ADD && value != EffectLightMapMethod.MULTIPLY)\n\t\t\tthrow new Error(\"Unknown blendmode!\");\n\n\t\tthis._blendMode = value;\n\n\t\tthis.iInvalidateShaderProgram();\n\t}\n\n\t/**\n\t * The lightMap containing the light map.\n\t */\n\tpublic get lightMap():TextureBase\n\t{\n\t\treturn this._lightMap;\n\t}\n\n\tpublic set lightMap(value:TextureBase)\n\t{\n\t\tif (this._lightMap == value)\n\t\t\treturn;\n\n\t\tif (this._lightMap)\n\t\t\tthis.iRemoveTexture(this._lightMap);\n\n\t\tthis._lightMap = value;\n\n\t\tif (this._lightMap)\n\t\t\tthis.iAddTexture(this._lightMap);\n\n\t\tthis.iInvalidateShaderProgram();\n\t}\n\n\t/**\n\t * Indicates whether the secondary UV set should be used to map the light map.\n\t */\n\tpublic get useSecondaryUV():boolean\n\t{\n\t\treturn this._useSecondaryUV;\n\t}\n\n\tpublic set useSecondaryUV(value:boolean)\n\t{\n\t\tif (this._useSecondaryUV == value)\n\t\t\treturn;\n\n\t\tthis._useSecondaryUV = value;\n\n\t\tthis.iInvalidateShaderProgram();\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentCode(shader:ShaderBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string;\n\t\tvar temp:ShaderRegisterElement = registerCache.getFreeFragmentVectorTemp();\n\n\t\tcode = methodVO.secondaryTextureVO._iGetFragmentCode(temp, registerCache, sharedRegisters, this._useSecondaryUV? sharedRegisters.secondaryUVVarying : sharedRegisters.uvVarying);\n\n\t\tswitch (this._blendMode) {\n\t\t\tcase EffectLightMapMethod.MULTIPLY:\n\t\t\t\tcode += \"mul \" + targetReg + \", \" + targetReg + \", \" + temp + \"\\n\";\n\t\t\t\tbreak;\n\t\t\tcase EffectLightMapMethod.ADD:\n\t\t\t\tcode += \"add \" + targetReg + \", \" + targetReg + \", \" + temp + \"\\n\";\n\t\t\t\tbreak;\n\t\t}\n\n\t\treturn code;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iActivate(shader:ShaderBase, methodVO:MethodVO, stage:Stage)\n\t{\n\t\tmethodVO.textureVO.activate();\n\t}\n\n\n\tpublic iSetRenderState(shader:ShaderBase, methodVO:MethodVO, renderable:RenderableBase, stage:Stage, camera:Camera)\n\t{\n\t\tmethodVO.textureVO._setRenderState(renderable);\n\t}\n}\n\nexport = EffectLightMapMethod;",
    "import IAsset\t\t\t\t\t\t= require(\"awayjs-core/lib/library/IAsset\");\nimport AbstractMethodError\t\t\t= require(\"awayjs-core/lib/errors/AbstractMethodError\");\n\nimport ShaderBase\t\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderBase\");\nimport ShaderRegisterCache\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterCache\");\nimport ShaderRegisterData\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterData\");\nimport ShaderRegisterElement\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterElement\");\n\nimport MethodVO\t\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/data/MethodVO\");\nimport ShadingMethodBase\t\t\t= require(\"awayjs-methodmaterials/lib/methods/ShadingMethodBase\");\n\n/**\n * EffectMethodBase forms an abstract base class for shader methods that are not dependent on light sources,\n * and are in essence post-process effects on the materials.\n */\nclass EffectMethodBase extends ShadingMethodBase implements IAsset\n{\n\tpublic static assetType:string = \"[asset EffectMethod]\";\n\n\tconstructor()\n\t{\n\t\tsuper();\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic get assetType():string\n\t{\n\t\treturn EffectMethodBase.assetType;\n\t}\n\n\t/**\n\t * Get the fragment shader code that should be added after all per-light code. Usually composits everything to the target register.\n\t * @param methodVO The MethodVO object containing the method data for the currently compiled material pass.\n\t * @param regCache The register cache used during the compilation.\n\t * @param targetReg The register that will be containing the method's output.\n\t * @private\n\t */\n\tpublic iGetFragmentCode(shader:ShaderBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tthrow new AbstractMethodError();\n\t\treturn \"\";\n\t}\n}\n\nexport = EffectMethodBase;",
    "import Camera\t\t\t\t\t\t\t= require(\"awayjs-display/lib/entities/Camera\");\nimport TextureBase\t\t\t\t\t\t= require(\"awayjs-display/lib/textures/TextureBase\");\n\nimport Stage\t\t\t\t\t\t\t= require(\"awayjs-stagegl/lib/base/Stage\");\n\nimport RenderableBase\t\t\t\t\t= require(\"awayjs-renderergl/lib/renderables/RenderableBase\");\nimport ShaderBase\t\t\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderBase\");\nimport ShaderRegisterCache\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterCache\");\nimport ShaderRegisterData\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterData\");\nimport ShaderRegisterElement\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterElement\");\n\nimport MethodVO\t\t\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/data/MethodVO\");\nimport EffectMethodBase\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/methods/EffectMethodBase\");\n\n/**\n * EffectRefractionEnvMapMethod provides a method to add refracted transparency based on cube maps.\n */\nclass EffectRefractionEnvMapMethod extends EffectMethodBase\n{\n\tprivate _envMap:TextureBase;\n\n\tprivate _dispersionR:number = 0;\n\tprivate _dispersionG:number = 0;\n\tprivate _dispersionB:number = 0;\n\tprivate _useDispersion:boolean;\n\tprivate _refractionIndex:number;\n\tprivate _alpha:number = 1;\n\n\t/**\n\t * Creates a new EffectRefractionEnvMapMethod object. Example values for dispersion are: dispersionR: -0.03, dispersionG: -0.01, dispersionB: = .0015\n\t *\n\t * @param envMap The environment map containing the refracted scene.\n\t * @param refractionIndex The refractive index of the material.\n\t * @param dispersionR The amount of chromatic dispersion of the red channel. Defaults to 0 (none).\n\t * @param dispersionG The amount of chromatic dispersion of the green channel. Defaults to 0 (none).\n\t * @param dispersionB The amount of chromatic dispersion of the blue channel. Defaults to 0 (none).\n\t */\n\tconstructor(envMap:TextureBase, refractionIndex:number = .1, dispersionR:number = 0, dispersionG:number = 0, dispersionB:number = 0)\n\t{\n\t\tsuper();\n\t\tthis._envMap = envMap;\n\t\tthis._dispersionR = dispersionR;\n\t\tthis._dispersionG = dispersionG;\n\t\tthis._dispersionB = dispersionB;\n\t\tthis._useDispersion = !(this._dispersionR == this._dispersionB && this._dispersionR == this._dispersionG);\n\t\tthis._refractionIndex = refractionIndex;\n\n\t\tif (this._envMap)\n\t\t\tthis.iAddTexture(this._envMap);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitConstants(shader:ShaderBase, methodVO:MethodVO)\n\t{\n\t\tvar index:number /*int*/ = methodVO.fragmentConstantsIndex;\n\t\tvar data:Float32Array = shader.fragmentConstantData;\n\t\tdata[index + 4] = 1;\n\t\tdata[index + 5] = 0;\n\t\tdata[index + 7] = 1;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitVO(shader:ShaderBase, methodVO:MethodVO)\n\t{\n\t\tmethodVO.needsNormals = true;\n\t\tmethodVO.needsView = true;\n\n\t\tmethodVO.textureVO = shader.getAbstraction(this._envMap);\n\t}\n\n\t/**\n\t * The cube environment map to use for the refraction.\n\t */\n\tpublic get envMap():TextureBase\n\t{\n\t\treturn this._envMap;\n\t}\n\n\tpublic set envMap(value:TextureBase)\n\t{\n\t\tif (this._envMap == value)\n\t\t\treturn;\n\n\t\tif (this._envMap)\n\t\t\tthis.iRemoveTexture(this._envMap);\n\n\t\tthis._envMap = value;\n\n\t\tif (this._envMap)\n\t\t\tthis.iAddTexture(this._envMap);\n\t}\n\n\t/**\n\t * The refractive index of the material.\n\t */\n\tpublic get refractionIndex():number\n\t{\n\t\treturn this._refractionIndex;\n\t}\n\n\tpublic set refractionIndex(value:number)\n\t{\n\t\tthis._refractionIndex = value;\n\t}\n\n\t/**\n\t * The amount of chromatic dispersion of the red channel. Defaults to 0 (none).\n\t */\n\tpublic get dispersionR():number\n\t{\n\t\treturn this._dispersionR;\n\t}\n\n\tpublic set dispersionR(value:number)\n\t{\n\t\tthis._dispersionR = value;\n\n\t\tvar useDispersion:boolean = !(this._dispersionR == this._dispersionB && this._dispersionR == this._dispersionG);\n\t\tif (this._useDispersion != useDispersion) {\n\t\t\tthis.iInvalidateShaderProgram();\n\t\t\tthis._useDispersion = useDispersion;\n\t\t}\n\t}\n\n\t/**\n\t * The amount of chromatic dispersion of the green channel. Defaults to 0 (none).\n\t */\n\tpublic get dispersionG():number\n\t{\n\t\treturn this._dispersionG;\n\t}\n\n\tpublic set dispersionG(value:number)\n\t{\n\t\tthis._dispersionG = value;\n\n\t\tvar useDispersion:boolean = !(this._dispersionR == this._dispersionB && this._dispersionR == this._dispersionG);\n\t\tif (this._useDispersion != useDispersion) {\n\t\t\tthis.iInvalidateShaderProgram();\n\t\t\tthis._useDispersion = useDispersion;\n\t\t}\n\t}\n\n\t/**\n\t * The amount of chromatic dispersion of the blue channel. Defaults to 0 (none).\n\t */\n\tpublic get dispersionB():number\n\t{\n\t\treturn this._dispersionB;\n\t}\n\n\tpublic set dispersionB(value:number)\n\t{\n\t\tthis._dispersionB = value;\n\n\t\tvar useDispersion:boolean = !(this._dispersionR == this._dispersionB && this._dispersionR == this._dispersionG);\n\t\tif (this._useDispersion != useDispersion) {\n\t\t\tthis.iInvalidateShaderProgram();\n\t\t\tthis._useDispersion = useDispersion;\n\t\t}\n\t}\n\n\t/**\n\t * The amount of transparency of the object. Warning: the alpha applies to the refracted color, not the actual\n\t * material. A value of 1 will make it appear fully transparent.\n\t */\n\tpublic get alpha():number\n\t{\n\t\treturn this._alpha;\n\t}\n\n\tpublic set alpha(value:number)\n\t{\n\t\tthis._alpha = value;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iActivate(shader:ShaderBase, methodVO:MethodVO, stage:Stage)\n\t{\n\t\tvar index:number /*int*/ = methodVO.fragmentConstantsIndex;\n\t\tvar data:Float32Array = shader.fragmentConstantData;\n\n\t\tdata[index] = this._dispersionR + this._refractionIndex;\n\n\t\tif (this._useDispersion) {\n\t\t\tdata[index + 1] = this._dispersionG + this._refractionIndex;\n\t\t\tdata[index + 2] = this._dispersionB + this._refractionIndex;\n\t\t}\n\t\tdata[index + 3] = this._alpha;\n\n\t\tmethodVO.textureVO.activate();\n\t}\n\n\tpublic iSetRenderState(shader:ShaderBase, methodVO:MethodVO, renderable:RenderableBase, stage:Stage, camera:Camera)\n\t{\n\t\tmethodVO.textureVO._setRenderState(renderable);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentCode(shader:ShaderBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\t// todo: data2.x could use common reg, so only 1 reg is used\n\t\tvar data:ShaderRegisterElement = registerCache.getFreeFragmentConstant();\n\t\tvar data2:ShaderRegisterElement = registerCache.getFreeFragmentConstant();\n\t\tvar code:string = \"\";\n\t\tvar refractionDir:ShaderRegisterElement;\n\t\tvar refractionColor:ShaderRegisterElement;\n\t\tvar temp:ShaderRegisterElement;\n\n\t\tmethodVO.fragmentConstantsIndex = data.index*4;\n\n\t\trefractionDir = registerCache.getFreeFragmentVectorTemp();\n\t\tregisterCache.addFragmentTempUsages(refractionDir, 1);\n\t\trefractionColor = registerCache.getFreeFragmentVectorTemp();\n\t\tregisterCache.addFragmentTempUsages(refractionColor, 1);\n\t\ttemp = registerCache.getFreeFragmentVectorTemp();\n\t\tregisterCache.addFragmentTempUsages(temp, 1);\n\n\t\tvar viewDirReg:ShaderRegisterElement = sharedRegisters.viewDirFragment;\n\t\tvar normalReg:ShaderRegisterElement = sharedRegisters.normalFragment;\n\n\t\tcode += \"neg \" + viewDirReg + \".xyz, \" + viewDirReg + \".xyz\\n\";\n\n\t\tcode += \"dp3 \" + temp + \".x, \" + viewDirReg + \".xyz, \" + normalReg + \".xyz\\n\" +\n\t\t\t\"mul \" + temp + \".w, \" + temp + \".x, \" + temp + \".x\\n\" +\n\t\t\t\"sub \" + temp + \".w, \" + data2 + \".x, \" + temp + \".w\\n\" +\n\t\t\t\"mul \" + temp + \".w, \" + data + \".x, \" + temp + \".w\\n\" +\n\t\t\t\"mul \" + temp + \".w, \" + data + \".x, \" + temp + \".w\\n\" +\n\t\t\t\"sub \" + temp + \".w, \" + data2 + \".x, \" + temp + \".w\\n\" +\n\t\t\t\"sqt \" + temp + \".y, \" + temp + \".w\\n\" +\n\n\t\t\t\"mul \" + temp + \".x, \" + data + \".x, \" + temp + \".x\\n\" +\n\t\t\t\"add \" + temp + \".x, \" + temp + \".x, \" + temp + \".y\\n\" +\n\t\t\t\"mul \" + temp + \".xyz, \" + temp + \".x, \" + normalReg + \".xyz\\n\" +\n\n\t\t\t\"mul \" + refractionDir + \", \" + data + \".x, \" + viewDirReg + \"\\n\" +\n\t\t\t\"sub \" + refractionDir + \".xyz, \" + refractionDir + \".xyz, \" + temp + \".xyz\\n\" +\n\t\t\t\"nrm \" + refractionDir + \".xyz, \" + refractionDir + \".xyz\\n\" +\n\t\tmethodVO.textureVO._iGetFragmentCode(refractionColor, registerCache, sharedRegisters, refractionDir) +\n\t\t\t\"sub \" + refractionColor + \".w, \" + refractionColor + \".w, fc0.x\t\\n\" +\n\t\t\t\"kil \" + refractionColor + \".w\\n\";\n\n\t\tif (this._useDispersion) {\n\t\t\t// GREEN\n\t\t\tcode += \"dp3 \" + temp + \".x, \" + viewDirReg + \".xyz, \" + normalReg + \".xyz\\n\" +\n\t\t\t\t\"mul \" + temp + \".w, \" + temp + \".x, \" + temp + \".x\\n\" +\n\t\t\t\t\"sub \" + temp + \".w, \" + data2 + \".x, \" + temp + \".w\\n\" +\n\t\t\t\t\"mul \" + temp + \".w, \" + data + \".y, \" + temp + \".w\\n\" +\n\t\t\t\t\"mul \" + temp + \".w, \" + data + \".y, \" + temp + \".w\\n\" +\n\t\t\t\t\"sub \" + temp + \".w, \" + data2 + \".x, \" + temp + \".w\\n\" +\n\t\t\t\t\"sqt \" + temp + \".y, \" + temp + \".w\\n\" +\n\n\t\t\t\t\"mul \" + temp + \".x, \" + data + \".y, \" + temp + \".x\\n\" +\n\t\t\t\t\"add \" + temp + \".x, \" + temp + \".x, \" + temp + \".y\\n\" +\n\t\t\t\t\"mul \" + temp + \".xyz, \" + temp + \".x, \" + normalReg + \".xyz\\n\" +\n\n\t\t\t\t\"mul \" + refractionDir + \", \" + data + \".y, \" + viewDirReg + \"\\n\" +\n\t\t\t\t\"sub \" + refractionDir + \".xyz, \" + refractionDir + \".xyz, \" + temp + \".xyz\\n\" +\n\t\t\t\t\"nrm \" + refractionDir + \".xyz, \" + refractionDir + \".xyz\\n\" +\n\t\t\tmethodVO.textureVO._iGetFragmentCode(temp, registerCache, sharedRegisters, refractionDir) +\n\t\t\t\t\"mov \" + refractionColor + \".y, \" + temp + \".y\\n\";\n\n\t\t\t// BLUE\n\t\t\tcode += \"dp3 \" + temp + \".x, \" + viewDirReg + \".xyz, \" + normalReg + \".xyz\\n\" +\n\t\t\t\t\"mul \" + temp + \".w, \" + temp + \".x, \" + temp + \".x\\n\" +\n\t\t\t\t\"sub \" + temp + \".w, \" + data2 + \".x, \" + temp + \".w\\n\" +\n\t\t\t\t\"mul \" + temp + \".w, \" + data + \".z, \" + temp + \".w\\n\" +\n\t\t\t\t\"mul \" + temp + \".w, \" + data + \".z, \" + temp + \".w\\n\" +\n\t\t\t\t\"sub \" + temp + \".w, \" + data2 + \".x, \" + temp + \".w\\n\" +\n\t\t\t\t\"sqt \" + temp + \".y, \" + temp + \".w\\n\" +\n\n\t\t\t\t\"mul \" + temp + \".x, \" + data + \".z, \" + temp + \".x\\n\" +\n\t\t\t\t\"add \" + temp + \".x, \" + temp + \".x, \" + temp + \".y\\n\" +\n\t\t\t\t\"mul \" + temp + \".xyz, \" + temp + \".x, \" + normalReg + \".xyz\\n\" +\n\n\t\t\t\t\"mul \" + refractionDir + \", \" + data + \".z, \" + viewDirReg + \"\\n\" +\n\t\t\t\t\"sub \" + refractionDir + \".xyz, \" + refractionDir + \".xyz, \" + temp + \".xyz\\n\" +\n\t\t\t\t\"nrm \" + refractionDir + \".xyz, \" + refractionDir + \".xyz\\n\" +\n\t\t\tmethodVO.textureVO._iGetFragmentCode(temp, registerCache, sharedRegisters, refractionDir) +\n\t\t\t\t\"mov \" + refractionColor + \".z, \" + temp + \".z\\n\";\n\t\t}\n\n\t\tcode += \"sub \" + refractionColor + \".xyz, \" + refractionColor + \".xyz, \" + targetReg + \".xyz\\n\" +\n\t\t\t\"mul \" + refractionColor + \".xyz, \" + refractionColor + \".xyz, \" + data + \".w\\n\" +\n\t\t\t\"add \" + targetReg + \".xyz, \" + targetReg + \".xyz, \" + refractionColor + \".xyz\\n\";\n\n\t\tregisterCache.removeFragmentTempUsage(temp);\n\t\tregisterCache.removeFragmentTempUsage(refractionDir);\n\t\tregisterCache.removeFragmentTempUsage(refractionColor);\n\n\t\t// restore\n\t\tcode += \"neg \" + viewDirReg + \".xyz, \" + viewDirReg + \".xyz\\n\";\n\n\t\treturn code;\n\t}\n}\n\nexport = EffectRefractionEnvMapMethod;",
    "import Stage\t\t\t\t\t\t\t= require(\"awayjs-stagegl/lib/base/Stage\");\n\nimport ShaderBase\t\t\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderBase\");\nimport ShaderRegisterCache\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterCache\");\nimport ShaderRegisterData\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterData\");\nimport ShaderRegisterElement\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterElement\");\n\nimport MethodVO\t\t\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/data/MethodVO\");\nimport EffectMethodBase\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/methods/EffectMethodBase\");\n\n/**\n * EffectRimLightMethod provides a method to add rim lighting to a material. This adds a glow-like effect to edges of objects.\n */\nclass EffectRimLightMethod extends EffectMethodBase\n{\n\tpublic static ADD:string = \"add\";\n\tpublic static MULTIPLY:string = \"multiply\";\n\tpublic static MIX:string = \"mix\";\n\n\tprivate _color:number /*uint*/;\n\tprivate _blendMode:string;\n\tprivate _colorR:number;\n\tprivate _colorG:number;\n\tprivate _colorB:number;\n\tprivate _strength:number;\n\tprivate _power:number;\n\n\t/**\n\t * Creates a new <code>EffectRimLightMethod</code> object.\n\t *\n\t * @param color The colour of the rim light.\n\t * @param strength The strength of the rim light.\n\t * @param power The power of the rim light. Higher values will result in a higher edge fall-off.\n\t * @param blend The blend mode with which to add the light to the object.\n\t */\n\tconstructor(color:number /*uint*/ = 0xffffff, strength:number = .4, power:number = 2, blend:string = \"mix\")\n\t{\n\t\tsuper();\n\n\t\tthis._blendMode = blend;\n\t\tthis._strength = strength;\n\t\tthis._power = power;\n\n\t\tthis.color = color;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitConstants(shader:ShaderBase, methodVO:MethodVO)\n\t{\n\t\tshader.fragmentConstantData[methodVO.fragmentConstantsIndex + 3] = 1;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitVO(shader:ShaderBase, methodVO:MethodVO)\n\t{\n\t\tmethodVO.needsNormals = true;\n\t\tmethodVO.needsView = true;\n\t}\n\n\n\t/**\n\t * The blend mode with which to add the light to the object.\n\t *\n\t * EffectRimLightMethod.MULTIPLY multiplies the rim light with the material's colour.\n\t * EffectRimLightMethod.ADD adds the rim light with the material's colour.\n\t * EffectRimLightMethod.MIX provides normal alpha blending.\n\t */\n\tpublic get blendMode():string\n\t{\n\t\treturn this._blendMode;\n\t}\n\n\tpublic set blendMode(value:string)\n\t{\n\t\tif (this._blendMode == value)\n\t\t\treturn;\n\n\t\tthis._blendMode = value;\n\n\t\tthis.iInvalidateShaderProgram();\n\t}\n\n\t/**\n\t * The color of the rim light.\n\t */\n\tpublic get color():number /*uint*/\n\t{\n\t\treturn this._color;\n\t}\n\n\tpublic set color(value:number /*uint*/)\n\t{\n\t\tthis._color = value;\n\t\tthis._colorR = ((value >> 16) & 0xff)/0xff;\n\t\tthis._colorG = ((value >> 8) & 0xff)/0xff;\n\t\tthis._colorB = (value & 0xff)/0xff;\n\t}\n\n\t/**\n\t * The strength of the rim light.\n\t */\n\tpublic get strength():number\n\t{\n\t\treturn this._strength;\n\t}\n\n\tpublic set strength(value:number)\n\t{\n\t\tthis._strength = value;\n\t}\n\n\t/**\n\t * The power of the rim light. Higher values will result in a higher edge fall-off.\n\t */\n\tpublic get power():number\n\t{\n\t\treturn this._power;\n\t}\n\n\tpublic set power(value:number)\n\t{\n\t\tthis._power = value;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iActivate(shader:ShaderBase, methodVO:MethodVO, stage:Stage)\n\t{\n\t\tvar index:number /*int*/ = methodVO.fragmentConstantsIndex;\n\t\tvar data:Float32Array = shader.fragmentConstantData;\n\t\tdata[index] = this._colorR;\n\t\tdata[index + 1] = this._colorG;\n\t\tdata[index + 2] = this._colorB;\n\t\tdata[index + 4] = this._strength;\n\t\tdata[index + 5] = this._power;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentCode(shader:ShaderBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar dataRegister:ShaderRegisterElement = registerCache.getFreeFragmentConstant();\n\t\tvar dataRegister2:ShaderRegisterElement = registerCache.getFreeFragmentConstant();\n\t\tvar temp:ShaderRegisterElement = registerCache.getFreeFragmentVectorTemp();\n\t\tvar code:string = \"\";\n\n\t\tmethodVO.fragmentConstantsIndex = dataRegister.index*4;\n\n\t\tcode += \"dp3 \" + temp + \".x, \" + sharedRegisters.viewDirFragment + \".xyz, \" + sharedRegisters.normalFragment + \".xyz\\n\" +\n\t\t\t\"sat \" + temp + \".x, \" + temp + \".x\\n\" +\n\t\t\t\"sub \" + temp + \".x, \" + dataRegister + \".w, \" + temp + \".x\\n\" +\n\t\t\t\"pow \" + temp + \".x, \" + temp + \".x, \" + dataRegister2 + \".y\\n\" +\n\t\t\t\"mul \" + temp + \".x, \" + temp + \".x, \" + dataRegister2 + \".x\\n\" +\n\t\t\t\"sub \" + temp + \".x, \" + dataRegister + \".w, \" + temp + \".x\\n\" +\n\t\t\t\"mul \" + targetReg + \".xyz, \" + targetReg + \".xyz, \" + temp + \".x\\n\" +\n\t\t\t\"sub \" + temp + \".w, \" + dataRegister + \".w, \" + temp + \".x\\n\";\n\n\t\tif (this._blendMode == EffectRimLightMethod.ADD) {\n\t\t\tcode += \"mul \" + temp + \".xyz, \" + temp + \".w, \" + dataRegister + \".xyz\\n\" +\n\t\t\t\t\"add \" + targetReg + \".xyz, \" + targetReg + \".xyz, \" + temp + \".xyz\\n\";\n\t\t} else if (this._blendMode == EffectRimLightMethod.MULTIPLY) {\n\t\t\tcode += \"mul \" + temp + \".xyz, \" + temp + \".w, \" + dataRegister + \".xyz\\n\" +\n\t\t\t\t\"mul \" + targetReg + \".xyz, \" + targetReg + \".xyz, \" + temp + \".xyz\\n\";\n\t\t} else {\n\t\t\tcode += \"sub \" + temp + \".xyz, \" + dataRegister + \".xyz, \" + targetReg + \".xyz\\n\" +\n\t\t\t\t\"mul \" + temp + \".xyz, \" + temp + \".xyz, \" + temp + \".w\\n\" +\n\t\t\t\t\"add \" + targetReg + \".xyz, \" + targetReg + \".xyz, \" + temp + \".xyz\\n\";\n\t\t}\n\n\t\treturn code;\n\t}\n}\n\nexport = EffectRimLightMethod;",
    "import ShaderBase\t\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderBase\");\nimport LightingShader\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/LightingShader\");\nimport ShaderRegisterCache\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterCache\");\nimport ShaderRegisterData\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterData\");\nimport ShaderRegisterElement\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterElement\");\n\nimport MethodVO\t\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/data/MethodVO\");\nimport ShadingMethodBase\t\t\t= require(\"awayjs-methodmaterials/lib/methods/ShadingMethodBase\");\n\n/**\n * LightingMethodBase provides an abstract base method for shading methods that uses lights.\n * Used for diffuse and specular shaders only.\n */\nclass LightingMethodBase extends ShadingMethodBase\n{\n\t/**\n\t * A method that is exposed to wrappers in case the strength needs to be controlled\n\t */\n\tpublic _iModulateMethod:(shader:ShaderBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData) => string;\n\n\t/**\n\t * Creates a new LightingMethodBase.\n\t */\n\tconstructor()\n\t{\n\t\tsuper();\n\t}\n\n\t/**\n\t * Get the fragment shader code that will be needed before any per-light code is added.\n\t * @param methodVO The MethodVO object containing the method data for the currently compiled material pass.\n\t * @param regCache The register cache used during the compilation.\n\t * @private\n\t */\n\tpublic iGetFragmentPreLightingCode(shader:LightingShader, methodVO:MethodVO, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\treturn \"\";\n\t}\n\n\t/**\n\t * Get the fragment shader code that will generate the code relevant to a single light.\n\t *\n\t * @param methodVO The MethodVO object containing the method data for the currently compiled material pass.\n\t * @param lightDirReg The register containing the light direction vector.\n\t * @param lightColReg The register containing the light colour.\n\t * @param regCache The register cache used during the compilation.\n\t */\n\tpublic iGetFragmentCodePerLight(shader:LightingShader, methodVO:MethodVO, lightDirReg:ShaderRegisterElement, lightColReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\treturn \"\";\n\t}\n\n\t/**\n\t * Get the fragment shader code that will generate the code relevant to a single light probe object.\n\t *\n\t * @param methodVO The MethodVO object containing the method data for the currently compiled material pass.\n\t * @param cubeMapReg The register containing the cube map for the current probe\n\t * @param weightRegister A string representation of the register + component containing the current weight\n\t * @param regCache The register cache providing any necessary registers to the shader\n\t */\n\tpublic iGetFragmentCodePerProbe(shader:LightingShader, methodVO:MethodVO, cubeMapReg:ShaderRegisterElement, weightRegister:string, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\treturn \"\";\n\t}\n\n\t/**\n\t * Get the fragment shader code that should be added after all per-light code. Usually composits everything to the target register.\n\t *\n\t * @param methodVO The MethodVO object containing the method data for the currently compiled material pass.\n\t * @param regCache The register cache used during the compilation.\n\t * @param targetReg The register containing the final shading output.\n\t * @private\n\t */\n\tpublic iGetFragmentPostLightingCode(shader:LightingShader, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\treturn \"\";\n\t}\n}\n\nexport = LightingMethodBase;",
    "import Camera\t\t\t\t\t\t\t= require(\"awayjs-display/lib/entities/Camera\");\nimport TextureBase\t\t\t\t\t\t= require(\"awayjs-display/lib/textures/TextureBase\");\n\nimport Stage\t\t\t\t\t\t\t= require(\"awayjs-stagegl/lib/base/Stage\");\n\nimport RenderableBase\t\t\t\t\t= require(\"awayjs-renderergl/lib/renderables/RenderableBase\");\nimport ShaderBase\t\t\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderBase\");\nimport ShaderRegisterCache\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterCache\");\nimport ShaderRegisterData\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterData\");\nimport ShaderRegisterElement\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterElement\");\n\nimport MethodVO\t\t\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/data/MethodVO\");\nimport ShadingMethodBase\t\t\t\t= require(\"awayjs-methodmaterials/lib/methods/ShadingMethodBase\");\n\n/**\n * NormalBasicMethod is the default method for standard tangent-space normal mapping.\n */\nclass NormalBasicMethod extends ShadingMethodBase\n{\n\tprivate _normalMap:TextureBase;\n\n\t/**\n\t * Creates a new NormalBasicMethod object.\n\t */\n\tconstructor(normalMap:TextureBase = null)\n\t{\n\t\tsuper();\n\n\t\tthis._normalMap = normalMap;\n\n\t\tif (this._normalMap)\n\t\t\tthis.iAddTexture(this._normalMap);\n\t}\n\n\tpublic iIsUsed(shader:ShaderBase):boolean\n\t{\n\t\tif (this._normalMap && shader.normalDependencies)\n\t\t\treturn true;\n\n\t\treturn false;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitVO(shader:ShaderBase, methodVO:MethodVO)\n\t{\n\t\tif (this._normalMap) {\n\t\t\tmethodVO.textureVO = shader.getAbstraction(this._normalMap);\n\t\t\tshader.uvDependencies++;\n\t\t}\n\t}\n\n\t/**\n\t * Indicates whether or not this method outputs normals in tangent space. Override for object-space normals.\n\t */\n\tpublic iOutputsTangentNormals():boolean\n\t{\n\t\treturn true;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic copyFrom(method:ShadingMethodBase)\n\t{\n\t\tvar s:any = method;\n\t\tvar bnm:NormalBasicMethod = <NormalBasicMethod> method;\n\n\t\tif (bnm.normalMap != null)\n\t\t\tthis.normalMap = bnm.normalMap;\n\t}\n\n\t/**\n\t * The texture containing the normals per pixel.\n\t */\n\tpublic get normalMap():TextureBase\n\t{\n\t\treturn this._normalMap;\n\t}\n\n\tpublic set normalMap(value:TextureBase)\n\t{\n\t\tif (this._normalMap == value)\n\t\t\treturn;\n\n\t\tif (this._normalMap)\n\t\t\tthis.iRemoveTexture(this._normalMap);\n\n\t\tthis._normalMap = value;\n\n\t\tif (this._normalMap)\n\t\t\tthis.iAddTexture(this._normalMap);\n\n\t\tthis.iInvalidateShaderProgram();\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic dispose()\n\t{\n\t\tif (this._normalMap)\n\t\t\tthis._normalMap = null;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iActivate(shader:ShaderBase, methodVO:MethodVO, stage:Stage)\n\t{\n\t\tif (this._normalMap)\n\t\t\tmethodVO.textureVO.activate();\n\t}\n\n\tpublic iSetRenderState(shader:ShaderBase, methodVO:MethodVO, renderable:RenderableBase, stage:Stage, camera:Camera)\n\t{\n\t\tif (this._normalMap)\n\t\t\tmethodVO.textureVO._setRenderState(renderable);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentCode(shader:ShaderBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = \"\";\n\n\t\tif (this._normalMap)\n\t\t\tcode += methodVO.textureVO._iGetFragmentCode(targetReg, registerCache, sharedRegisters, sharedRegisters.uvVarying);\n\n\n\t\tcode += \"sub \" + targetReg + \".xyz, \" + targetReg + \".xyz, \" + sharedRegisters.commons + \".xxx\\n\" +\n\t\t\t\"nrm \" + targetReg + \".xyz, \" + targetReg + \"\\n\";\n\n\t\treturn code;\n\t}\n}\n\nexport = NormalBasicMethod;",
    "import Single2DTexture\t\t\t\t\t= require(\"awayjs-display/lib/textures/Single2DTexture\");\nimport TextureBase\t\t\t\t\t\t= require(\"awayjs-display/lib/textures/TextureBase\");\n\nimport ShaderBase\t\t\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderBase\");\nimport ShaderRegisterCache\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterCache\");\nimport ShaderRegisterData\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterData\");\nimport ShaderRegisterElement\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterElement\");\n\nimport MethodVO\t\t\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/data/MethodVO\");\nimport NormalBasicMethod\t\t\t\t= require(\"awayjs-methodmaterials/lib/methods/NormalBasicMethod\");\nimport ShadingMethodBase\t\t\t\t= require(\"awayjs-methodmaterials/lib/methods/ShadingMethodBase\");\n\n/**\n * NormalHeightMapMethod provides a normal map method that uses a height map to calculate the normals.\n */\nclass NormalHeightMapMethod extends NormalBasicMethod\n{\n\tprivate _worldXYRatio:number;\n\tprivate _worldXZRatio:number;\n\n\t/**\n\t * Creates a new NormalHeightMapMethod method.\n\t *\n\t * @param heightMap The texture containing the height data. 0 means low, 1 means high.\n\t * @param worldWidth The width of the 'world'. This is used to map uv coordinates' u component to scene dimensions.\n\t * @param worldHeight The height of the 'world'. This is used to map the height map values to scene dimensions.\n\t * @param worldDepth The depth of the 'world'. This is used to map uv coordinates' v component to scene dimensions.\n\t */\n\tconstructor(heightMap:TextureBase, worldWidth:number, worldHeight:number, worldDepth:number)\n\t{\n\t\tsuper();\n\n\t\tthis.normalMap = heightMap;\n\t\tthis._worldXYRatio = worldWidth/worldHeight;\n\t\tthis._worldXZRatio = worldDepth/worldHeight;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitConstants(shader:ShaderBase, methodVO:MethodVO)\n\t{\n\t\tvar index:number /*int*/ = methodVO.fragmentConstantsIndex;\n\t\tvar data:Float32Array = shader.fragmentConstantData;\n\t\tdata[index] = 1/(<Single2DTexture> this.normalMap).image2D.width;\n\t\tdata[index + 1] = 1/(<Single2DTexture> this.normalMap).image2D.height;\n\t\tdata[index + 2] = 0;\n\t\tdata[index + 3] = 1;\n\t\tdata[index + 4] = this._worldXYRatio;\n\t\tdata[index + 5] = this._worldXZRatio;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic get tangentSpace():boolean\n\t{\n\t\treturn false;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic copyFrom(method:ShadingMethodBase)\n\t{\n\t\tsuper.copyFrom(method);\n\n\t\tthis._worldXYRatio = (<NormalHeightMapMethod> method)._worldXYRatio;\n\t\tthis._worldXZRatio = (<NormalHeightMapMethod> method)._worldXZRatio;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentCode(shader:ShaderBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = \"\";\n\t\tvar temp:ShaderRegisterElement = registerCache.getFreeFragmentVectorTemp();\n\t\tregisterCache.addFragmentTempUsages(temp, 1);\n\n\t\tvar dataReg:ShaderRegisterElement = registerCache.getFreeFragmentConstant();\n\t\tvar dataReg2:ShaderRegisterElement = registerCache.getFreeFragmentConstant();\n\n\t\tmethodVO.fragmentConstantsIndex = dataReg.index*4;\n\n\t\tcode+= methodVO.textureVO._iGetFragmentCode(targetReg, registerCache, sharedRegisters, sharedRegisters.uvVarying) +\n\n\t\t\t\"add \" + temp + \", \" + sharedRegisters.uvVarying + \", \" + dataReg + \".xzzz\\n\" +\n\n\t\tmethodVO.textureVO._iGetFragmentCode(temp, registerCache, sharedRegisters, temp) +\n\n\t\t\t\"sub \" + targetReg + \".x, \" + targetReg + \".x, \" + temp + \".x\\n\" +\n\t\t\t\"add \" + temp + \", \" + sharedRegisters.uvVarying + \", \" + dataReg + \".zyzz\\n\" +\n\n\t\tmethodVO.textureVO._iGetFragmentCode(temp, registerCache, sharedRegisters, temp) +\n\n\t\t\t\"sub \" + targetReg + \".z, \" + targetReg + \".z, \" + temp + \".x\\n\" +\n\t\t\t\"mov \" + targetReg + \".y, \" + dataReg + \".w\\n\" +\n\t\t\t\"mul \" + targetReg + \".xz, \" + targetReg + \".xz, \" + dataReg2 + \".xy\\n\" +\n\t\t\t\"nrm \" + targetReg + \".xyz, \" + targetReg + \".xyz\\n\";\n\n\t\tregisterCache.removeFragmentTempUsage(temp);\n\n\t\treturn code;\n\t}\n}\n\nexport = NormalHeightMapMethod;",
    "import Camera\t\t\t\t\t\t\t= require(\"awayjs-display/lib/entities/Camera\");\nimport TextureBase\t\t\t\t\t\t= require(\"awayjs-display/lib/textures/TextureBase\");\n\nimport Stage\t\t\t\t\t\t\t= require(\"awayjs-stagegl/lib/base/Stage\");\n\nimport RenderableBase\t\t\t\t\t= require(\"awayjs-renderergl/lib/renderables/RenderableBase\");\nimport ShaderBase\t\t\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderBase\");\nimport ShaderRegisterCache\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterCache\");\nimport ShaderRegisterData\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterData\");\nimport ShaderRegisterElement\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterElement\");\n\nimport MethodVO\t\t\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/data/MethodVO\");\nimport NormalBasicMethod\t\t\t\t= require(\"awayjs-methodmaterials/lib/methods/NormalBasicMethod\");\n\n/**\n * NormalSimpleWaterMethod provides a basic normal map method to create water ripples by translating two wave normal maps.\n */\nclass NormalSimpleWaterMethod extends NormalBasicMethod\n{\n\tprivate _secondaryNormalMap:TextureBase;\n\tprivate _water1OffsetX:number = 0;\n\tprivate _water1OffsetY:number = 0;\n\tprivate _water2OffsetX:number = 0;\n\tprivate _water2OffsetY:number = 0;\n\n\t/**\n\t * Creates a new NormalSimpleWaterMethod object.\n\t * @param waveMap1 A normal map containing one layer of a wave structure.\n\t * @param waveMap2 A normal map containing a second layer of a wave structure.\n\t */\n\tconstructor(normalMap:TextureBase = null, secondaryNormalMap:TextureBase = null)\n\t{\n\t\tsuper(normalMap);\n\n\t\tthis._secondaryNormalMap = secondaryNormalMap;\n\n\t\tif (this._secondaryNormalMap)\n\t\t\tthis.iAddTexture(this._secondaryNormalMap);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitConstants(shader:ShaderBase, methodVO:MethodVO)\n\t{\n\t\tvar index:number = methodVO.fragmentConstantsIndex;\n\t\tvar data:Float32Array = shader.fragmentConstantData;\n\t\tdata[index] = .5;\n\t\tdata[index + 1] = 0;\n\t\tdata[index + 2] = 0;\n\t\tdata[index + 3] = 1;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitVO(shader:ShaderBase, methodVO:MethodVO)\n\t{\n\t\tsuper.iInitVO(shader, methodVO);\n\t\t\n\t\tif (this._secondaryNormalMap) {\n\t\t\tmethodVO.secondaryTextureVO = shader.getAbstraction(this._secondaryNormalMap);\n\t\t\tshader.uvDependencies++;\n\t\t}\n\t}\n\n\t/**\n\t * The translation of the first wave layer along the X-axis.\n\t */\n\tpublic get water1OffsetX():number\n\t{\n\t\treturn this._water1OffsetX;\n\t}\n\n\tpublic set water1OffsetX(value:number)\n\t{\n\t\tthis._water1OffsetX = value;\n\t}\n\n\t/**\n\t * The translation of the first wave layer along the Y-axis.\n\t */\n\tpublic get water1OffsetY():number\n\t{\n\t\treturn this._water1OffsetY;\n\t}\n\n\tpublic set water1OffsetY(value:number)\n\t{\n\t\tthis._water1OffsetY = value;\n\t}\n\n\t/**\n\t * The translation of the second wave layer along the X-axis.\n\t */\n\tpublic get water2OffsetX():number\n\t{\n\t\treturn this._water2OffsetX;\n\t}\n\n\tpublic set water2OffsetX(value:number)\n\t{\n\t\tthis._water2OffsetX = value;\n\t}\n\n\t/**\n\t * The translation of the second wave layer along the Y-axis.\n\t */\n\tpublic get water2OffsetY():number\n\t{\n\t\treturn this._water2OffsetY;\n\t}\n\n\tpublic set water2OffsetY(value:number)\n\t{\n\t\tthis._water2OffsetY = value;\n\t}\n\n\t/**\n\t * A second normal map that will be combined with the first to create a wave-like animation pattern.\n\t */\n\tpublic get secondaryNormalMap():TextureBase\n\t{\n\t\treturn this._secondaryNormalMap;\n\t}\n\n\tpublic set secondaryNormalMap(value:TextureBase)\n\t{\n\t\tif (this._secondaryNormalMap == value)\n\t\t\treturn;\n\n\t\tif (this._secondaryNormalMap)\n\t\t\tthis.iRemoveTexture(this._secondaryNormalMap);\n\n\t\tthis._secondaryNormalMap = value;\n\n\t\tif (this._secondaryNormalMap)\n\t\t\tthis.iAddTexture(this._secondaryNormalMap);\n\n\t\tthis.iInvalidateShaderProgram();\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic dispose()\n\t{\n\t\tsuper.dispose();\n\n\t\tthis._secondaryNormalMap = null;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iActivate(shader:ShaderBase, methodVO:MethodVO, stage:Stage)\n\t{\n\t\tsuper.iActivate(shader, methodVO, stage);\n\n\t\tvar data:Float32Array = shader.fragmentConstantData;\n\t\tvar index:number = methodVO.fragmentConstantsIndex;\n\n\t\tdata[index + 4] = this._water1OffsetX;\n\t\tdata[index + 5] = this._water1OffsetY;\n\t\tdata[index + 6] = this._water2OffsetX;\n\t\tdata[index + 7] = this._water2OffsetY;\n\n\t\tif (this._secondaryNormalMap)\n\t\t\tmethodVO.secondaryTextureVO.activate();\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iSetRenderState(shader:ShaderBase, methodVO:MethodVO, renderable:RenderableBase, stage:Stage, camera:Camera)\n\t{\n\t\tsuper.iSetRenderState(shader, methodVO, renderable, stage, camera);\n\n\t\tif (this._secondaryNormalMap)\n\t\t\tmethodVO.secondaryTextureVO._setRenderState(renderable);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentCode(shader:ShaderBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = \"\";\n\t\tvar temp:ShaderRegisterElement = registerCache.getFreeFragmentVectorTemp();\n\t\tregisterCache.addFragmentTempUsages(temp, 1);\n\n\t\tvar dataReg:ShaderRegisterElement = registerCache.getFreeFragmentConstant();\n\t\tvar dataReg2:ShaderRegisterElement = registerCache.getFreeFragmentConstant();\n\t\tmethodVO.fragmentConstantsIndex = dataReg.index*4;\n\n\t\tcode += \"add \" + temp + \", \" + sharedRegisters.uvVarying + \", \" + dataReg2 + \".xyxy\\n\";\n\n\t\tif (this.normalMap)\n\t\t\tcode += methodVO.textureVO._iGetFragmentCode(targetReg, registerCache, sharedRegisters, temp);\n\n\t\tcode += \"add \" + temp + \", \" + sharedRegisters.uvVarying + \", \" + dataReg2 + \".zwzw\\n\";\n\n\t\tif (this._secondaryNormalMap)\n\t\t\tcode += methodVO.secondaryTextureVO._iGetFragmentCode(temp, registerCache, sharedRegisters, temp);\n\n\t\tcode +=\t\"add \" + targetReg + \", \" + targetReg + \", \" + temp + \"\t\t\\n\" +\n\t\t\t\"mul \" + targetReg + \", \" + targetReg + \", \" + dataReg + \".x\t\\n\" +\n\t\t\t\"sub \" + targetReg + \".xyz, \" + targetReg + \".xyz, \" + sharedRegisters.commons + \".xxx\t\\n\" +\n\t\t\t\"nrm \" + targetReg + \".xyz, \" + targetReg + \".xyz\t\t\t\t\t\t\t\\n\";\n\n\t\treturn code;\n\t}\n}\n\nexport = NormalSimpleWaterMethod;",
    "import AssetBase\t\t\t\t\t= require(\"awayjs-core/lib/library/AssetBase\");\n\nimport Camera\t\t\t\t\t\t= require(\"awayjs-display/lib/entities/Camera\");\nimport IRenderOwner\t\t\t\t\t= require(\"awayjs-display/lib/base/IRenderOwner\");\nimport TextureBase\t\t\t\t\t= require(\"awayjs-display/lib/textures/TextureBase\");\n\nimport Stage\t\t\t\t\t\t= require(\"awayjs-stagegl/lib/base/Stage\");\n\nimport RenderableBase\t\t\t\t= require(\"awayjs-renderergl/lib/renderables/RenderableBase\");\nimport ShadingMethodEvent\t\t\t= require(\"awayjs-renderergl/lib/events/ShadingMethodEvent\");\nimport ShaderBase\t\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderBase\");\nimport ShaderRegisterCache\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterCache\");\nimport ShaderRegisterData\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterData\");\nimport ShaderRegisterElement\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterElement\");\n\nimport MethodVO\t\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/data/MethodVO\");\n\n\n/**\n * ShadingMethodBase provides an abstract base method for shading methods, used by compiled passes to compile\n * the final shading program.\n */\nclass ShadingMethodBase extends AssetBase\n{\n\tpublic _textures:Array<TextureBase> = new Array<TextureBase>();\n\n\tpublic _owners:Array<IRenderOwner> = new Array<IRenderOwner>();\n\tpublic _counts:Array<number> = new Array<number>();\n\n\tpublic static assetType:string = \"[asset ShadingMethod]\";\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic get assetType():string\n\t{\n\t\treturn ShadingMethodBase.assetType;\n\t}\n\n\t/**\n\t * Create a new ShadingMethodBase object.\n\t */\n\tconstructor()\n\t{\n\t\tsuper();\n\t}\n\n\tpublic iIsUsed(shader:ShaderBase):boolean\n\t{\n\t\treturn true;\n\t}\n\n\t/**\n\t * Initializes the properties for a MethodVO, including register and texture indices.\n\t *\n\t * @param methodVO The MethodVO object linking this method with the pass currently being compiled.\n\t *\n\t * @internal\n\t */\n\tpublic iInitVO(shader:ShaderBase, methodVO:MethodVO)\n\t{\n\n\t}\n\n\t/**\n\t * Initializes unchanging shader constants using the data from a MethodVO.\n\t *\n\t * @param methodVO The MethodVO object linking this method with the pass currently being compiled.\n\t *\n\t * @internal\n\t */\n\tpublic iInitConstants(shader:ShaderBase, methodVO:MethodVO)\n\t{\n\n\n\t}\n\n\t/**\n\t * Indicates whether or not this method expects normals in tangent space. Override for object-space normals.\n\t */\n\tpublic iUsesTangentSpace():boolean\n\t{\n\t\treturn true;\n\t}\n\n\t/**\n\t * Cleans up any resources used by the current object.\n\t */\n\tpublic dispose()\n\t{\n\n\t}\n\n\n\tpublic iAddOwner(owner:IRenderOwner)\n\t{\n\t\t//a method can be used more than once in the same material, so we check for this\n\t\tvar index:number = this._owners.indexOf(owner);\n\n\t\tif (index != -1) {\n\t\t\tthis._counts[index]++;\n\t\t} else {\n\t\t\tthis._owners.push(owner);\n\t\t\tthis._counts.push(1);\n\n\t\t\t//add textures\n\t\t\tvar len:number = this._textures.length;\n\t\t\tfor (var i:number = 0; i< len; i++)\n\t\t\t\tthis._textures[i].iAddOwner(owner);\n\t\t}\n\t}\n\n\tpublic iRemoveOwner(owner:IRenderOwner)\n\t{\n\t\tvar index:number = this._owners.indexOf(owner);\n\n\t\tif (this._counts[index] != 1) {\n\t\t\tthis._counts[index]--;\n\t\t} else {\n\t\t\tthis._owners.splice(index, 1);\n\t\t\tthis._counts.splice(index, 1);\n\n\t\t\t//remove textures\n\t\t\tvar len:number = this._textures.length;\n\t\t\tfor (var i:number = 0; i< len; i++)\n\t\t\t\tthis._textures[i].iRemoveOwner(owner);\n\t\t}\n\t}\n\n\n\t/**\n\t *\n\t */\n\tpublic iAddTexture(texture:TextureBase)\n\t{\n\t\tthis._textures.push(texture);\n\n\t\tvar len:number = this._owners.length;\n\t\tfor (var i:number = 0; i < len; i++)\n\t\t\ttexture.iAddOwner(this._owners[i]);\n\t}\n\n\t/**\n\t *\n\t */\n\tpublic iRemoveTexture(texture:TextureBase)\n\t{\n\t\tthis._textures.splice(this._textures.indexOf(texture), 1);\n\n\t\tvar len:number = this._owners.length;\n\t\tfor (var i:number = 0; i < len; i++)\n\t\t\ttexture.iRemoveOwner(this._owners[i]);\n\t}\n\n\t/**\n\t * Resets the compilation state of the method.\n\t *\n\t * @internal\n\t */\n\tpublic iReset()\n\t{\n\t\tthis.iCleanCompilationData();\n\t}\n\n\t/**\n\t * Resets the method's state for compilation.\n\t *\n\t * @internal\n\t */\n\tpublic iCleanCompilationData()\n\t{\n\t}\n\n\t/**\n\t * Get the vertex shader code for this method.\n\t * @param vo The MethodVO object linking this method with the pass currently being compiled.\n\t * @param regCache The register cache used during the compilation.\n\t *\n\t * @internal\n\t */\n\tpublic iGetVertexCode(shader:ShaderBase, methodVO:MethodVO, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\treturn \"\";\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentCode(shader:ShaderBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\treturn null;\n\t}\n\n\t/**\n\t * Sets the render state for this method.\n\t *\n\t * @param methodVO The MethodVO object linking this method with the pass currently being compiled.\n\t * @param stage The Stage object currently used for rendering.\n\t *\n\t * @internal\n\t */\n\tpublic iActivate(shader:ShaderBase, methodVO:MethodVO, stage:Stage)\n\t{\n\n\t}\n\n\t/**\n\t * Sets the render state for a single renderable.\n\t *\n\t * @param vo The MethodVO object linking this method with the pass currently being compiled.\n\t * @param renderable The renderable currently being rendered.\n\t * @param stage The Stage object currently used for rendering.\n\t * @param camera The camera from which the scene is currently rendered.\n\t *\n\t * @internal\n\t */\n\tpublic iSetRenderState(shader:ShaderBase, methodVO:MethodVO, renderable:RenderableBase, stage:Stage, camera:Camera)\n\t{\n\n\t}\n\n\t/**\n\t * Clears the render state for this method.\n\t * @param vo The MethodVO object linking this method with the pass currently being compiled.\n\t * @param stage The Stage object currently used for rendering.\n\t *\n\t * @internal\n\t */\n\tpublic iDeactivate(shader:ShaderBase, methodVO:MethodVO, stage:Stage)\n\t{\n\n\t}\n\n\t/**\n\t * Marks the shader program as invalid, so it will be recompiled before the next render.\n\t *\n\t * @internal\n\t */\n\tpublic iInvalidateShaderProgram()\n\t{\n\t\tthis.dispatchEvent(new ShadingMethodEvent(ShadingMethodEvent.SHADER_INVALIDATED));\n\t}\n\n\t/**\n\t * Copies the state from a ShadingMethodBase object into the current object.\n\t */\n\tpublic copyFrom(method:ShadingMethodBase)\n\t{\n\t}\n}\n\nexport = ShadingMethodBase;",
    "import AssetEvent\t\t\t\t\t\t= require(\"awayjs-core/lib/events/AssetEvent\");\n\nimport Camera\t\t\t\t\t\t\t= require(\"awayjs-display/lib/entities/Camera\");\nimport DirectionalLight\t\t\t\t\t= require(\"awayjs-display/lib/entities/DirectionalLight\");\nimport CascadeShadowMapper\t\t\t\t= require(\"awayjs-display/lib/materials/shadowmappers/CascadeShadowMapper\");\nimport TextureBase\t\t\t\t\t\t= require(\"awayjs-display/lib/textures/TextureBase\");\n\nimport Stage\t\t\t\t\t\t\t= require(\"awayjs-stagegl/lib/base/Stage\");\n\nimport RenderableBase\t\t\t\t\t= require(\"awayjs-renderergl/lib/renderables/RenderableBase\");\nimport ShadingMethodEvent\t\t\t\t= require(\"awayjs-renderergl/lib/events/ShadingMethodEvent\");\nimport LightingShader\t\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/LightingShader\");\nimport ShaderBase\t\t\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderBase\");\nimport ShaderRegisterCache\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterCache\");\nimport ShaderRegisterData\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterData\");\nimport ShaderRegisterElement\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterElement\");\n\nimport MethodVO\t\t\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/data/MethodVO\");\nimport ShadowMapMethodBase\t\t\t\t= require(\"awayjs-methodmaterials/lib/methods/ShadowMapMethodBase\");\nimport ShadowMethodBase\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/methods/ShadowMethodBase\");\n\n/**\n * ShadowCascadeMethod is a shadow map method to apply cascade shadow mapping on materials.\n * Must be used with a DirectionalLight with a CascadeShadowMapper assigned to its shadowMapper property.\n *\n * @see away.lights.CascadeShadowMapper\n */\nclass ShadowCascadeMethod extends ShadowMapMethodBase\n{\n\tprivate _baseMethod:ShadowMethodBase;\n\tprivate _cascadeShadowMapper:CascadeShadowMapper;\n\tprivate _depthMapCoordVaryings:Array<ShaderRegisterElement>;\n\tprivate _cascadeProjections:Array<ShaderRegisterElement>;\n\n\t/**\n\t * Creates a new ShadowCascadeMethod object.\n\t *\n\t * @param shadowMethodBase The shadow map sampling method used to sample individual cascades (fe: ShadowHardMethod, ShadowSoftMethod)\n\t */\n\tconstructor(shadowMethodBase:ShadowMethodBase)\n\t{\n\t\tsuper(shadowMethodBase.castingLight);\n\n\t\tthis._baseMethod = shadowMethodBase;\n\t\tif (!(this._pCastingLight instanceof DirectionalLight))\n\t\t\tthrow new Error(\"ShadowCascadeMethod is only compatible with DirectionalLight\");\n\n\t\tthis._cascadeShadowMapper = <CascadeShadowMapper> this._pCastingLight.shadowMapper;\n\n\t\tif (!this._cascadeShadowMapper)\n\t\t\tthrow new Error(\"ShadowCascadeMethod requires a light that has a CascadeShadowMapper instance assigned to shadowMapper.\");\n\n\t\tthis._cascadeShadowMapper.addEventListener(AssetEvent.INVALIDATE, (event:AssetEvent) => this.onCascadeChange(event));\n\t\tthis._baseMethod.addEventListener(ShadingMethodEvent.SHADER_INVALIDATED, (event:ShadingMethodEvent) => this.onShaderInvalidated(event));\n\t}\n\n\t/**\n\t * The shadow map sampling method used to sample individual cascades. These are typically those used in conjunction\n\t * with a DirectionalShadowMapper.\n\t *\n\t * @see ShadowHardMethod\n\t * @see ShadowSoftMethod\n\t */\n\tpublic get baseMethod():ShadowMethodBase\n\t{\n\t\treturn this._baseMethod;\n\t}\n\n\tpublic set baseMethod(value:ShadowMethodBase)\n\t{\n\t\tif (this._baseMethod == value)\n\t\t\treturn;\n\n\t\tthis._baseMethod.removeEventListener(ShadingMethodEvent.SHADER_INVALIDATED, (event:ShadingMethodEvent) => this.onShaderInvalidated(event));\n\n\t\tthis._baseMethod = value;\n\n\t\tthis._baseMethod.addEventListener(ShadingMethodEvent.SHADER_INVALIDATED, (event:ShadingMethodEvent) => this.onShaderInvalidated(event));\n\n\t\tthis.iInvalidateShaderProgram();\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitVO(shader:LightingShader, methodVO:MethodVO)\n\t{\n\t\tvar tempVO:MethodVO = new MethodVO(this._baseMethod);\n\t\tthis._baseMethod.iInitVO(shader, tempVO);\n\n\t\tmethodVO.needsGlobalVertexPos = true;\n\t\tmethodVO.needsProjection = true;\n\n\t\tmethodVO.textureVO = shader.getAbstraction(this._pCastingLight.shadowMapper.depthMap);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitConstants(shader:ShaderBase, methodVO:MethodVO)\n\t{\n\t\tvar fragmentData:Float32Array = shader.fragmentConstantData;\n\t\tvar vertexData:Float32Array = shader.vertexConstantData;\n\t\tvar index:number = methodVO.fragmentConstantsIndex;\n\t\tfragmentData[index] = 1.0;\n\t\tfragmentData[index + 1] = 1/255.0;\n\t\tfragmentData[index + 2] = 1/65025.0;\n\t\tfragmentData[index + 3] = 1/16581375.0;\n\n\t\tfragmentData[index + 6] = .5;\n\t\tfragmentData[index + 7] = -.5;\n\n\t\tindex = methodVO.vertexConstantsIndex;\n\t\tvertexData[index] = .5;\n\t\tvertexData[index + 1] = -.5;\n\t\tvertexData[index + 2] = 0;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iCleanCompilationData()\n\t{\n\t\tsuper.iCleanCompilationData();\n\t\tthis._cascadeProjections = null;\n\t\tthis._depthMapCoordVaryings = null;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetVertexCode(shader:ShaderBase, methodVO:MethodVO, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = \"\";\n\t\tvar dataReg:ShaderRegisterElement = registerCache.getFreeVertexConstant();\n\n\t\tthis.initProjectionsRegs(registerCache);\n\t\tmethodVO.vertexConstantsIndex = dataReg.index*4;\n\n\t\tvar temp:ShaderRegisterElement = registerCache.getFreeVertexVectorTemp();\n\n\t\tfor (var i:number = 0; i < this._cascadeShadowMapper.numCascades; ++i) {\n\t\t\tcode += \"m44 \" + temp + \", \" + sharedRegisters.globalPositionVertex + \", \" + this._cascadeProjections[i] + \"\\n\" +\n\t\t\t\t\"add \" + this._depthMapCoordVaryings[i] + \", \" + temp + \", \" + dataReg + \".zzwz\\n\";\n\t\t}\n\n\t\treturn code;\n\t}\n\n\t/**\n\t * Creates the registers for the cascades' projection coordinates.\n\t */\n\tprivate initProjectionsRegs(registerCache:ShaderRegisterCache)\n\t{\n\t\tthis._cascadeProjections = new Array<ShaderRegisterElement>(this._cascadeShadowMapper.numCascades);\n\t\tthis._depthMapCoordVaryings = new Array<ShaderRegisterElement>(this._cascadeShadowMapper.numCascades);\n\n\t\tfor (var i:number = 0; i < this._cascadeShadowMapper.numCascades; ++i) {\n\t\t\tthis._depthMapCoordVaryings[i] = registerCache.getFreeVarying();\n\t\t\tthis._cascadeProjections[i] = registerCache.getFreeVertexConstant();\n\t\t\tregisterCache.getFreeVertexConstant();\n\t\t\tregisterCache.getFreeVertexConstant();\n\t\t\tregisterCache.getFreeVertexConstant();\n\t\t}\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentCode(shader:ShaderBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar numCascades:number = this._cascadeShadowMapper.numCascades;\n\t\tvar decReg:ShaderRegisterElement = registerCache.getFreeFragmentConstant();\n\t\tvar dataReg:ShaderRegisterElement = registerCache.getFreeFragmentConstant();\n\t\tvar planeDistanceReg:ShaderRegisterElement = registerCache.getFreeFragmentConstant();\n\t\tvar planeDistances:Array<string> = Array<string>( planeDistanceReg + \".x\", planeDistanceReg + \".y\", planeDistanceReg + \".z\", planeDistanceReg + \".w\" );\n\t\tvar code:string;\n\n\t\tmethodVO.fragmentConstantsIndex = decReg.index*4;\n\n\t\tvar inQuad:ShaderRegisterElement = registerCache.getFreeFragmentVectorTemp();\n\t\tregisterCache.addFragmentTempUsages(inQuad, 1);\n\t\tvar uvCoord:ShaderRegisterElement = registerCache.getFreeFragmentVectorTemp();\n\t\tregisterCache.addFragmentTempUsages(uvCoord, 1);\n\n\t\t// assume lowest partition is selected, will be overwritten later otherwise\n\t\tcode = \"mov \" + uvCoord + \", \" + this._depthMapCoordVaryings[numCascades - 1] + \"\\n\";\n\n\t\tfor (var i:number = numCascades - 2; i >= 0; --i) {\n\t\t\tvar uvProjection:ShaderRegisterElement = this._depthMapCoordVaryings[i];\n\n\t\t\t// calculate if in texturemap (result == 0 or 1, only 1 for a single partition)\n\t\t\tcode += \"slt \" + inQuad + \".z, \" + sharedRegisters.projectionFragment + \".z, \" + planeDistances[i] + \"\\n\"; // z = x > minX, w = y > minY\n\n\t\t\tvar temp:ShaderRegisterElement = registerCache.getFreeFragmentVectorTemp();\n\n\t\t\t// linearly interpolate between old and new uv coords using predicate value == conditional toggle to new value if predicate == 1 (true)\n\t\t\tcode += \"sub \" + temp + \", \" + uvProjection + \", \" + uvCoord + \"\\n\" +\n\t\t\t\t\"mul \" + temp + \", \" + temp + \", \" + inQuad + \".z\\n\" +\n\t\t\t\t\"add \" + uvCoord + \", \" + uvCoord + \", \" + temp + \"\\n\";\n\t\t}\n\n\t\tregisterCache.removeFragmentTempUsage(inQuad);\n\n\t\tcode += \"div \" + uvCoord + \", \" + uvCoord + \", \" + uvCoord + \".w\\n\" +\n\t\t\t\"mul \" + uvCoord + \".xy, \" + uvCoord + \".xy, \" + dataReg + \".zw\\n\" +\n\t\t\t\"add \" + uvCoord + \".xy, \" + uvCoord + \".xy, \" + dataReg + \".zz\\n\";\n\n\t\tcode += this._baseMethod._iGetCascadeFragmentCode(shader, methodVO, decReg, uvCoord, targetReg, registerCache, sharedRegisters) +\n\t\t\t\"add \" + targetReg + \".w, \" + targetReg + \".w, \" + dataReg + \".y\\n\";\n\n\t\tregisterCache.removeFragmentTempUsage(uvCoord);\n\n\t\treturn code;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iActivate(shader:ShaderBase, methodVO:MethodVO, stage:Stage)\n\t{\n\t\tmethodVO.textureVO.activate();\n\n\t\tvar vertexData:Float32Array = shader.vertexConstantData;\n\t\tvar vertexIndex:number = methodVO.vertexConstantsIndex;\n\n\t\tshader.vertexConstantData[methodVO.vertexConstantsIndex + 3] = -1/(this._cascadeShadowMapper.depth*this._pEpsilon);\n\n\t\tvar numCascades:number = this._cascadeShadowMapper.numCascades;\n\t\tvertexIndex += 4;\n\t\tfor (var k:number = 0; k < numCascades; ++k) {\n\t\t\tthis._cascadeShadowMapper.getDepthProjections(k).copyRawDataTo(vertexData, vertexIndex, true);\n\t\t\tvertexIndex += 16;\n\t\t}\n\n\t\tvar fragmentData:Float32Array = shader.fragmentConstantData;\n\t\tvar fragmentIndex:number = methodVO.fragmentConstantsIndex;\n\t\tfragmentData[fragmentIndex + 5] = 1 - this._pAlpha;\n\n\t\tvar nearPlaneDistances:Array<number> = this._cascadeShadowMapper._iNearPlaneDistances;\n\n\t\tfragmentIndex += 8;\n\t\tfor (var i:number = 0; i < numCascades; ++i)\n\t\t\tfragmentData[fragmentIndex + i] = nearPlaneDistances[i];\n\n\t\tthis._baseMethod.iActivateForCascade(shader, methodVO, stage);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iSetRenderState(shader:ShaderBase, methodVO:MethodVO, renderable:RenderableBase, stage:Stage, camera:Camera)\n\t{\n\t}\n\n\t/**\n\t * Called when the shadow mappers cascade configuration changes.\n\t */\n\tprivate onCascadeChange(event:AssetEvent)\n\t{\n\t\tthis.iInvalidateShaderProgram();\n\t}\n\n\t/**\n\t * Called when the base method's shader code is invalidated.\n\t */\n\tprivate onShaderInvalidated(event:ShadingMethodEvent)\n\t{\n\t\tthis.iInvalidateShaderProgram();\n\t}\n}\n\nexport = ShadowCascadeMethod;",
    "import BitmapImage2D\t\t\t\t\t= require(\"awayjs-core/lib/image/BitmapImage2D\");\n\nimport Camera\t\t\t\t\t\t\t= require(\"awayjs-display/lib/entities/Camera\");\nimport DirectionalLight\t\t\t\t\t= require(\"awayjs-display/lib/entities/DirectionalLight\");\nimport Single2DTexture\t\t\t\t\t= require(\"awayjs-display/lib/textures/Single2DTexture\");\n\nimport Stage\t\t\t\t\t\t\t= require(\"awayjs-stagegl/lib/base/Stage\");\n\nimport RenderableBase\t\t\t\t\t= require(\"awayjs-renderergl/lib/renderables/RenderableBase\");\nimport LightingShader\t\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/LightingShader\");\nimport ShaderBase\t\t\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderBase\");\nimport ShaderRegisterCache\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterCache\");\nimport ShaderRegisterData\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterData\");\nimport ShaderRegisterElement\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterElement\");\n\nimport MethodVO\t\t\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/data/MethodVO\");\nimport ShadowMethodBase\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/methods/ShadowMethodBase\");\n\n/**\n * ShadowDitheredMethod provides a soft shadowing technique by randomly distributing sample points differently for each fragment.\n */\nclass ShadowDitheredMethod extends ShadowMethodBase\n{\n\tprivate static _grainTexture:Single2DTexture;\n\tprivate static _grainUsages:number /*int*/;\n\tprivate static _grainBitmapImage2D:BitmapImage2D;\n\tprivate _depthMapSize:number /*int*/;\n\tprivate _range:number;\n\tprivate _numSamples:number /*int*/;\n\n\t/**\n\t * Creates a new ShadowDitheredMethod object.\n\t * @param castingLight The light casting the shadows\n\t * @param numSamples The amount of samples to take for dithering. Minimum 1, maximum 24.\n\t */\n\tconstructor(castingLight:DirectionalLight, numSamples:number /*int*/ = 4, range:number = 1)\n\t{\n\t\tsuper(castingLight);\n\n\t\tthis._depthMapSize = this._pCastingLight.shadowMapper.depthMapSize;\n\n\t\tthis.numSamples = numSamples;\n\t\tthis.range = range;\n\n\t\t++ShadowDitheredMethod._grainUsages;\n\n\t\tif (!ShadowDitheredMethod._grainTexture)\n\t\t\tthis.initGrainTexture();\n\t}\n\n\t/**\n\t * The amount of samples to take for dithering. Minimum 1, maximum 24. The actual maximum may depend on the\n\t * complexity of the shader.\n\t */\n\tpublic get numSamples():number /*int*/\n\t{\n\t\treturn this._numSamples;\n\t}\n\n\tpublic set numSamples(value:number /*int*/)\n\t{\n\t\tif (value < 1)\n\t\t\tvalue = 1;\n\t\telse if (value > 24)\n\t\t\tvalue = 24;\n\n\t\tif (this._numSamples == value)\n\t\t\treturn;\n\n\t\tthis._numSamples = value;\n\n\t\tthis.iInvalidateShaderProgram();\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitVO(shader:LightingShader, methodVO:MethodVO)\n\t{\n\t\tsuper.iInitVO(shader, methodVO);\n\n\t\tmethodVO.needsProjection = true;\n\n\t\tmethodVO.secondaryTextureVO = shader.getAbstraction(ShadowDitheredMethod._grainTexture);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitConstants(shader:ShaderBase, methodVO:MethodVO)\n\t{\n\t\tsuper.iInitConstants(shader, methodVO);\n\n\t\tvar fragmentData:Float32Array = shader.fragmentConstantData;\n\t\tvar index:number /*int*/ = methodVO.fragmentConstantsIndex;\n\t\tfragmentData[index + 8] = 1/this._numSamples;\n\t}\n\n\t/**\n\t * The range in the shadow map in which to distribute the samples.\n\t */\n\tpublic get range():number\n\t{\n\t\treturn this._range*2;\n\t}\n\n\tpublic set range(value:number)\n\t{\n\t\tthis._range = value/2;\n\t}\n\n\t/**\n\t * Creates a texture containing the dithering noise texture.\n\t */\n\tprivate initGrainTexture()\n\t{\n\t\tShadowDitheredMethod._grainBitmapImage2D = new BitmapImage2D(64, 64, false);\n\t\tvar vec:Array<number> /*uint*/ = new Array<number>();\n\t\tvar len:number /*uint*/ = 4096;\n\t\tvar step:number = 1/(this._depthMapSize*this._range);\n\t\tvar r:number, g:number;\n\n\t\tfor (var i:number /*uint*/ = 0; i < len; ++i) {\n\t\t\tr = 2*(Math.random() - .5);\n\t\t\tg = 2*(Math.random() - .5);\n\t\t\tif (r < 0)\n\t\t\t\tr -= step; else\n\t\t\t\tr += step;\n\t\t\tif (g < 0)\n\t\t\t\tg -= step; else\n\t\t\t\tg += step;\n\t\t\tif (r > 1)\n\t\t\t\tr = 1; else if (r < -1)\n\t\t\t\tr = -1;\n\t\t\tif (g > 1)\n\t\t\t\tg = 1; else if (g < -1)\n\t\t\t\tg = -1;\n\t\t\tvec[i] = (Math.floor((r*.5 + .5)*0xff) << 16) | (Math.floor((g*.5 + .5)*0xff) << 8);\n\t\t}\n\n\t\tShadowDitheredMethod._grainBitmapImage2D.setArray(ShadowDitheredMethod._grainBitmapImage2D.rect, vec);\n\t\tShadowDitheredMethod._grainTexture = new Single2DTexture(ShadowDitheredMethod._grainBitmapImage2D);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic dispose()\n\t{\n\t\tif (--ShadowDitheredMethod._grainUsages == 0) {\n\t\t\tShadowDitheredMethod._grainTexture.dispose();\n\t\t\tShadowDitheredMethod._grainBitmapImage2D.dispose();\n\t\t\tShadowDitheredMethod._grainTexture = null;\n\t\t}\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iActivate(shader:ShaderBase, methodVO:MethodVO, stage:Stage)\n\t{\n\t\tsuper.iActivate(shader, methodVO, stage);\n\n\t\tvar data:Float32Array = shader.fragmentConstantData;\n\t\tvar index:number /*uint*/ = methodVO.fragmentConstantsIndex;\n\t\tdata[index + 9] = (stage.width - 1)/63;\n\t\tdata[index + 10] = (stage.height - 1)/63;\n\t\tdata[index + 11] = 2*this._range/this._depthMapSize;\n\n\t\tmethodVO.secondaryTextureVO.activate();\n\t}\n\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iSetRenderState(shader:ShaderBase, methodVO:MethodVO, renderable:RenderableBase, stage:Stage, camera:Camera)\n\t{\n\t\tsuper.iSetRenderState(shader, methodVO, renderable, stage, camera);\n\n\t\tmethodVO.secondaryTextureVO._setRenderState(renderable);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic _pGetPlanarFragmentCode(shader:ShaderBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, regCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar decReg:ShaderRegisterElement = regCache.getFreeFragmentConstant();\n\t\tvar dataReg:ShaderRegisterElement = regCache.getFreeFragmentConstant();\n\t\tvar customDataReg:ShaderRegisterElement = regCache.getFreeFragmentConstant();\n\n\t\tmethodVO.fragmentConstantsIndex = decReg.index*4;\n\n\t\treturn this.getSampleCode(shader, methodVO, customDataReg, decReg, targetReg, regCache, sharedRegisters);\n\t}\n\n\t/**\n\t * Get the actual shader code for shadow mapping\n\t * @param regCache The register cache managing the registers.\n\t * @param depthMapRegister The texture register containing the depth map.\n\t * @param decReg The register containing the depth map decoding data.\n\t * @param targetReg The target register to add the shadow coverage.\n\t */\n\tprivate getSampleCode(shader:ShaderBase, methodVO:MethodVO, customDataReg:ShaderRegisterElement, decReg:ShaderRegisterElement, targetReg:ShaderRegisterElement, regCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = \"\";\n\t\tvar numSamples:number /*int*/ = this._numSamples;\n\t\tvar uvReg:ShaderRegisterElement = regCache.getFreeFragmentVectorTemp();\n\t\tregCache.addFragmentTempUsages(uvReg, 1);\n\t\tvar temp:ShaderRegisterElement = regCache.getFreeFragmentVectorTemp();\n\t\tregCache.addFragmentTempUsages(temp, 1);\n\n\t\tvar projectionReg:ShaderRegisterElement = sharedRegisters.projectionFragment;\n\n\t\tcode += \"div \" + uvReg + \", \" + projectionReg + \", \" + projectionReg + \".w\\n\" +\n\t\t\t\"mul \" + uvReg + \".xy, \" + uvReg + \".xy, \" + customDataReg + \".yz\\n\";\n\n\t\twhile (numSamples > 0) {\n\t\t\tif (numSamples == this._numSamples) {\n\t\t\t\tcode += methodVO.secondaryTextureVO._iGetFragmentCode(uvReg, regCache, sharedRegisters, uvReg);\n\t\t\t} else {\n\t\t\t\tcode += \"mov \" + temp + \", \" + uvReg + \".zwxy \\n\" +\n\t\t\t\t\tmethodVO.secondaryTextureVO._iGetFragmentCode(uvReg, regCache, sharedRegisters, temp);\n\t\t\t}\n\n\t\t\t// keep grain in uvReg.zw\n\t\t\tcode += \"sub \" + uvReg + \".zw, \" + uvReg + \".xy, fc0.xx\\n\" + // uv-.5\n\t\t\t\t\"mul \" + uvReg + \".zw, \" + uvReg + \".zw, \" + customDataReg + \".w\\n\"; // (tex unpack scale and tex scale in one)\n\n\t\t\tif (numSamples == this._numSamples) {\n\t\t\t\t// first sample\n\t\t\t\tcode += \"add \" + uvReg + \".xy, \" + uvReg + \".zw, \" + this._pDepthMapCoordReg + \".xy\\n\" +\n\t\t\t\t\tmethodVO.textureVO._iGetFragmentCode(temp, regCache, sharedRegisters, uvReg) +\n\t\t\t\t\t\"dp4 \" + temp + \".z, \" + temp + \", \" + decReg + \"\\n\" +\n\t\t\t\t\t\"slt \" + targetReg + \".w, \" + this._pDepthMapCoordReg + \".z, \" + temp + \".z\\n\"; // 0 if in shadow\n\t\t\t} else {\n\t\t\t\tcode += this.addSample(shader, methodVO, uvReg, decReg, targetReg, regCache, sharedRegisters);\n\t\t\t}\n\n\t\t\tif (numSamples > 4)\n\t\t\t\tcode += \"add \" + uvReg + \".xy, \" + uvReg + \".xy, \" + uvReg + \".zw\\n\" + this.addSample(shader, methodVO, uvReg, decReg, targetReg, regCache, sharedRegisters);\n\n\t\t\tif (numSamples > 1)\n\t\t\t\tcode += \"sub \" + uvReg + \".xy, \" + this._pDepthMapCoordReg + \".xy, \" + uvReg + \".zw\\n\" + this.addSample(shader, methodVO, uvReg, decReg, targetReg, regCache, sharedRegisters);\n\n\t\t\tif (numSamples > 5)\n\t\t\t\tcode += \"sub \" + uvReg + \".xy, \" + uvReg + \".xy, \" + uvReg + \".zw\\n\" + this.addSample(shader, methodVO, uvReg, decReg, targetReg, regCache, sharedRegisters);\n\n\t\t\tif (numSamples > 2) {\n\t\t\t\tcode += \"neg \" + uvReg + \".w, \" + uvReg + \".w\\n\"; // will be rotated 90 degrees when being accessed as wz\n\t\t\t\tcode += \"add \" + uvReg + \".xy, \" + uvReg + \".wz, \" + this._pDepthMapCoordReg + \".xy\\n\" + this.addSample(shader, methodVO, uvReg, decReg, targetReg, regCache, sharedRegisters);\n\t\t\t}\n\n\t\t\tif (numSamples > 6)\n\t\t\t\tcode += \"add \" + uvReg + \".xy, \" + uvReg + \".xy, \" + uvReg + \".wz\\n\" + this.addSample(shader, methodVO, uvReg, decReg, targetReg, regCache, sharedRegisters);\n\n\t\t\tif (numSamples > 3)\n\t\t\t\tcode += \"sub \" + uvReg + \".xy, \" + this._pDepthMapCoordReg + \".xy, \" + uvReg + \".wz\\n\" + this.addSample(shader, methodVO, uvReg, decReg, targetReg, regCache, sharedRegisters);\n\n\t\t\tif (numSamples > 7)\n\t\t\t\tcode += \"sub \" + uvReg + \".xy, \" + uvReg + \".xy, \" + uvReg + \".wz\\n\" + this.addSample(shader, methodVO, uvReg, decReg, targetReg, regCache, sharedRegisters);\n\n\t\t\tnumSamples -= 8;\n\t\t}\n\n\t\tregCache.removeFragmentTempUsage(temp);\n\t\tregCache.removeFragmentTempUsage(uvReg);\n\t\tcode += \"mul \" + targetReg + \".w, \" + targetReg + \".w, \" + customDataReg + \".x\\n\"; // average\n\t\treturn code;\n\t}\n\n\t/**\n\t * Adds the code for another tap to the shader code.\n\t * @param uvReg The uv register for the tap.\n\t * @param depthMapRegister The texture register containing the depth map.\n\t * @param decReg The register containing the depth map decoding data.\n\t * @param targetReg The target register to add the tap comparison result.\n\t * @param regCache The register cache managing the registers.\n\t * @return\n\t */\n\tprivate addSample(shader:ShaderBase, methodVO:MethodVO, uvReg:ShaderRegisterElement, decReg:ShaderRegisterElement, targetReg:ShaderRegisterElement, regCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar temp:ShaderRegisterElement = regCache.getFreeFragmentVectorTemp();\n\n\t\treturn methodVO.textureVO._iGetFragmentCode(temp, regCache, sharedRegisters, uvReg) +\n\t\t\t\"dp4 \" + temp + \".z, \" + temp + \", \" + decReg + \"\\n\" +\n\t\t\t\"slt \" + temp + \".z, \" + this._pDepthMapCoordReg + \".z, \" + temp + \".z\\n\" + // 0 if in shadow\n\t\t\t\"add \" + targetReg + \".w, \" + targetReg + \".w, \" + temp + \".z\\n\";\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iActivateForCascade(shader:ShaderBase, methodVO:MethodVO, stage:Stage)\n\t{\n\t\tvar data:Float32Array = shader.fragmentConstantData;\n\t\tvar index:number /*uint*/ = methodVO.secondaryFragmentConstantsIndex;\n\t\tdata[index] = 1/this._numSamples;\n\t\tdata[index + 1] = (stage.width - 1)/63;\n\t\tdata[index + 2] = (stage.height - 1)/63;\n\t\tdata[index + 3] = 2*this._range/this._depthMapSize;\n\n\t\tmethodVO.secondaryTextureVO.activate();\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic _iGetCascadeFragmentCode(shader:ShaderBase, methodVO:MethodVO, decodeRegister:ShaderRegisterElement, depthProjection:ShaderRegisterElement, targetRegister:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tthis._pDepthMapCoordReg = depthProjection;\n\n\t\tvar dataReg:ShaderRegisterElement = registerCache.getFreeFragmentConstant();\n\t\tmethodVO.secondaryFragmentConstantsIndex = dataReg.index*4;\n\n\t\treturn this.getSampleCode(shader, methodVO, dataReg, decodeRegister, targetRegister, registerCache, sharedRegisters);\n\t}\n}\n\nexport = ShadowDitheredMethod;",
    "import DirectionalLight\t\t\t\t\t= require(\"awayjs-display/lib/entities/DirectionalLight\");\n\nimport Stage\t\t\t\t\t\t\t= require(\"awayjs-stagegl/lib/base/Stage\");\n\nimport LightingShader\t\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/LightingShader\");\nimport ShaderBase\t\t\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderBase\");\nimport ShaderRegisterCache\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterCache\");\nimport ShaderRegisterData\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterData\");\nimport ShaderRegisterElement\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterElement\");\n\nimport MethodVO\t\t\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/data/MethodVO\");\nimport ShadowMethodBase\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/methods/ShadowMethodBase\");\n\n/**\n * ShadowFilteredMethod provides a softened shadowing technique by bilinearly interpolating shadow comparison\n * results of neighbouring pixels.\n */\nclass ShadowFilteredMethod extends ShadowMethodBase\n{\n\t/**\n\t * Creates a new DiffuseBasicMethod object.\n\t *\n\t * @param castingLight The light casting the shadow\n\t */\n\tconstructor(castingLight:DirectionalLight)\n\t{\n\t\tsuper(castingLight);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitConstants(shader:LightingShader, methodVO:MethodVO)\n\t{\n\t\tsuper.iInitConstants(shader, methodVO);\n\n\t\tvar fragmentData:Float32Array = shader.fragmentConstantData;\n\t\tvar index:number /*int*/ = methodVO.fragmentConstantsIndex;\n\t\tfragmentData[index + 8] = .5;\n\t\tvar size:number /*int*/ = this.castingLight.shadowMapper.depthMapSize;\n\t\tfragmentData[index + 9] = size;\n\t\tfragmentData[index + 10] = 1/size;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic _pGetPlanarFragmentCode(shader:ShaderBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, regCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = \"\";\n\t\tvar decReg:ShaderRegisterElement = regCache.getFreeFragmentConstant();\n\t\tregCache.getFreeFragmentConstant();\n\t\tvar customDataReg:ShaderRegisterElement = regCache.getFreeFragmentConstant();\n\n\t\tmethodVO.fragmentConstantsIndex = decReg.index*4;\n\n\t\tvar depthCol:ShaderRegisterElement = regCache.getFreeFragmentVectorTemp();\n\t\tregCache.addFragmentTempUsages(depthCol, 1);\n\t\tvar uvReg:ShaderRegisterElement = regCache.getFreeFragmentVectorTemp();\n\t\tregCache.addFragmentTempUsages(uvReg, 1);\n\n\t\tcode += \"mov \" + uvReg + \", \" + this._pDepthMapCoordReg + \"\\n\" +\n\n\t\t\tmethodVO.textureVO._iGetFragmentCode(depthCol, regCache, sharedRegisters, this._pDepthMapCoordReg) +\n\t\t\t\"dp4 \" + depthCol + \".z, \" + depthCol + \", \" + decReg + \"\\n\" +\n\t\t\t\"slt \" + uvReg + \".z, \" + this._pDepthMapCoordReg + \".z, \" + depthCol + \".z\\n\" +   // 0 if in shadow\n\n\t\t\t\"add \" + uvReg + \".x, \" + this._pDepthMapCoordReg + \".x, \" + customDataReg + \".z\\n\" + \t// (1, 0)\n\t\t\tmethodVO.textureVO._iGetFragmentCode(depthCol, regCache, sharedRegisters, uvReg) +\n\t\t\t\"dp4 \" + depthCol + \".z, \" + depthCol + \", \" + decReg + \"\\n\" +\n\t\t\t\"slt \" + uvReg + \".w, \" + this._pDepthMapCoordReg + \".z, \" + depthCol + \".z\\n\" +   // 0 if in shadow\n\n\t\t\t\"mul \" + depthCol + \".x, \" + this._pDepthMapCoordReg + \".x, \" + customDataReg + \".y\\n\" +\n\t\t\t\"frc \" + depthCol + \".x, \" + depthCol + \".x\\n\" +\n\t\t\t\"sub \" + uvReg + \".w, \" + uvReg + \".w, \" + uvReg + \".z\\n\" +\n\t\t\t\"mul \" + uvReg + \".w, \" + uvReg + \".w, \" + depthCol + \".x\\n\" +\n\t\t\t\"add \" + targetReg + \".w, \" + uvReg + \".z, \" + uvReg + \".w\\n\" +\n\n\t\t\t\"mov \" + uvReg + \".x, \" + this._pDepthMapCoordReg + \".x\\n\" +\n\t\t\t\"add \" + uvReg + \".y, \" + this._pDepthMapCoordReg + \".y, \" + customDataReg + \".z\\n\" +\t// (0, 1)\n\t\t\tmethodVO.textureVO._iGetFragmentCode(depthCol, regCache, sharedRegisters, uvReg) +\n\t\t\t\"dp4 \" + depthCol + \".z, \" + depthCol + \", \" + decReg + \"\\n\" +\n\t\t\t\"slt \" + uvReg + \".z, \" + this._pDepthMapCoordReg + \".z, \" + depthCol + \".z\\n\" +   // 0 if in shadow\n\n\t\t\t\"add \" + uvReg + \".x, \" + this._pDepthMapCoordReg + \".x, \" + customDataReg + \".z\\n\" +\t// (1, 1)\n\t\t\tmethodVO.textureVO._iGetFragmentCode(depthCol, regCache, sharedRegisters, uvReg) +\n\t\t\t\"dp4 \" + depthCol + \".z, \" + depthCol + \", \" + decReg + \"\\n\" +\n\t\t\t\"slt \" + uvReg + \".w, \" + this._pDepthMapCoordReg + \".z, \" + depthCol + \".z\\n\" +   // 0 if in shadow\n\n\t\t\t// recalculate fraction, since we ran out of registers :(\n\t\t\t\"mul \" + depthCol + \".x, \" + this._pDepthMapCoordReg + \".x, \" + customDataReg + \".y\\n\" +\n\t\t\t\"frc \" + depthCol + \".x, \" + depthCol + \".x\\n\" + \"sub \" + uvReg + \".w, \" + uvReg + \".w, \" + uvReg + \".z\\n\" +\n\t\t\t\"mul \" + uvReg + \".w, \" + uvReg + \".w, \" + depthCol + \".x\\n\" +\n\t\t\t\"add \" + uvReg + \".w, \" + uvReg + \".z, \" + uvReg + \".w\\n\" +\n\n\t\t\t\"mul \" + depthCol + \".x, \" + this._pDepthMapCoordReg + \".y, \" + customDataReg + \".y\\n\" +\n\t\t\t\"frc \" + depthCol + \".x, \" + depthCol + \".x\\n\" +\n\t\t\t\"sub \" + uvReg + \".w, \" + uvReg + \".w, \" + targetReg + \".w\\n\" +\n\t\t\t\"mul \" + uvReg + \".w, \" + uvReg + \".w, \" + depthCol + \".x\\n\" +\n\t\t\t\"add \" + targetReg + \".w, \" + targetReg + \".w, \" + uvReg + \".w\\n\";\n\n\t\tregCache.removeFragmentTempUsage(depthCol);\n\t\tregCache.removeFragmentTempUsage(uvReg);\n\n\t\treturn code;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iActivateForCascade(shader:ShaderBase, methodVO:MethodVO, stage:Stage)\n\t{\n\t\tvar size:number /*int*/ = this.castingLight.shadowMapper.depthMapSize;\n\t\tvar index:number /*int*/ = methodVO.secondaryFragmentConstantsIndex;\n\t\tvar data:Float32Array = shader.fragmentConstantData;\n\t\tdata[index] = size;\n\t\tdata[index + 1] = 1/size;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic _iGetCascadeFragmentCode(shader:ShaderBase, methodVO:MethodVO, decodeRegister:ShaderRegisterElement, depthProjection:ShaderRegisterElement, targetRegister:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string;\n\t\tvar dataReg:ShaderRegisterElement = registerCache.getFreeFragmentConstant();\n\t\tmethodVO.secondaryFragmentConstantsIndex = dataReg.index*4;\n\n\t\tvar temp:ShaderRegisterElement = registerCache.getFreeFragmentVectorTemp();\n\t\tregisterCache.addFragmentTempUsages(temp, 1);\n\t\tvar predicate:ShaderRegisterElement = registerCache.getFreeFragmentVectorTemp();\n\t\tregisterCache.addFragmentTempUsages(predicate, 1);\n\n\t\tcode = methodVO.textureVO._iGetFragmentCode(temp, registerCache, sharedRegisters, depthProjection) +\n\t\t\t\"dp4 \" + temp + \".z, \" + temp + \", \" + decodeRegister + \"\\n\" +\n\t\t\t\"slt \" + predicate + \".x, \" + depthProjection + \".z, \" + temp + \".z\\n\" +\n\n\t\t\t\"add \" + depthProjection + \".x, \" + depthProjection + \".x, \" + dataReg + \".y\\n\" +\n\t\t\tmethodVO.textureVO._iGetFragmentCode(temp, registerCache, sharedRegisters, depthProjection) +\n\t\t\t\"dp4 \" + temp + \".z, \" + temp + \", \" + decodeRegister + \"\\n\" +\n\t\t\t\"slt \" + predicate + \".z, \" + depthProjection + \".z, \" + temp + \".z\\n\" +\n\n\t\t\t\"add \" + depthProjection + \".y, \" + depthProjection + \".y, \" + dataReg + \".y\\n\" +\n\t\t\tmethodVO.textureVO._iGetFragmentCode(temp, registerCache, sharedRegisters, depthProjection) +\n\t\t\t\"dp4 \" + temp + \".z, \" + temp + \", \" + decodeRegister + \"\\n\" +\n\t\t\t\"slt \" + predicate + \".w, \" + depthProjection + \".z, \" + temp + \".z\\n\" +\n\n\t\t\t\"sub \" + depthProjection + \".x, \" + depthProjection + \".x, \" + dataReg + \".y\\n\" +\n\t\t\tmethodVO.textureVO._iGetFragmentCode(temp, registerCache, sharedRegisters, depthProjection) +\n\t\t\t\"dp4 \" + temp + \".z, \" + temp + \", \" + decodeRegister + \"\\n\" +\n\t\t\t\"slt \" + predicate + \".y, \" + depthProjection + \".z, \" + temp + \".z\\n\" +\n\n\t\t\t\"mul \" + temp + \".xy, \" + depthProjection + \".xy, \" + dataReg + \".x\\n\" +\n\t\t\t\"frc \" + temp + \".xy, \" + temp + \".xy\\n\" +\n\n\t\t\t// some strange register juggling to prevent agal bugging out\n\t\t\t\"sub \" + depthProjection + \", \" + predicate + \".xyzw, \" + predicate + \".zwxy\\n\" +\n\t\t\t\"mul \" + depthProjection + \", \" + depthProjection + \", \" + temp + \".x\\n\" +\n\n\t\t\t\"add \" + predicate + \".xy, \" + predicate + \".xy, \" + depthProjection + \".zw\\n\" +\n\n\t\t\t\"sub \" + predicate + \".y, \" + predicate + \".y, \" + predicate + \".x\\n\" +\n\t\t\t\"mul \" + predicate + \".y, \" + predicate + \".y, \" + temp + \".y\\n\" +\n\t\t\t\"add \" + targetRegister + \".w, \" + predicate + \".x, \" + predicate + \".y\\n\";\n\n\t\tregisterCache.removeFragmentTempUsage(temp);\n\t\tregisterCache.removeFragmentTempUsage(predicate);\n\t\treturn code;\n\t}\n}\n\nexport = ShadowFilteredMethod;",
    "import LightBase\t\t\t\t\t\t= require(\"awayjs-display/lib/base/LightBase\");\n\nimport Stage\t\t\t\t\t\t\t= require(\"awayjs-stagegl/lib/base/Stage\");\n\nimport ShaderBase\t\t\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderBase\");\nimport ShaderRegisterCache\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterCache\");\nimport ShaderRegisterData\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterData\");\nimport ShaderRegisterElement\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterElement\");\n\nimport MethodVO\t\t\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/data/MethodVO\");\nimport ShadowMethodBase\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/methods/ShadowMethodBase\");\n\n/**\n * ShadowHardMethod provides the cheapest shadow map method by using a single tap without any filtering.\n */\nclass ShadowHardMethod extends ShadowMethodBase\n{\n\t/**\n\t * Creates a new ShadowHardMethod object.\n\t */\n\tconstructor(castingLight:LightBase)\n\t{\n\t\tsuper(castingLight);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic _pGetPlanarFragmentCode(shader:ShaderBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, regCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = \"\";\n\t\tvar decReg:ShaderRegisterElement = regCache.getFreeFragmentConstant();\n\t\tregCache.getFreeFragmentConstant();\n\n\t\tvar depthCol:ShaderRegisterElement = regCache.getFreeFragmentVectorTemp();\n\n\t\tmethodVO.fragmentConstantsIndex = decReg.index*4;\n\n\t\tcode += methodVO.textureVO._iGetFragmentCode(depthCol, regCache, sharedRegisters, this._pDepthMapCoordReg) +\n\t\t\t\"dp4 \" + depthCol + \".z, \" + depthCol + \", \" + decReg + \"\\n\" +\n\t\t\t\"slt \" + targetReg + \".w, \" + this._pDepthMapCoordReg + \".z, \" + depthCol + \".z\\n\"; // 0 if in shadow\n\n\t\treturn code;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic _pGetPointFragmentCode(shader:ShaderBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, regCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = \"\";\n\t\tvar decReg:ShaderRegisterElement = regCache.getFreeFragmentConstant();\n\t\tvar epsReg:ShaderRegisterElement = regCache.getFreeFragmentConstant();\n\t\tvar posReg:ShaderRegisterElement = regCache.getFreeFragmentConstant();\n\t\tvar depthSampleCol:ShaderRegisterElement = regCache.getFreeFragmentVectorTemp();\n\t\tregCache.addFragmentTempUsages(depthSampleCol, 1);\n\t\tvar lightDir:ShaderRegisterElement = regCache.getFreeFragmentVectorTemp();\n\t\tregCache.addFragmentTempUsages(lightDir, 1);\n\n\t\tmethodVO.fragmentConstantsIndex = decReg.index*4;\n\n\t\tcode += \"sub \" + lightDir + \", \" + sharedRegisters.globalPositionVarying + \", \" + posReg + \"\\n\" +\n\t\t\t\"dp3 \" + lightDir + \".w, \" + lightDir + \".xyz, \" + lightDir + \".xyz\\n\" +\n\t\t\t\"mul \" + lightDir + \".w, \" + lightDir + \".w, \" + posReg + \".w\\n\" +\n\t\t\t\"nrm \" + lightDir + \".xyz, \" + lightDir + \".xyz\\n\" +\n\n\t\t\tmethodVO.textureVO._iGetFragmentCode(depthSampleCol, regCache, sharedRegisters, lightDir) +\n\t\t\t\"dp4 \" + depthSampleCol + \".z, \" + depthSampleCol + \", \" + decReg + \"\\n\" +\n\t\t\t\"add \" + targetReg + \".w, \" + lightDir + \".w, \" + epsReg + \".x\\n\" +    // offset by epsilon\n\n\t\t\t\"slt \" + targetReg + \".w, \" + targetReg + \".w, \" + depthSampleCol + \".z\\n\"; // 0 if in shadow\n\n\t\tregCache.removeFragmentTempUsage(lightDir);\n\t\tregCache.removeFragmentTempUsage(depthSampleCol);\n\n\t\treturn code;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic _iGetCascadeFragmentCode(shader:ShaderBase, methodVO:MethodVO, decodeRegister:ShaderRegisterElement, depthProjection:ShaderRegisterElement, targetRegister:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar temp:ShaderRegisterElement = registerCache.getFreeFragmentVectorTemp();\n\n\t\treturn methodVO.textureVO._iGetFragmentCode(temp, registerCache, sharedRegisters, depthProjection) +\n\t\t\t\"dp4 \" + temp + \".z, \" + temp + \", \" + decodeRegister + \"\\n\" +\n\t\t\t\"slt \" + targetRegister + \".w, \" + depthProjection + \".z, \" + temp + \".z\\n\"; // 0 if in shadow\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iActivateForCascade(shader:ShaderBase, methodVO:MethodVO, stage:Stage)\n\t{\n\t}\n}\n\nexport = ShadowHardMethod;",
    "import IAsset\t\t\t\t\t\t\t= require(\"awayjs-core/lib/library/IAsset\");\n\nimport LightBase\t\t\t\t\t\t= require(\"awayjs-display/lib/base/LightBase\");\nimport ShadowMapperBase\t\t\t\t\t= require(\"awayjs-display/lib/materials/shadowmappers/ShadowMapperBase\");\n\nimport ShadingMethodBase\t\t\t\t= require(\"awayjs-methodmaterials/lib/methods/ShadingMethodBase\");\n\n/**\n * ShadowMapMethodBase provides an abstract base method for shadow map methods.\n */\nclass ShadowMapMethodBase extends ShadingMethodBase implements IAsset\n{\n\tpublic static assetType:string = \"[asset ShadowMapMethod]\";\n\n\tpublic _pCastingLight:LightBase;\n\tpublic _pShadowMapper:ShadowMapperBase;\n\n\tpublic _pEpsilon:number = .02;\n\tpublic _pAlpha:number = 1;\n\n\t/**\n\t * Creates a new ShadowMapMethodBase object.\n\t * @param castingLight The light used to cast shadows.\n\t */\n\tconstructor(castingLight:LightBase)\n\t{\n\t\tsuper();\n\t\tthis._pCastingLight = castingLight;\n\t\tcastingLight.castsShadows = true;\n\t\tthis._pShadowMapper = castingLight.shadowMapper;\n\n\t\tthis.iAddTexture(castingLight.shadowMapper.depthMap);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic get assetType():string\n\t{\n\t\treturn ShadowMapMethodBase.assetType;\n\t}\n\n\t/**\n\t * The \"transparency\" of the shadows. This allows making shadows less strong.\n\t */\n\tpublic get alpha():number\n\t{\n\t\treturn this._pAlpha;\n\t}\n\n\tpublic set alpha(value:number)\n\t{\n\t\tthis._pAlpha = value;\n\t}\n\n\t/**\n\t * The light casting the shadows.\n\t */\n\tpublic get castingLight():LightBase\n\t{\n\t\treturn this._pCastingLight;\n\t}\n\n\t/**\n\t * A small value to counter floating point precision errors when comparing values in the shadow map with the\n\t * calculated depth value. Increase this if shadow banding occurs, decrease it if the shadow seems to be too detached.\n\t */\n\tpublic get epsilon():number\n\t{\n\t\treturn this._pEpsilon;\n\t}\n\n\tpublic set epsilon(value:number)\n\t{\n\t\tthis._pEpsilon = value;\n\t}\n}\n\nexport = ShadowMapMethodBase;",
    "import Vector3D\t\t\t\t\t\t\t= require(\"awayjs-core/lib/geom/Vector3D\");\nimport AbstractMethodError\t\t\t\t= require(\"awayjs-core/lib/errors/AbstractMethodError\");\n\nimport LightBase\t\t\t\t\t\t= require(\"awayjs-display/lib/base/LightBase\");\nimport Camera\t\t\t\t\t\t\t= require(\"awayjs-display/lib/entities/Camera\");\nimport DirectionalLight\t\t\t\t\t= require(\"awayjs-display/lib/entities/DirectionalLight\");\nimport PointLight\t\t\t\t\t\t= require(\"awayjs-display/lib/entities/PointLight\");\nimport DirectionalShadowMapper\t\t\t= require(\"awayjs-display/lib/materials/shadowmappers/DirectionalShadowMapper\");\nimport TextureBase\t\t\t\t\t\t= require(\"awayjs-display/lib/textures/TextureBase\");\n\nimport Stage\t\t\t\t\t\t\t= require(\"awayjs-stagegl/lib/base/Stage\");\n\nimport RenderableBase\t\t\t\t\t= require(\"awayjs-renderergl/lib/renderables/RenderableBase\");\nimport LightingShader\t\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/LightingShader\");\nimport ShaderBase\t\t\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderBase\");\nimport ShaderRegisterCache\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterCache\");\nimport ShaderRegisterData\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterData\");\nimport ShaderRegisterElement\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterElement\");\n\nimport MethodVO\t\t\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/data/MethodVO\");\nimport ShadowMapMethodBase\t\t\t\t= require(\"awayjs-methodmaterials/lib/methods/ShadowMapMethodBase\");\n\n/**\n * ShadowMethodBase provides an abstract method for simple (non-wrapping) shadow map methods.\n */\nclass ShadowMethodBase extends ShadowMapMethodBase\n{\n\tpublic _pDepthMapCoordReg:ShaderRegisterElement;\n\tpublic _pUsePoint:boolean;\n\n\t/**\n\t * Creates a new ShadowMethodBase object.\n\t * @param castingLight The light used to cast shadows.\n\t */\n\tconstructor(castingLight:LightBase)\n\t{\n\t\tthis._pUsePoint = (castingLight instanceof PointLight);\n\n\t\tsuper(castingLight);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitVO(shader:LightingShader, methodVO:MethodVO)\n\t{\n\t\tmethodVO.needsView = true;\n\t\tmethodVO.needsGlobalVertexPos = true;\n\t\tmethodVO.needsGlobalFragmentPos = this._pUsePoint;\n\t\tmethodVO.needsNormals = shader.numLights > 0;\n\n\t\tmethodVO.textureVO = shader.getAbstraction(this._pCastingLight.shadowMapper.depthMap);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitConstants(shader:ShaderBase, methodVO:MethodVO)\n\t{\n\t\tvar fragmentData:Float32Array = shader.fragmentConstantData;\n\t\tvar vertexData:Float32Array = shader.vertexConstantData;\n\t\tvar index:number /*int*/ = methodVO.fragmentConstantsIndex;\n\t\tfragmentData[index] = 1.0;\n\t\tfragmentData[index + 1] = 1/255.0;\n\t\tfragmentData[index + 2] = 1/65025.0;\n\t\tfragmentData[index + 3] = 1/16581375.0;\n\n\t\tfragmentData[index + 6] = 0;\n\t\tfragmentData[index + 7] = 1;\n\n\t\tif (this._pUsePoint) {\n\t\t\tfragmentData[index + 8] = 0;\n\t\t\tfragmentData[index + 9] = 0;\n\t\t\tfragmentData[index + 10] = 0;\n\t\t\tfragmentData[index + 11] = 1;\n\t\t}\n\n\t\tindex = methodVO.vertexConstantsIndex;\n\t\tif (index != -1) {\n\t\t\tvertexData[index] = .5;\n\t\t\tvertexData[index + 1] = .5;\n\t\t\tvertexData[index + 2] = 0.0;\n\t\t\tvertexData[index + 3] = 1.0;\n\t\t}\n\t}\n\n\t/**\n\t * Wrappers that override the vertex shader need to set this explicitly\n\t */\n\tpublic get _iDepthMapCoordReg():ShaderRegisterElement\n\t{\n\t\treturn this._pDepthMapCoordReg;\n\t}\n\n\tpublic set _iDepthMapCoordReg(value:ShaderRegisterElement)\n\t{\n\t\tthis._pDepthMapCoordReg = value;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iCleanCompilationData()\n\t{\n\t\tsuper.iCleanCompilationData();\n\n\t\tthis._pDepthMapCoordReg = null;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetVertexCode(shader:ShaderBase, methodVO:MethodVO, regCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\treturn this._pUsePoint? this._pGetPointVertexCode(methodVO, regCache, sharedRegisters):this.pGetPlanarVertexCode(methodVO, regCache, sharedRegisters);\n\t}\n\n\t/**\n\t * Gets the vertex code for shadow mapping with a point light.\n\t *\n\t * @param methodVO The MethodVO object linking this method with the pass currently being compiled.\n\t * @param regCache The register cache used during the compilation.\n\t */\n\tpublic _pGetPointVertexCode(methodVO:MethodVO, regCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tmethodVO.vertexConstantsIndex = -1;\n\t\treturn \"\";\n\t}\n\n\t/**\n\t * Gets the vertex code for shadow mapping with a planar shadow map (fe: directional lights).\n\t *\n\t * @param methodVO The MethodVO object linking this method with the pass currently being compiled.\n\t * @param regCache The register cache used during the compilation.\n\t */\n\tpublic pGetPlanarVertexCode(methodVO:MethodVO, regCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = \"\";\n\t\tvar temp:ShaderRegisterElement = regCache.getFreeVertexVectorTemp();\n\t\tvar dataReg:ShaderRegisterElement = regCache.getFreeVertexConstant();\n\t\tvar depthMapProj:ShaderRegisterElement = regCache.getFreeVertexConstant();\n\t\tregCache.getFreeVertexConstant();\n\t\tregCache.getFreeVertexConstant();\n\t\tregCache.getFreeVertexConstant();\n\t\tthis._pDepthMapCoordReg = regCache.getFreeVarying();\n\t\tmethodVO.vertexConstantsIndex = dataReg.index*4;\n\n\t\t// todo: can epsilon be applied here instead of fragment shader?\n\n\t\tcode += \"m44 \" + temp + \", \" + sharedRegisters.globalPositionVertex + \", \" + depthMapProj + \"\\n\" +\n\t\t\t\"div \" + temp + \", \" + temp + \", \" + temp + \".w\\n\" +\n\t\t\t\"mul \" + temp + \".xy, \" + temp + \".xy, \" + dataReg + \".xy\\n\" +\n\t\t\t\"add \" + this._pDepthMapCoordReg + \", \" + temp + \", \" + dataReg + \".xxwz\\n\";\n\t\t//\"sub \" + this._pDepthMapCoordReg + \".z, \" + this._pDepthMapCoordReg + \".z, \" + this._pDepthMapCoordReg + \".w\\n\";\n\n\t\treturn code;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentCode(shader:ShaderBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = this._pUsePoint? this._pGetPointFragmentCode(shader, methodVO, targetReg, registerCache, sharedRegisters) : this._pGetPlanarFragmentCode(shader, methodVO, targetReg, registerCache, sharedRegisters);\n\t\tcode += \"add \" + targetReg + \".w, \" + targetReg + \".w, fc\" + (methodVO.fragmentConstantsIndex/4 + 1) + \".y\\n\" +\n\t\t\t\"sat \" + targetReg + \".w, \" + targetReg + \".w\\n\";\n\t\treturn code;\n\t}\n\n\t/**\n\t * Gets the fragment code for shadow mapping with a planar shadow map.\n\t * @param methodVO The MethodVO object linking this method with the pass currently being compiled.\n\t * @param regCache The register cache used during the compilation.\n\t * @param targetReg The register to contain the shadow coverage\n\t * @return\n\t */\n\tpublic _pGetPlanarFragmentCode(shader:ShaderBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, regCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tthrow new AbstractMethodError();\n\t\treturn \"\";\n\t}\n\n\t/**\n\t * Gets the fragment code for shadow mapping with a point light.\n\t * @param methodVO The MethodVO object linking this method with the pass currently being compiled.\n\t * @param regCache The register cache used during the compilation.\n\t * @param targetReg The register to contain the shadow coverage\n\t * @return\n\t */\n\tpublic _pGetPointFragmentCode(shader:ShaderBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, regCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tthrow new AbstractMethodError();\n\t\treturn \"\";\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iSetRenderState(shader:ShaderBase, methodVO:MethodVO, renderable:RenderableBase, stage:Stage, camera:Camera)\n\t{\n\t\tif (!this._pUsePoint)\n\t\t\t(<DirectionalShadowMapper> this._pShadowMapper).iDepthProjection.copyRawDataTo(shader.vertexConstantData, methodVO.vertexConstantsIndex + 4, true);\n\n\t\tmethodVO.textureVO._setRenderState(renderable);\n\t}\n\n\t/**\n\t * Gets the fragment code for combining this method with a cascaded shadow map method.\n\t * @param methodVO The MethodVO object linking this method with the pass currently being compiled.\n\t * @param regCache The register cache used during the compilation.\n\t * @param decodeRegister The register containing the data to decode the shadow map depth value.\n\t * @param depthTexture The texture containing the shadow map.\n\t * @param depthProjection The projection of the fragment relative to the light.\n\t * @param targetRegister The register to contain the shadow coverage\n\t * @return\n\t */\n\tpublic _iGetCascadeFragmentCode(shader:ShaderBase, methodVO:MethodVO, decodeRegister:ShaderRegisterElement, depthProjection:ShaderRegisterElement, targetRegister:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tthrow new Error(\"This shadow method is incompatible with cascade shadows\");\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iActivate(shader:ShaderBase, methodVO:MethodVO, stage:Stage)\n\t{\n\t\tvar fragmentData:Float32Array = shader.fragmentConstantData;\n\t\tvar index:number /*int*/ = methodVO.fragmentConstantsIndex;\n\n\t\tif (this._pUsePoint)\n\t\t\tfragmentData[index + 4] = -Math.pow(1/((<PointLight> this._pCastingLight).fallOff*this._pEpsilon), 2);\n\t\telse\n\t\t\tshader.vertexConstantData[methodVO.vertexConstantsIndex + 3] = -1/((<DirectionalShadowMapper> this._pShadowMapper).depth*this._pEpsilon);\n\n\t\tfragmentData[index + 5] = 1 - this._pAlpha;\n\n\t\tif (this._pUsePoint) {\n\t\t\tvar pos:Vector3D = this._pCastingLight.scenePosition;\n\t\t\tfragmentData[index + 8] = pos.x;\n\t\t\tfragmentData[index + 9] = pos.y;\n\t\t\tfragmentData[index + 10] = pos.z;\n\t\t\t// used to decompress distance\n\t\t\tvar f:number = (<PointLight> this._pCastingLight).fallOff;\n\t\t\tfragmentData[index + 11] = 1/(2*f*f);\n\t\t}\n\n\t\tmethodVO.textureVO.activate();\n\t}\n\n\t/**\n\t * Sets the method state for cascade shadow mapping.\n\t */\n\tpublic iActivateForCascade(shader:ShaderBase, methodVO:MethodVO, stage:Stage)\n\t{\n\t\tthrow new Error(\"This shadow method is incompatible with cascade shadows\");\n\t}\n}\n\nexport = ShadowMethodBase;",
    "import NearDirectionalShadowMapper\t\t= require(\"awayjs-display/lib/materials/shadowmappers/NearDirectionalShadowMapper\");\nimport Camera\t\t\t\t\t\t\t= require(\"awayjs-display/lib/entities/Camera\");\n\nimport Stage\t\t\t\t\t\t\t= require(\"awayjs-stagegl/lib/base/Stage\");\n\nimport RenderableBase\t\t\t\t\t= require(\"awayjs-renderergl/lib/renderables/RenderableBase\");\nimport ShadingMethodEvent\t\t\t\t= require(\"awayjs-renderergl/lib/events/ShadingMethodEvent\");\nimport LightingShader\t\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/LightingShader\");\nimport ShaderBase\t\t\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderBase\");\nimport ShaderRegisterCache\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterCache\");\nimport ShaderRegisterData\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterData\");\nimport ShaderRegisterElement\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterElement\");\n\nimport MethodVO\t\t\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/data/MethodVO\");\nimport ShadowMethodBase\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/methods/ShadowMethodBase\");\n\n// TODO: shadow mappers references in materials should be an interface so that this class should NOT extend ShadowMapMethodBase just for some delegation work\n/**\n * ShadowNearMethod provides a shadow map method that restricts the shadowed area near the camera to optimize\n * shadow map usage. This method needs to be used in conjunction with a NearDirectionalShadowMapper.\n *\n * @see away.lights.NearDirectionalShadowMapper\n */\nclass ShadowNearMethod extends ShadowMethodBase\n{\n\tprivate _baseMethod:ShadowMethodBase;\n\n\tprivate _fadeRatio:number;\n\tprivate _nearShadowMapper:NearDirectionalShadowMapper;\n\n\tprivate _onShaderInvalidatedDelegate:(event:ShadingMethodEvent) => void;\n\n\t/**\n\t * Creates a new ShadowNearMethod object.\n\t * @param baseMethod The shadow map sampling method used to sample individual cascades (fe: ShadowHardMethod, ShadowSoftMethod)\n\t * @param fadeRatio The amount of shadow fading to the outer shadow area. A value of 1 would mean the shadows start fading from the camera's near plane.\n\t */\n\tconstructor(baseMethod:ShadowMethodBase, fadeRatio:number = .1)\n\t{\n\t\tsuper(baseMethod.castingLight);\n\n\t\tthis._onShaderInvalidatedDelegate = (event:ShadingMethodEvent) => this.onShaderInvalidated(event);\n\n\t\tthis._baseMethod = baseMethod;\n\t\tthis._fadeRatio = fadeRatio;\n\t\tthis._nearShadowMapper = <NearDirectionalShadowMapper> this._pCastingLight.shadowMapper;\n\t\tif (!this._nearShadowMapper)\n\t\t\tthrow new Error(\"ShadowNearMethod requires a light that has a NearDirectionalShadowMapper instance assigned to shadowMapper.\");\n\t\tthis._baseMethod.addEventListener(ShadingMethodEvent.SHADER_INVALIDATED, this._onShaderInvalidatedDelegate);\n\t}\n\n\t/**\n\t * The base shadow map method on which this method's shading is based.\n\t */\n\tpublic get baseMethod():ShadowMethodBase\n\t{\n\t\treturn this._baseMethod;\n\t}\n\n\tpublic set baseMethod(value:ShadowMethodBase)\n\t{\n\t\tif (this._baseMethod == value)\n\t\t\treturn;\n\n\t\tthis._baseMethod.removeEventListener(ShadingMethodEvent.SHADER_INVALIDATED, this._onShaderInvalidatedDelegate);\n\n\t\tthis._baseMethod = value;\n\n\t\tthis._baseMethod.addEventListener(ShadingMethodEvent.SHADER_INVALIDATED, this._onShaderInvalidatedDelegate);\n\n\t\tthis.iInvalidateShaderProgram();\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitConstants(shader:ShaderBase, methodVO:MethodVO)\n\t{\n\t\tsuper.iInitConstants(shader, methodVO);\n\t\tthis._baseMethod.iInitConstants(shader, methodVO);\n\n\t\tvar fragmentData:Float32Array = shader.fragmentConstantData;\n\t\tvar index:number /*int*/ = methodVO.secondaryFragmentConstantsIndex;\n\t\tfragmentData[index + 2] = 0;\n\t\tfragmentData[index + 3] = 1;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitVO(shader:LightingShader, methodVO:MethodVO)\n\t{\n\t\tthis._baseMethod.iInitVO(shader, methodVO);\n\n\t\tmethodVO.needsProjection = true;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic dispose()\n\t{\n\t\tthis._baseMethod.removeEventListener(ShadingMethodEvent.SHADER_INVALIDATED, this._onShaderInvalidatedDelegate);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic get alpha():number\n\t{\n\t\treturn this._baseMethod.alpha;\n\t}\n\n\tpublic set alpha(value:number)\n\t{\n\t\tthis._baseMethod.alpha = value;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic get epsilon():number\n\t{\n\t\treturn this._baseMethod.epsilon;\n\t}\n\n\tpublic set epsilon(value:number)\n\t{\n\t\tthis._baseMethod.epsilon = value;\n\t}\n\n\t/**\n\t * The amount of shadow fading to the outer shadow area. A value of 1 would mean the shadows start fading from the camera's near plane.\n\t */\n\tpublic get fadeRatio():number\n\t{\n\t\treturn this._fadeRatio;\n\t}\n\n\tpublic set fadeRatio(value:number)\n\t{\n\t\tthis._fadeRatio = value;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentCode(shader:ShaderBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = this._baseMethod.iGetFragmentCode(shader, methodVO, targetReg, registerCache, sharedRegisters);\n\n\t\tvar dataReg:ShaderRegisterElement = registerCache.getFreeFragmentConstant();\n\t\tvar temp:ShaderRegisterElement = registerCache.getFreeFragmentSingleTemp();\n\t\tmethodVO.secondaryFragmentConstantsIndex = dataReg.index*4;\n\n\t\tcode += \"abs \" + temp + \", \" + sharedRegisters.projectionFragment + \".w\\n\" +\n\t\t\t\"sub \" + temp + \", \" + temp + \", \" + dataReg + \".x\\n\" +\n\t\t\t\"mul \" + temp + \", \" + temp + \", \" + dataReg + \".y\\n\" +\n\t\t\t\"sat \" + temp + \", \" + temp + \"\\n\" +\n\t\t\t\"sub \" + temp + \", \" + dataReg + \".w,\" + temp + \"\\n\" +\n\t\t\t\"sub \" + targetReg + \".w, \" + dataReg + \".w,\" + targetReg + \".w\\n\" +\n\t\t\t\"mul \" + targetReg + \".w, \" + targetReg + \".w, \" + temp + \"\\n\" +\n\t\t\t\"sub \" + targetReg + \".w, \" + dataReg + \".w,\" + targetReg + \".w\\n\";\n\n\t\treturn code;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iActivate(shader:ShaderBase, methodVO:MethodVO, stage:Stage)\n\t{\n\t\tthis._baseMethod.iActivate(shader, methodVO, stage);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iDeactivate(shader:ShaderBase, methodVO:MethodVO, stage:Stage)\n\t{\n\t\tthis._baseMethod.iDeactivate(shader, methodVO, stage);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iSetRenderState(shader:ShaderBase, methodVO:MethodVO, renderable:RenderableBase, stage:Stage, camera:Camera)\n\t{\n\t\t// todo: move this to activate (needs camera)\n\t\tvar near:number = camera.projection.near;\n\t\tvar d:number = camera.projection.far - near;\n\t\tvar maxDistance:number = this._nearShadowMapper.coverageRatio;\n\t\tvar minDistance:number = maxDistance*(1 - this._fadeRatio);\n\n\t\tmaxDistance = near + maxDistance*d;\n\t\tminDistance = near + minDistance*d;\n\n\t\tvar fragmentData:Float32Array = shader.fragmentConstantData;\n\t\tvar index:number /*int*/ = methodVO.secondaryFragmentConstantsIndex;\n\t\tfragmentData[index] = minDistance;\n\t\tfragmentData[index + 1] = 1/(maxDistance - minDistance);\n\n\t\tthis._baseMethod.iSetRenderState(shader, methodVO, renderable, stage, camera);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetVertexCode(shader:ShaderBase, methodVO:MethodVO, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\treturn this._baseMethod.iGetVertexCode(shader, methodVO, registerCache, sharedRegisters);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iReset()\n\t{\n\t\tthis._baseMethod.iReset();\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iCleanCompilationData()\n\t{\n\t\tsuper.iCleanCompilationData();\n\t\tthis._baseMethod.iCleanCompilationData();\n\t}\n\n\t/**\n\t * Called when the base method's shader code is invalidated.\n\t */\n\tprivate onShaderInvalidated(event:ShadingMethodEvent)\n\t{\n\t\tthis.iInvalidateShaderProgram();\n\t}\n}\n\nexport = ShadowNearMethod;",
    "import PoissonLookup\t\t\t\t\t= require(\"awayjs-core/lib/geom/PoissonLookup\");\n\nimport DirectionalLight\t\t\t\t\t= require(\"awayjs-display/lib/entities/DirectionalLight\");\n\nimport Stage\t\t\t\t\t\t\t= require(\"awayjs-stagegl/lib/base/Stage\");\n\nimport ShaderBase\t\t\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderBase\");\nimport ShaderRegisterCache\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterCache\");\nimport ShaderRegisterData\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterData\");\nimport ShaderRegisterElement\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterElement\");\n\nimport MethodVO\t\t\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/data/MethodVO\");\nimport ShadowMethodBase\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/methods/ShadowMethodBase\");\n\n/**\n * ShadowSoftMethod provides a soft shadowing technique by randomly distributing sample points.\n */\nclass ShadowSoftMethod extends ShadowMethodBase\n{\n\tprivate _range:number = 1;\n\tprivate _numSamples:number /*int*/;\n\tprivate _offsets:Array<number>;\n\n\t/**\n\t * Creates a new DiffuseBasicMethod object.\n\t *\n\t * @param castingLight The light casting the shadows\n\t * @param numSamples The amount of samples to take for dithering. Minimum 1, maximum 32.\n\t */\n\tconstructor(castingLight:DirectionalLight, numSamples:number /*int*/ = 5, range:number = 1)\n\t{\n\t\tsuper(castingLight);\n\n\t\tthis.numSamples = numSamples;\n\t\tthis.range = range;\n\t}\n\n\t/**\n\t * The amount of samples to take for dithering. Minimum 1, maximum 32. The actual maximum may depend on the\n\t * complexity of the shader.\n\t */\n\tpublic get numSamples():number /*int*/\n\t{\n\t\treturn this._numSamples;\n\t}\n\n\tpublic set numSamples(value:number /*int*/)\n\t{\n\t\tthis._numSamples = value;\n\t\t\n\t\tif (this._numSamples < 1)\n\t\t\tthis._numSamples = 1;\n\t\telse if (this._numSamples > 32)\n\t\t\tthis._numSamples = 32;\n\n\t\tthis._offsets = PoissonLookup.getDistribution(this._numSamples);\n\t\t\n\t\tthis.iInvalidateShaderProgram();\n\t}\n\n\t/**\n\t * The range in the shadow map in which to distribute the samples.\n\t */\n\tpublic get range():number\n\t{\n\t\treturn this._range;\n\t}\n\n\tpublic set range(value:number)\n\t{\n\t\tthis._range = value;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitConstants(shader:ShaderBase, methodVO:MethodVO)\n\t{\n\t\tsuper.iInitConstants(shader, methodVO);\n\n\t\tshader.fragmentConstantData[methodVO.fragmentConstantsIndex + 8] = 1/this._numSamples;\n\t\tshader.fragmentConstantData[methodVO.fragmentConstantsIndex + 9] = 0;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iActivate(shader:ShaderBase, methodVO:MethodVO, stage:Stage)\n\t{\n\t\tsuper.iActivate(shader, methodVO, stage);\n\n\t\tvar texRange:number = .5*this._range/this._pCastingLight.shadowMapper.depthMapSize;\n\t\tvar data:Float32Array = shader.fragmentConstantData;\n\t\tvar index:number /*uint*/ = methodVO.fragmentConstantsIndex + 10;\n\t\tvar len:number /*uint*/ = this._numSamples << 1;\n\n\t\tfor (var i:number /*int*/ = 0; i < len; ++i)\n\t\t\tdata[index + i] = this._offsets[i]*texRange;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic _pGetPlanarFragmentCode(shader:ShaderBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, regCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\t// todo: move some things to super\n\t\tvar decReg:ShaderRegisterElement = regCache.getFreeFragmentConstant();\n\t\tregCache.getFreeFragmentConstant();\n\t\tvar dataReg:ShaderRegisterElement = regCache.getFreeFragmentConstant();\n\n\t\tmethodVO.fragmentConstantsIndex = decReg.index*4;\n\n\t\treturn this.getSampleCode(shader, methodVO, decReg, targetReg, regCache, sharedRegisters, dataReg);\n\t}\n\n\t/**\n\t * Adds the code for another tap to the shader code.\n\t * @param uv The uv register for the tap.\n\t * @param texture The texture register containing the depth map.\n\t * @param decode The register containing the depth map decoding data.\n\t * @param target The target register to add the tap comparison result.\n\t * @param regCache The register cache managing the registers.\n\t * @return\n\t */\n\tprivate addSample(shader:ShaderBase, methodVO:MethodVO, decodeRegister:ShaderRegisterElement, targetRegister:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData, uvReg:ShaderRegisterElement):string\n\t{\n\t\tvar temp:ShaderRegisterElement = registerCache.getFreeFragmentVectorTemp();\n\t\treturn methodVO.textureVO._iGetFragmentCode(temp, registerCache, sharedRegisters, uvReg) +\n\t\t\t\"dp4 \" + temp + \".z, \" + temp + \", \" + decodeRegister + \"\\n\" +\n\t\t\t\"slt \" + uvReg + \".w, \" + this._pDepthMapCoordReg + \".z, \" + temp + \".z\\n\" + // 0 if in shadow\n\t\t\t\"add \" + targetRegister + \".w, \" + targetRegister + \".w, \" + uvReg + \".w\\n\";\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iActivateForCascade(shader:ShaderBase, methodVO:MethodVO, stage:Stage)\n\t{\n\t\tsuper.iActivate(shader, methodVO, stage);\n\n\t\tvar texRange:number = this._range/this._pCastingLight.shadowMapper.depthMapSize;\n\t\tvar data:Float32Array = shader.fragmentConstantData;\n\t\tvar index:number /*uint*/ = methodVO.secondaryFragmentConstantsIndex;\n\t\tvar len:number /*uint*/ = this._numSamples << 1;\n\t\tdata[index] = 1/this._numSamples;\n\t\tdata[index + 1] = 0;\n\t\tindex += 2;\n\n\t\tfor (var i:number /*int*/ = 0; i < len; ++i)\n\t\t\tdata[index + i] = this._offsets[i]*texRange;\n\n\t\tif (len%4 == 0) {\n\t\t\tdata[index + len] = 0;\n\t\t\tdata[index + len + 1] = 0;\n\t\t}\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic _iGetCascadeFragmentCode(shader:ShaderBase, methodVO:MethodVO, decodeRegister:ShaderRegisterElement, depthProjection:ShaderRegisterElement, targetRegister:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tthis._pDepthMapCoordReg = depthProjection;\n\n\t\tvar dataReg:ShaderRegisterElement = registerCache.getFreeFragmentConstant();\n\t\tmethodVO.secondaryFragmentConstantsIndex = dataReg.index*4;\n\n\t\treturn this.getSampleCode(shader, methodVO, decodeRegister, targetRegister, registerCache, sharedRegisters, dataReg);\n\t}\n\n\t/**\n\t * Get the actual shader code for shadow mapping\n\t * @param regCache The register cache managing the registers.\n\t * @param depthTexture The texture register containing the depth map.\n\t * @param decodeRegister The register containing the depth map decoding data.\n\t * @param targetReg The target register to add the shadow coverage.\n\t * @param dataReg The register containing additional data.\n\t */\n\tprivate getSampleCode(shader:ShaderBase, methodVO:MethodVO, decodeRegister:ShaderRegisterElement, targetRegister:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData, dataReg:ShaderRegisterElement):string\n\t{\n\t\tvar code:string;\n\t\tvar uvReg:ShaderRegisterElement = registerCache.getFreeFragmentVectorTemp();\n\t\tregisterCache.addFragmentTempUsages(uvReg, 1);\n\n\t\tvar offsets:Array<string> = new Array<string>(dataReg + \".zw\");\n\t\tvar numRegs:number /*int*/ = this._numSamples >> 1;\n\n\t\tfor (var i:number /*int*/ = 0; i < numRegs; ++i) {\n\t\t\tvar reg:ShaderRegisterElement = registerCache.getFreeFragmentConstant();\n\t\t\toffsets.push(reg + \".xy\");\n\t\t\toffsets.push(reg + \".zw\");\n\t\t}\n\n\t\tfor (i = 0; i < this._numSamples; ++i) {\n\t\t\tif (i == 0) {\n\t\t\t\tvar temp:ShaderRegisterElement = registerCache.getFreeFragmentVectorTemp();\n\n\t\t\t\tcode = \"add \" + uvReg + \", \" + this._pDepthMapCoordReg + \", \" + dataReg + \".zwyy\\n\" +\n\t\t\t\t\tmethodVO.textureVO._iGetFragmentCode(temp, registerCache, sharedRegisters, uvReg) +\n\t\t\t\t\t\"dp4 \" + temp + \".z, \" + temp + \", \" + decodeRegister + \"\\n\" +\n\t\t\t\t\t\"slt \" + targetRegister + \".w, \" + this._pDepthMapCoordReg + \".z, \" + temp + \".z\\n\"; // 0 if in shadow;\n\t\t\t} else {\n\t\t\t\tcode += \"add \" + uvReg + \".xy, \" + this._pDepthMapCoordReg + \".xy, \" + offsets[i] + \"\\n\" +\n\t\t\t\t\tthis.addSample(shader, methodVO, decodeRegister, targetRegister, registerCache, sharedRegisters, uvReg);\n\t\t\t}\n\t\t}\n\n\t\tregisterCache.removeFragmentTempUsage(uvReg);\n\n\t\tcode += \"mul \" + targetRegister + \".w, \" + targetRegister + \".w, \" + dataReg + \".x\\n\"; // average\n\n\t\treturn code;\n\t}\n}\n\nexport = ShadowSoftMethod;",
    "import LightingShader\t\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/LightingShader\");\nimport ShaderRegisterCache\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterCache\");\nimport ShaderRegisterData\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterData\");\nimport ShaderRegisterElement\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterElement\");\n\nimport MethodVO\t\t\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/data/MethodVO\");\nimport SpecularBasicMethod\t\t\t\t= require(\"awayjs-methodmaterials/lib/methods/SpecularBasicMethod\");\n\n/**\n * SpecularAnisotropicMethod provides a specular method resulting in anisotropic highlights. These are typical for\n * surfaces with microfacet details such as tiny grooves. In particular, this uses the Heidrich-Seidel distrubution.\n * The tangent vectors are used as the surface groove directions.\n */\nclass SpecularAnisotropicMethod extends SpecularBasicMethod\n{\n\t/**\n\t * Creates a new SpecularAnisotropicMethod object.\n\t */\n\tconstructor()\n\t{\n\t\tsuper();\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitVO(shader:LightingShader, methodVO:MethodVO)\n\t{\n\t\tmethodVO.needsTangents = true;\n\t\tmethodVO.needsView = true;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentCodePerLight(shader:LightingShader, methodVO:MethodVO, lightDirReg:ShaderRegisterElement, lightColReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = \"\";\n\t\tvar t:ShaderRegisterElement;\n\n\t\tif (this._pIsFirstLight)\n\t\t\tt = this._pTotalLightColorReg;\n\t\telse {\n\t\t\tt = registerCache.getFreeFragmentVectorTemp();\n\t\t\tregisterCache.addFragmentTempUsages(t, 1);\n\t\t}\n\n\t\t// (sin(l,t) * sin(v,t) - cos(l,t)*cos(v,t)) ^ k\n\n\t\tcode += \"nrm \" + t + \".xyz, \" + sharedRegisters.tangentVarying + \".xyz\\n\" +\n\t\t\t\"dp3 \" + t + \".w, \" + t + \".xyz, \" + lightDirReg + \".xyz\\n\" +\n\t\t\t\"dp3 \" + t + \".z, \" + t + \".xyz, \" + sharedRegisters.viewDirFragment + \".xyz\\n\";\n\n\t\t// (sin(t.w) * sin(t.z) - cos(t.w)*cos(t.z)) ^ k\n\t\tcode += \"sin \" + t + \".x, \" + t + \".w\\n\" +\n\t\t\t\"sin \" + t + \".y, \" + t + \".z\\n\" +\n\t\t\t// (t.x * t.y - cos(t.w)*cos(t.z)) ^ k\n\t\t\t\"mul \" + t + \".x, \" + t + \".x, \" + t + \".y\\n\" +\n\t\t\t// (t.x - cos(t.w)*cos(t.z)) ^ k\n\t\t\t\"cos \" + t + \".z, \" + t + \".z\\n\" +\n\t\t\t\"cos \" + t + \".w, \" + t + \".w\\n\" +\n\t\t\t// (t.x - t.w*t.z) ^ k\n\t\t\t\"mul \" + t + \".w, \" + t + \".w, \" + t + \".z\\n\" +\n\t\t\t// (t.x - t.w) ^ k\n\t\t\t\"sub \" + t + \".w, \" + t + \".x, \" + t + \".w\\n\";\n\n\t\tif (this.texture) {\n\t\t\t// apply gloss modulation from texture\n\t\t\tcode += \"mul \" + this._pSpecularTexData + \".w, \" + this._pSpecularTexData + \".y, \" + this._pSpecularDataRegister + \".w\\n\" +\n\t\t\t\t\"pow \" + t + \".w, \" + t + \".w, \" + this._pSpecularTexData + \".w\\n\";\n\t\t} else\n\t\t\tcode += \"pow \" + t + \".w, \" + t + \".w, \" + this._pSpecularDataRegister + \".w\\n\";\n\n\t\t// attenuate\n\t\tcode += \"mul \" + t + \".w, \" + t + \".w, \" + lightDirReg + \".w\\n\";\n\n\t\tif (this._iModulateMethod != null)\n\t\t\tcode += this._iModulateMethod(shader, methodVO, t, registerCache, sharedRegisters);\n\n\t\tcode += \"mul \" + t + \".xyz, \" + lightColReg + \".xyz, \" + t + \".w\\n\";\n\n\t\tif (!this._pIsFirstLight) {\n\t\t\tcode += \"add \" + this._pTotalLightColorReg + \".xyz, \" + this._pTotalLightColorReg + \".xyz, \" + t + \".xyz\\n\";\n\t\t\tregisterCache.removeFragmentTempUsage(t);\n\t\t}\n\n\t\tthis._pIsFirstLight = false;\n\n\t\treturn code;\n\t}\n}\n\nexport = SpecularAnisotropicMethod;",
    "import AssetEvent\t\t\t\t\t\t= require(\"awayjs-core/lib/events/AssetEvent\");\n\nimport Camera\t\t\t\t\t\t\t= require(\"awayjs-display/lib/entities/Camera\");\nimport TextureBase\t\t\t\t\t\t= require(\"awayjs-display/lib/textures/TextureBase\");\n\nimport Stage\t\t\t\t\t\t\t= require(\"awayjs-stagegl/lib/base/Stage\");\n\nimport RenderableBase\t\t\t\t\t= require(\"awayjs-renderergl/lib/renderables/RenderableBase\");\nimport LightingShader\t\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/LightingShader\");\nimport ShaderRegisterCache\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterCache\");\nimport ShaderRegisterData\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterData\");\nimport ShaderRegisterElement\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterElement\");\n\nimport MethodVO\t\t\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/data/MethodVO\");\nimport LightingMethodBase\t\t\t\t= require(\"awayjs-methodmaterials/lib/methods/LightingMethodBase\");\nimport ShadingMethodBase\t\t\t\t= require(\"awayjs-methodmaterials/lib/methods/ShadingMethodBase\");\n\n/**\n * SpecularBasicMethod provides the default shading method for Blinn-Phong specular highlights (an optimized but approximated\n * version of Phong specularity).\n */\nclass SpecularBasicMethod extends LightingMethodBase\n{\n\tpublic _pTotalLightColorReg:ShaderRegisterElement;\n\tpublic _pSpecularTexData:ShaderRegisterElement;\n\tpublic _pSpecularDataRegister:ShaderRegisterElement;\n\n\tprivate _texture:TextureBase;\n\n\tprivate _gloss:number = 50;\n\tprivate _specular:number = 1;\n\tprivate _specularColor:number = 0xffffff;\n\tpublic _iSpecularR:number = 1;\n\tpublic _iSpecularG:number = 1;\n\tpublic _iSpecularB:number = 1;\n\tpublic _pIsFirstLight:boolean;\n\n\t/**\n\t * Creates a new SpecularBasicMethod object.\n\t */\n\tconstructor()\n\t{\n\t\tsuper();\n\t}\n\n\tpublic iIsUsed(shader:LightingShader):boolean\n\t{\n\t\tif (!shader.numLights)\n\t\t\treturn false;\n\n\t\treturn true;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitVO(shader:LightingShader, methodVO:MethodVO)\n\t{\n\t\tmethodVO.needsNormals = shader.numLights > 0;\n\t\tmethodVO.needsView = shader.numLights > 0;\n\n\t\tif (this._texture) {\n\t\t\tmethodVO.textureVO = shader.getAbstraction(this._texture);\n\t\t\tshader.uvDependencies++;\n\t\t} else if (methodVO.textureVO) {\n\t\t\tmethodVO.textureVO.onClear(new AssetEvent(AssetEvent.CLEAR, null));\n\t\t\tmethodVO.textureVO = null;\n\t\t}\n\t}\n\n\t/**\n\t * The sharpness of the specular highlight.\n\t */\n\tpublic get gloss():number\n\t{\n\t\treturn this._gloss;\n\t}\n\n\tpublic set gloss(value:number)\n\t{\n\t\tthis._gloss = value;\n\t}\n\n\t/**\n\t * The overall strength of the specular highlights.\n\t */\n\tpublic get specular():number\n\t{\n\t\treturn this._specular;\n\t}\n\n\tpublic set specular(value:number)\n\t{\n\t\tif (value == this._specular)\n\t\t\treturn;\n\n\t\tthis._specular = value;\n\t\tthis.updateSpecular();\n\t}\n\n\t/**\n\t * The colour of the specular reflection of the surface.\n\t */\n\tpublic get specularColor():number\n\t{\n\t\treturn this._specularColor;\n\t}\n\n\tpublic set specularColor(value:number)\n\t{\n\t\tif (this._specularColor == value)\n\t\t\treturn;\n\n\t\t// specular is now either enabled or disabled\n\t\tif (this._specularColor == 0 || value == 0)\n\t\t\tthis.iInvalidateShaderProgram();\n\n\t\tthis._specularColor = value;\n\t\tthis.updateSpecular();\n\t}\n\n\t/**\n\t * The bitmapData that encodes the specular highlight strength per texel in the red channel, and the sharpness\n\t * in the green channel. You can use SpecularTextureBase if you want to easily set specular and gloss maps\n\t * from grayscale images, but prepared images are preferred.\n\t */\n\tpublic get texture():TextureBase\n\t{\n\t\treturn this._texture;\n\t}\n\n\tpublic set texture(value:TextureBase)\n\t{\n\t\tif (this._texture == value)\n\t\t\treturn;\n\n\t\tif (this._texture)\n\t\t\tthis.iRemoveTexture(this._texture);\n\n\t\tthis._texture = value;\n\n\t\tif (this._texture)\n\t\t\tthis.iAddTexture(this._texture);\n\n\t\tthis.iInvalidateShaderProgram();\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic copyFrom(method:ShadingMethodBase)\n\t{\n\n\t\tvar m:any = method;\n\t\tvar bsm:SpecularBasicMethod = <SpecularBasicMethod> method;\n\n\t\tvar spec:SpecularBasicMethod = bsm;//SpecularBasicMethod(method);\n\t\tthis.texture = spec.texture;\n\t\tthis.specular = spec.specular;\n\t\tthis.specularColor = spec.specularColor;\n\t\tthis.gloss = spec.gloss;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iCleanCompilationData()\n\t{\n\t\tsuper.iCleanCompilationData();\n\t\tthis._pTotalLightColorReg = null;\n\t\tthis._pSpecularTexData = null;\n\t\tthis._pSpecularDataRegister = null;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentPreLightingCode(shader:LightingShader, methodVO:MethodVO, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = \"\";\n\n\t\tthis._pIsFirstLight = true;\n\n\t\tthis._pSpecularDataRegister = registerCache.getFreeFragmentConstant();\n\t\tmethodVO.fragmentConstantsIndex = this._pSpecularDataRegister.index*4;\n\n\t\tif (this._texture) {\n\n\t\t\tthis._pSpecularTexData = registerCache.getFreeFragmentVectorTemp();\n\t\t\tregisterCache.addFragmentTempUsages(this._pSpecularTexData, 1);\n\n\t\t\tcode += methodVO.textureVO._iGetFragmentCode(this._pSpecularTexData, registerCache, sharedRegisters, sharedRegisters.uvVarying);\n\t\t}\n\n\t\tthis._pTotalLightColorReg = registerCache.getFreeFragmentVectorTemp();\n\t\tregisterCache.addFragmentTempUsages(this._pTotalLightColorReg, 1);\n\n\t\treturn code;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentCodePerLight(shader:LightingShader, methodVO:MethodVO, lightDirReg:ShaderRegisterElement, lightColReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = \"\";\n\t\tvar t:ShaderRegisterElement;\n\n\t\tif (this._pIsFirstLight) {\n\t\t\tt = this._pTotalLightColorReg;\n\t\t} else {\n\t\t\tt = registerCache.getFreeFragmentVectorTemp();\n\t\t\tregisterCache.addFragmentTempUsages(t, 1);\n\t\t}\n\n\t\tvar viewDirReg:ShaderRegisterElement = sharedRegisters.viewDirFragment;\n\t\tvar normalReg:ShaderRegisterElement = sharedRegisters.normalFragment;\n\n\t\t// blinn-phong half vector model\n\t\tcode += \"add \" + t + \", \" + lightDirReg + \", \" + viewDirReg + \"\\n\" +\n\t\t\t\t\"nrm \" + t + \".xyz, \" + t + \"\\n\" +\n\t\t\t\t\"dp3 \" + t + \".w, \" + normalReg + \", \" + t + \"\\n\" +\n\t\t\t\t\"sat \" + t + \".w, \" + t + \".w\\n\";\n\n\t\tif (this._texture) {\n\t\t\t// apply gloss modulation from texture\n\t\t\tcode += \"mul \" + this._pSpecularTexData + \".w, \" + this._pSpecularTexData + \".y, \" + this._pSpecularDataRegister + \".w\\n\" +\n\t\t\t\t\t\"pow \" + t + \".w, \" + t + \".w, \" + this._pSpecularTexData + \".w\\n\";\n\t\t} else {\n\t\t\tcode += \"pow \" + t + \".w, \" + t + \".w, \" + this._pSpecularDataRegister + \".w\\n\";\n\t\t}\n\n\t\t// attenuate\n\t\tif (shader.usesLightFallOff)\n\t\t\tcode += \"mul \" + t + \".w, \" + t + \".w, \" + lightDirReg + \".w\\n\";\n\n\t\tif (this._iModulateMethod != null)\n\t\t\tcode += this._iModulateMethod(shader, methodVO, t, registerCache, sharedRegisters);\n\n\t\tcode += \"mul \" + t + \".xyz, \" + lightColReg + \", \" + t + \".w\\n\";\n\n\t\tif (!this._pIsFirstLight) {\n\t\t\tcode += \"add \" + this._pTotalLightColorReg + \".xyz, \" + this._pTotalLightColorReg + \", \" + t + \"\\n\";\n\t\t\tregisterCache.removeFragmentTempUsage(t);\n\t\t}\n\n\t\tthis._pIsFirstLight = false;\n\n\t\treturn code;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentCodePerProbe(shader:LightingShader, methodVO:MethodVO, cubeMapReg:ShaderRegisterElement, weightRegister:string, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = \"\";\n\t\tvar t:ShaderRegisterElement;\n\n\t\t// write in temporary if not first light, so we can add to total diffuse colour\n\t\tif (this._pIsFirstLight) {\n\t\t\tt = this._pTotalLightColorReg;\n\t\t} else {\n\t\t\tt = registerCache.getFreeFragmentVectorTemp();\n\t\t\tregisterCache.addFragmentTempUsages(t, 1);\n\t\t}\n\n\t\tvar normalReg:ShaderRegisterElement = sharedRegisters.normalFragment;\n\t\tvar viewDirReg:ShaderRegisterElement = sharedRegisters.viewDirFragment;\n\n\t\tcode += \"dp3 \" + t + \".w, \" + normalReg + \", \" + viewDirReg + \"\\n\" +\n\t\t\t\t\"add \" + t + \".w, \" + t + \".w, \" + t + \".w\\n\" +\n\t\t\t\t\"mul \" + t + \", \" + t + \".w, \" + normalReg + \"\\n\" +\n\t\t\t\t\"sub \" + t + \", \" + t + \", \" + viewDirReg + \"\\n\" +\n\t\t\t\t\"tex \" + t + \", \" + t + \", \" + cubeMapReg + \" <cube,\" + (shader.useSmoothTextures? \"linear\":\"nearest\") + \",miplinear>\\n\" +\n\t\t\t\t\"mul \" + t + \".xyz, \" + t + \", \" + weightRegister + \"\\n\";\n\n\t\tif (this._iModulateMethod != null)\n\t\t\tcode += this._iModulateMethod(shader, methodVO, t, registerCache, sharedRegisters);\n\n\t\tif (!this._pIsFirstLight) {\n\t\t\tcode += \"add \" + this._pTotalLightColorReg + \".xyz, \" + this._pTotalLightColorReg + \", \" + t + \"\\n\";\n\t\t\tregisterCache.removeFragmentTempUsage(t);\n\t\t}\n\n\t\tthis._pIsFirstLight = false;\n\n\t\treturn code;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentPostLightingCode(shader:LightingShader, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = \"\";\n\n\t\tif (sharedRegisters.shadowTarget)\n\t\t\tcode += \"mul \" + this._pTotalLightColorReg + \".xyz, \" + this._pTotalLightColorReg + \", \" + sharedRegisters.shadowTarget + \".w\\n\";\n\n\t\tif (this._texture) {\n\t\t\t// apply strength modulation from texture\n\t\t\tcode += \"mul \" + this._pTotalLightColorReg + \".xyz, \" + this._pTotalLightColorReg + \", \" + this._pSpecularTexData + \".x\\n\";\n\t\t\tregisterCache.removeFragmentTempUsage(this._pSpecularTexData);\n\t\t}\n\n\t\t// apply material's specular reflection\n\t\tcode += \"mul \" + this._pTotalLightColorReg + \".xyz, \" + this._pTotalLightColorReg + \", \" + this._pSpecularDataRegister + \"\\n\" +\n\t\t\t\"add \" + targetReg + \".xyz, \" + targetReg + \", \" + this._pTotalLightColorReg + \"\\n\";\n\t\tregisterCache.removeFragmentTempUsage(this._pTotalLightColorReg);\n\n\t\treturn code;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iActivate(shader:LightingShader, methodVO:MethodVO, stage:Stage)\n\t{\n\t\tif (this._texture)\n\t\t\tmethodVO.textureVO.activate();\n\n\t\tvar index:number = methodVO.fragmentConstantsIndex;\n\t\tvar data:Float32Array = shader.fragmentConstantData;\n\t\tdata[index] = this._iSpecularR;\n\t\tdata[index + 1] = this._iSpecularG;\n\t\tdata[index + 2] = this._iSpecularB;\n\t\tdata[index + 3] = this._gloss;\n\t}\n\n\tpublic iSetRenderState(shader:LightingShader, methodVO:MethodVO, renderable:RenderableBase, stage:Stage, camera:Camera)\n\t{\n\t\tif (this._texture)\n\t\t\tmethodVO.textureVO._setRenderState(renderable);\n\t}\n\n\t/**\n\t * Updates the specular color data used by the render state.\n\t */\n\tprivate updateSpecular()\n\t{\n\t\tthis._iSpecularR = (( this._specularColor >> 16) & 0xff)/0xff*this._specular;\n\t\tthis._iSpecularG = (( this._specularColor >> 8) & 0xff)/0xff*this._specular;\n\t\tthis._iSpecularB = ( this._specularColor & 0xff)/0xff*this._specular;\n\t}\n}\n\nexport = SpecularBasicMethod;",
    "import Stage\t\t\t\t\t\t\t= require(\"awayjs-stagegl/lib/base/Stage\");\n\nimport LightingShader\t\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/LightingShader\");\nimport ShaderBase\t\t\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderBase\");\nimport ShaderRegisterCache\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterCache\");\nimport ShaderRegisterData\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterData\");\nimport ShaderRegisterElement\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterElement\");\n\nimport MethodVO\t\t\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/data/MethodVO\");\nimport SpecularBasicMethod\t\t\t\t= require(\"awayjs-methodmaterials/lib/methods/SpecularBasicMethod\");\nimport SpecularCompositeMethod\t\t\t= require(\"awayjs-methodmaterials/lib/methods/SpecularCompositeMethod\");\n\n/**\n * SpecularCelMethod provides a shading method to add specular cel (cartoon) shading.\n */\nclass SpecularCelMethod extends SpecularCompositeMethod\n{\n\tprivate _dataReg:ShaderRegisterElement;\n\tprivate _smoothness:number = .1;\n\tprivate _specularCutOff:number = .1;\n\n\t/**\n\t * Creates a new SpecularCelMethod object.\n\t * @param specularCutOff The threshold at which the specular highlight should be shown.\n\t * @param baseMethod An optional specular method on which the cartoon shading is based. If ommitted, SpecularBasicMethod is used.\n\t */\n\tconstructor(specularCutOff:number = .5, baseMethod:SpecularBasicMethod = null)\n\t{\n\t\tsuper(null, baseMethod);\n\n\t\tthis.baseMethod._iModulateMethod = (shader:ShaderBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData) => this.clampSpecular(shader, methodVO, targetReg, registerCache, sharedRegisters);\n\n\t\tthis._specularCutOff = specularCutOff;\n\t}\n\n\t/**\n\t * The smoothness of the highlight edge.\n\t */\n\tpublic get smoothness():number\n\t{\n\t\treturn this._smoothness;\n\t}\n\n\tpublic set smoothness(value:number)\n\t{\n\t\tthis._smoothness = value;\n\t}\n\n\t/**\n\t * The threshold at which the specular highlight should be shown.\n\t */\n\tpublic get specularCutOff():number\n\t{\n\t\treturn this._specularCutOff;\n\t}\n\n\tpublic set specularCutOff(value:number)\n\t{\n\t\tthis._specularCutOff = value;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iActivate(shader:LightingShader, methodVO:MethodVO, stage:Stage)\n\t{\n\t\tsuper.iActivate(shader, methodVO, stage);\n\n\t\tvar index:number /*int*/ = methodVO.secondaryFragmentConstantsIndex;\n\t\tvar data:Float32Array = shader.fragmentConstantData;\n\t\tdata[index] = this._smoothness;\n\t\tdata[index + 1] = this._specularCutOff;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iCleanCompilationData()\n\t{\n\t\tsuper.iCleanCompilationData();\n\t\tthis._dataReg = null;\n\t}\n\n\t/**\n\t * Snaps the specular shading strength of the wrapped method to zero or one, depending on whether or not it exceeds the specularCutOff\n\t * @param vo The MethodVO used to compile the current shader.\n\t * @param t The register containing the specular strength in the \"w\" component, and either the half-vector or the reflection vector in \"xyz\".\n\t * @param regCache The register cache used for the shader compilation.\n\t * @param sharedRegisters The shared register data for this shader.\n\t * @return The AGAL fragment code for the method.\n\t */\n\tprivate clampSpecular(shader:ShaderBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\treturn \"sub \" + targetReg + \".y, \" + targetReg + \".w, \" + this._dataReg + \".y\\n\" + // x - cutoff\n\t\t\t\"div \" + targetReg + \".y, \" + targetReg + \".y, \" + this._dataReg + \".x\\n\" + // (x - cutoff)/epsilon\n\t\t\t\"sat \" + targetReg + \".y, \" + targetReg + \".y\\n\" +\n\t\t\t\"sge \" + targetReg + \".w, \" + targetReg + \".w, \" + this._dataReg + \".y\\n\" +\n\t\t\t\"mul \" + targetReg + \".w, \" + targetReg + \".w, \" + targetReg + \".y\\n\";\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentPreLightingCode(shader:LightingShader, methodVO:MethodVO, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tthis._dataReg = registerCache.getFreeFragmentConstant();\n\t\tmethodVO.secondaryFragmentConstantsIndex = this._dataReg.index*4;\n\n\t\treturn super.iGetFragmentPreLightingCode(shader, methodVO, registerCache, sharedRegisters);\n\t}\n}\n\nexport = SpecularCelMethod;",
    "import Camera\t\t\t\t\t\t\t= require(\"awayjs-display/lib/entities/Camera\");\nimport TextureBase\t\t\t\t\t\t= require(\"awayjs-display/lib/textures/TextureBase\");\nimport IRenderOwner\t\t\t\t\t\t= require(\"awayjs-display/lib/base/IRenderOwner\");\n\nimport Stage\t\t\t\t\t\t\t= require(\"awayjs-stagegl/lib/base/Stage\");\n\nimport RenderableBase\t\t\t\t\t= require(\"awayjs-renderergl/lib/renderables/RenderableBase\");\nimport ShadingMethodEvent\t\t\t\t= require(\"awayjs-renderergl/lib/events/ShadingMethodEvent\");\nimport LightingShader\t\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/LightingShader\");\nimport ShaderBase\t\t\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderBase\");\nimport ShaderRegisterCache\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterCache\");\nimport ShaderRegisterData\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterData\");\nimport ShaderRegisterElement\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterElement\");\n\nimport MethodVO\t\t\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/data/MethodVO\");\nimport SpecularBasicMethod\t\t\t\t= require(\"awayjs-methodmaterials/lib/methods/SpecularBasicMethod\");\n\n/**\n * SpecularCompositeMethod provides a base class for specular methods that wrap a specular method to alter the\n * calculated specular reflection strength.\n */\nclass SpecularCompositeMethod extends SpecularBasicMethod\n{\n\tprivate _baseMethod:SpecularBasicMethod;\n\n\tprivate _onShaderInvalidatedDelegate:(event:ShadingMethodEvent) => void;\n\n\t/**\n\t * Creates a new <code>SpecularCompositeMethod</code> object.\n\t *\n\t * @param modulateMethod The method which will add the code to alter the base method's strength. It needs to have the signature modSpecular(t:ShaderRegisterElement, regCache:ShaderRegisterCache):string, in which t.w will contain the specular strength and t.xyz will contain the half-vector or the reflection vector.\n\t * @param baseMethod The base specular method on which this method's shading is based.\n\t */\n\tconstructor(modulateMethod:(shader:ShaderBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData) => string, baseMethod:SpecularBasicMethod = null)\n\t{\n\t\tsuper();\n\n\t\tthis._onShaderInvalidatedDelegate = (event:ShadingMethodEvent) => this.onShaderInvalidated(event);\n\n\t\tthis._baseMethod = baseMethod || new SpecularBasicMethod();\n\t\tthis._baseMethod._iModulateMethod = modulateMethod;\n\t\tthis._baseMethod.addEventListener(ShadingMethodEvent.SHADER_INVALIDATED, this._onShaderInvalidatedDelegate);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitVO(shader:LightingShader, methodVO:MethodVO)\n\t{\n\t\tthis._baseMethod.iInitVO(shader, methodVO);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitConstants(shader:ShaderBase, methodVO:MethodVO)\n\t{\n\t\tthis._baseMethod.iInitConstants(shader, methodVO);\n\t}\n\n\n\tpublic iAddOwner(owner:IRenderOwner)\n\t{\n\t\tsuper.iAddOwner(owner);\n\n\t\tthis._baseMethod.iAddOwner(owner);\n\t}\n\n\tpublic iRemoveOwner(owner:IRenderOwner)\n\t{\n\t\tsuper.iRemoveOwner(owner);\n\n\t\tthis._baseMethod.iRemoveOwner(owner);\n\t}\n\n\t/**\n\t * The base specular method on which this method's shading is based.\n\t */\n\tpublic get baseMethod():SpecularBasicMethod\n\t{\n\t\treturn this._baseMethod;\n\t}\n\n\tpublic set baseMethod(value:SpecularBasicMethod)\n\t{\n\t\tif (this._baseMethod == value)\n\t\t\treturn;\n\n\t\tthis._baseMethod.removeEventListener(ShadingMethodEvent.SHADER_INVALIDATED, this._onShaderInvalidatedDelegate);\n\n\t\tthis._baseMethod = value;\n\n\t\tthis._baseMethod.addEventListener(ShadingMethodEvent.SHADER_INVALIDATED, this._onShaderInvalidatedDelegate);\n\n\t\tthis.iInvalidateShaderProgram();\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic get gloss():number\n\t{\n\t\treturn this._baseMethod.gloss;\n\t}\n\n\tpublic set gloss(value:number)\n\t{\n\t\tthis._baseMethod.gloss = value;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic get specular():number\n\t{\n\t\treturn this._baseMethod.specular;\n\t}\n\n\tpublic set specular(value:number)\n\t{\n\t\tthis._baseMethod.specular = value;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic dispose()\n\t{\n\t\tthis._baseMethod.removeEventListener(ShadingMethodEvent.SHADER_INVALIDATED, this._onShaderInvalidatedDelegate);\n\t\tthis._baseMethod.dispose();\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic get texture():TextureBase\n\t{\n\t\treturn this._baseMethod.texture;\n\t}\n\n\tpublic set texture(value:TextureBase)\n\t{\n\t\tthis._baseMethod.texture = value;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iActivate(shader:LightingShader, methodVO:MethodVO, stage:Stage)\n\t{\n\t\tthis._baseMethod.iActivate(shader, methodVO, stage);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iSetRenderState(shader:LightingShader, methodVO:MethodVO, renderable:RenderableBase, stage:Stage, camera:Camera)\n\t{\n\t\tthis._baseMethod.iSetRenderState(shader, methodVO, renderable, stage, camera);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iDeactivate(shader:ShaderBase, methodVO:MethodVO, stage:Stage)\n\t{\n\t\tthis._baseMethod.iDeactivate(shader, methodVO, stage);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetVertexCode(shader:ShaderBase, methodVO:MethodVO, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\treturn this._baseMethod.iGetVertexCode(shader, methodVO, registerCache, sharedRegisters);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentPreLightingCode(shader:LightingShader, methodVO:MethodVO, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\treturn this._baseMethod.iGetFragmentPreLightingCode(shader, methodVO, registerCache, sharedRegisters);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentCodePerLight(shader:LightingShader, methodVO:MethodVO, lightDirReg:ShaderRegisterElement, lightColReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\treturn this._baseMethod.iGetFragmentCodePerLight(shader, methodVO, lightDirReg, lightColReg, registerCache, sharedRegisters);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t * @return\n\t */\n\tpublic iGetFragmentCodePerProbe(shader:LightingShader, methodVO:MethodVO, cubeMapReg:ShaderRegisterElement, weightRegister:string, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\treturn this._baseMethod.iGetFragmentCodePerProbe(shader, methodVO, cubeMapReg, weightRegister, registerCache, sharedRegisters);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentPostLightingCode(shader:LightingShader, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\treturn this._baseMethod.iGetFragmentPostLightingCode(shader, methodVO, targetReg, registerCache, sharedRegisters);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iReset()\n\t{\n\t\tthis._baseMethod.iReset();\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iCleanCompilationData()\n\t{\n\t\tsuper.iCleanCompilationData();\n\t\tthis._baseMethod.iCleanCompilationData();\n\t}\n\n\t/**\n\t * Called when the base method's shader code is invalidated.\n\t */\n\tprivate onShaderInvalidated(event:ShadingMethodEvent)\n\t{\n\t\tthis.iInvalidateShaderProgram();\n\t}\n}\n\nexport = SpecularCompositeMethod;",
    "import Camera\t\t\t\t\t\t\t= require(\"awayjs-display/lib/entities/Camera\");\n\nimport Stage\t\t\t\t\t\t\t= require(\"awayjs-stagegl/lib/base/Stage\");\n\nimport LightingShader\t\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/LightingShader\");\nimport ShaderBase\t\t\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderBase\");\nimport ShaderRegisterCache\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterCache\");\nimport ShaderRegisterData\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterData\");\nimport ShaderRegisterElement\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterElement\");\n\nimport MethodVO\t\t\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/data/MethodVO\");\nimport SpecularBasicMethod\t\t\t\t= require(\"awayjs-methodmaterials/lib/methods/SpecularBasicMethod\");\nimport SpecularCompositeMethod\t\t\t= require(\"awayjs-methodmaterials/lib/methods/SpecularCompositeMethod\");\n\n/**\n * SpecularFresnelMethod provides a specular shading method that causes stronger highlights on grazing view angles.\n */\nclass SpecularFresnelMethod extends SpecularCompositeMethod\n{\n\tprivate _dataReg:ShaderRegisterElement;\n\tprivate _incidentLight:boolean;\n\tprivate _fresnelPower:number = 5;\n\tprivate _normalReflectance:number = .028; // default value for skin\n\n\t/**\n\t * Creates a new SpecularFresnelMethod object.\n\t * @param basedOnSurface Defines whether the fresnel effect should be based on the view angle on the surface (if true), or on the angle between the light and the view.\n\t * @param baseMethod The specular method to which the fresnel equation. Defaults to SpecularBasicMethod.\n\t */\n\tconstructor(basedOnSurface:boolean = true, baseMethod:SpecularBasicMethod = null)\n\t{\n\t\t// may want to offer diff speculars\n\t\tsuper(null, baseMethod);\n\n\t\tthis.baseMethod._iModulateMethod = (shader:ShaderBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData) => this.modulateSpecular(shader, methodVO, targetReg, registerCache, sharedRegisters);\n\n\t\tthis._incidentLight = !basedOnSurface;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitConstants(shader:ShaderBase, methodVO:MethodVO)\n\t{\n\n\t\tvar index:number = methodVO.secondaryFragmentConstantsIndex;\n\t\tshader.fragmentConstantData[index + 2] = 1;\n\t\tshader.fragmentConstantData[index + 3] = 0;\n\t}\n\n\t/**\n\t * Defines whether the fresnel effect should be based on the view angle on the surface (if true), or on the angle between the light and the view.\n\t */\n\tpublic get basedOnSurface():boolean\n\t{\n\t\treturn !this._incidentLight;\n\t}\n\n\tpublic set basedOnSurface(value:boolean)\n\t{\n\t\tif (this._incidentLight != value)\n\t\t\treturn;\n\n\t\tthis._incidentLight = !value;\n\n\t\tthis.iInvalidateShaderProgram();\n\t}\n\n\t/**\n\t * The power used in the Fresnel equation. Higher values make the fresnel effect more pronounced. Defaults to 5.\n\t */\n\tpublic get fresnelPower():number\n\t{\n\t\treturn this._fresnelPower;\n\t}\n\n\tpublic set fresnelPower(value:number)\n\t{\n\t\tthis._fresnelPower = value;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iCleanCompilationData()\n\t{\n\t\tsuper.iCleanCompilationData();\n\t\tthis._dataReg = null;\n\t}\n\n\t/**\n\t * The minimum amount of reflectance, ie the reflectance when the view direction is normal to the surface or light direction.\n\t */\n\tpublic get normalReflectance():number\n\t{\n\t\treturn this._normalReflectance;\n\t}\n\n\tpublic set normalReflectance(value:number)\n\t{\n\t\tthis._normalReflectance = value;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iActivate(shader:LightingShader, methodVO:MethodVO, stage:Stage)\n\t{\n\t\tsuper.iActivate(shader, methodVO, stage);\n\n\t\tvar fragmentData:Float32Array = shader.fragmentConstantData;\n\n\t\tvar index:number = methodVO.secondaryFragmentConstantsIndex;\n\t\tfragmentData[index] = this._normalReflectance;\n\t\tfragmentData[index + 1] = this._fresnelPower;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentPreLightingCode(shader:LightingShader, methodVO:MethodVO, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tthis._dataReg = registerCache.getFreeFragmentConstant();\n\n\t\tmethodVO.secondaryFragmentConstantsIndex = this._dataReg.index*4;\n\n\t\treturn super.iGetFragmentPreLightingCode(shader, methodVO, registerCache, sharedRegisters);\n\t}\n\n\t/**\n\t * Applies the fresnel effect to the specular strength.\n\t *\n\t * @param vo The MethodVO object containing the method data for the currently compiled material pass.\n\t * @param target The register containing the specular strength in the \"w\" component, and the half-vector/reflection vector in \"xyz\".\n\t * @param regCache The register cache used for the shader compilation.\n\t * @param sharedRegisters The shared registers created by the compiler.\n\t * @return The AGAL fragment code for the method.\n\t */\n\tprivate modulateSpecular(shader:ShaderBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string;\n\n\t\tcode = \"dp3 \" + targetReg + \".y, \" + sharedRegisters.viewDirFragment + \".xyz, \" + (this._incidentLight? targetReg : sharedRegisters.normalFragment) + \".xyz\\n\" +   // dot(V, H)\n\t\t\t\"sub \" + targetReg + \".y, \" + this._dataReg + \".z, \" + targetReg + \".y\\n\" +             // base = 1-dot(V, H)\n\t\t\t\"pow \" + targetReg + \".x, \" + targetReg + \".y, \" + this._dataReg + \".y\\n\" +             // exp = pow(base, 5)\n\t\t\t\"sub \" + targetReg + \".y, \" + this._dataReg + \".z, \" + targetReg + \".y\\n\" +             // 1 - exp\n\t\t\t\"mul \" + targetReg + \".y, \" + this._dataReg + \".x, \" + targetReg + \".y\\n\" +             // f0*(1 - exp)\n\t\t\t\"add \" + targetReg + \".y, \" + targetReg + \".x, \" + targetReg + \".y\\n\" +          // exp + f0*(1 - exp)\n\t\t\t\"mul \" + targetReg + \".w, \" + targetReg + \".w, \" + targetReg + \".y\\n\";\n\n\t\treturn code;\n\t}\n\n}\n\nexport = SpecularFresnelMethod;",
    "import LightingShader\t\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/LightingShader\");\nimport ShaderRegisterCache\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterCache\");\nimport ShaderRegisterData\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterData\");\nimport ShaderRegisterElement\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterElement\");\n\nimport MethodVO\t\t\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/data/MethodVO\");\nimport SpecularBasicMethod\t\t\t\t= require(\"awayjs-methodmaterials/lib/methods/SpecularBasicMethod\");\n\n/**\n * SpecularPhongMethod provides a specular method that provides Phong highlights.\n */\nclass SpecularPhongMethod extends SpecularBasicMethod\n{\n\t/**\n\t * Creates a new SpecularPhongMethod object.\n\t */\n\tconstructor()\n\t{\n\t\tsuper();\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentCodePerLight(shader:LightingShader, methodVO:MethodVO, lightDirReg:ShaderRegisterElement, lightColReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = \"\";\n\t\tvar t:ShaderRegisterElement;\n\n\t\tif (this._pIsFirstLight) {\n\t\t\tt = this._pTotalLightColorReg;\n\t\t} else {\n\t\t\tt = registerCache.getFreeFragmentVectorTemp();\n\t\t\tregisterCache.addFragmentTempUsages(t, 1);\n\t\t}\n\n\t\tvar viewDirReg:ShaderRegisterElement =sharedRegisters.viewDirFragment;\n\t\tvar normalReg:ShaderRegisterElement =sharedRegisters.normalFragment;\n\n\t\t// phong model\n\t\tcode += \"dp3 \" + t + \".w, \" + lightDirReg + \", \" + normalReg + \"\\n\" + // sca1 = light.normal\n\n\t\t\t//find the reflected light vector R\n\t\t\t\"add \" + t + \".w, \" + t + \".w, \" + t + \".w\\n\" + // sca1 = sca1*2\n\t\t\t\"mul \" + t + \".xyz, \" + normalReg + \", \" + t + \".w\\n\" + // vec1 = normal*sca1\n\t\t\t\"sub \" + t + \".xyz, \" + t + \", \" + lightDirReg + \"\\n\" + // vec1 = vec1 - light (light vector is negative)\n\n\t\t\t//smooth the edge as incidence angle approaches 90\n\t\t\t\"add \" + t + \".w, \" + t + \".w, \" +sharedRegisters.commons + \".w\\n\" + // sca1 = sca1 + smoothtep;\n\t\t\t\"sat \" + t + \".w, \" + t + \".w\\n\" + // sca1 range 0 - 1\n\t\t\t\"mul \" + t + \".xyz, \" + t + \", \" + t + \".w\\n\" + // vec1 = vec1*sca1\n\n\t\t\t//find the dot product between R and V\n\t\t\t\"dp3 \" + t + \".w, \" + t + \", \" + viewDirReg + \"\\n\" + // sca1 = vec1.view\n\t\t\t\"sat \" + t + \".w, \" + t + \".w\\n\";\n\n\t\tif (this.texture) {\n\t\t\t// apply gloss modulation from texture\n\t\t\tcode += \"mul \" + this._pSpecularTexData + \".w, \" + this._pSpecularTexData + \".y, \" + this._pSpecularDataRegister + \".w\\n\" +\n\t\t\t\t\"pow \" + t + \".w, \" + t + \".w, \" + this._pSpecularTexData + \".w\\n\";\n\t\t} else\n\t\t\tcode += \"pow \" + t + \".w, \" + t + \".w, \" + this._pSpecularDataRegister + \".w\\n\";\n\n\t\t// attenuate\n\t\tif (shader.usesLightFallOff)\n\t\t\tcode += \"mul \" + t + \".w, \" + t + \".w, \" + lightDirReg + \".w\\n\";\n\n\t\tif (this._iModulateMethod != null)\n\t\t\tcode += this._iModulateMethod(shader, methodVO, t, registerCache, sharedRegisters);\n\n\t\tcode += \"mul \" + t + \".xyz, \" + lightColReg + \".xyz, \" + t + \".w\\n\";\n\n\t\tif (!this._pIsFirstLight) {\n\t\t\tcode += \"add \" + this._pTotalLightColorReg + \".xyz, \" + this._pTotalLightColorReg + \".xyz, \" + t + \".xyz\\n\";\n\t\t\tregisterCache.removeFragmentTempUsage(t);\n\t\t}\n\n\t\tthis._pIsFirstLight = false;\n\n\t\treturn code;\n\t}\n}\n\nexport = SpecularPhongMethod;",
    "import BlendMode\t\t\t\t\t\t= require(\"awayjs-core/lib/image/BlendMode\");\nimport ColorTransform\t\t\t\t\t= require(\"awayjs-core/lib/geom/ColorTransform\");\nimport Matrix\t\t\t\t\t\t\t= require(\"awayjs-core/lib/geom/Matrix\");\nimport Matrix3D\t\t\t\t\t\t\t= require(\"awayjs-core/lib/geom/Matrix3D\");\nimport Matrix3DUtils\t\t\t\t\t= require(\"awayjs-core/lib/geom/Matrix3DUtils\");\nimport Vector3D\t\t\t\t\t\t\t= require(\"awayjs-core/lib/geom/Vector3D\");\nimport AbstractMethodError\t\t\t\t= require(\"awayjs-core/lib/errors/AbstractMethodError\");\nimport AssetEvent\t\t\t\t\t\t= require(\"awayjs-core/lib/events/AssetEvent\");\n\nimport Camera\t\t\t\t\t\t\t= require(\"awayjs-display/lib/entities/Camera\");\nimport IRenderOwner\t\t\t\t\t\t= require(\"awayjs-display/lib/base/IRenderOwner\");\nimport StaticLightPicker\t\t\t\t= require(\"awayjs-display/lib/materials/lightpickers/StaticLightPicker\");\n\nimport ContextGLCompareMode\t\t\t\t= require(\"awayjs-stagegl/lib/base/ContextGLCompareMode\");\n\nimport RendererBase\t\t\t\t\t\t= require(\"awayjs-renderergl/lib/RendererBase\");\nimport ShaderBase\t\t\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderBase\");\nimport ShadingMethodEvent\t\t\t\t= require(\"awayjs-renderergl/lib/events/ShadingMethodEvent\");\nimport RenderableBase\t\t\t\t\t= require(\"awayjs-renderergl/lib/renderables/RenderableBase\");\nimport IRenderableClass\t\t\t\t\t= require(\"awayjs-renderergl/lib/renderables/IRenderableClass\");\nimport RenderBase\t\t\t\t\t\t= require(\"awayjs-renderergl/lib/render/RenderBase\");\nimport RenderPool\t\t\t\t\t\t= require(\"awayjs-renderergl/lib/render/RenderPool\");\n\nimport MethodMaterial\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/MethodMaterial\");\nimport MethodMaterialMode\t\t\t\t= require(\"awayjs-methodmaterials/lib/MethodMaterialMode\");\nimport MethodPassMode\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/render/passes/MethodPassMode\");\nimport MethodPass\t\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/render/passes/MethodPass\");\nimport AmbientBasicMethod\t\t\t\t= require(\"awayjs-methodmaterials/lib/methods/AmbientBasicMethod\");\nimport DiffuseBasicMethod\t\t\t\t= require(\"awayjs-methodmaterials/lib/methods/DiffuseBasicMethod\");\nimport EffectColorTransformMethod\t\t= require(\"awayjs-methodmaterials/lib/methods/EffectColorTransformMethod\");\nimport EffectMethodBase\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/methods/EffectMethodBase\");\nimport LightingMethodBase\t\t\t\t= require(\"awayjs-methodmaterials/lib/methods/LightingMethodBase\");\nimport NormalBasicMethod\t\t\t\t= require(\"awayjs-methodmaterials/lib/methods/NormalBasicMethod\");\nimport ShadowMapMethodBase\t\t\t\t= require(\"awayjs-methodmaterials/lib/methods/ShadowMapMethodBase\");\nimport SpecularBasicMethod\t\t\t\t= require(\"awayjs-methodmaterials/lib/methods/SpecularBasicMethod\");\n\n/**\n * CompiledPass forms an abstract base class for the default compiled pass materials provided by Away3D,\n * using material methods to define their appearance.\n */\nclass MethodMaterialRender extends RenderBase\n{\n\tprivate _material:MethodMaterial;\n\tprivate _pass:MethodPass;\n\tprivate _casterLightPass:MethodPass;\n\tprivate _nonCasterLightPasses:Array<MethodPass>;\n\t\n\t/**\n\t * The maximum total number of lights provided by the light picker.\n\t */\n\tprivate get numLights():number\n\t{\n\t\treturn this._material.lightPicker? this._material.lightPicker.numLightProbes + this._material.lightPicker.numDirectionalLights + this._material.lightPicker.numPointLights + this._material.lightPicker.numCastingDirectionalLights + this._material.lightPicker.numCastingPointLights : 0;\n\t}\n\n\t/**\n\t * The amount of lights that don't cast shadows.\n\t */\n\tprivate get numNonCasters():number\n\t{\n\t\treturn this._material.lightPicker? this._material.lightPicker.numLightProbes + this._material.lightPicker.numDirectionalLights + this._material.lightPicker.numPointLights : 0;\n\t}\n\n\t/**\n\t * Creates a new CompiledPass object.\n\t *\n\t * @param material The material to which this pass belongs.\n\t */\n\tconstructor(material:MethodMaterial, renderableClass:IRenderableClass, pool:RenderPool)\n\t{\n\t\tsuper(material, renderableClass, pool);\n\n\t\tthis._material = material;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic _pUpdateRender()\n\t{\n\t\tsuper._pUpdateRender();\n\n\t\tthis.initPasses();\n\n\t\tthis.setBlendAndCompareModes();\n\n\t\tthis._pClearPasses();\n\n\t\tif (this._material.mode == MethodMaterialMode.MULTI_PASS) {\n\t\t\tif (this._casterLightPass)\n\t\t\t\tthis._pAddPass(this._casterLightPass);\n\n\t\t\tif (this._nonCasterLightPasses)\n\t\t\t\tfor (var i:number = 0; i < this._nonCasterLightPasses.length; ++i)\n\t\t\t\t\tthis._pAddPass(this._nonCasterLightPasses[i]);\n\t\t}\n\n\t\tif (this._pass)\n\t\t\tthis._pAddPass(this._pass);\n\t}\n\n\t/**\n\t * Initializes all the passes and their dependent passes.\n\t */\n\tprivate initPasses()\n\t{\n\t\t// let the effects pass handle everything if there are no lights, when there are effect methods applied\n\t\t// after shading, or when the material mode is single pass.\n\t\tif (this.numLights == 0 || this._material.numEffectMethods > 0 || this._material.mode == MethodMaterialMode.SINGLE_PASS)\n\t\t\tthis.initEffectPass();\n\t\telse if (this._pass)\n\t\t\tthis.removeEffectPass();\n\n\t\t// only use a caster light pass if shadows need to be rendered\n\t\tif (this._material.shadowMethod && this._material.mode == MethodMaterialMode.MULTI_PASS)\n\t\t\tthis.initCasterLightPass();\n\t\telse if (this._casterLightPass)\n\t\t\tthis.removeCasterLightPass();\n\n\t\t// only use non caster light passes if there are lights that don't cast\n\t\tif (this.numNonCasters > 0 && this._material.mode == MethodMaterialMode.MULTI_PASS)\n\t\t\tthis.initNonCasterLightPasses();\n\t\telse if (this._nonCasterLightPasses)\n\t\t\tthis.removeNonCasterLightPasses();\n\t}\n\n\t/**\n\t * Sets up the various blending modes for all screen passes, based on whether or not there are previous passes.\n\t */\n\tprivate setBlendAndCompareModes()\n\t{\n\t\tvar forceSeparateMVP:boolean = Boolean(this._casterLightPass || this._pass);\n\n\t\t// caster light pass is always first if it exists, hence it uses normal blending\n\t\tif (this._casterLightPass) {\n\t\t\tthis._casterLightPass.forceSeparateMVP = forceSeparateMVP;\n\t\t\tthis._casterLightPass.shader.setBlendMode(BlendMode.NORMAL);\n\t\t\tthis._casterLightPass.shader.depthCompareMode = this._material.depthCompareMode;\n\t\t}\n\n\t\tif (this._nonCasterLightPasses) {\n\t\t\tvar firstAdditiveIndex:number = 0;\n\n\t\t\t// if there's no caster light pass, the first non caster light pass will be the first\n\t\t\t// and should use normal blending\n\t\t\tif (!this._casterLightPass) {\n\t\t\t\tthis._nonCasterLightPasses[0].forceSeparateMVP = forceSeparateMVP;\n\t\t\t\tthis._nonCasterLightPasses[0].shader.setBlendMode(BlendMode.NORMAL);\n\t\t\t\tthis._nonCasterLightPasses[0].shader.depthCompareMode = this._material.depthCompareMode;\n\t\t\t\tfirstAdditiveIndex = 1;\n\t\t\t}\n\n\t\t\t// all lighting passes following the first light pass should use additive blending\n\t\t\tfor (var i:number = firstAdditiveIndex; i < this._nonCasterLightPasses.length; ++i) {\n\t\t\t\tthis._nonCasterLightPasses[i].forceSeparateMVP = forceSeparateMVP;\n\t\t\t\tthis._nonCasterLightPasses[i].shader.setBlendMode(BlendMode.ADD);\n\t\t\t\tthis._nonCasterLightPasses[i].shader.depthCompareMode = ContextGLCompareMode.LESS_EQUAL;\n\t\t\t}\n\t\t}\n\n\t\tif (this._casterLightPass || this._nonCasterLightPasses) {\n\t\t\t//cannot be blended by blendmode property if multipass enabled\n\t\t\tthis._pRequiresBlending = false;\n\n\t\t\t// there are light passes, so this should be blended in\n\t\t\tif (this._pass) {\n\t\t\t\tthis._pass.mode = MethodPassMode.EFFECTS;\n\t\t\t\tthis._pass.forceSeparateMVP = forceSeparateMVP;\n\t\t\t\tthis._pass.shader.depthCompareMode = ContextGLCompareMode.LESS_EQUAL;\n\t\t\t\tthis._pass.shader.setBlendMode(BlendMode.LAYER);\n\t\t\t}\n\n\t\t} else if (this._pass) {\n\t\t\tthis._pRequiresBlending = (this._material.blendMode != BlendMode.NORMAL || this._material.alphaBlending || (this._material.colorTransform && this._material.colorTransform.alphaMultiplier < 1));\n\t\t\t// effects pass is the only pass, so it should just blend normally\n\t\t\tthis._pass.mode = MethodPassMode.SUPER_SHADER;\n\t\t\tthis._pass.preserveAlpha = this._pRequiresBlending;\n\t\t\tthis._pass.forceSeparateMVP = false;\n\t\t\tthis._pass.colorTransform = this._material.colorTransform;\n\t\t\tthis._pass.shader.setBlendMode((this._material.blendMode == BlendMode.NORMAL && this._pRequiresBlending)? BlendMode.LAYER : this._material.blendMode);\n\t\t\tthis._pass.shader.depthCompareMode = this._material.depthCompareMode;\n\t\t}\n\t}\n\n\tprivate initCasterLightPass()\n\t{\n\n\t\tif (this._casterLightPass == null)\n\t\t\tthis._casterLightPass = new MethodPass(MethodPassMode.LIGHTING, this, this._material, this._renderableClass, this._stage);\n\n\t\tthis._casterLightPass.lightPicker = new StaticLightPicker([this._material.shadowMethod.castingLight]);\n\t\tthis._casterLightPass.shadowMethod = this._material.shadowMethod;\n\t\tthis._casterLightPass.diffuseMethod = this._material.diffuseMethod;\n\t\tthis._casterLightPass.ambientMethod = this._material.ambientMethod;\n\t\tthis._casterLightPass.normalMethod = this._material.normalMethod;\n\t\tthis._casterLightPass.specularMethod = this._material.specularMethod;\n\t}\n\n\tprivate removeCasterLightPass()\n\t{\n\t\tthis._casterLightPass.dispose();\n\t\tthis._pRemovePass(this._casterLightPass);\n\t\tthis._casterLightPass = null;\n\t}\n\n\tprivate initNonCasterLightPasses()\n\t{\n\t\tthis.removeNonCasterLightPasses();\n\t\tvar pass:MethodPass;\n\t\tvar numDirLights:number = this._material.lightPicker.numDirectionalLights;\n\t\tvar numPointLights:number = this._material.lightPicker.numPointLights;\n\t\tvar numLightProbes:number = this._material.lightPicker.numLightProbes;\n\t\tvar dirLightOffset:number = 0;\n\t\tvar pointLightOffset:number = 0;\n\t\tvar probeOffset:number = 0;\n\n\t\tif (!this._casterLightPass) {\n\t\t\tnumDirLights += this._material.lightPicker.numCastingDirectionalLights;\n\t\t\tnumPointLights += this._material.lightPicker.numCastingPointLights;\n\t\t}\n\n\t\tthis._nonCasterLightPasses = new Array<MethodPass>();\n\n\t\twhile (dirLightOffset < numDirLights || pointLightOffset < numPointLights || probeOffset < numLightProbes) {\n\t\t\tpass = new MethodPass(MethodPassMode.LIGHTING, this, this._material, this._renderableClass, this._stage);\n\t\t\tpass.includeCasters = this._material.shadowMethod == null;\n\t\t\tpass.directionalLightsOffset = dirLightOffset;\n\t\t\tpass.pointLightsOffset = pointLightOffset;\n\t\t\tpass.lightProbesOffset = probeOffset;\n\t\t\tpass.lightPicker = this._material.lightPicker;\n\t\t\tpass.diffuseMethod = this._material.diffuseMethod;\n\t\t\tpass.ambientMethod = this._material.ambientMethod;\n\t\t\tpass.normalMethod = this._material.normalMethod;\n\t\t\tpass.specularMethod = this._material.specularMethod;\n\t\t\tthis._nonCasterLightPasses.push(pass);\n\n\t\t\tdirLightOffset += pass.numDirectionalLights;\n\t\t\tpointLightOffset += pass.numPointLights;\n\t\t\tprobeOffset += pass.numLightProbes;\n\t\t}\n\t}\n\n\tprivate removeNonCasterLightPasses()\n\t{\n\t\tif (!this._nonCasterLightPasses)\n\t\t\treturn;\n\n\t\tfor (var i:number = 0; i < this._nonCasterLightPasses.length; ++i)\n\t\t\tthis._pRemovePass(this._nonCasterLightPasses[i]);\n\n\t\tthis._nonCasterLightPasses = null;\n\t}\n\n\tprivate removeEffectPass()\n\t{\n\t\tif (this._pass.ambientMethod != this._material.ambientMethod)\n\t\t\tthis._pass.ambientMethod.dispose();\n\n\t\tif (this._pass.diffuseMethod != this._material.diffuseMethod)\n\t\t\tthis._pass.diffuseMethod.dispose();\n\n\t\tif (this._pass.specularMethod != this._material.specularMethod)\n\t\t\tthis._pass.specularMethod.dispose();\n\n\t\tif (this._pass.normalMethod != this._material.normalMethod)\n\t\t\tthis._pass.normalMethod.dispose();\n\n\t\tthis._pRemovePass(this._pass);\n\t\tthis._pass = null;\n\t}\n\n\tprivate initEffectPass()\n\t{\n\t\tif (this._pass == null)\n\t\t\tthis._pass = new MethodPass(MethodPassMode.SUPER_SHADER, this, this._material, this._renderableClass, this._stage);\n\n\t\tif (this._material.mode == MethodMaterialMode.SINGLE_PASS) {\n\t\t\tthis._pass.ambientMethod = this._material.ambientMethod;\n\t\t\tthis._pass.diffuseMethod = this._material.diffuseMethod;\n\t\t\tthis._pass.specularMethod = this._material.specularMethod;\n\t\t\tthis._pass.normalMethod = this._material.normalMethod;\n\t\t\tthis._pass.shadowMethod = this._material.shadowMethod;\n\t\t} else if (this._material.mode == MethodMaterialMode.MULTI_PASS) {\n\t\t\tif (this.numLights == 0) {\n\t\t\t\tthis._pass.ambientMethod = this._material.ambientMethod;\n\t\t\t} else {\n\t\t\t\tthis._pass.ambientMethod = null;\n\t\t\t}\n\n\t\t\tthis._pass.preserveAlpha = false;\n\t\t\tthis._pass.normalMethod = this._material.normalMethod;\n\t\t}\n\n\t\t//update effect methods\n\t\tvar i:number = 0;\n\t\tvar effectMethod:EffectMethodBase;\n\t\tvar len:number = Math.max(this._material.numEffectMethods, this._pass.numEffectMethods);\n\n\t\twhile (i < len) {\n\t\t\teffectMethod = this._material.getEffectMethodAt(i);\n\t\t\tif (effectMethod != this._pass.getEffectMethodAt(i)) {\n\t\t\t\tthis._pass.removeEffectMethodAt(i);\n\n\t\t\t\tif (effectMethod != null) {\n\t\t\t\t\tif (i < this._pass.numEffectMethods)\n\t\t\t\t\t\tthis._pass.addEffectMethodAt(effectMethod, i);\n\t\t\t\t\telse\n\t\t\t\t\t\tthis._pass.addEffectMethod(effectMethod);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\ti++;\n\t\t}\n\t}\n\t\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic onClear(event:AssetEvent)\n\t{\n\t\tsuper.onClear(event);\n\n\t\t//TODO\n\t}\n}\n\nexport = MethodMaterialRender;",
    "class PassMode\n{\n\t/**\n\t *\n\t */\n\tpublic static EFFECTS:number = 0x01;\n\n\t/**\n\t *\n\t */\n\tpublic static LIGHTING:number = 0x02;\n\n\t/**\n\t *\n\t */\n\tpublic static SUPER_SHADER:number = 0x03;\n}\n\nexport = PassMode;",
    "import ColorTransform\t\t\t\t\t= require(\"awayjs-core/lib/geom/ColorTransform\");\nimport Matrix\t\t\t\t\t\t\t= require(\"awayjs-core/lib/geom/Matrix\");\nimport Matrix3D\t\t\t\t\t\t\t= require(\"awayjs-core/lib/geom/Matrix3D\");\nimport Matrix3DUtils\t\t\t\t\t= require(\"awayjs-core/lib/geom/Matrix3DUtils\");\nimport Vector3D\t\t\t\t\t\t\t= require(\"awayjs-core/lib/geom/Vector3D\");\nimport AbstractMethodError\t\t\t\t= require(\"awayjs-core/lib/errors/AbstractMethodError\");\nimport AssetEvent\t\t\t\t\t\t= require(\"awayjs-core/lib/events/AssetEvent\");\nimport MaterialBase\t\t\t\t\t\t= require(\"awayjs-display/lib/materials/MaterialBase\");\n\nimport Camera\t\t\t\t\t\t\t= require(\"awayjs-display/lib/entities/Camera\");\nimport IRenderOwner\t\t\t\t\t\t= require(\"awayjs-display/lib/base/IRenderOwner\");\nimport LightPickerBase\t\t\t\t\t= require(\"awayjs-display/lib/materials/lightpickers/LightPickerBase\");\nimport LightSources\t\t\t\t\t\t= require(\"awayjs-display/lib/materials/LightSources\");\n\nimport Stage\t\t\t\t\t\t\t= require(\"awayjs-stagegl/lib/base/Stage\");\n\nimport RendererBase\t\t\t\t\t\t= require(\"awayjs-renderergl/lib/RendererBase\");\nimport LightingShader\t\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/LightingShader\");\nimport ShadingMethodEvent\t\t\t\t= require(\"awayjs-renderergl/lib/events/ShadingMethodEvent\");\nimport ShaderBase\t\t\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderBase\");\nimport ShaderRegisterCache\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterCache\");\nimport ShaderRegisterData\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterData\");\nimport ShaderRegisterElement\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterElement\");\nimport RenderableBase\t\t\t\t\t= require(\"awayjs-renderergl/lib/renderables/RenderableBase\");\nimport PassBase\t\t\t\t\t\t\t= require(\"awayjs-renderergl/lib/render/passes/PassBase\");\nimport ILightingPass\t\t\t\t\t= require(\"awayjs-renderergl/lib/render/passes/ILightingPass\");\nimport IRenderableClass\t\t\t\t\t= require(\"awayjs-renderergl/lib/renderables/IRenderableClass\");\n\nimport MethodVO\t\t\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/data/MethodVO\");\nimport AmbientBasicMethod\t\t\t\t= require(\"awayjs-methodmaterials/lib/methods/AmbientBasicMethod\");\nimport DiffuseBasicMethod\t\t\t\t= require(\"awayjs-methodmaterials/lib/methods/DiffuseBasicMethod\");\nimport EffectColorTransformMethod\t\t= require(\"awayjs-methodmaterials/lib/methods/EffectColorTransformMethod\");\nimport EffectMethodBase\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/methods/EffectMethodBase\");\nimport LightingMethodBase\t\t\t\t= require(\"awayjs-methodmaterials/lib/methods/LightingMethodBase\");\nimport NormalBasicMethod\t\t\t\t= require(\"awayjs-methodmaterials/lib/methods/NormalBasicMethod\");\nimport ShadowMapMethodBase\t\t\t\t= require(\"awayjs-methodmaterials/lib/methods/ShadowMapMethodBase\");\nimport SpecularBasicMethod\t\t\t\t= require(\"awayjs-methodmaterials/lib/methods/SpecularBasicMethod\");\nimport MethodPassMode\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/render/passes/MethodPassMode\");\nimport MethodMaterialRender\t\t\t\t= require(\"awayjs-methodmaterials/lib/render/MethodMaterialRender\");\n\n/**\n * CompiledPass forms an abstract base class for the default compiled pass materials provided by Away3D,\n * using material methods to define their appearance.\n */\nclass MethodPass extends PassBase implements ILightingPass\n{\n\tprivate _maxLights:number = 3;\n\n\tprivate _mode:number = 0x03;\n\tprivate _material:MaterialBase;\n\tprivate _lightPicker:LightPickerBase;\n\n\tprivate _includeCasters:boolean = true;\n\n\tpublic _iColorTransformMethodVO:MethodVO;\n\tpublic _iNormalMethodVO:MethodVO;\n\tpublic _iAmbientMethodVO:MethodVO;\n\tpublic _iShadowMethodVO:MethodVO;\n\tpublic _iDiffuseMethodVO:MethodVO;\n\tpublic _iSpecularMethodVO:MethodVO;\n\tpublic _iMethodVOs:Array<MethodVO> = new Array<MethodVO>();\n\n\tpublic _numEffectDependencies:number = 0;\n\n\tprivate _onLightsChangeDelegate:(event:AssetEvent) => void;\n\tprivate _onMethodInvalidatedDelegate:(event:ShadingMethodEvent) => void;\n\n\tpublic numDirectionalLights:number = 0;\n\n\tpublic numPointLights:number = 0;\n\n\tpublic numLightProbes:number = 0;\n\n\tpublic pointLightsOffset:number = 0;\n\t\n\tpublic directionalLightsOffset:number= 0;\n\t\n\tpublic lightProbesOffset:number = 0;\n\t\n\t/**\n\t *\n\t */\n\tpublic get mode():number\n\t{\n\t\treturn this._mode;\n\t}\n\n\tpublic set mode(value:number)\n\t{\n\t\tif (this._mode == value)\n\t\t\treturn;\n\t\t\n\t\tthis._mode = value;\n\n\t\tthis._updateLights();\n\t}\n\n\t/**\n\t * Indicates whether or not shadow casting lights need to be included.\n\t */\n\tpublic get includeCasters():boolean\n\t{\n\t\treturn this._includeCasters;\n\t}\n\n\tpublic set includeCasters(value:boolean)\n\t{\n\t\tif (this._includeCasters == value)\n\t\t\treturn;\n\n\t\tthis._includeCasters = value;\n\n\t\tthis._updateLights();\n\t}\n\n\t/**\n\t * \n\t * @returns {LightPickerBase}\n\t */\n\tpublic get lightPicker():LightPickerBase\n\t{\n\t\treturn this._lightPicker;\n\t}\n\n\tpublic set lightPicker(value:LightPickerBase)\n\t{\n\t\t//if (this._lightPicker == value)\n\t\t//\treturn;\n\n\t\tif (this._lightPicker)\n\t\t\tthis._lightPicker.removeEventListener(AssetEvent.INVALIDATE, this._onLightsChangeDelegate);\n\n\t\tthis._lightPicker = value;\n\n\t\tif (this._lightPicker)\n\t\t\tthis._lightPicker.addEventListener(AssetEvent.INVALIDATE, this._onLightsChangeDelegate);\n\n\t\tthis._updateLights();\n\t}\n\t\n\t/**\n\t * Whether or not to use fallOff and radius properties for lights. This can be used to improve performance and\n\t * compatibility for constrained mode.\n\t */\n\tpublic get enableLightFallOff():boolean\n\t{\n\t\treturn this._material.enableLightFallOff;\n\t}\n\n\t/**\n\t * Define which light source types to use for diffuse reflections. This allows choosing between regular lights\n\t * and/or light probes for diffuse reflections.\n\t *\n\t * @see away3d.materials.LightSources\n\t */\n\tpublic get diffuseLightSources():number\n\t{\n\t\treturn this._material.diffuseLightSources;\n\t}\n\n\t/**\n\t * Define which light source types to use for specular reflections. This allows choosing between regular lights\n\t * and/or light probes for specular reflections.\n\t *\n\t * @see away3d.materials.LightSources\n\t */\n\tpublic get specularLightSources():number\n\t{\n\t\treturn this._material.specularLightSources;\n\t}\n\n\t/**\n\t * Creates a new CompiledPass object.\n\t *\n\t * @param material The material to which this pass belongs.\n\t */\n\tconstructor(mode:number, render:MethodMaterialRender, renderOwner:MaterialBase, renderableClass:IRenderableClass, stage:Stage)\n\t{\n\t\tsuper(render, renderOwner, renderableClass, stage);\n\n\t\tthis._mode = mode;\n\n\t\tthis._material = renderOwner;\n\n\t\tthis._onLightsChangeDelegate = (event:AssetEvent) => this.onLightsChange(event);\n\t\t\n\t\tthis._onMethodInvalidatedDelegate = (event:ShadingMethodEvent) => this.onMethodInvalidated(event);\n\n\t\tthis.lightPicker = renderOwner.lightPicker;\n\n\t\tif (this._shader == null)\n\t\t\tthis._updateShader();\n\t}\n\n\tprivate _updateShader()\n\t{\n\t\tif ((this.numDirectionalLights || this.numPointLights || this.numLightProbes) && !(this._shader instanceof LightingShader)) {\n\t\t\tif (this._shader != null)\n\t\t\t\tthis._shader.dispose();\n\n\t\t\tthis._shader = new LightingShader(this._renderableClass, this, this._stage);\n\t\t} else if (!(this._shader instanceof ShaderBase)) {\n\t\t\tif (this._shader != null)\n\t\t\t\tthis._shader.dispose();\n\n\t\t\tthis._shader = new ShaderBase(this._renderableClass, this, this._stage);\n\t\t}\n\t}\n\n\t/**\n\t * Initializes the unchanging constant data for this material.\n\t */\n\tpublic _iInitConstantData(shader:ShaderBase)\n\t{\n\t\tsuper._iInitConstantData(shader);\n\n\t\t//Updates method constants if they have changed.\n\t\tvar len:number = this._iMethodVOs.length;\n\t\tfor (var i:number = 0; i < len; ++i)\n\t\t\tthis._iMethodVOs[i].method.iInitConstants(shader, this._iMethodVOs[i]);\n\t}\n\n\t/**\n\t * The ColorTransform object to transform the colour of the material with. Defaults to null.\n\t */\n\tpublic get colorTransform():ColorTransform\n\t{\n\t\treturn this.colorTransformMethod? this.colorTransformMethod.colorTransform : null;\n\t}\n\n\tpublic set colorTransform(value:ColorTransform)\n\t{\n\t\tif (value) {\n\t\t\tif (this.colorTransformMethod == null)\n\t\t\t\tthis.colorTransformMethod = new EffectColorTransformMethod();\n\n\t\t\tthis.colorTransformMethod.colorTransform = value;\n\n\t\t} else if (!value) {\n\t\t\tif (this.colorTransformMethod)\n\t\t\t\tthis.colorTransformMethod = null;\n\t\t}\n\t}\n\n\t/**\n\t * The EffectColorTransformMethod object to transform the colour of the material with. Defaults to null.\n\t */\n\tpublic get colorTransformMethod():EffectColorTransformMethod\n\t{\n\t\treturn this._iColorTransformMethodVO? <EffectColorTransformMethod> this._iColorTransformMethodVO.method : null;\n\t}\n\n\tpublic set colorTransformMethod(value:EffectColorTransformMethod)\n\t{\n\t\tif (this._iColorTransformMethodVO && this._iColorTransformMethodVO.method == value)\n\t\t\treturn;\n\n\t\tif (this._iColorTransformMethodVO) {\n\t\t\tthis._removeDependency(this._iColorTransformMethodVO);\n\t\t\tthis._iColorTransformMethodVO = null;\n\t\t}\n\n\t\tif (value) {\n\t\t\tthis._iColorTransformMethodVO = new MethodVO(value);\n\t\t\tthis._addDependency(this._iColorTransformMethodVO);\n\t\t}\n\t}\n\n\tprivate _removeDependency(methodVO:MethodVO, effectsDependency:boolean = false)\n\t{\n\t\tvar index:number = this._iMethodVOs.indexOf(methodVO);\n\n\t\tif (!effectsDependency)\n\t\t\tthis._numEffectDependencies--;\n\n\t\tmethodVO.method.removeEventListener(ShadingMethodEvent.SHADER_INVALIDATED, this._onMethodInvalidatedDelegate);\n\t\tthis._iMethodVOs.splice(index, 1);\n\n\t\tthis.invalidate();\n\t}\n\n\tprivate _addDependency(methodVO:MethodVO, effectsDependency:boolean = false, index:number = -1)\n\t{\n\t\tmethodVO.method.addEventListener(ShadingMethodEvent.SHADER_INVALIDATED, this._onMethodInvalidatedDelegate);\n\n\t\tif (effectsDependency) {\n\t\t\tif (index != -1)\n\t\t\t\tthis._iMethodVOs.splice(index + this._iMethodVOs.length - this._numEffectDependencies, 0, methodVO);\n\t\t\telse\n\t\t\t\tthis._iMethodVOs.push(methodVO);\n\t\t\tthis._numEffectDependencies++;\n\t\t} else {\n\t\t\tthis._iMethodVOs.splice(this._iMethodVOs.length - this._numEffectDependencies, 0, methodVO);\n\t\t}\n\n\t\tthis.invalidate();\n\t}\n\n\t/**\n\t * Appends an \"effect\" shading method to the shader. Effect methods are those that do not influence the lighting\n\t * but modulate the shaded colour, used for fog, outlines, etc. The method will be applied to the result of the\n\t * methods added prior.\n\t */\n\tpublic addEffectMethod(method:EffectMethodBase)\n\t{\n\t\tthis._addDependency(new MethodVO(method), true);\n\t}\n\n\t/**\n\t * The number of \"effect\" methods added to the material.\n\t */\n\tpublic get numEffectMethods():number\n\t{\n\t\treturn this._numEffectDependencies;\n\t}\n\n\t/**\n\t * Queries whether a given effects method was added to the material.\n\t *\n\t * @param method The method to be queried.\n\t * @return true if the method was added to the material, false otherwise.\n\t */\n\tpublic hasEffectMethod(method:EffectMethodBase):boolean\n\t{\n\t\treturn this.getDependencyForMethod(method) != null;\n\t}\n\n\t/**\n\t * Returns the method added at the given index.\n\t * @param index The index of the method to retrieve.\n\t * @return The method at the given index.\n\t */\n\tpublic getEffectMethodAt(index:number):EffectMethodBase\n\t{\n\t\tif (index < 0 || index > this._numEffectDependencies - 1)\n\t\t\treturn null;\n\n\t\treturn <EffectMethodBase> this._iMethodVOs[index + this._iMethodVOs.length - this._numEffectDependencies].method;\n\t}\n\n\t/**\n\t * Adds an effect method at the specified index amongst the methods already added to the material. Effect\n\t * methods are those that do not influence the lighting but modulate the shaded colour, used for fog, outlines,\n\t * etc. The method will be applied to the result of the methods with a lower index.\n\t */\n\tpublic addEffectMethodAt(method:EffectMethodBase, index:number)\n\t{\n\t\tthis._addDependency(new MethodVO(method), true, index);\n\t}\n\n\t/**\n\t * Removes an effect method from the material.\n\t * @param method The method to be removed.\n\t */\n\tpublic removeEffectMethod(method:EffectMethodBase)\n\t{\n\t\tvar methodVO:MethodVO = this.getDependencyForMethod(method);\n\n\t\tif (methodVO != null)\n\t\t\tthis._removeDependency(methodVO, true);\n\t}\n\n\n\t/**\n\t * remove an effect method at the specified index from the material.\n\t */\n\tpublic removeEffectMethodAt(index:number)\n\t{\n\t\tif (index < 0 || index > this._numEffectDependencies - 1)\n\t\t\treturn;\n\n\t\tvar methodVO:MethodVO = this._iMethodVOs[index + this._iMethodVOs.length - this._numEffectDependencies];\n\n\t\tif (methodVO != null)\n\t\t\tthis._removeDependency(methodVO, true);\n\t}\n\n\n\tprivate getDependencyForMethod(method:EffectMethodBase):MethodVO\n\t{\n\t\tvar len:number = this._iMethodVOs.length;\n\t\tfor (var i:number = 0; i < len; ++i)\n\t\t\tif (this._iMethodVOs[i].method == method)\n\t\t\t\treturn this._iMethodVOs[i];\n\n\t\treturn null;\n\t}\n\n\t/**\n\t * The method used to generate the per-pixel normals. Defaults to NormalBasicMethod.\n\t */\n\tpublic get normalMethod():NormalBasicMethod\n\t{\n\t\treturn this._iNormalMethodVO? <NormalBasicMethod> this._iNormalMethodVO.method : null;\n\t}\n\n\tpublic set normalMethod(value:NormalBasicMethod)\n\t{\n\t\tif (this._iNormalMethodVO && this._iNormalMethodVO.method == value)\n\t\t\treturn;\n\n\t\tif (this._iNormalMethodVO) {\n\t\t\tthis._removeDependency(this._iNormalMethodVO);\n\t\t\tthis._iNormalMethodVO = null;\n\t\t}\n\n\t\tif (value) {\n\t\t\tthis._iNormalMethodVO = new MethodVO(value);\n\t\t\tthis._addDependency(this._iNormalMethodVO);\n\t\t}\n\t}\n\n\t/**\n\t * The method that provides the ambient lighting contribution. Defaults to AmbientBasicMethod.\n\t */\n\tpublic get ambientMethod():AmbientBasicMethod\n\t{\n\t\treturn this._iAmbientMethodVO? <AmbientBasicMethod> this._iAmbientMethodVO.method : null;\n\t}\n\n\tpublic set ambientMethod(value:AmbientBasicMethod)\n\t{\n\t\tif (this._iAmbientMethodVO && this._iAmbientMethodVO.method == value)\n\t\t\treturn;\n\n\t\tif (this._iAmbientMethodVO) {\n\t\t\tthis._removeDependency(this._iAmbientMethodVO);\n\t\t\tthis._iAmbientMethodVO = null;\n\t\t}\n\n\t\tif (value) {\n\t\t\tthis._iAmbientMethodVO = new MethodVO(value);\n\t\t\tthis._addDependency(this._iAmbientMethodVO);\n\t\t}\n\t}\n\n\t/**\n\t * The method used to render shadows cast on this surface, or null if no shadows are to be rendered. Defaults to null.\n\t */\n\tpublic get shadowMethod():ShadowMapMethodBase\n\t{\n\t\treturn this._iShadowMethodVO? <ShadowMapMethodBase> this._iShadowMethodVO.method : null;\n\t}\n\n\tpublic set shadowMethod(value:ShadowMapMethodBase)\n\t{\n\t\tif (this._iShadowMethodVO && this._iShadowMethodVO.method == value)\n\t\t\treturn;\n\n\t\tif (this._iShadowMethodVO) {\n\t\t\tthis._removeDependency(this._iShadowMethodVO);\n\t\t\tthis._iShadowMethodVO = null;\n\t\t}\n\n\t\tif (value) {\n\t\t\tthis._iShadowMethodVO = new MethodVO(value);\n\t\t\tthis._addDependency(this._iShadowMethodVO);\n\t\t}\n\t}\n\n\t/**\n\t * The method that provides the diffuse lighting contribution. Defaults to DiffuseBasicMethod.\n\t */\n\tpublic get diffuseMethod():DiffuseBasicMethod\n\t{\n\t\treturn this._iDiffuseMethodVO? <DiffuseBasicMethod> this._iDiffuseMethodVO.method : null;\n\t}\n\n\tpublic set diffuseMethod(value:DiffuseBasicMethod)\n\t{\n\t\tif (this._iDiffuseMethodVO && this._iDiffuseMethodVO.method == value)\n\t\t\treturn;\n\n\t\tif (this._iDiffuseMethodVO) {\n\t\t\tthis._removeDependency(this._iDiffuseMethodVO);\n\t\t\tthis._iDiffuseMethodVO = null;\n\t\t}\n\n\t\tif (value) {\n\t\t\tthis._iDiffuseMethodVO = new MethodVO(value);\n\t\t\tthis._addDependency(this._iDiffuseMethodVO);\n\t\t}\n\t}\n\n\t/**\n\t * The method that provides the specular lighting contribution. Defaults to SpecularBasicMethod.\n\t */\n\tpublic get specularMethod():SpecularBasicMethod\n\t{\n\t\treturn this._iSpecularMethodVO? <SpecularBasicMethod> this._iSpecularMethodVO.method : null;\n\t}\n\n\tpublic set specularMethod(value:SpecularBasicMethod)\n\t{\n\t\tif (this._iSpecularMethodVO && this._iSpecularMethodVO.method == value)\n\t\t\treturn;\n\n\t\tif (this._iSpecularMethodVO) {\n\t\t\tthis._removeDependency(this._iSpecularMethodVO);\n\t\t\tthis._iSpecularMethodVO = null;\n\t\t}\n\n\t\tif (value) {\n\t\t\tthis._iSpecularMethodVO = new MethodVO(value);\n\t\t\tthis._addDependency(this._iSpecularMethodVO);\n\t\t}\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic dispose()\n\t{\n\t\tif (this._lightPicker)\n\t\t\tthis._lightPicker.removeEventListener(AssetEvent.INVALIDATE, this._onLightsChangeDelegate);\n\n\t\twhile (this._iMethodVOs.length)\n\t\t\tthis._removeDependency(this._iMethodVOs[0]);\n\n\t\tsuper.dispose();\n\n\t\tthis._iMethodVOs = null;\n\t}\n\n\t/**\n\t * Called when any method's shader code is invalidated.\n\t */\n\tprivate onMethodInvalidated(event:ShadingMethodEvent)\n\t{\n\t\tthis.invalidate();\n\t}\n\n\t// RENDER LOOP\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic _iActivate(camera:Camera)\n\t{\n\t\tsuper._iActivate(camera);\n\n\t\tvar methodVO:MethodVO;\n\t\tvar len:number = this._iMethodVOs.length;\n\t\tfor (var i:number = 0; i < len; ++i) {\n\t\t\tmethodVO = this._iMethodVOs[i];\n\t\t\tif (methodVO.useMethod)\n\t\t\t\tmethodVO.method.iActivate(this._shader, methodVO, this._stage);\n\t\t}\n\t}\n\n\t/**\n\t *\n\t *\n\t * @param renderable\n\t * @param stage\n\t * @param camera\n\t */\n\tpublic _iRender(renderable:RenderableBase, camera:Camera, viewProjection:Matrix3D)\n\t{\n\t\tsuper._iRender(renderable, camera, viewProjection);\n\n\t\tvar methodVO:MethodVO;\n\t\tvar len:number = this._iMethodVOs.length;\n\t\tfor (var i:number = 0; i < len; ++i) {\n\t\t\tmethodVO = this._iMethodVOs[i];\n\t\t\tif (methodVO.useMethod)\n\t\t\t\tmethodVO.method.iSetRenderState(this._shader, methodVO, renderable, this._stage, camera);\n\t\t}\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic _iDeactivate()\n\t{\n\t\tsuper._iDeactivate();\n\n\t\tvar methodVO:MethodVO;\n\t\tvar len:number = this._iMethodVOs.length;\n\t\tfor (var i:number = 0; i < len; ++i) {\n\t\t\tmethodVO = this._iMethodVOs[i];\n\t\t\tif (methodVO.useMethod)\n\t\t\t\tmethodVO.method.iDeactivate(this._shader, methodVO, this._stage);\n\t\t}\n\t}\n\n\tpublic _iIncludeDependencies(shader:LightingShader)\n\t{\n\t\tsuper._iIncludeDependencies(shader);\n\n\t\t//TODO: fragment animtion should be compatible with lighting pass\n\t\tshader.usesFragmentAnimation = Boolean(this._mode == MethodPassMode.SUPER_SHADER);\n\n\t\tif (shader.useAlphaPremultiplied && shader.usesBlending)\n\t\t\tshader.usesCommonData = true;\n\n\t\tvar i:number;\n\t\tvar len:number = this._iMethodVOs.length;\n\t\tfor (i = 0; i < len; ++i)\n\t\t\tthis.setupAndCountDependencies(shader, this._iMethodVOs[i]);\n\n\t\tvar usesTangentSpace:boolean = true;\n\n\t\tvar methodVO:MethodVO;\n\t\tfor (i = 0; i < len; ++i) {\n\t\t\tmethodVO = this._iMethodVOs[i];\n\t\t\tif ((methodVO.useMethod = methodVO.method.iIsUsed(shader)) && !methodVO.method.iUsesTangentSpace())\n\t\t\t\tusesTangentSpace = false;\n\t\t}\n\n\t\tshader.outputsNormals = this._iNormalMethodVO && this._iNormalMethodVO.useMethod;\n\t\tshader.outputsTangentNormals = shader.outputsNormals && (<NormalBasicMethod> this._iNormalMethodVO.method).iOutputsTangentNormals();\n\t\tshader.usesTangentSpace = shader.outputsTangentNormals && !shader.usesProbes && usesTangentSpace;\n\n\t\tif (!shader.usesTangentSpace) {\n\t\t\tif (shader.viewDirDependencies > 0) {\n\t\t\t\tshader.globalPosDependencies++;\n\t\t\t} else if (this.numPointLights > 0 && shader.usesLights) {\n\t\t\t\tshader.globalPosDependencies++;\n\t\t\t\tif (Boolean(this._mode & MethodPassMode.EFFECTS))\n\t\t\t\t\tshader.usesGlobalPosFragment = true;\n\t\t\t}\n\t\t}\n\t}\n\n\n\t/**\n\t * Counts the dependencies for a given method.\n\t * @param method The method to count the dependencies for.\n\t * @param methodVO The method's data for this material.\n\t */\n\tprivate setupAndCountDependencies(shader:ShaderBase, methodVO:MethodVO)\n\t{\n\t\tmethodVO.reset();\n\n\t\tmethodVO.method.iInitVO(shader, methodVO);\n\n\t\tif (methodVO.needsProjection)\n\t\t\tshader.projectionDependencies++;\n\n\t\tif (methodVO.needsGlobalVertexPos || methodVO.needsGlobalFragmentPos) {\n\n\t\t\tshader.globalPosDependencies++;\n\n\t\t\tif (methodVO.needsGlobalFragmentPos)\n\t\t\t\tshader.usesGlobalPosFragment = true;\n\n\t\t}\n\n\t\tif (methodVO.needsNormals)\n\t\t\tshader.normalDependencies++;\n\n\t\tif (methodVO.needsTangents)\n\t\t\tshader.tangentDependencies++;\n\n\t\tif (methodVO.needsView)\n\t\t\tshader.viewDirDependencies++;\n\t}\n\n\tpublic _iGetPreLightingVertexCode(shader:ShaderBase, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = \"\";\n\n\t\tif (this._iAmbientMethodVO && this._iAmbientMethodVO.useMethod)\n\t\t\tcode += this._iAmbientMethodVO.method.iGetVertexCode(shader, this._iAmbientMethodVO, registerCache, sharedRegisters);\n\n\t\tif (this._iDiffuseMethodVO && this._iDiffuseMethodVO.useMethod)\n\t\t\tcode += this._iDiffuseMethodVO.method.iGetVertexCode(shader, this._iDiffuseMethodVO, registerCache, sharedRegisters);\n\n\t\tif (this._iSpecularMethodVO && this._iSpecularMethodVO.useMethod)\n\t\t\tcode += this._iSpecularMethodVO.method.iGetVertexCode(shader, this._iSpecularMethodVO, registerCache, sharedRegisters);\n\n\t\treturn code;\n\t}\n\n\tpublic _iGetPreLightingFragmentCode(shader:ShaderBase, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = \"\";\n\n\t\tif (this._iAmbientMethodVO && this._iAmbientMethodVO.useMethod) {\n\t\t\tcode += this._iAmbientMethodVO.method.iGetFragmentCode(shader, this._iAmbientMethodVO, sharedRegisters.shadedTarget, registerCache, sharedRegisters);\n\n\t\t\tif (this._iAmbientMethodVO.needsNormals)\n\t\t\t\tregisterCache.removeFragmentTempUsage(sharedRegisters.normalFragment);\n\n\t\t\tif (this._iAmbientMethodVO.needsView)\n\t\t\t\tregisterCache.removeFragmentTempUsage(sharedRegisters.viewDirFragment);\n\t\t}\n\n\t\tif (this._iDiffuseMethodVO && this._iDiffuseMethodVO.useMethod)\n\t\t\tcode += (<LightingMethodBase> this._iDiffuseMethodVO.method).iGetFragmentPreLightingCode(<LightingShader> shader, this._iDiffuseMethodVO, registerCache, sharedRegisters);\n\n\t\tif (this._iSpecularMethodVO && this._iSpecularMethodVO.useMethod)\n\t\t\tcode += (<LightingMethodBase> this._iSpecularMethodVO.method).iGetFragmentPreLightingCode(<LightingShader> shader, this._iSpecularMethodVO, registerCache, sharedRegisters);\n\n\t\treturn code;\n\t}\n\n\tpublic _iGetPerLightDiffuseFragmentCode(shader:LightingShader, lightDirReg:ShaderRegisterElement, diffuseColorReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\treturn (<LightingMethodBase> this._iDiffuseMethodVO.method).iGetFragmentCodePerLight(shader, this._iDiffuseMethodVO, lightDirReg, diffuseColorReg, registerCache, sharedRegisters);\n\t}\n\n\tpublic _iGetPerLightSpecularFragmentCode(shader:LightingShader, lightDirReg:ShaderRegisterElement, specularColorReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\treturn (<LightingMethodBase> this._iSpecularMethodVO.method).iGetFragmentCodePerLight(shader, this._iSpecularMethodVO, lightDirReg, specularColorReg, registerCache, sharedRegisters);\n\t}\n\n\tpublic _iGetPerProbeDiffuseFragmentCode(shader:LightingShader, texReg:ShaderRegisterElement, weightReg:string, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\treturn (<LightingMethodBase> this._iDiffuseMethodVO.method).iGetFragmentCodePerProbe(shader, this._iDiffuseMethodVO, texReg, weightReg, registerCache, sharedRegisters);\n\t}\n\n\tpublic _iGetPerProbeSpecularFragmentCode(shader:LightingShader, texReg:ShaderRegisterElement, weightReg:string, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\treturn (<LightingMethodBase> this._iSpecularMethodVO.method).iGetFragmentCodePerProbe(shader, this._iSpecularMethodVO, texReg, weightReg, registerCache, sharedRegisters);\n\t}\n\n\tpublic _iGetPostLightingVertexCode(shader:LightingShader, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = \"\";\n\n\t\tif (this._iShadowMethodVO)\n\t\t\tcode += this._iShadowMethodVO.method.iGetVertexCode(shader, this._iShadowMethodVO, registerCache, sharedRegisters);\n\n\t\treturn code;\n\t}\n\n\tpublic _iGetPostLightingFragmentCode(shader:LightingShader, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = \"\";\n\n\t\tif (shader.useAlphaPremultiplied && shader.usesBlending) {\n\t\t\tcode += \"add \" + sharedRegisters.shadedTarget + \".w, \" + sharedRegisters.shadedTarget + \".w, \" + sharedRegisters.commons + \".z\\n\" +\n\t\t\t\"div \" + sharedRegisters.shadedTarget + \".xyz, \" + sharedRegisters.shadedTarget + \", \" + sharedRegisters.shadedTarget + \".w\\n\" +\n\t\t\t\"sub \" + sharedRegisters.shadedTarget + \".w, \" + sharedRegisters.shadedTarget + \".w, \" + sharedRegisters.commons + \".z\\n\" +\n\t\t\t\"sat \" + sharedRegisters.shadedTarget + \".xyz, \" + sharedRegisters.shadedTarget + \"\\n\";\n\t\t}\n\n\t\tif (this._iShadowMethodVO)\n\t\t\tcode += this._iShadowMethodVO.method.iGetFragmentCode(shader, this._iShadowMethodVO, sharedRegisters.shadowTarget, registerCache, sharedRegisters);\n\n\t\tif (this._iDiffuseMethodVO && this._iDiffuseMethodVO.useMethod) {\n\t\t\tcode += (<LightingMethodBase> this._iDiffuseMethodVO.method).iGetFragmentPostLightingCode(shader, this._iDiffuseMethodVO, sharedRegisters.shadedTarget, registerCache, sharedRegisters);\n\n\t\t\t// resolve other dependencies as well?\n\t\t\tif (this._iDiffuseMethodVO.needsNormals)\n\t\t\t\tregisterCache.removeFragmentTempUsage(sharedRegisters.normalFragment);\n\n\t\t\tif (this._iDiffuseMethodVO.needsView)\n\t\t\t\tregisterCache.removeFragmentTempUsage(sharedRegisters.viewDirFragment);\n\t\t}\n\n\t\tif (this._iSpecularMethodVO && this._iSpecularMethodVO.useMethod) {\n\t\t\tcode += (<LightingMethodBase> this._iSpecularMethodVO.method).iGetFragmentPostLightingCode(shader, this._iSpecularMethodVO, sharedRegisters.shadedTarget, registerCache, sharedRegisters);\n\t\t\tif (this._iSpecularMethodVO.needsNormals)\n\t\t\t\tregisterCache.removeFragmentTempUsage(sharedRegisters.normalFragment);\n\t\t\tif (this._iSpecularMethodVO.needsView)\n\t\t\t\tregisterCache.removeFragmentTempUsage(sharedRegisters.viewDirFragment);\n\t\t}\n\n\t\tif (this._iShadowMethodVO)\n\t\t\tregisterCache.removeFragmentTempUsage(sharedRegisters.shadowTarget);\n\n\t\treturn code;\n\t}\n\n\n\tpublic _iGetNormalVertexCode(shader:ShaderBase, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\treturn this._iNormalMethodVO.method.iGetVertexCode(shader, this._iNormalMethodVO, registerCache, sharedRegisters);\n\t}\n\n\tpublic _iGetNormalFragmentCode(shader:ShaderBase, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = this._iNormalMethodVO.method.iGetFragmentCode(shader, this._iNormalMethodVO, sharedRegisters.normalFragment, registerCache, sharedRegisters);\n\n\t\tif (this._iNormalMethodVO.needsView)\n\t\t\tregisterCache.removeFragmentTempUsage(sharedRegisters.viewDirFragment);\n\n\t\tif (this._iNormalMethodVO.needsGlobalFragmentPos || this._iNormalMethodVO.needsGlobalVertexPos)\n\t\t\tregisterCache.removeVertexTempUsage(sharedRegisters.globalPositionVertex);\n\n\t\treturn code;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic _iGetVertexCode(shader:ShaderBase, regCache:ShaderRegisterCache, sharedReg:ShaderRegisterData):string\n\t{\n\t\tvar code:string = \"\";\n\t\tvar methodVO:MethodVO;\n\t\tvar len:number = this._iMethodVOs.length;\n\t\tfor (var i:number = len - this._numEffectDependencies; i < len; i++) {\n\t\t\tmethodVO = this._iMethodVOs[i];\n\t\t\tif (methodVO.useMethod) {\n\t\t\t\tcode += methodVO.method.iGetVertexCode(shader, methodVO, regCache, sharedReg);\n\n\t\t\t\tif (methodVO.needsGlobalVertexPos || methodVO.needsGlobalFragmentPos)\n\t\t\t\t\tregCache.removeVertexTempUsage(sharedReg.globalPositionVertex);\n\t\t\t}\n\t\t}\n\n\t\tif (this._iColorTransformMethodVO && this._iColorTransformMethodVO.useMethod)\n\t\t\tcode += this._iColorTransformMethodVO.method.iGetVertexCode(shader, this._iColorTransformMethodVO, regCache, sharedReg);\n\n\t\treturn code;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic _iGetFragmentCode(shader:ShaderBase, regCache:ShaderRegisterCache, sharedReg:ShaderRegisterData):string\n\t{\n\t\tvar code:string = \"\";\n\t\tvar alphaReg:ShaderRegisterElement;\n\n\t\tif (this.preserveAlpha && this._numEffectDependencies > 0) {\n\t\t\talphaReg = regCache.getFreeFragmentSingleTemp();\n\t\t\tregCache.addFragmentTempUsages(alphaReg, 1);\n\t\t\tcode += \"mov \" + alphaReg + \", \" + sharedReg.shadedTarget + \".w\\n\";\n\t\t}\n\n\t\tvar methodVO:MethodVO;\n\t\tvar len:number = this._iMethodVOs.length;\n\t\tfor (var i:number = len - this._numEffectDependencies; i < len; i++) {\n\t\t\tmethodVO = this._iMethodVOs[i];\n\t\t\tif (methodVO.useMethod) {\n\t\t\t\tcode += methodVO.method.iGetFragmentCode(shader, methodVO, sharedReg.shadedTarget, regCache, sharedReg);\n\n\t\t\t\tif (methodVO.needsNormals)\n\t\t\t\t\tregCache.removeFragmentTempUsage(sharedReg.normalFragment);\n\n\t\t\t\tif (methodVO.needsView)\n\t\t\t\t\tregCache.removeFragmentTempUsage(sharedReg.viewDirFragment);\n\n\t\t\t}\n\t\t}\n\n\t\tif (this.preserveAlpha && this._numEffectDependencies > 0) {\n\t\t\tcode += \"mov \" + sharedReg.shadedTarget + \".w, \" + alphaReg + \"\\n\";\n\t\t\tregCache.removeFragmentTempUsage(alphaReg);\n\t\t}\n\n\t\tif (this._iColorTransformMethodVO && this._iColorTransformMethodVO.useMethod)\n\t\t\tcode += this._iColorTransformMethodVO.method.iGetFragmentCode(shader, this._iColorTransformMethodVO, sharedReg.shadedTarget, regCache, sharedReg);\n\n\t\treturn code;\n\t}\n\t/**\n\t * Indicates whether the shader uses any shadows.\n\t */\n\tpublic _iUsesShadows(shader:ShaderBase):boolean\n\t{\n\t\treturn Boolean(this._iShadowMethodVO && (this._lightPicker.castingDirectionalLights.length > 0 || this._lightPicker.castingPointLights.length > 0));\n\t}\n\n\t/**\n\t * Indicates whether the shader uses any specular component.\n\t */\n\tpublic _iUsesSpecular(shader:ShaderBase):boolean\n\t{\n\t\treturn Boolean(this._iSpecularMethodVO);\n\t}\n\n\t/**\n\t * Indicates whether the shader uses any specular component.\n\t */\n\tpublic _iUsesDiffuse(shader:ShaderBase):boolean\n\t{\n\t\treturn Boolean(this._iDiffuseMethodVO);\n\t}\n\n\n\tprivate onLightsChange(event:AssetEvent)\n\t{\n\t\tthis._updateLights();\n\t}\n\n\tprivate _updateLights()\n\t{\n\t\tvar numDirectionalLightsOld:number = this.numDirectionalLights;\n\t\tvar numPointLightsOld:number = this.numPointLights;\n\t\tvar numLightProbesOld:number = this.numLightProbes;\n\n\t\tif (this._lightPicker && (this._mode & MethodPassMode.LIGHTING)) {\n\t\t\tthis.numDirectionalLights = this.calculateNumDirectionalLights(this._lightPicker.numDirectionalLights);\n\t\t\tthis.numPointLights = this.calculateNumPointLights(this._lightPicker.numPointLights);\n\t\t\tthis.numLightProbes = this.calculateNumProbes(this._lightPicker.numLightProbes);\n\n\t\t\tif (this._includeCasters) {\n\t\t\t\tthis.numDirectionalLights += this._lightPicker.numCastingDirectionalLights;\n\t\t\t\tthis.numPointLights += this._lightPicker.numCastingPointLights;\n\t\t\t}\n\n\t\t} else {\n\t\t\tthis.numDirectionalLights = 0;\n\t\t\tthis.numPointLights = 0;\n\t\t\tthis.numLightProbes = 0;\n\t\t}\n\n\t\tif (numDirectionalLightsOld != this.numDirectionalLights || numPointLightsOld != this.numPointLights || numLightProbesOld != this.numLightProbes) {\n\t\t\tthis._updateShader();\n\n\t\t\tthis.invalidate();\n\t\t}\n\t}\n\n\t/**\n\t * Calculates the amount of directional lights this material will support.\n\t * @param numDirectionalLights The maximum amount of directional lights to support.\n\t * @return The amount of directional lights this material will support, bounded by the amount necessary.\n\t */\n\tprivate calculateNumDirectionalLights(numDirectionalLights:number):number\n\t{\n\t\treturn Math.min(numDirectionalLights - this.directionalLightsOffset, this._maxLights);\n\t}\n\n\t/**\n\t * Calculates the amount of point lights this material will support.\n\t * @param numDirectionalLights The maximum amount of point lights to support.\n\t * @return The amount of point lights this material will support, bounded by the amount necessary.\n\t */\n\tprivate calculateNumPointLights(numPointLights:number):number\n\t{\n\t\tvar numFree:number = this._maxLights - this.numDirectionalLights;\n\t\treturn Math.min(numPointLights - this.pointLightsOffset, numFree);\n\t}\n\n\t/**\n\t * Calculates the amount of light probes this material will support.\n\t * @param numDirectionalLights The maximum amount of light probes to support.\n\t * @return The amount of light probes this material will support, bounded by the amount necessary.\n\t */\n\tprivate calculateNumProbes(numLightProbes:number):number\n\t{\n\t\tvar numChannels:number = 0;\n\n\t\tif ((this.specularLightSources & LightSources.PROBES) != 0)\n\t\t\t++numChannels;\n\n\t\tif ((this.diffuseLightSources & LightSources.PROBES) != 0)\n\t\t\t++numChannels;\n\n\t\t// 4 channels available\n\t\treturn Math.min(numLightProbes - this.lightProbesOffset, (4/numChannels) | 0);\n\t}\n}\n\nexport = MethodPass;",
    "import Image2D\t\t\t\t\t\t\t= require(\"awayjs-core/lib/image/Image2D\");\nimport Matrix3D\t\t\t\t\t\t\t= require(\"awayjs-core/lib/geom/Matrix3D\");\n\nimport LightBase\t\t\t\t\t\t= require(\"awayjs-display/lib/base/LightBase\");\nimport TriangleSubGeometry\t\t\t\t= require(\"awayjs-display/lib/base/TriangleSubGeometry\");\nimport Camera\t\t\t\t\t\t\t= require(\"awayjs-display/lib/entities/Camera\");\nimport MaterialBase\t\t\t\t\t\t= require(\"awayjs-display/lib/materials/MaterialBase\");\nimport IRenderOwner\t\t\t\t\t\t= require(\"awayjs-display/lib/base/IRenderOwner\");\nimport Single2DTexture\t\t\t\t\t= require(\"awayjs-display/lib/textures/Single2DTexture\");\nimport TextureBase\t\t\t\t\t\t= require(\"awayjs-display/lib/textures/TextureBase\");\n\nimport ContextGLDrawMode\t\t\t\t= require(\"awayjs-stagegl/lib/base/ContextGLDrawMode\");\nimport ContextGLProgramType\t\t\t\t= require(\"awayjs-stagegl/lib/base/ContextGLProgramType\");\nimport IContextGL\t\t\t\t\t\t= require(\"awayjs-stagegl/lib/base/IContextGL\");\nimport Stage\t\t\t\t\t\t\t= require(\"awayjs-stagegl/lib/base/Stage\");\n\nimport RendererBase\t\t\t\t\t\t= require(\"awayjs-renderergl/lib/RendererBase\");\nimport ShaderBase\t\t\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderBase\");\nimport ShaderRegisterCache\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterCache\");\nimport ShaderRegisterData\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterData\");\nimport PassBase\t\t\t\t\t\t\t= require(\"awayjs-renderergl/lib/render/passes/PassBase\");\nimport IRenderableClass\t\t\t\t\t= require(\"awayjs-renderergl/lib/renderables/IRenderableClass\");\nimport RenderableBase\t\t\t\t\t= require(\"awayjs-renderergl/lib/renderables/RenderableBase\");\nimport RenderBase\t\t\t\t\t\t= require(\"awayjs-renderergl/lib/render/RenderBase\");\nimport SubGeometryVOBase\t\t\t\t= require(\"awayjs-renderergl/lib/vos/SubGeometryVOBase\");\n\n/**\n * The SingleObjectDepthPass provides a material pass that renders a single object to a depth map from the point\n * of view from a light.\n */\nclass SingleObjectDepthPass extends PassBase\n{\n\tprivate _textures:Object;\n\tprivate _projections:Object;\n\tprivate _textureSize:number /*uint*/ = 512;\n\tprivate _polyOffset:Float32Array = new Float32Array([15, 0, 0, 0]);\n\tprivate _enc:Float32Array;\n\tprivate _projectionTexturesInvalid:Boolean = true;\n\n\t/**\n\t * The size of the depth map texture to render to.\n\t */\n\tpublic get textureSize():number\n\t{\n\t\treturn this._textureSize;\n\t}\n\n\tpublic set textureSize(value:number)\n\t{\n\t\tthis._textureSize = value;\n\t}\n\n\t/**\n\t * The amount by which the rendered object will be inflated, to prevent depth map rounding errors.\n\t */\n\tpublic get polyOffset():number\n\t{\n\t\treturn this._polyOffset[0];\n\t}\n\n\tpublic set polyOffset(value:number)\n\t{\n\t\tthis._polyOffset[0] = value;\n\t}\n\n\t/**\n\t * Creates a new SingleObjectDepthPass object.\n\t */\n\tconstructor(render:RenderBase, renderOwner:IRenderOwner, renderableClass:IRenderableClass, stage:Stage)\n\t{\n\t\tsuper(render, renderOwner, renderableClass, stage);\n\n\t\t//this._pNumUsedStreams = 2;\n\t\t//this._pNumUsedVertexConstants = 7;\n\t\t//this._enc = Array<number>(1.0, 255.0, 65025.0, 16581375.0, 1.0/255.0, 1.0/255.0, 1.0/255.0, 0.0);\n\t\t//\n\t\t//this._pAnimatableAttributes = Array<string>(\"va0\", \"va1\");\n\t\t//this._pAnimationTargetRegisters = Array<string>(\"vt0\", \"vt1\");\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic dispose()\n\t{\n\t\tif (this._textures) {\n\t\t\tfor (var key in this._textures) {\n\t\t\t\tvar texture:TextureBase = this._textures[key];\n\t\t\t\ttexture.dispose();\n\t\t\t}\n\t\t\tthis._textures = null;\n\t\t}\n\t}\n\n\t/**\n\t * Updates the projection textures used to contain the depth renders.\n\t */\n\tprivate updateProjectionTextures()\n\t{\n\t\tif (this._textures) {\n\t\t\tfor (var key in this._textures) {\n\t\t\t\tvar texture:TextureBase = this._textures[key];\n\t\t\t\ttexture.dispose();\n\t\t\t}\n\t\t}\n\n\t\tthis._textures = new Object();\n\t\tthis._projections = new Object();\n\t\tthis._projectionTexturesInvalid = false;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic _iGetVertexCode():string\n\t{\n\t\tvar code:string;\n\t\t// offset\n\t\tcode = \"mul vt7, vt1, vc4.x\t\\n\" +\n\t\t\t\t\"add vt7, vt7, vt0\\n\" +\n\t\t\t\t\"mov vt7.w, vt0.w\\n\";\n\t\t// project\n\t\tcode += \"m44 vt2, vt7, vc0\\n\" +\n\t\t\t\t\"mov op, vt2\\n\";\n\n\t\t// perspective divide\n\t\tcode += \"div v0, vt2, vt2.w\\n\";\n\n\t\treturn code;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic _iGetFragmentCode(shader:ShaderBase, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = \"\";\n\n\t\t// encode float -> rgba\n\t\tcode += \"mul ft0, fc0, v0.z\\n\" +\n\t\t\t\t\"frc ft0, ft0\\n\" +\n\t\t\t\t\"mul ft1, ft0.yzww, fc1\\n\" +\n\t\t\t\t\"sub ft0, ft0, ft1\\n\" +\n\t\t\t\t\"mov oc, ft0\\n\";\n\n\t\treturn code;\n\t}\n\n\t/**\n\t * Gets the depth maps rendered for this object from all lights.\n\t * @param renderable The renderable for which to retrieve the depth maps.\n\t * @param stage3DProxy The Stage3DProxy object currently used for rendering.\n\t * @return A list of depth map textures for all supported lights.\n\t */\n\tpublic _iGetDepthMap(renderable:RenderableBase):TextureBase\n\t{\n\t\treturn this._textures[renderable.renderableOwner.id];\n\t}\n\n\t/**\n\t * Retrieves the depth map projection maps for all lights.\n\t * @param renderable The renderable for which to retrieve the projection maps.\n\t * @return A list of projection maps for all supported lights.\n\t */\n\tpublic _iGetProjection(renderable:RenderableBase):Matrix3D\n\t{\n\t\treturn this._projections[renderable.renderableOwner.id];\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic _iRender(renderable:RenderableBase, camera:Camera, viewProjection:Matrix3D)\n\t{\n\t\tvar matrix:Matrix3D;\n\t\tvar context:IContextGL = this._stage.context;\n\t\tvar len:number /*uint*/;\n\t\tvar light:LightBase;\n\t\tvar lights:Array<LightBase> = this._renderOwner.lightPicker.allPickedLights;\n\t\tvar rId:number = renderable.renderableOwner.id;\n\n\t\tif (!this._textures[rId])\n\t\t\tthis._textures[rId] = new Single2DTexture(new Image2D(this._textureSize, this._textureSize));\n\n\t\tif (!this._projections[rId])\n\t\t\tthis._projections[rId] = new Matrix3D();\n\n\t\tlen = lights.length;\n\n\t\t// local position = enough\n\t\tlight = lights[0];\n\n\t\tmatrix = light.iGetObjectProjectionMatrix(renderable.sourceEntity, camera, this._projections[rId]);\n\n\t\tthis._stage.setRenderTarget(this._textures[rId], true);\n\t\tcontext.clear(1.0, 1.0, 1.0);\n\t\tcontext.setProgramConstantsFromMatrix(ContextGLProgramType.VERTEX, 0, matrix, true);\n\t\tcontext.setProgramConstantsFromArray(ContextGLProgramType.FRAGMENT, 0, this._enc, 2);\n\n\t\tvar subGeometryVO:SubGeometryVOBase = renderable.subGeometryVO;\n\t\tvar subGeom:TriangleSubGeometry = <TriangleSubGeometry> subGeometryVO.subGeometry;\n\n\t\tsubGeometryVO.activateVertexBufferVO(0, subGeom.positions);\n\t\tsubGeometryVO.activateVertexBufferVO(1, subGeom.normals);\n\t\tsubGeometryVO.getIndexBufferVO().draw(ContextGLDrawMode.TRIANGLES, 0, subGeometryVO.subGeometry.numElements);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic _iActivate(camera:Camera)\n\t{\n\t\tif (this._projectionTexturesInvalid)\n\t\t\tthis.updateProjectionTextures();\n\n\t\t// never scale\n\t\tsuper._iActivate(camera);\n\n\t\tthis._stage.context.setProgramConstantsFromArray(ContextGLProgramType.VERTEX, 4, this._polyOffset, 1);\n\t}\n}\n\nexport = SingleObjectDepthPass;"
  ],
  "sourceRoot": ""
}