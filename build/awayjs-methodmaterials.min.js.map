{
  "version": 3,
  "sources": [
    "node_modules/browserify/node_modules/browser-pack/_prelude.js",
    "awayjs-methodmaterials/lib/MethodMaterialMode.ts",
    "awayjs-methodmaterials.js",
    "awayjs-methodmaterials/lib/MethodMaterial.ts",
    "awayjs-methodmaterials/lib/data/MethodVO.ts",
    "awayjs-methodmaterials/lib/methods/AmbientBasicMethod.ts",
    "awayjs-methodmaterials/lib/methods/AmbientEnvMapMethod.ts",
    "awayjs-methodmaterials/lib/methods/CurveBasicMethod.ts",
    "awayjs-methodmaterials/lib/methods/DiffuseBasicMethod.ts",
    "awayjs-methodmaterials/lib/methods/DiffuseCelMethod.ts",
    "awayjs-methodmaterials/lib/methods/DiffuseCompositeMethod.ts",
    "awayjs-methodmaterials/lib/methods/DiffuseDepthMethod.ts",
    "awayjs-methodmaterials/lib/methods/DiffuseGradientMethod.ts",
    "awayjs-methodmaterials/lib/methods/DiffuseLightMapMethod.ts",
    "awayjs-methodmaterials/lib/methods/DiffuseSubSurfaceMethod.ts",
    "awayjs-methodmaterials/lib/methods/DiffuseWrapMethod.ts",
    "awayjs-methodmaterials/lib/methods/EffectAlphaMaskMethod.ts",
    "awayjs-methodmaterials/lib/methods/EffectColorMatrixMethod.ts",
    "awayjs-methodmaterials/lib/methods/EffectColorTransformMethod.ts",
    "awayjs-methodmaterials/lib/methods/EffectEnvMapMethod.ts",
    "awayjs-methodmaterials/lib/methods/EffectFogMethod.ts",
    "awayjs-methodmaterials/lib/methods/EffectFresnelEnvMapMethod.ts",
    "awayjs-methodmaterials/lib/methods/EffectLightMapMethod.ts",
    "awayjs-methodmaterials/lib/methods/EffectMethodBase.ts",
    "awayjs-methodmaterials/lib/methods/EffectRefractionEnvMapMethod.ts",
    "awayjs-methodmaterials/lib/methods/EffectRimLightMethod.ts",
    "awayjs-methodmaterials/lib/methods/LightingMethodBase.ts",
    "awayjs-methodmaterials/lib/methods/NormalBasicMethod.ts",
    "awayjs-methodmaterials/lib/methods/NormalHeightMapMethod.ts",
    "awayjs-methodmaterials/lib/methods/NormalSimpleWaterMethod.ts",
    "awayjs-methodmaterials/lib/methods/ShadingMethodBase.ts",
    "awayjs-methodmaterials/lib/methods/ShadowCascadeMethod.ts",
    "awayjs-methodmaterials/lib/methods/ShadowDitheredMethod.ts",
    "awayjs-methodmaterials/lib/methods/ShadowFilteredMethod.ts",
    "awayjs-methodmaterials/lib/methods/ShadowHardMethod.ts",
    "awayjs-methodmaterials/lib/methods/ShadowMapMethodBase.ts",
    "awayjs-methodmaterials/lib/methods/ShadowMethodBase.ts",
    "awayjs-methodmaterials/lib/methods/ShadowNearMethod.ts",
    "awayjs-methodmaterials/lib/methods/ShadowSoftMethod.ts",
    "awayjs-methodmaterials/lib/methods/SpecularAnisotropicMethod.ts",
    "awayjs-methodmaterials/lib/methods/SpecularBasicMethod.ts",
    "awayjs-methodmaterials/lib/methods/SpecularCelMethod.ts",
    "awayjs-methodmaterials/lib/methods/SpecularCompositeMethod.ts",
    "awayjs-methodmaterials/lib/methods/SpecularFresnelMethod.ts",
    "awayjs-methodmaterials/lib/methods/SpecularPhongMethod.ts",
    "awayjs-methodmaterials/lib/render/MethodMaterialRender.ts",
    "awayjs-methodmaterials/lib/render/passes/MethodPassMode.ts",
    "awayjs-methodmaterials/lib/render/passes/MethodPass.ts",
    "awayjs-methodmaterials/lib/render/passes/SingleObjectDepthPass.ts"
  ],
  "names": [
    "require",
    "e",
    "t",
    "n",
    "r",
    "s",
    "o",
    "u",
    "a",
    "i",
    "f",
    "Error",
    "code",
    "l",
    "exports",
    "call",
    "length",
    "awayjs-methodmaterials/lib/MethodMaterialMode",
    "module",
    "MethodMaterialMode",
    "SINGLE_PASS",
    "MULTI_PASS",
    "awayjs-methodmaterials/lib/MethodMaterial",
    "__extends",
    "this",
    "d",
    "b",
    "p",
    "hasOwnProperty",
    "__",
    "constructor",
    "prototype",
    "Image2D",
    "MaterialBase",
    "Single2DTexture",
    "TextureBase",
    "ContextGLCompareMode",
    "RenderPool",
    "AmbientBasicMethod",
    "DiffuseBasicMethod",
    "NormalBasicMethod",
    "SpecularBasicMethod",
    "MethodMaterialRender",
    "MethodMaterial",
    "_super",
    "textureColor",
    "smoothAlpha",
    "repeat",
    "mipmap",
    "_effectMethods",
    "Array",
    "_ambientMethod",
    "_diffuseMethod",
    "_normalMethod",
    "_specularMethod",
    "_depthCompareMode",
    "LESS_EQUAL",
    "_mode",
    "texture",
    "smooth",
    "color",
    "Number",
    "alpha",
    "addRenderable",
    "registerClass",
    "Object",
    "defineProperty",
    "get",
    "assetType",
    "enumerable",
    "configurable",
    "set",
    "value",
    "_pInvalidateRender",
    "copyFrom",
    "_shadowMethod",
    "addEffectMethod",
    "method",
    "push",
    "getEffectMethodAt",
    "index",
    "addEffectMethodAt",
    "splice",
    "removeEffectMethod",
    "indexOf",
    "normalMap",
    "gloss",
    "ambient",
    "specular",
    "ambientColor",
    "diffuseColor",
    "specularColor",
    "register",
    "awayjs-core/lib/data/Image2D",
    "undefined",
    "awayjs-display/lib/materials/MaterialBase",
    "awayjs-display/lib/textures/Single2DTexture",
    "awayjs-display/lib/textures/TextureBase",
    "awayjs-methodmaterials/lib/methods/AmbientBasicMethod",
    "awayjs-methodmaterials/lib/methods/DiffuseBasicMethod",
    "awayjs-methodmaterials/lib/methods/NormalBasicMethod",
    "awayjs-methodmaterials/lib/methods/SpecularBasicMethod",
    "awayjs-methodmaterials/lib/render/MethodMaterialRender",
    "awayjs-renderergl/lib/render/RenderPool",
    "awayjs-stagegl/lib/base/ContextGLCompareMode",
    "awayjs-methodmaterials/lib/data/MethodVO",
    "MethodVO",
    "useMethod",
    "reset",
    "iReset",
    "vertexConstantsIndex",
    "secondaryVertexConstantsIndex",
    "fragmentConstantsIndex",
    "secondaryFragmentConstantsIndex",
    "needsProjection",
    "needsView",
    "needsNormals",
    "needsTangents",
    "needsGlobalVertexPos",
    "needsGlobalFragmentPos",
    "ShadingMethodBase",
    "_color",
    "_alpha",
    "_colorR",
    "_colorG",
    "_colorB",
    "_ambient",
    "iInitVO",
    "shader",
    "methodVO",
    "uvDependencies",
    "iInitConstants",
    "updateColor",
    "m",
    "iGetFragmentCode",
    "targetReg",
    "registerCache",
    "sharedRegisters",
    "_iInitRegisters",
    "_iGetFragmentCode",
    "uvVarying",
    "alphaThreshold",
    "cutOffReg",
    "getFreeFragmentConstant",
    "ambientInputRegister",
    "iActivate",
    "stage",
    "activate",
    "fragmentConstantData",
    "data",
    "awayjs-methodmaterials/lib/methods/ShadingMethodBase",
    "awayjs-methodmaterials/lib/methods/AmbientEnvMapMethod",
    "AmbientEnvMapMethod",
    "regCache",
    "normalFragment",
    "awayjs-methodmaterials/lib/methods/CurveBasicMethod",
    "CurveBasicMethod",
    "LightingMethodBase",
    "_multiply",
    "_diffuseColor",
    "_ambientColor",
    "_diffuseR",
    "_diffuseG",
    "_diffuseB",
    "_ambientR",
    "_ambientG",
    "_ambientB",
    "iIsUsed",
    "numLights",
    "iInvalidateShaderProgram",
    "_texture",
    "textureVO",
    "getTextureVO",
    "dispose",
    "updateDiffuse",
    "updateAmbient",
    "diff",
    "multiply",
    "iCleanCompilationData",
    "_pTotalLightColorReg",
    "iGetFragmentPreLightingCode",
    "_pIsFirstLight",
    "addFragmentTempUsages",
    "getFreeFragmentVectorTemp",
    "iGetFragmentCodePerLight",
    "lightDirReg",
    "lightColReg",
    "commons",
    "usesLightFallOff",
    "_iModulateMethod",
    "removeFragmentTempUsage",
    "iGetFragmentCodePerProbe",
    "cubeMapReg",
    "weightRegister",
    "iGetFragmentPostLightingCode",
    "albedo",
    "shadowTarget",
    "pApplyShadow",
    "ambientColorRegister",
    "diffuseInputRegister",
    "iSetRenderState",
    "renderable",
    "camera",
    "ambientR",
    "ambientG",
    "ambientB",
    "awayjs-methodmaterials/lib/methods/LightingMethodBase",
    "awayjs-methodmaterials/lib/methods/DiffuseCelMethod",
    "DiffuseCompositeMethod",
    "DiffuseCelMethod",
    "levels",
    "baseMethod",
    "_this",
    "_smoothness",
    "clampDiffuse",
    "_levels",
    "_dataReg",
    "awayjs-methodmaterials/lib/methods/DiffuseCompositeMethod",
    "ShadingMethodEvent",
    "modulateMethod",
    "_onShaderInvalidatedDelegate",
    "event",
    "onShaderInvalidated",
    "pBaseMethod",
    "addEventListener",
    "SHADER_INVALIDATED",
    "removeEventListener",
    "iDeactivate",
    "iGetVertexCode",
    "awayjs-renderergl/lib/events/ShadingMethodEvent",
    "awayjs-methodmaterials/lib/methods/DiffuseDepthMethod",
    "DiffuseDepthMethod",
    "temp",
    "decReg",
    "awayjs-methodmaterials/lib/methods/DiffuseGradientMethod",
    "DiffuseGradientMethod",
    "gradient",
    "_gradient",
    "secondaryTextureVO",
    "awayjs-methodmaterials/lib/methods/DiffuseLightMapMethod",
    "DiffuseLightMapMethod",
    "lightMap",
    "blendMode",
    "useSecondaryUV",
    "_useSecondaryUV",
    "_lightMap",
    "secondaryUVDependencies",
    "_blendMode",
    "ADD",
    "MULTIPLY",
    "secondaryUVVarying",
    "awayjs-methodmaterials/lib/methods/DiffuseSubSurfaceMethod",
    "DiffuseSubSurfaceMethod",
    "depthMapSize",
    "depthMapOffset",
    "_translucency",
    "_scatterColor",
    "_scatterR",
    "_scatterG",
    "_scatterB",
    "scatterLight",
    "_scattering",
    "vertexConstantData",
    "_lightProjVarying",
    "_propReg",
    "_lightColorReg",
    "_colorReg",
    "_decReg",
    "_targetReg",
    "scatterColor",
    "lightProjection",
    "toTexRegister",
    "getFreeVertexVectorTemp",
    "getFreeVertexConstant",
    "getFreeVarying",
    "viewDirFragment",
    "_depthPass",
    "_iGetDepthMap",
    "_iGetProjection",
    "copyRawDataTo",
    "awayjs-methodmaterials/lib/methods/DiffuseWrapMethod",
    "DiffuseWrapMethod",
    "wrapFactor",
    "_wrapDataRegister",
    "_wrapFactor",
    "awayjs-methodmaterials/lib/methods/EffectAlphaMaskMethod",
    "EffectMethodBase",
    "EffectAlphaMaskMethod",
    "awayjs-methodmaterials/lib/methods/EffectMethodBase",
    "awayjs-methodmaterials/lib/methods/EffectColorMatrixMethod",
    "EffectColorMatrixMethod",
    "matrix",
    "_matrix",
    "colorMultReg",
    "colorOffsetReg",
    "awayjs-methodmaterials/lib/methods/EffectColorTransformMethod",
    "EffectColorTransformMethod",
    "_colorTransform",
    "colorOffsReg",
    "inv",
    "redMultiplier",
    "greenMultiplier",
    "blueMultiplier",
    "alphaMultiplier",
    "redOffset",
    "greenOffset",
    "blueOffset",
    "alphaOffset",
    "awayjs-methodmaterials/lib/methods/EffectEnvMapMethod",
    "EffectEnvMapMethod",
    "envMap",
    "_envMap",
    "_mask",
    "dataRegister",
    "temp2",
    "awayjs-methodmaterials/lib/methods/EffectFogMethod",
    "EffectFogMethod",
    "minDistance",
    "maxDistance",
    "fogColor",
    "_minDistance",
    "_maxDistance",
    "_fogColor",
    "_fogR",
    "_fogG",
    "_fogB",
    "fogData",
    "projectionFragment",
    "awayjs-methodmaterials/lib/methods/EffectFresnelEnvMapMethod",
    "EffectFresnelEnvMapMethod",
    "_fresnelPower",
    "_normalReflectance",
    "viewDirReg",
    "normalReg",
    "awayjs-methodmaterials/lib/methods/EffectLightMapMethod",
    "EffectLightMapMethod",
    "AbstractMethodError",
    "awayjs-core/lib/errors/AbstractMethodError",
    "awayjs-methodmaterials/lib/methods/EffectRefractionEnvMapMethod",
    "EffectRefractionEnvMapMethod",
    "refractionIndex",
    "dispersionR",
    "dispersionG",
    "dispersionB",
    "_dispersionR",
    "_dispersionG",
    "_dispersionB",
    "_useDispersion",
    "_refractionIndex",
    "useDispersion",
    "data2",
    "refractionDir",
    "refractionColor",
    "awayjs-methodmaterials/lib/methods/EffectRimLightMethod",
    "EffectRimLightMethod",
    "strength",
    "power",
    "blend",
    "_strength",
    "_power",
    "dataRegister2",
    "MIX",
    "_normalMap",
    "normalDependencies",
    "iOutputsTangentNormals",
    "bnm",
    "awayjs-methodmaterials/lib/methods/NormalHeightMapMethod",
    "NormalHeightMapMethod",
    "heightMap",
    "worldWidth",
    "worldHeight",
    "worldDepth",
    "_worldXYRatio",
    "_worldXZRatio",
    "width",
    "height",
    "dataReg",
    "dataReg2",
    "awayjs-methodmaterials/lib/methods/NormalSimpleWaterMethod",
    "NormalSimpleWaterMethod",
    "secondaryNormalMap",
    "_water1OffsetX",
    "_water1OffsetY",
    "_water2OffsetX",
    "_water2OffsetY",
    "_secondaryNormalMap",
    "AssetBase",
    "iUsesTangentSpace",
    "dispatchEvent",
    "awayjs-core/lib/library/AssetBase",
    "awayjs-methodmaterials/lib/methods/ShadowCascadeMethod",
    "Event",
    "DirectionalLight",
    "ShadowMapMethodBase",
    "ShadowCascadeMethod",
    "shadowMethodBase",
    "castingLight",
    "_baseMethod",
    "_pCastingLight",
    "_cascadeShadowMapper",
    "shadowMapper",
    "CHANGE",
    "onCascadeChange",
    "tempVO",
    "depthMap",
    "fragmentData",
    "vertexData",
    "_cascadeProjections",
    "_depthMapCoordVaryings",
    "initProjectionsRegs",
    "numCascades",
    "globalPositionVertex",
    "planeDistanceReg",
    "planeDistances",
    "inQuad",
    "uvCoord",
    "uvProjection",
    "_iGetCascadeFragmentCode",
    "vertexIndex",
    "depth",
    "_pEpsilon",
    "k",
    "getDepthProjections",
    "fragmentIndex",
    "_pAlpha",
    "nearPlaneDistances",
    "_iNearPlaneDistances",
    "iActivateForCascade",
    "awayjs-core/lib/events/Event",
    "awayjs-display/lib/entities/DirectionalLight",
    "awayjs-methodmaterials/lib/methods/ShadowMapMethodBase",
    "awayjs-methodmaterials/lib/methods/ShadowDitheredMethod",
    "BitmapImage2D",
    "ShadowMethodBase",
    "ShadowDitheredMethod",
    "numSamples",
    "range",
    "_depthMapSize",
    "_grainUsages",
    "_grainTexture",
    "initGrainTexture",
    "_numSamples",
    "_range",
    "_grainBitmapImage2D",
    "vec",
    "len",
    "step",
    "g",
    "Math",
    "random",
    "floor",
    "setArray",
    "rect",
    "_pGetPlanarFragmentCode",
    "customDataReg",
    "getSampleCode",
    "uvReg",
    "projectionReg",
    "_pDepthMapCoordReg",
    "addSample",
    "decodeRegister",
    "depthProjection",
    "targetRegister",
    "awayjs-core/lib/data/BitmapImage2D",
    "awayjs-methodmaterials/lib/methods/ShadowMethodBase",
    "awayjs-methodmaterials/lib/methods/ShadowFilteredMethod",
    "ShadowFilteredMethod",
    "size",
    "depthCol",
    "predicate",
    "awayjs-methodmaterials/lib/methods/ShadowHardMethod",
    "ShadowHardMethod",
    "_pGetPointFragmentCode",
    "epsReg",
    "posReg",
    "depthSampleCol",
    "lightDir",
    "globalPositionVarying",
    "castsShadows",
    "_pShadowMapper",
    "PointLight",
    "_pUsePoint",
    "_pGetPointVertexCode",
    "pGetPlanarVertexCode",
    "depthMapProj",
    "iDepthProjection",
    "pow",
    "fallOff",
    "pos",
    "scenePosition",
    "x",
    "y",
    "z",
    "awayjs-display/lib/entities/PointLight",
    "awayjs-methodmaterials/lib/methods/ShadowNearMethod",
    "ShadowNearMethod",
    "fadeRatio",
    "_fadeRatio",
    "_nearShadowMapper",
    "epsilon",
    "getFreeFragmentSingleTemp",
    "near",
    "projection",
    "far",
    "coverageRatio",
    "awayjs-methodmaterials/lib/methods/ShadowSoftMethod",
    "PoissonLookup",
    "ShadowSoftMethod",
    "_offsets",
    "getDistribution",
    "texRange",
    "offsets",
    "numRegs",
    "reg",
    "awayjs-core/lib/geom/PoissonLookup",
    "awayjs-methodmaterials/lib/methods/SpecularAnisotropicMethod",
    "SpecularAnisotropicMethod",
    "tangentVarying",
    "_pSpecularTexData",
    "_pSpecularDataRegister",
    "_gloss",
    "_specular",
    "_specularColor",
    "_iSpecularR",
    "_iSpecularG",
    "_iSpecularB",
    "updateSpecular",
    "bsm",
    "spec",
    "useSmoothTextures",
    "awayjs-methodmaterials/lib/methods/SpecularCelMethod",
    "SpecularCompositeMethod",
    "SpecularCelMethod",
    "specularCutOff",
    "_specularCutOff",
    "clampSpecular",
    "awayjs-methodmaterials/lib/methods/SpecularCompositeMethod",
    "awayjs-methodmaterials/lib/methods/SpecularFresnelMethod",
    "SpecularFresnelMethod",
    "basedOnSurface",
    "modulateSpecular",
    "_incidentLight",
    "awayjs-methodmaterials/lib/methods/SpecularPhongMethod",
    "SpecularPhongMethod",
    "BlendMode",
    "StaticLightPicker",
    "RenderBase",
    "MethodPassMode",
    "MethodPass",
    "pool",
    "material",
    "renderableClass",
    "_material",
    "lightPicker",
    "numLightProbes",
    "numDirectionalLights",
    "numPointLights",
    "numCastingDirectionalLights",
    "numCastingPointLights",
    "_pUpdateRender",
    "initPasses",
    "setBlendAndCompareModes",
    "_pClearPasses",
    "mode",
    "_casterLightPass",
    "_pAddPass",
    "_nonCasterLightPasses",
    "_pass",
    "numEffectMethods",
    "initEffectPass",
    "removeEffectPass",
    "shadowMethod",
    "initCasterLightPass",
    "removeCasterLightPass",
    "numNonCasters",
    "initNonCasterLightPasses",
    "removeNonCasterLightPasses",
    "forceSeparateMVP",
    "Boolean",
    "setBlendMode",
    "NORMAL",
    "depthCompareMode",
    "firstAdditiveIndex",
    "_pRequiresBlending",
    "EFFECTS",
    "LAYER",
    "alphaBlending",
    "colorTransform",
    "SUPER_SHADER",
    "preserveAlpha",
    "LIGHTING",
    "_renderableClass",
    "_stage",
    "diffuseMethod",
    "ambientMethod",
    "normalMethod",
    "specularMethod",
    "_pRemovePass",
    "pass",
    "numDirLights",
    "dirLightOffset",
    "pointLightOffset",
    "probeOffset",
    "includeCasters",
    "directionalLightsOffset",
    "pointLightsOffset",
    "lightProbesOffset",
    "effectMethod",
    "max",
    "removeEffectMethodAt",
    "awayjs-core/lib/data/BlendMode",
    "awayjs-display/lib/materials/lightpickers/StaticLightPicker",
    "awayjs-methodmaterials/lib/render/passes/MethodPass",
    "awayjs-methodmaterials/lib/render/passes/MethodPassMode",
    "awayjs-renderergl/lib/render/RenderBase",
    "PassMode",
    "LightSources",
    "LightingShader",
    "ShaderBase",
    "PassBase",
    "render",
    "renderOwner",
    "_maxLights",
    "_includeCasters",
    "_iMethodVOs",
    "_numEffectDependencies",
    "_onLightsChangeDelegate",
    "onLightsChange",
    "_onMethodInvalidatedDelegate",
    "onMethodInvalidated",
    "_shader",
    "_updateShader",
    "_updateLights",
    "_lightPicker",
    "enableLightFallOff",
    "diffuseLightSources",
    "specularLightSources",
    "_iInitConstantData",
    "colorTransformMethod",
    "_iColorTransformMethodVO",
    "_removeDependency",
    "_addDependency",
    "effectsDependency",
    "invalidatePass",
    "hasEffectMethod",
    "getDependencyForMethod",
    "_iNormalMethodVO",
    "_iAmbientMethodVO",
    "_iShadowMethodVO",
    "_iDiffuseMethodVO",
    "_iSpecularMethodVO",
    "_iActivate",
    "_iRender",
    "viewProjection",
    "_iDeactivate",
    "_iIncludeDependencies",
    "usesFragmentAnimation",
    "setupAndCountDependencies",
    "usesTangentSpace",
    "outputsNormals",
    "outputsTangentNormals",
    "usesProbes",
    "viewDirDependencies",
    "globalPosDependencies",
    "usesLights",
    "usesGlobalPosFragment",
    "projectionDependencies",
    "tangentDependencies",
    "_iGetPreLightingVertexCode",
    "_iGetPreLightingFragmentCode",
    "shadedTarget",
    "_iGetPerLightDiffuseFragmentCode",
    "diffuseColorReg",
    "_iGetPerLightSpecularFragmentCode",
    "specularColorReg",
    "_iGetPerProbeDiffuseFragmentCode",
    "texReg",
    "weightReg",
    "_iGetPerProbeSpecularFragmentCode",
    "_iGetPostLightingVertexCode",
    "_iGetPostLightingFragmentCode",
    "useAlphaPremultiplied",
    "usesBlending",
    "_iGetNormalVertexCode",
    "_iGetNormalFragmentCode",
    "removeVertexTempUsage",
    "_iGetVertexCode",
    "sharedReg",
    "alphaReg",
    "_iUsesShadows",
    "castingDirectionalLights",
    "castingPointLights",
    "_iUsesSpecular",
    "_iUsesDiffuse",
    "numDirectionalLightsOld",
    "numPointLightsOld",
    "numLightProbesOld",
    "calculateNumDirectionalLights",
    "calculateNumPointLights",
    "calculateNumProbes",
    "min",
    "numFree",
    "numChannels",
    "PROBES",
    "awayjs-display/lib/materials/LightSources",
    "awayjs-renderergl/lib/render/passes/PassBase",
    "awayjs-renderergl/lib/shaders/LightingShader",
    "awayjs-renderergl/lib/shaders/ShaderBase",
    "awayjs-methodmaterials/lib/render/passes/SingleObjectDepthPass",
    "TriangleSubGeometry",
    "Matrix3D",
    "ContextGLProgramType",
    "SingleObjectDepthPass",
    "_textureSize",
    "_polyOffset",
    "_projectionTexturesInvalid",
    "_textures",
    "key",
    "updateProjectionTextures",
    "_projections",
    "renderableOwner",
    "id",
    "context",
    "light",
    "lights",
    "_renderOwner",
    "allPickedLights",
    "rId",
    "iGetObjectProjectionMatrix",
    "sourceEntity",
    "setRenderTarget",
    "clear",
    "setProgramConstantsFromMatrix",
    "VERTEX",
    "setProgramConstantsFromArray",
    "FRAGMENT",
    "_enc",
    "activateBuffer",
    "getVertexData",
    "POSITION_DATA",
    "getVertexOffset",
    "POSITION_FORMAT",
    "NORMAL_DATA",
    "NORMAL_FORMAT",
    "drawTriangles",
    "getIndexBuffer",
    "getIndexData",
    "numTriangles",
    "awayjs-core/lib/data/TriangleSubGeometry",
    "awayjs-core/lib/geom/Matrix3D",
    "awayjs-stagegl/lib/base/ContextGLProgramType"
  ],
  "mappings": "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",
  "file": "awayjs-methodmaterials.min.js",
  "sourcesContent": [
    "(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})",
    "class MethodMaterialMode\n{\n\t/**\n\t *\n\t */\n\tpublic static SINGLE_PASS:string = \"singlePass\";\n\n\t/**\n\t *\n\t */\n\tpublic static MULTI_PASS:string = \"multiPass\";\n}\n\nexport = MethodMaterialMode;",
    null,
    "import BlendMode\t\t\t\t\t= require(\"awayjs-core/lib/data/BlendMode\");\nimport Image2D\t\t\t\t\t\t= require(\"awayjs-core/lib/data/Image2D\");\n\nimport IRenderOwner\t\t\t\t\t= require(\"awayjs-display/lib/base/IRenderOwner\");\nimport Camera\t\t\t\t\t\t= require(\"awayjs-display/lib/entities/Camera\");\nimport StaticLightPicker\t\t\t= require(\"awayjs-display/lib/materials/lightpickers/StaticLightPicker\");\nimport MaterialBase\t\t\t\t\t= require(\"awayjs-display/lib/materials/MaterialBase\");\nimport IRender\t\t\t\t\t\t= require(\"awayjs-display/lib/pool/IRender\");\nimport Single2DTexture\t\t\t\t= require(\"awayjs-display/lib/textures/Single2DTexture\");\nimport TextureBase\t\t\t\t\t= require(\"awayjs-display/lib/textures/TextureBase\");\n\nimport ContextGLCompareMode\t\t\t= require(\"awayjs-stagegl/lib/base/ContextGLCompareMode\");\n\nimport RenderPool\t\t\t\t\t= require(\"awayjs-renderergl/lib/render/RenderPool\");\n\nimport MethodMaterialMode\t\t\t= require(\"awayjs-methodmaterials/lib/MethodMaterialMode\");\nimport AmbientBasicMethod\t\t\t= require(\"awayjs-methodmaterials/lib/methods/AmbientBasicMethod\");\nimport DiffuseBasicMethod\t\t\t= require(\"awayjs-methodmaterials/lib/methods/DiffuseBasicMethod\");\nimport EffectMethodBase\t\t\t\t= require(\"awayjs-methodmaterials/lib/methods/EffectMethodBase\");\nimport NormalBasicMethod\t\t\t= require(\"awayjs-methodmaterials/lib/methods/NormalBasicMethod\");\nimport ShadowMapMethodBase\t\t\t= require(\"awayjs-methodmaterials/lib/methods/ShadowMapMethodBase\");\nimport SpecularBasicMethod\t\t\t= require(\"awayjs-methodmaterials/lib/methods/SpecularBasicMethod\");\nimport MethodMaterialRender\t\t\t= require(\"awayjs-methodmaterials/lib/render/MethodMaterialRender\");\n\n/**\n * MethodMaterial forms an abstract base class for the default shaded materials provided by Stage,\n * using material methods to define their appearance.\n */\nclass MethodMaterial extends MaterialBase\n{\n\tpublic static assetType:string = \"[materials MethodMaterial]\";\n\n\tprivate _effectMethods:Array<EffectMethodBase> = new Array<EffectMethodBase>();\n\tprivate _mode:string;\n\n\tprivate _ambientMethod:AmbientBasicMethod = new AmbientBasicMethod();\n\tprivate _shadowMethod:ShadowMapMethodBase;\n\tprivate _diffuseMethod:DiffuseBasicMethod = new DiffuseBasicMethod();\n\tprivate _normalMethod:NormalBasicMethod = new NormalBasicMethod();\n\tprivate _specularMethod:SpecularBasicMethod = new SpecularBasicMethod();\n\n\n\tprivate _depthCompareMode:string = ContextGLCompareMode.LESS_EQUAL;\n\n\tprivate static register = MethodMaterial.addRenderable();\n\n\tprivate static addRenderable()\n\t{\n\t\tRenderPool.registerClass(MethodMaterialRender, MethodMaterial);\n\t}\n\n\t/**\n\t *\n\t */\n\tpublic get assetType():string\n\t{\n\t\treturn MethodMaterial.assetType;\n\t}\n\n\t/**\n\t * Creates a new MethodMaterial object.\n\t *\n\t * @param texture The texture used for the material's albedo color.\n\t * @param smooth Indicates whether the texture should be filtered when sampled. Defaults to true.\n\t * @param repeat Indicates whether the texture should be tiled when sampled. Defaults to false.\n\t * @param mipmap Indicates whether or not any used textures should use mipmapping. Defaults to false.\n\t */\n\tconstructor(texture?:Image2D, smooth?:boolean, repeat?:boolean, mipmap?:boolean);\n\tconstructor(texture?:TextureBase, smooth?:boolean, repeat?:boolean, mipmap?:boolean);\n\tconstructor(color?:number, alpha?:number);\n\tconstructor(textureColor:any = null, smoothAlpha:any = null, repeat:boolean = false, mipmap:boolean = true)\n\t{\n\t\tsuper();\n\n\t\tthis._mode = MethodMaterialMode.SINGLE_PASS;\n\n\t\tif (textureColor instanceof Image2D)\n\t\t\ttextureColor = new Single2DTexture(textureColor);\n\n\t\tif (textureColor instanceof TextureBase) {\n\t\t\tthis.texture = <TextureBase> textureColor;\n\n\t\t\tthis.smooth = (smoothAlpha == null)? true : false;\n\t\t\tthis.repeat = repeat;\n\t\t\tthis.mipmap = mipmap;\n\t\t} else {\n\t\t\tthis.color = (textureColor == null)? 0xFFFFFF : Number(textureColor);\n\t\t\tthis.alpha = (smoothAlpha == null)? 1 : Number(smoothAlpha);\n\t\t}\n\t}\n\n\n\tpublic get mode():string\n\t{\n\t\treturn this._mode;\n\t}\n\n\tpublic set mode(value:string)\n\t{\n\t\tif (this._mode == value)\n\t\t\treturn;\n\n\t\tthis._mode = value;\n\n\t\tthis._pInvalidateRender();\n\t}\n\n\t/**\n\t * The depth compare mode used to render the renderables using this material.\n\t *\n\t * @see away.stagegl.ContextGLCompareMode\n\t */\n\n\tpublic get depthCompareMode():string\n\t{\n\t\treturn this._depthCompareMode;\n\t}\n\n\tpublic set depthCompareMode(value:string)\n\t{\n\t\tif (this._depthCompareMode == value)\n\t\t\treturn;\n\n\t\tthis._depthCompareMode = value;\n\n\t\tthis._pInvalidateRender();\n\t}\n\n\t/**\n\t * The texture object to use for the ambient colour.\n\t */\n\tpublic get diffuseTexture():TextureBase\n\t{\n\t\treturn this._diffuseMethod.texture;\n\t}\n\n\tpublic set diffuseTexture(value:TextureBase)\n\t{\n\t\tthis._diffuseMethod.texture = value;\n\t}\n\n\t/**\n\t * The method that provides the ambient lighting contribution. Defaults to AmbientBasicMethod.\n\t */\n\tpublic get ambientMethod():AmbientBasicMethod\n\t{\n\t\treturn this._ambientMethod;\n\t}\n\n\tpublic set ambientMethod(value:AmbientBasicMethod)\n\t{\n\t\tif (this._ambientMethod == value)\n\t\t\treturn;\n\n\t\tif (value && this._ambientMethod)\n\t\t\tvalue.copyFrom(this._ambientMethod);\n\n\t\tthis._ambientMethod = value;\n\n\t\tthis._pInvalidateRender();\n\t}\n\n\t/**\n\t * The method used to render shadows cast on this surface, or null if no shadows are to be rendered. Defaults to null.\n\t */\n\tpublic get shadowMethod():ShadowMapMethodBase\n\t{\n\t\treturn this._shadowMethod;\n\t}\n\n\tpublic set shadowMethod(value:ShadowMapMethodBase)\n\t{\n\t\tif (this._shadowMethod == value)\n\t\t\treturn;\n\n\t\tif (value && this._shadowMethod)\n\t\t\tvalue.copyFrom(this._shadowMethod);\n\n\t\tthis._shadowMethod = value;\n\n\t\tthis._pInvalidateRender();\n\t}\n\n\t/**\n\t * The method that provides the diffuse lighting contribution. Defaults to DiffuseBasicMethod.\n\t */\n\tpublic get diffuseMethod():DiffuseBasicMethod\n\t{\n\t\treturn this._diffuseMethod;\n\t}\n\n\tpublic set diffuseMethod(value:DiffuseBasicMethod)\n\t{\n\t\tif (this._diffuseMethod == value)\n\t\t\treturn;\n\n\t\tif (value && this._diffuseMethod)\n\t\t\tvalue.copyFrom(this._diffuseMethod);\n\n\t\tthis._diffuseMethod = value;\n\n\t\tthis._pInvalidateRender();\n\t}\n\n\t/**\n\t * The method that provides the specular lighting contribution. Defaults to SpecularBasicMethod.\n\t */\n\tpublic get specularMethod():SpecularBasicMethod\n\t{\n\t\treturn this._specularMethod;\n\t}\n\n\tpublic set specularMethod(value:SpecularBasicMethod)\n\t{\n\t\tif (this._specularMethod == value)\n\t\t\treturn;\n\n\t\tif (value && this._specularMethod)\n\t\t\tvalue.copyFrom(this._specularMethod);\n\n\t\tthis._specularMethod = value;\n\n\t\tthis._pInvalidateRender();\n\t}\n\n\t/**\n\t * The method used to generate the per-pixel normals. Defaults to NormalBasicMethod.\n\t */\n\tpublic get normalMethod():NormalBasicMethod\n\t{\n\t\treturn this._normalMethod;\n\t}\n\n\tpublic set normalMethod(value:NormalBasicMethod)\n\t{\n\t\tif (this._normalMethod == value)\n\t\t\treturn;\n\n\t\tif (value && this._normalMethod)\n\t\t\tvalue.copyFrom(this._normalMethod);\n\n\t\tthis._normalMethod = value;\n\n\t\tthis._pInvalidateRender();\n\t}\n\n\tpublic get numEffectMethods():number\n\t{\n\t\treturn this._effectMethods.length;\n\t}\n\n\t/**\n\t * Appends an \"effect\" shading method to the shader. Effect methods are those that do not influence the lighting\n\t * but modulate the shaded colour, used for fog, outlines, etc. The method will be applied to the result of the\n\t * methods added prior.\n\t */\n\tpublic addEffectMethod(method:EffectMethodBase)\n\t{\n\t\tthis._effectMethods.push(method);\n\n\t\tthis._pInvalidateRender();\n\t}\n\n\t/**\n\t * Returns the method added at the given index.\n\t * @param index The index of the method to retrieve.\n\t * @return The method at the given index.\n\t */\n\tpublic getEffectMethodAt(index:number):EffectMethodBase\n\t{\n\t\treturn this._effectMethods[index];\n\t}\n\n\t/**\n\t * Adds an effect method at the specified index amongst the methods already added to the material. Effect\n\t * methods are those that do not influence the lighting but modulate the shaded colour, used for fog, outlines,\n\t * etc. The method will be applied to the result of the methods with a lower index.\n\t */\n\tpublic addEffectMethodAt(method:EffectMethodBase, index:number)\n\t{\n\t\tthis._effectMethods.splice(index, 0, method);\n\n\t\tthis._pInvalidateRender();\n\t}\n\n\t/**\n\t * Removes an effect method from the material.\n\t * @param method The method to be removed.\n\t */\n\tpublic removeEffectMethod(method:EffectMethodBase)\n\t{\n\t\tthis._effectMethods.splice(this._effectMethods.indexOf(method), 1);\n\n\t\tthis._pInvalidateRender();\n\t}\n\n\t/**\n\t * The normal map to modulate the direction of the surface for each texel. The default normal method expects\n\t * tangent-space normal maps, but others could expect object-space maps.\n\t */\n\tpublic get normalMap():TextureBase\n\t{\n\t\treturn this._normalMethod.normalMap;\n\t}\n\n\tpublic set normalMap(value:TextureBase)\n\t{\n\t\tthis._normalMethod.normalMap = value;\n\t}\n\n\t/**\n\t * A specular map that defines the strength of specular reflections for each texel in the red channel,\n\t * and the gloss factor in the green channel. You can use Specular2DTexture if you want to easily set\n\t * specular and gloss maps from grayscale images, but correctly authored images are preferred.\n\t */\n\tpublic get specularMap():TextureBase\n\t{\n\t\treturn this._specularMethod.texture;\n\t}\n\n\tpublic set specularMap(value:TextureBase)\n\t{\n\t\tthis._specularMethod.texture = value;\n\t}\n\n\t/**\n\t * The glossiness of the material (sharpness of the specular highlight).\n\t */\n\tpublic get gloss():number\n\t{\n\t\treturn this._specularMethod.gloss;\n\t}\n\n\tpublic set gloss(value:number)\n\t{\n\t\tthis._specularMethod.gloss = value;\n\t}\n\n\t/**\n\t * The strength of the ambient reflection.\n\t */\n\tpublic get ambient():number\n\t{\n\t\treturn this._ambientMethod.ambient;\n\t}\n\n\tpublic set ambient(value:number)\n\t{\n\t\tthis._ambientMethod.ambient = value;\n\t}\n\n\t/**\n\t * The overall strength of the specular reflection.\n\t */\n\tpublic get specular():number\n\t{\n\t\treturn this._specularMethod.specular;\n\t}\n\n\tpublic set specular(value:number)\n\t{\n\t\tthis._specularMethod.specular = value;\n\t}\n\n\t/**\n\t * The colour of the ambient reflection.\n\t */\n\tpublic get ambientColor():number\n\t{\n\t\treturn this._diffuseMethod.ambientColor;\n\t}\n\n\tpublic set ambientColor(value:number)\n\t{\n\t\tthis._diffuseMethod.ambientColor = value;\n\t}\n\n\t/**\n\t * The colour of the diffuse reflection.\n\t */\n\tpublic get diffuseColor():number\n\t{\n\t\treturn this._diffuseMethod.diffuseColor;\n\t}\n\n\tpublic set diffuseColor(value:number)\n\t{\n\t\tthis._diffuseMethod.diffuseColor = value;\n\t}\n\n\t/**\n\t * The colour of the specular reflection.\n\t */\n\tpublic get specularColor():number\n\t{\n\t\treturn this._specularMethod.specularColor;\n\t}\n\n\tpublic set specularColor(value:number)\n\t{\n\t\tthis._specularMethod.specularColor = value;\n\t}\n}\n\nexport = MethodMaterial;",
    "import TextureVOBase\t\t\t\t= require(\"awayjs-renderergl/lib/vos/TextureVOBase\");\n\nimport ShadingMethodBase\t\t\t= require(\"awayjs-methodmaterials/lib/methods/ShadingMethodBase\");\n\n/**\n * MethodVO contains data for a given shader object for the use within a single material.\n * This allows shader methods to be shared across materials while their non-public state differs.\n */\nclass MethodVO\n{\n\tpublic useMethod:boolean = true;\n\n\tpublic method:ShadingMethodBase;\n\n\t// public register indices\n\tpublic textureVO:TextureVOBase;\n\tpublic secondaryTextureVO:TextureVOBase; // sometimes needed for composites\n\tpublic vertexConstantsIndex:number;\n\tpublic secondaryVertexConstantsIndex:number; // sometimes needed for composites\n\tpublic fragmentConstantsIndex:number;\n\tpublic secondaryFragmentConstantsIndex:number; // sometimes needed for composites\n\n\t// internal stuff for the material to know before assembling code\n\tpublic needsProjection:boolean;\n\tpublic needsView:boolean;\n\tpublic needsNormals:boolean;\n\tpublic needsTangents:boolean;\n\tpublic needsGlobalVertexPos:boolean;\n\tpublic needsGlobalFragmentPos:boolean;\n\t/**\n\t * Creates a new MethodVO object.\n\t */\n\tconstructor(method:ShadingMethodBase)\n\t{\n\t\tthis.method = method;\n\t}\n\n\t/**\n\t * Resets the values of the value object to their \"unused\" state.\n\t */\n\tpublic reset()\n\t{\n\t\tthis.method.iReset();\n\n\t\tthis.vertexConstantsIndex = -1;\n\t\tthis.secondaryVertexConstantsIndex = -1;\n\t\tthis.fragmentConstantsIndex = -1;\n\t\tthis.secondaryFragmentConstantsIndex = -1;\n\n\t\tthis.needsProjection = false;\n\t\tthis.needsView = false;\n\t\tthis.needsNormals = false;\n\t\tthis.needsTangents = false;\n\t\tthis.needsGlobalVertexPos = false;\n\t\tthis.needsGlobalFragmentPos = false;\n\t}\n}\n\nexport = MethodVO;\n",
    "import Stage\t\t\t\t\t\t= require(\"awayjs-stagegl/lib/base/Stage\");\n\nimport ShaderBase\t\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderBase\");\nimport ShaderRegisterCache\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterCache\");\nimport ShaderRegisterData\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterData\");\nimport ShaderRegisterElement\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterElement\");\n\nimport MethodVO\t\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/data/MethodVO\");\nimport ShadingMethodBase\t\t\t= require(\"awayjs-methodmaterials/lib/methods/ShadingMethodBase\");\n\n/**\n * AmbientBasicMethod provides the default shading method for uniform ambient lighting.\n */\nclass AmbientBasicMethod extends ShadingMethodBase\n{\n\tprivate _color:number = 0xffffff;\n\tprivate _alpha:number = 1;\n\n\tprivate _colorR:number = 1;\n\tprivate _colorG:number = 1;\n\tprivate _colorB:number = 1;\n\n\tprivate _ambient:number = 1;\n\n\t/**\n\t * Creates a new AmbientBasicMethod object.\n\t */\n\tconstructor()\n\t{\n\t\tsuper();\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitVO(shader:ShaderBase, methodVO:MethodVO)\n\t{\n\t\tif (shader.texture)\n\t\t\tshader.uvDependencies++;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitConstants(shader:ShaderBase, methodVO:MethodVO)\n\t{\n\t\tif (!shader.texture) {\n\t\t\tthis._color = shader.color;\n\t\t\tthis.updateColor();\n\t\t}\n\t}\n\n\t/**\n\t * The strength of the ambient reflection of the surface.\n\t */\n\tpublic get ambient():number\n\t{\n\t\treturn this._ambient;\n\t}\n\n\tpublic set ambient(value:number)\n\t{\n\t\tif (this._ambient == value)\n\t\t\treturn;\n\n\t\tthis._ambient = value;\n\n\t\tthis.updateColor();\n\t}\n\n\t/**\n\t * The alpha component of the surface.\n\t */\n\tpublic get alpha():number\n\t{\n\t\treturn this._alpha;\n\t}\n\n\tpublic set alpha(value:number)\n\t{\n\t\tif (this._alpha == value)\n\t\t\treturn;\n\n\t\tthis._alpha = value;\n\n\t\tthis.updateColor();\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic copyFrom(method:ShadingMethodBase)\n\t{\n\t\tvar m:any = method;\n\t\tvar b:AmbientBasicMethod = <AmbientBasicMethod> m;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentCode(shader:ShaderBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = \"\";\n\n\t\tif (shader.texture) {\n\t\t\tshader.texture._iInitRegisters(shader, registerCache);\n\n\t\t\tcode += shader.texture._iGetFragmentCode(shader, targetReg, registerCache, sharedRegisters.uvVarying);\n\n\t\t\tif (shader.alphaThreshold > 0) {\n\t\t\t\tvar cutOffReg:ShaderRegisterElement = registerCache.getFreeFragmentConstant();\n\t\t\t\tmethodVO.fragmentConstantsIndex = cutOffReg.index*4;\n\n\t\t\t\tcode += \"sub \" + targetReg + \".w, \" + targetReg + \".w, \" + cutOffReg + \".x\\n\" +\n\t\t\t\t\t\"kil \" + targetReg + \".w\\n\" +\n\t\t\t\t\t\"add \" + targetReg + \".w, \" + targetReg + \".w, \" + cutOffReg + \".x\\n\";\n\t\t\t}\n\n\t\t} else {\n\t\t\tvar ambientInputRegister:ShaderRegisterElement = registerCache.getFreeFragmentConstant();\n\t\t\tmethodVO.fragmentConstantsIndex = ambientInputRegister.index*4;\n\n\t\t\tcode += \"mov \" + targetReg + \", \" + ambientInputRegister + \"\\n\";\n\t\t}\n\n\t\treturn code;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iActivate(shader:ShaderBase, methodVO:MethodVO, stage:Stage)\n\t{\n\t\tif (shader.texture) {\n\t\t\tshader.texture.activate(shader);\n\n\t\t\tif (shader.alphaThreshold > 0)\n\t\t\t\tshader.fragmentConstantData[methodVO.fragmentConstantsIndex] = shader.alphaThreshold;\n\t\t} else {\n\t\t\tvar index:number = methodVO.fragmentConstantsIndex;\n\t\t\tvar data:Array<number> = shader.fragmentConstantData;\n\t\t\tdata[index] = this._colorR;\n\t\t\tdata[index + 1] = this._colorG;\n\t\t\tdata[index + 2] = this._colorB;\n\t\t\tdata[index + 3] = this._alpha;\n\t\t}\n\t}\n\n\t/**\n\t * Updates the ambient color data used by the render state.\n\t */\n\tprivate updateColor()\n\t{\n\t\tthis._colorR = ((this._color >> 16) & 0xff)/0xff*this._ambient;\n\t\tthis._colorG = ((this._color >> 8) & 0xff)/0xff*this._ambient;\n\t\tthis._colorB = (this._color & 0xff)/0xff*this._ambient;\n\t}\n}\n\nexport = AmbientBasicMethod;",
    "import ShaderBase\t\t\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderBase\");\nimport ShaderRegisterCache\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterCache\");\nimport ShaderRegisterData\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterData\");\nimport ShaderRegisterElement\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterElement\");\n\nimport MethodVO\t\t\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/data/MethodVO\");\nimport AmbientBasicMethod\t\t\t\t= require(\"awayjs-methodmaterials/lib/methods/AmbientBasicMethod\");\n\n/**\n * AmbientEnvMapMethod provides a diffuse shading method that uses a diffuse irradiance environment map to\n * approximate global lighting rather than lights.\n */\nclass AmbientEnvMapMethod extends AmbientBasicMethod\n{\n\t/**\n\t * Creates a new <code>AmbientEnvMapMethod</code> object.\n\t *\n\t * @param envMap The cube environment map to use for the ambient lighting.\n\t */\n\tconstructor()\n\t{\n\t\tsuper();\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitVO(shader:ShaderBase, methodVO:MethodVO)\n\t{\n\t\tmethodVO.needsNormals = true;\n\t}\n\t\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentCode(shader:ShaderBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, regCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tshader.texture._iInitRegisters(shader, regCache);\n\n\t\treturn shader.texture._iGetFragmentCode(shader, targetReg, regCache, sharedRegisters.normalFragment);\n\t}\n}\n\nexport = AmbientEnvMapMethod;",
    "import Stage\t\t\t\t\t\t= require(\"awayjs-stagegl/lib/base/Stage\");\n\nimport ShaderBase\t\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderBase\");\nimport ShaderRegisterCache\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterCache\");\nimport ShaderRegisterData\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterData\");\nimport ShaderRegisterElement\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterElement\");\n\nimport MethodVO\t\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/data/MethodVO\");\nimport ShadingMethodBase\t\t\t= require(\"awayjs-methodmaterials/lib/methods/ShadingMethodBase\");\n\n/**\n * AmbientBasicMethod provides the default shading method for uniform ambient lighting.\n */\nclass CurveBasicMethod extends ShadingMethodBase\n{\n\tprivate _color:number = 0xffffff;\n\tprivate _alpha:number = 1;\n\n\tprivate _colorR:number = 1;\n\tprivate _colorG:number = 1;\n\tprivate _colorB:number = 1;\n\n\tprivate _ambient:number = 1;\n\n\t/**\n\t * Creates a new AmbientBasicMethod object.\n\t */\n\tconstructor()\n\t{\n\t\tsuper();\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitVO(shader:ShaderBase, methodVO:MethodVO)\n\t{\n\t\tif (shader.texture)\n\t\t\tshader.uvDependencies++;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitConstants(shader:ShaderBase, methodVO:MethodVO)\n\t{\n\t\tif (!shader.texture) {\n\t\t\tthis._color = shader.color;\n\t\t\tthis.updateColor();\n\t\t}\n\t}\n\n\t/**\n\t * The strength of the ambient reflection of the surface.\n\t */\n\tpublic get ambient():number\n\t{\n\t\treturn this._ambient;\n\t}\n\n\tpublic set ambient(value:number)\n\t{\n\t\tif (this._ambient == value)\n\t\t\treturn;\n\n\t\tthis._ambient = value;\n\n\t\tthis.updateColor();\n\t}\n\n\t/**\n\t * The alpha component of the surface.\n\t */\n\tpublic get alpha():number\n\t{\n\t\treturn this._alpha;\n\t}\n\n\tpublic set alpha(value:number)\n\t{\n\t\tif (this._alpha == value)\n\t\t\treturn;\n\n\t\tthis._alpha = value;\n\n\t\tthis.updateColor();\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic copyFrom(method:ShadingMethodBase)\n\t{\n\t\tvar m:any = method;\n\t\tvar b:CurveBasicMethod = <CurveBasicMethod> m;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n    /*\n    public iGeVertexCode(shader:ShaderBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string {\n        var code:string = \"\";\n        code = \"mov \" + sharedRegisters.uvVarying + \" \" + registerCache.uv +  \" \\n\";\n    }*/\n    public iGetFragmentCode(shader:ShaderBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = \"\";\n\t\tvar ambientInputRegister:ShaderRegisterElement;\n\n\t\tif (shader.texture) {\n\t\t\tshader.texture._iInitRegisters(shader, registerCache);\n\n\t\t\tcode += shader.texture._iGetFragmentCode(shader, targetReg, registerCache, sharedRegisters.uvVarying);\n\n\t\t\tif (shader.alphaThreshold > 0) {\n\t\t\t\tvar cutOffReg:ShaderRegisterElement = registerCache.getFreeFragmentConstant();\n\t\t\t\tmethodVO.fragmentConstantsIndex = cutOffReg.index*4;\n\n\t\t\t\tcode += \"sub \" + targetReg + \".w, \" + targetReg + \".w, \" + cutOffReg + \".x\\n\" +\n\t\t\t\t\t\"kil \" + targetReg + \".w\\n\" +\n\t\t\t\t\t\"add \" + targetReg + \".w, \" + targetReg + \".w, \" + cutOffReg + \".x\\n\";\n\t\t\t}\n\n\t\t} else {\n\t\t\tambientInputRegister = registerCache.getFreeFragmentConstant();\n\t\t\tmethodVO.fragmentConstantsIndex = ambientInputRegister.index*4;\n\n\t\t\tcode += \"mov \" + targetReg + \", \" + ambientInputRegister + \"\\n\";\n\t\t}\n        code = \"mov \" + targetReg + \", \" + sharedRegisters.uvVarying + \"\\n\";\n\t\treturn code;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iActivate(shader:ShaderBase, methodVO:MethodVO, stage:Stage)\n\t{\n\t\tif (shader.texture) {\n\t\t\tshader.texture.activate(shader);\n\n\t\t\tif (shader.alphaThreshold > 0)\n\t\t\t\tshader.fragmentConstantData[methodVO.fragmentConstantsIndex] = shader.alphaThreshold;\n\t\t} else {\n\t\t\tvar index:number = methodVO.fragmentConstantsIndex;\n\t\t\tvar data:Array<number> = shader.fragmentConstantData;\n\t\t\tdata[index] = this._colorR;\n\t\t\tdata[index + 1] = this._colorG;\n\t\t\tdata[index + 2] = this._colorB;\n\t\t\tdata[index + 3] = this._alpha;\n\t\t}\n\t}\n\n\t/**\n\t * Updates the ambient color data used by the render state.\n\t */\n\tprivate updateColor()\n\t{\n\t\tthis._colorR = ((this._color >> 16) & 0xff)/0xff*this._ambient;\n\t\tthis._colorG = ((this._color >> 8) & 0xff)/0xff*this._ambient;\n\t\tthis._colorB = (this._color & 0xff)/0xff*this._ambient;\n\t}\n}\nexport = CurveBasicMethod;",
    "import Camera\t\t\t\t\t\t= require(\"awayjs-display/lib/entities/Camera\");\nimport TextureBase\t\t\t\t\t= require(\"awayjs-display/lib/textures/TextureBase\");\n\nimport Stage\t\t\t\t\t\t= require(\"awayjs-stagegl/lib/base/Stage\");\n\nimport LightingShader\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/LightingShader\");\nimport ShaderRegisterCache\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterCache\");\nimport ShaderRegisterData\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterData\");\nimport ShaderRegisterElement\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterElement\");\nimport RenderableBase\t\t\t\t= require(\"awayjs-renderergl/lib/renderables/RenderableBase\");\n\nimport MethodVO\t\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/data/MethodVO\");\nimport ShadingMethodBase\t\t\t= require(\"awayjs-methodmaterials/lib/methods/ShadingMethodBase\");\nimport LightingMethodBase\t\t\t= require(\"awayjs-methodmaterials/lib/methods/LightingMethodBase\");\n\n/**\n * DiffuseBasicMethod provides the default shading method for Lambert (dot3) diffuse lighting.\n */\nclass DiffuseBasicMethod extends LightingMethodBase\n{\n\tprivate _multiply:boolean = true;\n\n\tpublic _pTotalLightColorReg:ShaderRegisterElement;\n\n\tpublic _texture:TextureBase;\n\tprivate _diffuseColor:number = 0xffffff;\n\tprivate _ambientColor:number = 0xffffff;\n\tprivate _diffuseR:number = 1;\n\tprivate _diffuseG:number = 1;\n\tprivate _diffuseB:number = 1;\n\tprivate _ambientR:number = 1;\n\tprivate _ambientG:number = 1;\n\tprivate _ambientB:number = 1;\n\n\tpublic _pIsFirstLight:boolean;\n\n\t/**\n\t * Creates a new DiffuseBasicMethod object.\n\t */\n\tconstructor()\n\t{\n\t\tsuper();\n\t}\n\n\tpublic iIsUsed(shader:LightingShader):boolean\n\t{\n\t\tif (!shader.numLights)\n\t\t\treturn false;\n\n\t\treturn true;\n\t}\n\n\t/**\n\t * Set internally if diffuse color component multiplies or replaces the ambient color\n\t */\n\tpublic get multiply():boolean\n\t{\n\t\treturn this._multiply;\n\t}\n\n\tpublic set multiply(value:boolean)\n\t{\n\t\tif (this._multiply == value)\n\t\t\treturn;\n\n\t\tthis._multiply = value;\n\n\t\tthis.iInvalidateShaderProgram();\n\t}\n\n\tpublic iInitVO(shader:LightingShader, methodVO:MethodVO)\n\t{\n\t\tif (this._texture) {\n\t\t\tmethodVO.textureVO = shader.getTextureVO(this._texture);\n\t\t\tshader.uvDependencies++;\n\t\t} else if (methodVO.textureVO) {\n\t\t\tmethodVO.textureVO.dispose();\n\t\t\tmethodVO.textureVO = null;\n\t\t}\n\n\n\t\tmethodVO.needsNormals = shader.numLights > 0;\n\t}\n\n\t/**\n\t * The color of the diffuse reflection when not using a texture.\n\t */\n\tpublic get diffuseColor():number\n\t{\n\t\treturn this._diffuseColor;\n\t}\n\n\tpublic set diffuseColor(value:number)\n\t{\n\t\tif (this._diffuseColor == value)\n\t\t\treturn;\n\n\t\tthis._diffuseColor = value;\n\n\t\tthis.updateDiffuse();\n\t}\n\n\t/**\n\t * The color of the ambient reflection\n\t */\n\tpublic get ambientColor():number\n\t{\n\t\treturn this._ambientColor;\n\t}\n\n\tpublic set ambientColor(value:number)\n\t{\n\t\tif (this._ambientColor == value)\n\t\t\treturn;\n\n\t\tthis._ambientColor = value;\n\n\t\tthis.updateAmbient();\n\t}\n\n\n\t/**\n\t * The bitmapData to use to define the diffuse reflection color per texel.\n\t */\n\tpublic get texture():TextureBase\n\t{\n\t\treturn this._texture;\n\t}\n\n\tpublic set texture(value:TextureBase)\n\t{\n\t\tif (this._texture == value)\n\t\t\treturn;\n\n\t\tthis._texture = value;\n\n\t\tthis.iInvalidateShaderProgram();\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic dispose()\n\t{\n\t\tthis._texture = null;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic copyFrom(method:ShadingMethodBase)\n\t{\n\t\tvar diff:DiffuseBasicMethod = <DiffuseBasicMethod> method;\n\n\t\tthis.texture = diff.texture;\n\t\tthis.multiply = diff.multiply;\n\t\tthis.diffuseColor = diff.diffuseColor;\n\t\tthis.ambientColor = diff.ambientColor;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iCleanCompilationData()\n\t{\n\t\tsuper.iCleanCompilationData();\n\n\t\tthis._pTotalLightColorReg = null;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentPreLightingCode(shader:LightingShader, methodVO:MethodVO, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = \"\";\n\n\t\tthis._pIsFirstLight = true;\n\n\t\tregisterCache.addFragmentTempUsages(this._pTotalLightColorReg = registerCache.getFreeFragmentVectorTemp(), 1);\n\n\t\treturn code;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentCodePerLight(shader:LightingShader, methodVO:MethodVO, lightDirReg:ShaderRegisterElement, lightColReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = \"\";\n\t\tvar t:ShaderRegisterElement;\n\n\t\t// write in temporary if not first light, so we can add to total diffuse colour\n\t\tif (this._pIsFirstLight) {\n\t\t\tt = this._pTotalLightColorReg;\n\t\t} else {\n\t\t\tt = registerCache.getFreeFragmentVectorTemp();\n\t\t\tregisterCache.addFragmentTempUsages(t, 1);\n\t\t}\n\n\t\tcode += \"dp3 \" + t + \".x, \" + lightDirReg + \", \" + sharedRegisters.normalFragment + \"\\n\" +\n\t\t\t\t\"max \" + t + \".w, \" + t + \".x, \" + sharedRegisters.commons + \".y\\n\";\n\n\t\tif (shader.usesLightFallOff)\n\t\t\tcode += \"mul \" + t + \".w, \" + t + \".w, \" + lightDirReg + \".w\\n\";\n\n\t\tif (this._iModulateMethod != null)\n\t\t\tcode += this._iModulateMethod(shader, methodVO, t, registerCache, sharedRegisters);\n\n\t\tcode += \"mul \" + t + \", \" + t + \".w, \" + lightColReg + \"\\n\";\n\n\t\tif (!this._pIsFirstLight) {\n\t\t\tcode += \"add \" + this._pTotalLightColorReg + \".xyz, \" + this._pTotalLightColorReg + \", \" + t + \"\\n\";\n\t\t\tregisterCache.removeFragmentTempUsage(t);\n\t\t}\n\n\t\tthis._pIsFirstLight = false;\n\n\t\treturn code;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentCodePerProbe(shader:LightingShader, methodVO:MethodVO, cubeMapReg:ShaderRegisterElement, weightRegister:string, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = \"\";\n\t\tvar t:ShaderRegisterElement;\n\n\t\t// write in temporary if not first light, so we can add to total diffuse colour\n\t\tif (this._pIsFirstLight) {\n\t\t\tt = this._pTotalLightColorReg;\n\t\t} else {\n\t\t\tt = registerCache.getFreeFragmentVectorTemp();\n\t\t\tregisterCache.addFragmentTempUsages(t, 1);\n\t\t}\n\n\t\tcode += \"tex \" + t + \", \" + sharedRegisters.normalFragment + \", \" + cubeMapReg + \" <cube,linear,miplinear>\\n\" +\n\t\t\t\t\"mul \" + t + \".xyz, \" + t + \".xyz, \" + weightRegister + \"\\n\";\n\n\t\tif (this._iModulateMethod != null)\n\t\t\tcode += this._iModulateMethod(shader, methodVO, t, registerCache, sharedRegisters);\n\n\t\tif (!this._pIsFirstLight) {\n\t\t\tcode += \"add \" + this._pTotalLightColorReg + \".xyz, \" + this._pTotalLightColorReg + \", \" + t + \"\\n\";\n\t\t\tregisterCache.removeFragmentTempUsage(t);\n\t\t}\n\n\t\tthis._pIsFirstLight = false;\n\n\t\treturn code;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentPostLightingCode(shader:LightingShader, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = \"\";\n\n\t\tvar albedo:ShaderRegisterElement;\n\t\tvar cutOffReg:ShaderRegisterElement;\n\n\t\t// incorporate input from ambient\n\t\tif (sharedRegisters.shadowTarget)\n\t\t\tcode += this.pApplyShadow(shader, methodVO, registerCache, sharedRegisters);\n\n\t\tregisterCache.addFragmentTempUsages(albedo = registerCache.getFreeFragmentVectorTemp(), 1);\n\n\t\tvar ambientColorRegister:ShaderRegisterElement = registerCache.getFreeFragmentConstant();\n\t\tmethodVO.fragmentConstantsIndex = ambientColorRegister.index*4;\n\n\t\tif (this._texture) {\n\t\t\tmethodVO.textureVO._iInitRegisters(shader, registerCache);\n\n\t\t\tcode += methodVO.textureVO._iGetFragmentCode(shader, albedo, registerCache, sharedRegisters.uvVarying);\n\t\t} else {\n\t\t\tvar diffuseInputRegister:ShaderRegisterElement = registerCache.getFreeFragmentConstant();\n\n\t\t\tcode += \"mov \" + albedo + \", \" + diffuseInputRegister + \"\\n\";\n\t\t}\n\n\t\tcode += \"sat \" + this._pTotalLightColorReg + \", \" + this._pTotalLightColorReg + \"\\n\" +\n\t\t\t\"mul \" + albedo + \".xyz, \" + albedo + \", \" + this._pTotalLightColorReg + \"\\n\";\n\n\t\tif (this._multiply) {\n\t\t\tcode += \"add \" + albedo + \".xyz, \" + albedo + \", \" + ambientColorRegister + \"\\n\" +\n\t\t\t\t\"mul \" + targetReg + \".xyz, \" + targetReg + \", \" + albedo + \"\\n\";\n\t\t} else {\n\t\t\tcode += \"mul \" + targetReg + \".xyz, \" + targetReg + \", \" + ambientColorRegister + \"\\n\" +\n\t\t\t\t\"mul \" + this._pTotalLightColorReg + \".xyz, \" + targetReg + \", \" + this._pTotalLightColorReg + \"\\n\" +\n\t\t\t\t\"sub \" + targetReg + \".xyz, \" + targetReg + \", \" + this._pTotalLightColorReg + \"\\n\" +\n\t\t\t\t\"add \" + targetReg + \".xyz, \" + targetReg + \", \" + albedo + \"\\n\";\n\t\t}\n\n\t\tregisterCache.removeFragmentTempUsage(this._pTotalLightColorReg);\n\t\tregisterCache.removeFragmentTempUsage(albedo);\n\n\t\treturn code;\n\t}\n\n\t/**\n\t * Generate the code that applies the calculated shadow to the diffuse light\n\t * @param methodVO The MethodVO object for which the compilation is currently happening.\n\t * @param regCache The register cache the compiler is currently using for the register management.\n\t */\n\tpublic pApplyShadow(shader:LightingShader, methodVO:MethodVO, regCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\treturn \"mul \" + this._pTotalLightColorReg + \".xyz, \" + this._pTotalLightColorReg + \", \" + sharedRegisters.shadowTarget + \".w\\n\";\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iActivate(shader:LightingShader, methodVO:MethodVO, stage:Stage)\n\t{\n\t\tif (this._texture) {\n\t\t\tmethodVO.textureVO.activate(shader);\n\t\t} else {\n\t\t\tvar index:number = methodVO.fragmentConstantsIndex;\n\t\t\tvar data:Array<number> = shader.fragmentConstantData;\n\t\t\tdata[index + 4] = this._diffuseR;\n\t\t\tdata[index + 5] = this._diffuseG;\n\t\t\tdata[index + 6] = this._diffuseB;\n\t\t\tdata[index + 7] = 1;\n\t\t}\n\t}\n\n\t/**\n\t * Updates the diffuse color data used by the render state.\n\t */\n\tprivate updateDiffuse()\n\t{\n\t\tthis._diffuseR = ((this._diffuseColor >> 16) & 0xff)/0xff;\n\t\tthis._diffuseG = ((this._diffuseColor >> 8) & 0xff)/0xff;\n\t\tthis._diffuseB = (this._diffuseColor & 0xff)/0xff;\n\t}\n\n\t/**\n\t * Updates the ambient color data used by the render state.\n\t */\n\tprivate updateAmbient()\n\t{\n\t\tthis._ambientR = ((this._ambientColor >> 16) & 0xff)/0xff;\n\t\tthis._ambientG = ((this._ambientColor >> 8) & 0xff)/0xff;\n\t\tthis._ambientB = (this._ambientColor & 0xff)/0xff;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iSetRenderState(shader:LightingShader, methodVO:MethodVO, renderable:RenderableBase, stage:Stage, camera:Camera)\n\t{\n\t\t//TODO move this to Activate (ambientR/G/B currently calc'd in render state)\n\t\tif (shader.numLights > 0) {\n\t\t\tvar index:number = methodVO.fragmentConstantsIndex;\n\t\t\tvar data:Array<number> = shader.fragmentConstantData;\n\t\t\tdata[index] = shader.ambientR*this._ambientR;\n\t\t\tdata[index + 1] = shader.ambientG*this._ambientG;\n\t\t\tdata[index + 2] = shader.ambientB*this._ambientB;\n\t\t\tdata[index + 3] = 1;\n\t\t}\n\t}\n}\n\nexport = DiffuseBasicMethod;",
    "import Stage\t\t\t\t\t\t\t= require(\"awayjs-stagegl/lib/base/Stage\");\n\nimport LightingShader\t\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/LightingShader\");\nimport ShaderBase\t\t\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderBase\");\nimport ShaderRegisterCache\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterCache\");\nimport ShaderRegisterData\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterData\");\nimport ShaderRegisterElement\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterElement\");\n\nimport MethodVO\t\t\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/data/MethodVO\");\nimport DiffuseBasicMethod\t\t\t\t= require(\"awayjs-methodmaterials/lib/methods/DiffuseBasicMethod\");\nimport DiffuseCompositeMethod\t\t\t= require(\"awayjs-methodmaterials/lib/methods/DiffuseCompositeMethod\");\n\n/**\n * DiffuseCelMethod provides a shading method to add diffuse cel (cartoon) shading.\n */\nclass DiffuseCelMethod extends DiffuseCompositeMethod\n{\n\tprivate _levels:number /*uint*/;\n\tprivate _dataReg:ShaderRegisterElement;\n\tprivate _smoothness:number = .1;\n\n\t/**\n\t * Creates a new DiffuseCelMethod object.\n\t * @param levels The amount of shadow gradations.\n\t * @param baseMethod An optional diffuse method on which the cartoon shading is based. If omitted, DiffuseBasicMethod is used.\n\t */\n\tconstructor(levels:number /*uint*/ = 3, baseMethod:DiffuseBasicMethod = null)\n\t{\n\t\tsuper(null, baseMethod);\n\n\t\tthis.baseMethod._iModulateMethod = (shader:ShaderBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData) => this.clampDiffuse(shader, methodVO, targetReg, registerCache, sharedRegisters);\n\n\t\tthis._levels = levels;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitConstants(shader:LightingShader, methodVO:MethodVO)\n\t{\n\t\tvar data:Array<number> = shader.fragmentConstantData;\n\t\tvar index:number /*int*/ = methodVO.secondaryFragmentConstantsIndex;\n\t\tsuper.iInitConstants(shader, methodVO);\n\t\tdata[index + 1] = 1;\n\t\tdata[index + 2] = 0;\n\t}\n\n\t/**\n\t * The amount of shadow gradations.\n\t */\n\tpublic get levels():number /*uint*/\n\t{\n\t\treturn this._levels;\n\t}\n\n\tpublic set levels(value:number /*uint*/)\n\t{\n\t\tthis._levels = value;\n\t}\n\n\t/**\n\t * The smoothness of the edge between 2 shading levels.\n\t */\n\tpublic get smoothness():number\n\t{\n\t\treturn this._smoothness;\n\t}\n\n\tpublic set smoothness(value:number)\n\t{\n\t\tthis._smoothness = value;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iCleanCompilationData()\n\t{\n\t\tsuper.iCleanCompilationData();\n\t\tthis._dataReg = null;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentPreLightingCode(shader:LightingShader, methodVO:MethodVO, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tthis._dataReg = registerCache.getFreeFragmentConstant();\n\t\tmethodVO.secondaryFragmentConstantsIndex = this._dataReg.index*4;\n\n\t\treturn super.iGetFragmentPreLightingCode(shader, methodVO, registerCache, sharedRegisters);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iActivate(shader:LightingShader, methodVO:MethodVO, stage:Stage)\n\t{\n\t\tsuper.iActivate(shader, methodVO, stage);\n\t\tvar data:Array<number> = shader.fragmentConstantData;\n\t\tvar index:number /*int*/ = methodVO.secondaryFragmentConstantsIndex;\n\t\tdata[index] = this._levels;\n\t\tdata[index + 3] = this._smoothness;\n\t}\n\n\t/**\n\t * Snaps the diffuse shading of the wrapped method to one of the levels.\n\t * @param vo The MethodVO used to compile the current shader.\n\t * @param t The register containing the diffuse strength in the \"w\" component.\n\t * @param regCache The register cache used for the shader compilation.\n\t * @param sharedRegisters The shared register data for this shader.\n\t * @return The AGAL fragment code for the method.\n\t */\n\tprivate clampDiffuse(shader:ShaderBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\treturn \"mul \" + targetReg + \".w, \" + targetReg + \".w, \" + this._dataReg + \".x\\n\" +\n\t\t\t\"frc \" + targetReg + \".z, \" + targetReg + \".w\\n\" +\n\t\t\t\"sub \" + targetReg + \".y, \" + targetReg + \".w, \" + targetReg + \".z\\n\" +\n\t\t\t\"mov \" + targetReg + \".x, \" + this._dataReg + \".x\\n\" +\n\t\t\t\"sub \" + targetReg + \".x, \" + targetReg + \".x, \" + this._dataReg + \".y\\n\" +\n\t\t\t\"rcp \" + targetReg + \".x,\" + targetReg + \".x\\n\" +\n\t\t\t\"mul \" + targetReg + \".w, \" + targetReg + \".y, \" + targetReg + \".x\\n\" +\n\n\t\t\t// previous clamped strength\n\t\t\t\"sub \" + targetReg + \".y, \" + targetReg + \".w, \" + targetReg + \".x\\n\" +\n\n\t\t\t// fract/epsilon (so 0 - epsilon will become 0 - 1)\n\t\t\t\"div \" + targetReg + \".z, \" + targetReg + \".z, \" + this._dataReg + \".w\\n\" +\n\t\t\t\"sat \" + targetReg + \".z, \" + targetReg + \".z\\n\" +\n\n\t\t\t\"mul \" + targetReg + \".w, \" + targetReg + \".w, \" + targetReg + \".z\\n\" +\n\t\t\t// 1-z\n\t\t\t\"sub \" + targetReg + \".z, \" + this._dataReg + \".y, \" + targetReg + \".z\\n\" +\n\t\t\t\"mul \" + targetReg + \".y, \" + targetReg + \".y, \" + targetReg + \".z\\n\" +\n\t\t\t\"add \" + targetReg + \".w, \" + targetReg + \".w, \" + targetReg + \".y\\n\" +\n\t\t\t\"sat \" + targetReg + \".w, \" + targetReg + \".w\\n\";\n\t}\n}\n\nexport = DiffuseCelMethod;",
    "import Camera\t\t\t\t\t\t\t= require(\"awayjs-display/lib/entities/Camera\");\nimport TextureBase\t\t\t\t\t\t= require(\"awayjs-display/lib/textures/TextureBase\");\n\nimport Stage\t\t\t\t\t\t\t= require(\"awayjs-stagegl/lib/base/Stage\");\n\nimport LightingShader\t\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/LightingShader\");\nimport ShaderBase\t\t\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderBase\");\nimport ShaderRegisterCache\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterCache\");\nimport ShaderRegisterData\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterData\");\nimport ShaderRegisterElement\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterElement\");\nimport ShadingMethodEvent\t\t\t\t= require(\"awayjs-renderergl/lib/events/ShadingMethodEvent\");\nimport RenderableBase\t\t\t\t\t= require(\"awayjs-renderergl/lib/renderables/RenderableBase\");\n\nimport MethodVO\t\t\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/data/MethodVO\");\nimport DiffuseBasicMethod\t\t\t\t= require(\"awayjs-methodmaterials/lib/methods/DiffuseBasicMethod\");\n\n/**\n * DiffuseCompositeMethod provides a base class for diffuse methods that wrap a diffuse method to alter the\n * calculated diffuse reflection strength.\n */\nclass DiffuseCompositeMethod extends DiffuseBasicMethod\n{\n\tpublic pBaseMethod:DiffuseBasicMethod;\n\n\tprivate _onShaderInvalidatedDelegate:Function;\n\n\t/**\n\t * Creates a new <code>DiffuseCompositeMethod</code> object.\n\t *\n\t * @param modulateMethod The method which will add the code to alter the base method's strength. It needs to have the signature clampDiffuse(t:ShaderRegisterElement, regCache:ShaderRegisterCache):string, in which t.w will contain the diffuse strength.\n\t * @param baseMethod The base diffuse method on which this method's shading is based.\n\t */\n\tconstructor(modulateMethod:(shader:ShaderBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData) => string, baseMethod:DiffuseBasicMethod = null)\n\t{\n\t\tsuper();\n\n\t\tthis._onShaderInvalidatedDelegate = (event:ShadingMethodEvent) => this.onShaderInvalidated(event);\n\n\t\tthis.pBaseMethod = baseMethod || new DiffuseBasicMethod();\n\t\tthis.pBaseMethod._iModulateMethod = modulateMethod;\n\t\tthis.pBaseMethod.addEventListener(ShadingMethodEvent.SHADER_INVALIDATED, this._onShaderInvalidatedDelegate);\n\t}\n\n\t/**\n\t * The base diffuse method on which this method's shading is based.\n\t */\n\tpublic get baseMethod():DiffuseBasicMethod\n\t{\n\t\treturn this.pBaseMethod;\n\t}\n\n\tpublic set baseMethod(value:DiffuseBasicMethod)\n\t{\n\t\tif (this.pBaseMethod == value)\n\t\t\treturn;\n\n\t\tthis.pBaseMethod.removeEventListener(ShadingMethodEvent.SHADER_INVALIDATED, this._onShaderInvalidatedDelegate);\n\t\tthis.pBaseMethod = value;\n\t\tthis.pBaseMethod.addEventListener(ShadingMethodEvent.SHADER_INVALIDATED, this._onShaderInvalidatedDelegate);\n\t\tthis.iInvalidateShaderProgram();\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitVO(shader:LightingShader, methodVO:MethodVO)\n\t{\n\t\tthis.pBaseMethod.iInitVO(shader, methodVO);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitConstants(shader:LightingShader, methodVO:MethodVO)\n\t{\n\t\tthis.pBaseMethod.iInitConstants(shader, methodVO);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic dispose()\n\t{\n\t\tthis.pBaseMethod.removeEventListener(ShadingMethodEvent.SHADER_INVALIDATED, this._onShaderInvalidatedDelegate);\n\t\tthis.pBaseMethod.dispose();\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic get texture():TextureBase\n\t{\n\t\treturn this.pBaseMethod.texture;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic set texture(value:TextureBase)\n\t{\n\t\tthis.pBaseMethod.texture = value;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic get diffuseColor():number\n\t{\n\t\treturn this.pBaseMethod.diffuseColor;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic set diffuseColor(value:number)\n\t{\n\t\tthis.pBaseMethod.diffuseColor = value;\n\t}\n\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic get ambientColor():number\n\t{\n\t\treturn this.pBaseMethod.ambientColor;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic set ambientColor(value:number)\n\t{\n\t\tthis.pBaseMethod.ambientColor = value;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentPreLightingCode(shader:LightingShader, methodVO:MethodVO, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\treturn this.pBaseMethod.iGetFragmentPreLightingCode(shader, methodVO, registerCache, sharedRegisters);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentCodePerLight(shader:LightingShader, methodVO:MethodVO, lightDirReg:ShaderRegisterElement, lightColReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = this.pBaseMethod.iGetFragmentCodePerLight(shader, methodVO, lightDirReg, lightColReg, registerCache, sharedRegisters);\n\t\tthis._pTotalLightColorReg = this.pBaseMethod._pTotalLightColorReg;\n\t\treturn code;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentCodePerProbe(shader:LightingShader, methodVO:MethodVO, cubeMapReg:ShaderRegisterElement, weightRegister:string, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = this.pBaseMethod.iGetFragmentCodePerProbe(shader, methodVO, cubeMapReg, weightRegister, registerCache, sharedRegisters);\n\t\tthis._pTotalLightColorReg = this.pBaseMethod._pTotalLightColorReg;\n\t\treturn code;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iActivate(shader:LightingShader, methodVO:MethodVO, stage:Stage)\n\t{\n\t\tthis.pBaseMethod.iActivate(shader, methodVO, stage);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iSetRenderState(shader:LightingShader, methodVO:MethodVO, renderable:RenderableBase, stage:Stage, camera:Camera)\n\t{\n\t\tthis.pBaseMethod.iSetRenderState(shader, methodVO, renderable, stage, camera);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iDeactivate(shader:LightingShader, methodVO:MethodVO, stage:Stage)\n\t{\n\t\tthis.pBaseMethod.iDeactivate(shader, methodVO, stage);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetVertexCode(shader:ShaderBase, methodVO:MethodVO, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\treturn this.pBaseMethod.iGetVertexCode(shader, methodVO, registerCache, sharedRegisters);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentPostLightingCode(shader:LightingShader, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\treturn this.pBaseMethod.iGetFragmentPostLightingCode(shader, methodVO, targetReg, registerCache, sharedRegisters);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iReset()\n\t{\n\t\tthis.pBaseMethod.iReset();\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iCleanCompilationData()\n\t{\n\t\tsuper.iCleanCompilationData();\n\t\tthis.pBaseMethod.iCleanCompilationData();\n\t}\n\n\t/**\n\t * Called when the base method's shader code is invalidated.\n\t */\n\tprivate onShaderInvalidated(event:ShadingMethodEvent)\n\t{\n\t\tthis.iInvalidateShaderProgram();\n\t}\n}\n\nexport = DiffuseCompositeMethod;",
    "import LightingShader\t\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/LightingShader\");\nimport ShaderBase\t\t\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderBase\");\nimport ShaderRegisterCache\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterCache\");\nimport ShaderRegisterData\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterData\");\nimport ShaderRegisterElement\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterElement\");\n\nimport MethodVO\t\t\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/data/MethodVO\");\nimport DiffuseBasicMethod\t\t\t\t= require(\"awayjs-methodmaterials/lib/methods/DiffuseBasicMethod\");\n\n/**\n * DiffuseDepthMethod provides a debug method to visualise depth maps\n */\nclass DiffuseDepthMethod extends DiffuseBasicMethod\n{\n\t/**\n\t * Creates a new DiffuseBasicMethod object.\n\t */\n\tconstructor()\n\t{\n\t\tsuper();\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitConstants(shader:ShaderBase, methodVO:MethodVO)\n\t{\n\t\tvar data:Array<number> = shader.fragmentConstantData;\n\t\tvar index:number /*int*/ = methodVO.fragmentConstantsIndex;\n\t\tdata[index] = 1.0;\n\t\tdata[index + 1] = 1/255.0;\n\t\tdata[index + 2] = 1/65025.0;\n\t\tdata[index + 3] = 1/16581375.0;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentPostLightingCode(shader:LightingShader, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = \"\";\n\t\tvar temp:ShaderRegisterElement;\n\t\tvar decReg:ShaderRegisterElement;\n\n\t\tif (!this._texture)\n\t\t\tthrow new Error(\"DiffuseDepthMethod requires texture!\");\n\n\t\t// incorporate input from ambient\n\t\tif (shader.numLights > 0) {\n\t\t\tif (sharedRegisters.shadowTarget)\n\t\t\t\tcode += \"mul \" + this._pTotalLightColorReg + \".xyz, \" + this._pTotalLightColorReg + \".xyz, \" + sharedRegisters.shadowTarget + \".w\\n\";\n\t\t\tcode += \"add \" + targetReg + \".xyz, \" + this._pTotalLightColorReg + \".xyz, \" + targetReg + \".xyz\\n\" +\n\t\t\t\t\"sat \" + targetReg + \".xyz, \" + targetReg + \".xyz\\n\";\n\t\t\tregisterCache.removeFragmentTempUsage(this._pTotalLightColorReg);\n\t\t\tregisterCache.addFragmentTempUsages(temp = registerCache.getFreeFragmentVectorTemp(), 1);\n\t\t} else {\n\t\t\ttemp = targetReg;\n\t\t}\n\n\t\tdecReg = registerCache.getFreeFragmentConstant();\n\t\tmethodVO.fragmentConstantsIndex = decReg.index*4;\n\n\t\tmethodVO.textureVO._iInitRegisters(shader, registerCache);\n\n\t\tcode += methodVO.textureVO._iGetFragmentCode(shader, temp, registerCache, sharedRegisters.uvVarying) +\n\t\t\t\"dp4 \" + temp + \".x, \" + temp + \", \" + decReg + \"\\n\" +\n\t\t\t\"mov \" + temp + \".yz, \" + temp + \".xx\t\t\t\\n\" +\n\t\t\t\"mov \" + temp + \".w, \" + decReg + \".x\\n\" +\n\t\t\t\"sub \" + temp + \".xyz, \" + decReg + \".xxx, \" + temp + \".xyz\\n\";\n\n\t\tif (shader.numLights == 0)\n\t\t\treturn code;\n\n\t\tcode += \"mul \" + targetReg + \".xyz, \" + temp + \".xyz, \" + targetReg + \".xyz\\n\" +\n\t\t\t\"mov \" + targetReg + \".w, \" + temp + \".w\\n\";\n\n\t\tif (shader.numLights > 0)\n\t\t\tregisterCache.removeFragmentTempUsage(temp);\n\n\t\treturn code;\n\t}\n}\n\nexport = DiffuseDepthMethod;",
    "import TextureBase\t\t\t\t\t\t= require(\"awayjs-display/lib/textures/TextureBase\");\n\nimport Stage\t\t\t\t\t\t\t= require(\"awayjs-stagegl/lib/base/Stage\");\n\nimport LightingShader\t\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/LightingShader\");\nimport ShaderRegisterCache\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterCache\");\nimport ShaderRegisterData\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterData\");\nimport ShaderRegisterElement\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterElement\");\n\nimport MethodVO\t\t\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/data/MethodVO\");\nimport DiffuseBasicMethod\t\t\t\t= require(\"awayjs-methodmaterials/lib/methods/DiffuseBasicMethod\");\n\n/**\n * DiffuseGradientMethod is an alternative to DiffuseBasicMethod in which the shading can be modulated with a gradient\n * to introduce color-tinted shading as opposed to the single-channel diffuse strength. This can be used as a crude\n * approximation to subsurface scattering (for instance, the mid-range shading for skin can be tinted red to similate\n * scattered light within the skin attributing to the final colour)\n */\nclass DiffuseGradientMethod extends DiffuseBasicMethod\n{\n\tprivate _gradient:TextureBase;\n\n\t/**\n\t * Creates a new DiffuseGradientMethod object.\n\t * @param gradient A texture that contains the light colour based on the angle. This can be used to change\n\t * the light colour due to subsurface scattering when the surface faces away from the light.\n\t */\n\tconstructor(gradient:TextureBase)\n\t{\n\t\tsuper();\n\n\t\tthis._gradient = gradient;\n\t}\n\n\tpublic iInitVO(shader:LightingShader, methodVO:MethodVO)\n\t{\n\t\tsuper.iInitVO(shader, methodVO);\n\n\t\tmethodVO.secondaryTextureVO = shader.getTextureVO(this._gradient);\n\t}\n\n\t/**\n\t * A texture that contains the light colour based on the angle. This can be used to change the light colour\n\t * due to subsurface scattering when the surface faces away from the light.\n\t */\n\tpublic get gradient():TextureBase\n\t{\n\t\treturn this._gradient;\n\t}\n\n\tpublic set gradient(value:TextureBase)\n\t{\n\t\tif (this._gradient == value)\n\t\t\treturn;\n\n\t\tthis._gradient = value;\n\n\t\tthis.iInvalidateShaderProgram();\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iCleanCompilationData()\n\t{\n\t\tsuper.iCleanCompilationData();\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentPreLightingCode(shader:LightingShader, methodVO:MethodVO, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = super.iGetFragmentPreLightingCode(shader, methodVO, registerCache, sharedRegisters);\n\t\tthis._pIsFirstLight = true;\n\n\t\tif (shader.numLights > 0)\n\t\t\tmethodVO.secondaryTextureVO._iInitRegisters(shader, registerCache);\n\n\t\treturn code;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentCodePerLight(shader:LightingShader, methodVO:MethodVO, lightDirReg:ShaderRegisterElement, lightColReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = \"\";\n\t\tvar t:ShaderRegisterElement;\n\n\t\t// write in temporary if not first light, so we can add to total diffuse colour\n\t\tif (this._pIsFirstLight)\n\t\t\tt = this._pTotalLightColorReg;\n\t\telse {\n\t\t\tt = registerCache.getFreeFragmentVectorTemp();\n\t\t\tregisterCache.addFragmentTempUsages(t, 1);\n\t\t}\n\n\t\tcode += \"dp3 \" + t + \".w, \" + lightDirReg + \".xyz, \" + sharedRegisters.normalFragment + \".xyz\\n\" +\n\t\t\t\"mul \" + t + \".w, \" + t + \".w, \" + sharedRegisters.commons + \".x\\n\" +\n\t\t\t\"add \" + t + \".w, \" + t + \".w, \" + sharedRegisters.commons + \".x\\n\" +\n\t\t\t\"mul \" + t + \".xyz, \" + t + \".w, \" + lightDirReg + \".w\\n\";\n\n\t\tif (this._iModulateMethod != null)\n\t\t\tcode += this._iModulateMethod(shader, methodVO, t, registerCache, sharedRegisters);\n\n\t\tcode += methodVO.secondaryTextureVO._iGetFragmentCode(shader, t, registerCache, t) +\n\t\t\t//\t\t\t\t\t\"mul \" + t + \".xyz, \" + t + \".xyz, \" + t + \".w\\n\" +\n\t\t\t\"mul \" + t + \".xyz, \" + t + \".xyz, \" + lightColReg + \".xyz\\n\";\n\n\t\tif (!this._pIsFirstLight) {\n\t\t\tcode += \"add \" + this._pTotalLightColorReg + \".xyz, \" + this._pTotalLightColorReg + \".xyz, \" + t + \".xyz\\n\";\n\t\t\tregisterCache.removeFragmentTempUsage(t);\n\t\t}\n\n\t\tthis._pIsFirstLight = false;\n\n\t\treturn code;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic pApplyShadow(shader:LightingShader, methodVO:MethodVO, regCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar t:ShaderRegisterElement = regCache.getFreeFragmentVectorTemp();\n\n\t\treturn \"mov \" + t + \", \" + sharedRegisters.shadowTarget + \".wwww\\n\" +\n\t\t\tmethodVO.secondaryTextureVO._iGetFragmentCode(shader, t, regCache, sharedRegisters.uvVarying) +\n\t\t\t\"mul \" + this._pTotalLightColorReg + \".xyz, \" + this._pTotalLightColorReg + \", \" + t + \"\\n\";\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iActivate(shader:LightingShader, methodVO:MethodVO, stage:Stage)\n\t{\n\t\tsuper.iActivate(shader, methodVO, stage);\n\n\t\tmethodVO.secondaryTextureVO.activate(shader);\n\t}\n}\n\nexport = DiffuseGradientMethod;",
    "import TextureBase\t\t\t\t\t\t= require(\"awayjs-display/lib/textures/TextureBase\");\n\nimport Stage\t\t\t\t\t\t\t= require(\"awayjs-stagegl/lib/base/Stage\");\n\nimport LightingShader\t\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/LightingShader\");\nimport ShaderRegisterCache\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterCache\");\nimport ShaderRegisterData\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterData\");\nimport ShaderRegisterElement\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterElement\");\n\nimport MethodVO\t\t\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/data/MethodVO\");\nimport DiffuseBasicMethod\t\t\t\t= require(\"awayjs-methodmaterials/lib/methods/DiffuseBasicMethod\");\nimport DiffuseCompositeMethod\t\t\t= require(\"awayjs-methodmaterials/lib/methods/DiffuseCompositeMethod\");\n\n/**\n * DiffuseLightMapMethod provides a diffuse shading method that uses a light map to modulate the calculated diffuse\n * lighting. It is different from EffectLightMapMethod in that the latter modulates the entire calculated pixel color, rather\n * than only the diffuse lighting value.\n */\nclass DiffuseLightMapMethod extends DiffuseCompositeMethod\n{\n\t/**\n\t * Indicates the light map should be multiplied with the calculated shading result.\n\t * This can be used to add pre-calculated shadows or occlusion.\n\t */\n\tpublic static MULTIPLY:string = \"multiply\";\n\n\t/**\n\t * Indicates the light map should be added into the calculated shading result.\n\t * This can be used to add pre-calculated lighting or global illumination.\n\t */\n\tpublic static ADD:string = \"add\";\n\n\tprivate _lightMap:TextureBase;\n\tprivate _blendMode:string;\n\tprivate _useSecondaryUV:boolean;\n\n\t/**\n\t * Creates a new DiffuseLightMapMethod method.\n\t *\n\t * @param lightMap The texture containing the light map.\n\t * @param blendMode The blend mode with which the light map should be applied to the lighting result.\n\t * @param useSecondaryUV Indicates whether the secondary UV set should be used to map the light map.\n\t * @param baseMethod The diffuse method used to calculate the regular diffuse-based lighting.\n\t */\n\tconstructor(lightMap:TextureBase, blendMode:string = \"multiply\", useSecondaryUV:boolean = false, baseMethod:DiffuseBasicMethod = null)\n\t{\n\t\tsuper(null, baseMethod);\n\n\t\tthis._useSecondaryUV = useSecondaryUV;\n\t\tthis._lightMap = lightMap;\n\t\tthis.blendMode = blendMode;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitVO(shader:LightingShader, methodVO:MethodVO)\n\t{\n\t\tmethodVO.secondaryTextureVO = shader.getTextureVO(this._lightMap);\n\n\t\tif (this._useSecondaryUV)\n\t\t\tshader.secondaryUVDependencies++;\n\t\telse\n\t\t\tshader.uvDependencies++;\n\t}\n\n\t/**\n\t * The blend mode with which the light map should be applied to the lighting result.\n\t *\n\t * @see DiffuseLightMapMethod.ADD\n\t * @see DiffuseLightMapMethod.MULTIPLY\n\t */\n\tpublic get blendMode():string\n\t{\n\t\treturn this._blendMode;\n\t}\n\n\tpublic set blendMode(value:string)\n\t{\n\t\tif (value != DiffuseLightMapMethod.ADD && value != DiffuseLightMapMethod.MULTIPLY)\n\t\t\tthrow new Error(\"Unknown blendmode!\");\n\n\t\tif (this._blendMode == value)\n\t\t\treturn;\n\n\t\tthis._blendMode = value;\n\n\t\tthis.iInvalidateShaderProgram();\n\t}\n\n\t/**\n\t * The texture containing the light map data.\n\t */\n\tpublic get lightMap():TextureBase\n\t{\n\t\treturn this._lightMap;\n\t}\n\n\tpublic set lightMap(value:TextureBase)\n\t{\n\t\tif (this._lightMap == value)\n\t\t\treturn;\n\n\t\tthis._lightMap = value;\n\n\t\tthis.iInvalidateShaderProgram();\n\t}\n\n\t/**\n\t * Indicates whether the secondary UV set should be used to map the light map.\n\t */\n\tpublic get useSecondaryUV():boolean\n\t{\n\t\treturn this._useSecondaryUV;\n\t}\n\n\tpublic set useSecondaryUV(value:boolean)\n\t{\n\t\tif (this._useSecondaryUV == value)\n\t\t\treturn;\n\n\t\tthis._useSecondaryUV = value;\n\n\t\tthis.iInvalidateShaderProgram();\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentPostLightingCode(shader:LightingShader, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string;\n\t\tvar temp:ShaderRegisterElement = registerCache.getFreeFragmentVectorTemp();\n\n\t\tmethodVO.secondaryTextureVO._iInitRegisters(shader, registerCache);\n\n\t\tcode = methodVO.secondaryTextureVO._iGetFragmentCode(shader, temp, registerCache, this._useSecondaryUV? sharedRegisters.secondaryUVVarying : sharedRegisters.uvVarying);\n\n\t\tswitch (this._blendMode) {\n\t\t\tcase DiffuseLightMapMethod.MULTIPLY:\n\t\t\t\tcode += \"mul \" + this._pTotalLightColorReg + \", \" + this._pTotalLightColorReg + \", \" + temp + \"\\n\";\n\t\t\t\tbreak;\n\t\t\tcase DiffuseLightMapMethod.ADD:\n\t\t\t\tcode += \"add \" + this._pTotalLightColorReg + \", \" + this._pTotalLightColorReg + \", \" + temp + \"\\n\";\n\t\t\t\tbreak;\n\t\t}\n\n\t\tcode += super.iGetFragmentPostLightingCode(shader, methodVO, targetReg, registerCache, sharedRegisters);\n\n\t\treturn code;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iActivate(shader:LightingShader, methodVO:MethodVO, stage:Stage)\n\t{\n\t\tsuper.iActivate(shader, methodVO, stage);\n\n\t\tmethodVO.secondaryTextureVO.activate(shader);\n\t}\n}\n\nexport = DiffuseLightMapMethod;",
    "import Camera\t\t\t\t\t\t\t= require(\"awayjs-display/lib/entities/Camera\");\n\nimport Stage\t\t\t\t\t\t\t= require(\"awayjs-stagegl/lib/base/Stage\");\n\nimport LightingShader\t\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/LightingShader\");\nimport ShaderBase\t\t\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderBase\");\nimport ShaderRegisterCache\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterCache\");\nimport ShaderRegisterData\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterData\");\nimport ShaderRegisterElement\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterElement\");\nimport RenderableBase\t\t\t\t\t= require(\"awayjs-renderergl/lib/renderables/RenderableBase\");\n\nimport MethodVO\t\t\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/data/MethodVO\");\nimport DiffuseBasicMethod\t\t\t\t= require(\"awayjs-methodmaterials/lib/methods/DiffuseBasicMethod\");\nimport DiffuseCompositeMethod\t\t\t= require(\"awayjs-methodmaterials/lib/methods/DiffuseCompositeMethod\");\nimport SingleObjectDepthPass\t\t\t= require(\"awayjs-methodmaterials/lib/render/passes/SingleObjectDepthPass\");\n\n/**\n * DiffuseSubSurfaceMethod provides a depth map-based diffuse shading method that mimics the scattering of\n * light inside translucent surfaces. It allows light to shine through an object and to soften the diffuse shading.\n * It can be used for candle wax, ice, skin, ...\n */\nclass DiffuseSubSurfaceMethod extends DiffuseCompositeMethod\n{\n\tprivate _depthPass:SingleObjectDepthPass;\n\tprivate _lightProjVarying:ShaderRegisterElement;\n\tprivate _propReg:ShaderRegisterElement;\n\tprivate _scattering:number;\n\tprivate _translucency:number = 1;\n\tprivate _lightColorReg:ShaderRegisterElement;\n\tprivate _scatterColor:number /*uint*/ = 0xffffff;\n\tprivate _colorReg:ShaderRegisterElement;\n\tprivate _decReg:ShaderRegisterElement;\n\tprivate _scatterR:number = 1.0;\n\tprivate _scatterG:number = 1.0;\n\tprivate _scatterB:number = 1.0;\n\tprivate _targetReg:ShaderRegisterElement;\n\t\n\t/**\n\t * Creates a new <code>DiffuseSubSurfaceMethod</code> object.\n\t *\n\t * @param depthMapSize The size of the depth map used.\n\t * @param depthMapOffset The amount by which the rendered object will be inflated, to prevent depth map rounding errors.\n\t * @param baseMethod The diffuse method used to calculate the regular diffuse-based lighting.\n\t */\n\tconstructor(depthMapSize:number /*int*/ = 512, depthMapOffset:number = 15, baseMethod:DiffuseBasicMethod = null)\n\t{\n\t\tsuper(null, baseMethod);\n\n\t\tthis.pBaseMethod._iModulateMethod = (shader:ShaderBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData) => this.scatterLight(shader, methodVO, targetReg, registerCache, sharedRegisters);\n\n\t\t//this._passes = new Array<MaterialPassGLBase>();\n\t\t//this._depthPass = new SingleObjectDepthPass();\n\t\t//this._depthPass.textureSize = depthMapSize;\n\t\t//this._depthPass.polyOffset = depthMapOffset;\n\t\t//this._passes.push(this._depthPass);\n\t\tthis._scattering = 0.2;\n\t\tthis._translucency = 1;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitConstants(shader:LightingShader, methodVO:MethodVO)\n\t{\n\t\tsuper.iInitConstants(shader, methodVO);\n\n\t\tvar data:Array<number> = shader.vertexConstantData;\n\t\tvar index:number /*int*/ = methodVO.secondaryVertexConstantsIndex;\n\t\tdata[index] = .5;\n\t\tdata[index + 1] = -.5;\n\t\tdata[index + 2] = 0;\n\t\tdata[index + 3] = 1;\n\t\t\n\t\tdata = shader.fragmentConstantData;\n\t\tindex = methodVO.secondaryFragmentConstantsIndex;\n\t\tdata[index + 3] = 1.0;\n\t\tdata[index + 4] = 1.0;\n\t\tdata[index + 5] = 1/255;\n\t\tdata[index + 6] = 1/65025;\n\t\tdata[index + 7] = 1/16581375;\n\t\tdata[index + 10] = .5;\n\t\tdata[index + 11] = -.1;\n\t}\n\t\n\tpublic iCleanCompilationData()\n\t{\n\t\tsuper.iCleanCompilationData();\n\n\t\tthis._lightProjVarying = null;\n\t\tthis._propReg = null;\n\t\tthis._lightColorReg = null;\n\t\tthis._colorReg = null;\n\t\tthis._decReg = null;\n\t\tthis._targetReg = null;\n\t}\n\t\n\t/**\n\t * The amount by which the light scatters. It can be used to set the translucent surface's thickness. Use low\n\t * values for skin.\n\t */\n\tpublic get scattering():number\n\t{\n\t\treturn this._scattering;\n\t}\n\t\n\tpublic set scattering(value:number)\n\t{\n\t\tthis._scattering = value;\n\t}\n\t\n\t/**\n\t * The translucency of the object.\n\t */\n\tpublic get translucency():number\n\t{\n\t\treturn this._translucency;\n\t}\n\t\n\tpublic set translucency(value:number)\n\t{\n\t\tthis._translucency = value;\n\t}\n\t\n\t/**\n\t * The colour of the \"insides\" of the object, ie: the colour the light becomes after leaving the object.\n\t */\n\tpublic get scatterColor():number /*uint*/\n\t{\n\t\treturn this._scatterColor;\n\t}\n\t\n\tpublic set scatterColor(scatterColor:number /*uint*/)\n\t{\n\t\tthis._scatterColor = scatterColor;\n\t\tthis._scatterR = ((scatterColor >> 16) & 0xff)/0xff;\n\t\tthis._scatterG = ((scatterColor >> 8) & 0xff)/0xff;\n\t\tthis._scatterB = (scatterColor & 0xff)/0xff;\n\t}\n\t\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetVertexCode(shader:ShaderBase, methodVO:MethodVO, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = super.iGetVertexCode(shader, methodVO, registerCache, sharedRegisters);\n\t\tvar lightProjection:ShaderRegisterElement;\n\t\tvar toTexRegister:ShaderRegisterElement;\n\t\tvar temp:ShaderRegisterElement = registerCache.getFreeVertexVectorTemp();\n\t\t\n\t\ttoTexRegister = registerCache.getFreeVertexConstant();\n\t\tmethodVO.secondaryVertexConstantsIndex = toTexRegister.index*4;\n\n\t\tthis._lightProjVarying = registerCache.getFreeVarying();\n\t\tlightProjection = registerCache.getFreeVertexConstant();\n\t\tregisterCache.getFreeVertexConstant();\n\t\tregisterCache.getFreeVertexConstant();\n\t\tregisterCache.getFreeVertexConstant();\n\t\t\n\t\tcode += \"m44 \" + temp + \", vt0, \" + lightProjection + \"\\n\" +\n\t\t\t\"div \" + temp + \".xyz, \" + temp + \".xyz, \" + temp + \".w\\n\" +\n\t\t\t\"mul \" + temp + \".xy, \" + temp + \".xy, \" + toTexRegister + \".xy\\n\" +\n\t\t\t\"add \" + temp + \".xy, \" + temp + \".xy, \" + toTexRegister + \".xx\\n\" +\n\t\t\t\"mov \" + this._lightProjVarying + \".xyz, \" + temp + \".xyz\\n\" +\n\t\t\t\"mov \" + this._lightProjVarying + \".w, va0.w\\n\";\n\t\t\n\t\treturn code;\n\t}\n\t\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentPreLightingCode(shader:LightingShader, methodVO:MethodVO, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tthis._colorReg = registerCache.getFreeFragmentConstant();\n\t\tthis._decReg = registerCache.getFreeFragmentConstant();\n\t\tthis._propReg = registerCache.getFreeFragmentConstant();\n\t\tmethodVO.secondaryFragmentConstantsIndex = this._colorReg.index*4;\n\t\t\n\t\treturn super.iGetFragmentPreLightingCode(shader, methodVO, registerCache, sharedRegisters);\n\t}\n\t\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentCodePerLight(shader:LightingShader, methodVO:MethodVO, lightDirReg:ShaderRegisterElement, lightColReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tthis._pIsFirstLight = true;\n\t\tthis._lightColorReg = lightColReg;\n\t\treturn super.iGetFragmentCodePerLight(shader, methodVO, lightDirReg, lightColReg, registerCache, sharedRegisters);\n\t}\n\t\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentPostLightingCode(shader:LightingShader, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = super.iGetFragmentPostLightingCode(shader, methodVO, targetReg, registerCache, sharedRegisters);\n\t\tvar temp:ShaderRegisterElement = registerCache.getFreeFragmentVectorTemp();\n\t\t\n\t\tcode += \"mul \" + temp + \".xyz, \" + this._lightColorReg + \".xyz, \" + this._targetReg + \".w\\n\" +\n\t\t\t\"mul \" + temp + \".xyz, \" + temp + \".xyz, \" + this._colorReg + \".xyz\\n\" +\n\t\t\t\"add \" + targetReg + \".xyz, \" + targetReg + \".xyz, \" + temp + \".xyz\\n\";\n\t\t\n\t\tif (this._targetReg != sharedRegisters.viewDirFragment)\n\t\t\tregisterCache.removeFragmentTempUsage(targetReg);\n\t\t\n\t\treturn code;\n\t}\n\t\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iActivate(shader:LightingShader, methodVO:MethodVO, stage:Stage)\n\t{\n\t\tsuper.iActivate(shader, methodVO, stage);\n\n\t\tvar index:number /*int*/ = methodVO.secondaryFragmentConstantsIndex;\n\t\tvar data:Array<number> = shader.fragmentConstantData;\n\t\tdata[index] = this._scatterR;\n\t\tdata[index + 1] = this._scatterG;\n\t\tdata[index + 2] = this._scatterB;\n\t\tdata[index + 8] = this._scattering;\n\t\tdata[index + 9] = this._translucency;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iSetRenderState(shader:ShaderBase, methodVO:MethodVO, renderable:RenderableBase, stage:Stage, camera:Camera)\n\t{\n\t\tmethodVO.secondaryTextureVO = shader.getTextureVO(this._depthPass._iGetDepthMap(renderable));\n\t\tmethodVO.secondaryTextureVO.activate(shader);\n\n\t\tthis._depthPass._iGetProjection(renderable).copyRawDataTo(shader.vertexConstantData, methodVO.secondaryVertexConstantsIndex + 4, true);\n\t}\n\t\n\t/**\n\t * Generates the code for this method\n\t */\n\tprivate scatterLight(shader:ShaderBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\t// only scatter first light\n\t\tif (!this._pIsFirstLight)\n\t\t\treturn \"\";\n\n\t\tthis._pIsFirstLight = false;\n\n\t\tvar code:string = \"\";\n\n\t\tif (sharedRegisters.viewDirFragment)\n\t\t\tthis._targetReg = sharedRegisters.viewDirFragment;\n\t\telse\n\t\t\tregisterCache.addFragmentTempUsages(this._targetReg = registerCache.getFreeFragmentVectorTemp(), 1);\n\n\t\tvar temp:ShaderRegisterElement = registerCache.getFreeFragmentVectorTemp();\n\n\t\tcode += methodVO.secondaryTextureVO._iGetFragmentCode(shader, temp, registerCache, this._lightProjVarying) +\n\t\t\t// reencode RGBA\n\t\t\t\"dp4 \" + targetReg + \".z, \" + temp + \", \" + this._decReg + \"\\n\";\n\t\t// currentDistanceToLight - closestDistanceToLight\n\t\tcode += \"sub \" + targetReg + \".z, \" + this._lightProjVarying + \".z, \" + targetReg + \".z\\n\" +\n\t\t\t\n\t\t\t\"sub \" + targetReg + \".z, \" + this._propReg + \".x, \" + targetReg + \".z\\n\" +\n\t\t\t\"mul \" + targetReg + \".z, \" + this._propReg + \".y, \" + targetReg + \".z\\n\" +\n\t\t\t\"sat \" + targetReg + \".z, \" + targetReg + \".z\\n\" +\n\t\t\t\n\t\t\t// targetReg.x contains dot(lightDir, normal)\n\t\t\t// modulate according to incident light angle (scatter = scatter*(-.5*dot(light, normal) + .5)\n\t\t\t\"neg \" + targetReg + \".y, \" + targetReg + \".x\\n\" +\n\t\t\t\"mul \" + targetReg + \".y, \" + targetReg + \".y, \" + this._propReg + \".z\\n\" +\n\t\t\t\"add \" + targetReg + \".y, \" + targetReg + \".y, \" + this._propReg + \".z\\n\" +\n\t\t\t\"mul \" + this._targetReg + \".w, \" + targetReg + \".z, \" + targetReg + \".y\\n\" +\n\t\t\t\n\t\t\t// blend diffuse: d' = (1-s)*d + s*1\n\t\t\t\"sub \" + targetReg + \".y, \" + this._colorReg + \".w, \" + this._targetReg + \".w\\n\" +\n\t\t\t\"mul \" + targetReg + \".w, \" + targetReg + \".w, \" + targetReg + \".y\\n\";\n\t\t\n\t\treturn code;\n\t}\n}\n\nexport = DiffuseSubSurfaceMethod;",
    "import Stage\t\t\t\t\t\t\t= require(\"awayjs-stagegl/lib/base/Stage\");\n\nimport LightingShader\t\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/LightingShader\");\nimport ShaderRegisterCache\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterCache\");\nimport ShaderRegisterData\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterData\");\nimport ShaderRegisterElement\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterElement\");\n\nimport MethodVO\t\t\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/data/MethodVO\");\nimport DiffuseBasicMethod\t\t\t\t= require(\"awayjs-methodmaterials/lib/methods/DiffuseBasicMethod\");\n\n/**\n * DiffuseWrapMethod is an alternative to DiffuseBasicMethod in which the light is allowed to be \"wrapped around\" the normally dark area, to some extent.\n * It can be used as a crude approximation to Oren-Nayar or simple subsurface scattering.\n */\nclass DiffuseWrapMethod extends DiffuseBasicMethod\n{\n\tprivate _wrapDataRegister:ShaderRegisterElement;\n\tprivate _wrapFactor:number;\n\n\t/**\n\t * Creates a new DiffuseWrapMethod object.\n\t * @param wrapFactor A factor to indicate the amount by which the light is allowed to wrap\n\t */\n\tconstructor(wrapFactor:number = .5)\n\t{\n\t\tsuper();\n\n\t\tthis.wrapFactor = wrapFactor;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iCleanCompilationData()\n\t{\n\t\tsuper.iCleanCompilationData();\n\n\t\tthis._wrapDataRegister = null;\n\t}\n\n\t/**\n\t * A factor to indicate the amount by which the light is allowed to wrap.\n\t */\n\tpublic get wrapFactor():number\n\t{\n\t\treturn this._wrapFactor;\n\t}\n\n\tpublic set wrapFactor(value:number)\n\t{\n\t\tthis._wrapFactor = value;\n\t\tthis._wrapFactor = 1/(value + 1);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentPreLightingCode(shader:LightingShader, methodVO:MethodVO, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = super.iGetFragmentPreLightingCode(shader, methodVO, registerCache, sharedRegisters);\n\t\tthis._pIsFirstLight = true;\n\t\tthis._wrapDataRegister = registerCache.getFreeFragmentConstant();\n\t\tmethodVO.secondaryFragmentConstantsIndex = this._wrapDataRegister.index*4;\n\n\t\treturn code;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentCodePerLight(shader:LightingShader, methodVO:MethodVO, lightDirReg:ShaderRegisterElement, lightColReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = \"\";\n\t\tvar t:ShaderRegisterElement;\n\n\t\t// write in temporary if not first light, so we can add to total diffuse colour\n\t\tif (this._pIsFirstLight) {\n\t\t\tt = this._pTotalLightColorReg;\n\t\t} else {\n\t\t\tt = registerCache.getFreeFragmentVectorTemp();\n\t\t\tregisterCache.addFragmentTempUsages(t, 1);\n\t\t}\n\n\t\tcode += \"dp3 \" + t + \".x, \" + lightDirReg + \".xyz, \" + sharedRegisters.normalFragment + \".xyz\\n\" +\n\t\t\t\"add \" + t + \".y, \" + t + \".x, \" + this._wrapDataRegister + \".x\\n\" +\n\t\t\t\"mul \" + t + \".y, \" + t + \".y, \" + this._wrapDataRegister + \".y\\n\" +\n\t\t\t\"sat \" + t + \".w, \" + t + \".y\\n\" +\n\t\t\t\"mul \" + t + \".xz, \" + t + \".w, \" + lightDirReg + \".wz\\n\";\n\n\t\tif (this._iModulateMethod != null)\n\t\t\tcode += this._iModulateMethod(shader, methodVO, lightDirReg, registerCache, sharedRegisters);\n\n\t\tcode += \"mul \" + t + \", \" + t + \".x, \" + lightColReg + \"\\n\";\n\n\t\tif (!this._pIsFirstLight) {\n\t\t\tcode += \"add \" + this._pTotalLightColorReg + \".xyz, \" + this._pTotalLightColorReg + \".xyz, \" + t + \".xyz\\n\";\n\t\t\tregisterCache.removeFragmentTempUsage(t);\n\t\t}\n\n\t\tthis._pIsFirstLight = false;\n\n\t\treturn code;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iActivate(shader:LightingShader, methodVO:MethodVO, stage:Stage)\n\t{\n\t\tsuper.iActivate(shader, methodVO, stage);\n\n\t\tvar index:number /*int*/ = methodVO.secondaryFragmentConstantsIndex;\n\t\tvar data:Array<number> = shader.fragmentConstantData;\n\t\tdata[index] = this._wrapFactor;\n\t\tdata[index + 1] = 1/(this._wrapFactor + 1);\n\t}\n}\n\nexport = DiffuseWrapMethod;",
    "import TextureBase\t\t\t\t\t\t= require(\"awayjs-display/lib/textures/TextureBase\");\n\nimport Stage\t\t\t\t\t\t\t= require(\"awayjs-stagegl/lib/base/Stage\");\n\nimport LightingShader\t\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/LightingShader\");\nimport ShaderBase\t\t\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderBase\");\nimport ShaderRegisterCache\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterCache\");\nimport ShaderRegisterData\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterData\");\nimport ShaderRegisterElement\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterElement\");\n\nimport MethodVO\t\t\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/data/MethodVO\");\nimport EffectMethodBase\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/methods/EffectMethodBase\");\n\n/**\n * EffectAlphaMaskMethod allows the use of an additional texture to specify the alpha value of the material. When used\n * with the secondary uv set, it allows for a tiled main texture with independently varying alpha (useful for water\n * etc).\n */\nclass EffectAlphaMaskMethod extends EffectMethodBase\n{\n\tprivate _texture:TextureBase;\n\tprivate _useSecondaryUV:boolean;\n\n\t/**\n\t * Creates a new EffectAlphaMaskMethod object.\n\t *\n\t * @param texture The texture to use as the alpha mask.\n\t * @param useSecondaryUV Indicated whether or not the secondary uv set for the mask. This allows mapping alpha independently.\n\t */\n\tconstructor(texture:TextureBase, useSecondaryUV:boolean = false)\n\t{\n\t\tsuper();\n\n\t\tthis._texture = texture;\n\t\tthis._useSecondaryUV = useSecondaryUV;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitVO(shader:ShaderBase, methodVO:MethodVO)\n\t{\n\t\tmethodVO.textureVO = shader.getTextureVO(this._texture);\n\n\t\tif (this._useSecondaryUV)\n\t\t\tshader.secondaryUVDependencies++;\n\t\telse\n\t\t\tshader.uvDependencies++;\n\t}\n\n\t/**\n\t * Indicated whether or not the secondary uv set for the mask. This allows mapping alpha independently, for\n\t * instance to tile the main texture and normal map while providing untiled alpha, for example to define the\n\t * transparency over a tiled water surface.\n\t */\n\tpublic get useSecondaryUV():boolean\n\t{\n\t\treturn this._useSecondaryUV;\n\t}\n\n\tpublic set useSecondaryUV(value:boolean)\n\t{\n\t\tif (this._useSecondaryUV == value)\n\t\t\treturn;\n\n\t\tthis._useSecondaryUV = value;\n\n\t\tthis.iInvalidateShaderProgram();\n\t}\n\n\t/**\n\t * The texture to use as the alpha mask.\n\t */\n\tpublic get texture():TextureBase\n\t{\n\t\treturn this._texture;\n\t}\n\n\tpublic set texture(value:TextureBase)\n\t{\n\t\tif (this._texture == value)\n\t\t\treturn;\n\n\t\tthis._texture = value;\n\n\t\tthis.iInvalidateShaderProgram();\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentCode(shader:ShaderBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar temp:ShaderRegisterElement = registerCache.getFreeFragmentVectorTemp();\n\n\t\treturn methodVO.textureVO._iGetFragmentCode(shader, temp, registerCache, this._useSecondaryUV? sharedRegisters.secondaryUVVarying : sharedRegisters.uvVarying) +\n\t\t\t\"mul \" + targetReg + \", \" + targetReg + \", \" + temp + \".x\\n\";\n\t}\n\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iActivate(shader:LightingShader, methodVO:MethodVO, stage:Stage)\n\t{\n\t\tsuper.iActivate(shader, methodVO, stage);\n\n\t\tmethodVO.textureVO.activate(shader);\n\t}\n}\n\nexport = EffectAlphaMaskMethod;",
    "import Stage\t\t\t\t\t\t\t= require(\"awayjs-stagegl/lib/base/Stage\");\n\nimport ShaderBase\t\t\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderBase\");\nimport ShaderRegisterCache\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterCache\");\nimport ShaderRegisterData\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterData\");\nimport ShaderRegisterElement\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterElement\");\n\nimport MethodVO\t\t\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/data/MethodVO\");\nimport EffectMethodBase\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/methods/EffectMethodBase\");\n\n/**\n * EffectColorMatrixMethod provides a shading method that changes the colour of a material analogous to a ColorMatrixFilter.\n */\nclass EffectColorMatrixMethod extends EffectMethodBase\n{\n\tprivate _matrix:Array<number>;\n\n\t/**\n\t * Creates a new EffectColorTransformMethod.\n\t *\n\t * @param matrix An array of 20 items for 4 x 5 color transform.\n\t */\n\tconstructor(matrix:Array<number>)\n\t{\n\t\tsuper();\n\n\t\tif (matrix.length != 20)\n\t\t\tthrow new Error(\"Matrix length must be 20!\");\n\n\t\tthis._matrix = matrix;\n\t}\n\n\t/**\n\t * The 4 x 5 matrix to transform the color of the material.\n\t */\n\tpublic get colorMatrix():Array<number>\n\t{\n\t\treturn this._matrix;\n\t}\n\n\tpublic set colorMatrix(value:Array<number>)\n\t{\n\t\tthis._matrix = value;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentCode(shader:ShaderBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = \"\";\n\t\tvar colorMultReg:ShaderRegisterElement = registerCache.getFreeFragmentConstant();\n\t\tregisterCache.getFreeFragmentConstant();\n\t\tregisterCache.getFreeFragmentConstant();\n\t\tregisterCache.getFreeFragmentConstant();\n\n\t\tvar colorOffsetReg:ShaderRegisterElement = registerCache.getFreeFragmentConstant();\n\n\t\tmethodVO.fragmentConstantsIndex = colorMultReg.index*4;\n\n\t\tvar temp:ShaderRegisterElement = registerCache.getFreeFragmentVectorTemp();\n\n\t\tcode += \"m44 \" + temp + \", \" + targetReg + \", \" + colorMultReg + \"\\n\" +\n\t\t\t\t\"add \" + targetReg + \", \" + temp + \", \" + colorOffsetReg + \"\\n\";\n\n\t\treturn code;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iActivate(shader:ShaderBase, methodVO:MethodVO, stage:Stage)\n\t{\n\t\tvar matrix:Array<number> = this._matrix;\n\t\tvar index:number /*int*/ = methodVO.fragmentConstantsIndex;\n\t\tvar data:Array<number> = shader.fragmentConstantData;\n\n\t\t// r\n\t\tdata[index] = matrix[0];\n\t\tdata[index + 1] = matrix[1];\n\t\tdata[index + 2] = matrix[2];\n\t\tdata[index + 3] = matrix[3];\n\n\t\t// g\n\t\tdata[index + 4] = matrix[5];\n\t\tdata[index + 5] = matrix[6];\n\t\tdata[index + 6] = matrix[7];\n\t\tdata[index + 7] = matrix[8];\n\n\t\t// b\n\t\tdata[index + 8] = matrix[10];\n\t\tdata[index + 9] = matrix[11];\n\t\tdata[index + 10] = matrix[12];\n\t\tdata[index + 11] = matrix[13];\n\n\t\t// a\n\t\tdata[index + 12] = matrix[15];\n\t\tdata[index + 13] = matrix[16];\n\t\tdata[index + 14] = matrix[17];\n\t\tdata[index + 15] = matrix[18];\n\n\t\t// rgba offset\n\t\tdata[index + 16] = matrix[4];\n\t\tdata[index + 17] = matrix[9];\n\t\tdata[index + 18] = matrix[14];\n\t\tdata[index + 19] = matrix[19];\n\t}\n}\n\nexport = EffectColorMatrixMethod;",
    "import ColorTransform\t\t\t\t= require(\"awayjs-core/lib/geom/ColorTransform\");\n\nimport Stage\t\t\t\t\t\t= require(\"awayjs-stagegl/lib/base/Stage\");\n\nimport ShaderBase\t\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderBase\");\nimport ShaderRegisterCache\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterCache\");\nimport ShaderRegisterData\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterData\");\nimport ShaderRegisterElement\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterElement\");\n\nimport MethodVO\t\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/data/MethodVO\");\nimport EffectMethodBase\t\t\t\t= require(\"awayjs-methodmaterials/lib/methods/EffectMethodBase\");\n\n/**\n * EffectColorTransformMethod provides a shading method that changes the colour of a material analogous to a\n * ColorTransform object.\n */\nclass EffectColorTransformMethod extends EffectMethodBase\n{\n\tprivate _colorTransform:ColorTransform;\n\n\t/**\n\t * Creates a new EffectColorTransformMethod.\n\t */\n\tconstructor()\n\t{\n\t\tsuper();\n\t}\n\n\t/**\n\t * The ColorTransform object to transform the colour of the material with.\n\t */\n\tpublic get colorTransform():ColorTransform\n\t{\n\t\treturn this._colorTransform;\n\t}\n\n\tpublic set colorTransform(value:ColorTransform)\n\t{\n\t\tthis._colorTransform = value;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentCode(shader:ShaderBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = \"\";\n\t\tvar colorMultReg:ShaderRegisterElement = registerCache.getFreeFragmentConstant();\n\t\tvar colorOffsReg:ShaderRegisterElement = registerCache.getFreeFragmentConstant();\n\n\t\tmethodVO.fragmentConstantsIndex = colorMultReg.index*4;\n\n\t\t//TODO: AGAL <> GLSL\n\n\t\tcode += \"mul \" + targetReg + \", \" + targetReg + \", \" + colorMultReg + \"\\n\" + \"add \" + targetReg + \", \" + targetReg + \", \" + colorOffsReg + \"\\n\";\n\n\t\treturn code;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iActivate(shader:ShaderBase, methodVO:MethodVO, stage:Stage)\n\t{\n\t\tvar inv:number = 1/0xff;\n\t\tvar index:number = methodVO.fragmentConstantsIndex;\n\t\tvar data:Array<number> = shader.fragmentConstantData;\n\n\t\tdata[index] = this._colorTransform.redMultiplier;\n\t\tdata[index + 1] = this._colorTransform.greenMultiplier;\n\t\tdata[index + 2] = this._colorTransform.blueMultiplier;\n\t\tdata[index + 3] = this._colorTransform.alphaMultiplier;\n\t\tdata[index + 4] = this._colorTransform.redOffset*inv;\n\t\tdata[index + 5] = this._colorTransform.greenOffset*inv;\n\t\tdata[index + 6] = this._colorTransform.blueOffset*inv;\n\t\tdata[index + 7] = this._colorTransform.alphaOffset*inv;\n\n\t}\n}\n\nexport = EffectColorTransformMethod;",
    "import TextureBase\t\t\t\t\t\t= require(\"awayjs-display/lib/textures/TextureBase\");\n\nimport Stage\t\t\t\t\t\t\t= require(\"awayjs-stagegl/lib/base/Stage\");\n\nimport ShaderBase\t\t\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderBase\");\nimport ShaderRegisterCache\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterCache\");\nimport ShaderRegisterData\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterData\");\nimport ShaderRegisterElement\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterElement\");\n\nimport MethodVO\t\t\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/data/MethodVO\");\nimport EffectMethodBase\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/methods/EffectMethodBase\");\n\n/**\n * EffectEnvMapMethod provides a material method to perform reflection mapping using cube maps.\n */\nclass EffectEnvMapMethod extends EffectMethodBase\n{\n\tprivate _envMap:TextureBase;\n\tprivate _alpha:number;\n\tprivate _mask:TextureBase;\n\n\t/**\n\t * Creates an EffectEnvMapMethod object.\n\t * @param envMap The environment map containing the reflected scene.\n\t * @param alpha The reflectivity of the surface.\n\t */\n\tconstructor(envMap:TextureBase, alpha:number = 1)\n\t{\n\t\tsuper();\n\t\tthis._envMap = envMap;\n\t\tthis._alpha = alpha;\n\n\t}\n\n\t/**\n\t * An optional texture to modulate the reflectivity of the surface.\n\t */\n\tpublic get mask():TextureBase\n\t{\n\t\treturn this._mask;\n\t}\n\n\tpublic set mask(value:TextureBase)\n\t{\n\t\tif (value == this._mask)\n\t\t\treturn;\n\n\t\tthis._mask = value;\n\n\t\tthis.iInvalidateShaderProgram();\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitVO(shader:ShaderBase, methodVO:MethodVO)\n\t{\n\t\tmethodVO.needsNormals = true;\n\t\tmethodVO.needsView = true;\n\n\t\tmethodVO.textureVO = shader.getTextureVO(this._envMap);\n\n\t\tif (this._mask != null) {\n\t\t\tmethodVO.secondaryTextureVO = shader.getTextureVO(this._mask);\n\t\t\tshader.uvDependencies++;\n\t\t}\n\t}\n\n\t/**\n\t * The cubic environment map containing the reflected scene.\n\t */\n\tpublic get envMap():TextureBase\n\t{\n\t\treturn this._envMap;\n\t}\n\n\tpublic set envMap(value:TextureBase)\n\t{\n\t\tif (this._envMap == value)\n\t\t\treturn;\n\n\t\tthis._envMap = value;\n\n\t\tthis.iInvalidateShaderProgram();\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic dispose()\n\t{\n\t}\n\n\t/**\n\t * The reflectivity of the surface.\n\t */\n\tpublic get alpha():number\n\t{\n\t\treturn this._alpha;\n\t}\n\n\tpublic set alpha(value:number)\n\t{\n\t\tthis._alpha = value;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iActivate(shader:ShaderBase, methodVO:MethodVO, stage:Stage)\n\t{\n\t\tshader.fragmentConstantData[methodVO.fragmentConstantsIndex] = this._alpha;\n\n\t\tmethodVO.textureVO.activate(shader);\n\n\t\tif (this._mask)\n\t\t\tmethodVO.secondaryTextureVO.activate(shader);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentCode(shader:ShaderBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar dataRegister:ShaderRegisterElement = registerCache.getFreeFragmentConstant();\n\t\tvar code:string = \"\";\n\n\t\tmethodVO.fragmentConstantsIndex = dataRegister.index*4;\n\n\t\tvar temp:ShaderRegisterElement = registerCache.getFreeFragmentVectorTemp();\n\t\tregisterCache.addFragmentTempUsages(temp, 1);\n\t\tvar temp2:ShaderRegisterElement = registerCache.getFreeFragmentVectorTemp();\n\t\tregisterCache.addFragmentTempUsages(temp2, 1);\n\n\t\tmethodVO.textureVO._iInitRegisters(shader, registerCache);\n\n\t\t// r = I - 2(I.N)*N\n\t\tcode += \"dp3 \" + temp + \".w, \" + sharedRegisters.viewDirFragment + \".xyz, \" + sharedRegisters.normalFragment + \".xyz\\n\" +\n\t\t\t\"add \" + temp + \".w, \" + temp + \".w, \" + temp + \".w\\n\" +\n\t\t\t\"mul \" + temp + \".xyz, \" + sharedRegisters.normalFragment + \".xyz, \" + temp + \".w\\n\" +\n\t\t\t\"sub \" + temp + \".xyz, \" + temp + \".xyz, \" + sharedRegisters.viewDirFragment + \".xyz\\n\" +\n\t\t\tmethodVO.textureVO._iGetFragmentCode(shader, temp, registerCache, temp) +\n\t\t\t\"sub \" + temp2 + \".w, \" + temp + \".w, fc0.x\\n\" + // -.5\n\t\t\t\"kil \" + temp2 + \".w\\n\" +\t// used for real time reflection mapping - if alpha is not 1 (mock texture) kil output\n\t\t\t\"sub \" + temp + \", \" + temp + \", \" + targetReg + \"\\n\";\n\n\t\tif (this._mask) {\n\t\t\tmethodVO.secondaryTextureVO._iInitRegisters(shader, registerCache);\n\n\t\t\tcode += methodVO.secondaryTextureVO._iGetFragmentCode(shader, temp2, registerCache, sharedRegisters.uvVarying) +\n\t\t\t\t\"mul \" + temp + \", \" + temp2 + \", \" + temp + \"\\n\";\n\t\t}\n\n\t\tcode += \"mul \" + temp + \", \" + temp + \", \" + dataRegister + \".x\\n\" +\n\t\t\t\t\"add \" + targetReg + \", \" + targetReg + \", \" + temp + \"\\n\";\n\n\t\tregisterCache.removeFragmentTempUsage(temp);\n\t\tregisterCache.removeFragmentTempUsage(temp2);\n\n\t\treturn code;\n\t}\n}\n\nexport = EffectEnvMapMethod;",
    "import Stage\t\t\t\t\t\t\t= require(\"awayjs-stagegl/lib/base/Stage\");\n\nimport LightingShader\t\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/LightingShader\");\nimport ShaderBase\t\t\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderBase\");\nimport ShaderRegisterCache\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterCache\");\nimport ShaderRegisterData\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterData\");\nimport ShaderRegisterElement\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterElement\");\n\nimport MethodVO\t\t\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/data/MethodVO\");\nimport EffectMethodBase\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/methods/EffectMethodBase\");\n\n/**\n * EffectFogMethod provides a method to add distance-based fog to a material.\n */\nclass EffectFogMethod extends EffectMethodBase\n{\n\tprivate _minDistance:number = 0;\n\tprivate _maxDistance:number = 1000;\n\tprivate _fogColor:number /*uint*/;\n\tprivate _fogR:number;\n\tprivate _fogG:number;\n\tprivate _fogB:number;\n\n\t/**\n\t * Creates a new EffectFogMethod object.\n\t * @param minDistance The distance from which the fog starts appearing.\n\t * @param maxDistance The distance at which the fog is densest.\n\t * @param fogColor The colour of the fog.\n\t */\n\tconstructor(minDistance:number, maxDistance:number, fogColor:number /*uint*/ = 0x808080)\n\t{\n\t\tsuper();\n\t\tthis.minDistance = minDistance;\n\t\tthis.maxDistance = maxDistance;\n\t\tthis.fogColor = fogColor;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitVO(shader:LightingShader, methodVO:MethodVO)\n\t{\n\t\tmethodVO.needsProjection = true;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitConstants(shader:ShaderBase, methodVO:MethodVO)\n\t{\n\t\tvar data:Array<number> = shader.fragmentConstantData;\n\t\tvar index:number /*int*/ = methodVO.fragmentConstantsIndex;\n\t\tdata[index + 3] = 1;\n\t\tdata[index + 6] = 0;\n\t\tdata[index + 7] = 0;\n\t}\n\n\t/**\n\t * The distance from which the fog starts appearing.\n\t */\n\tpublic get minDistance():number\n\t{\n\t\treturn this._minDistance;\n\t}\n\n\tpublic set minDistance(value:number)\n\t{\n\t\tthis._minDistance = value;\n\t}\n\n\t/**\n\t * The distance at which the fog is densest.\n\t */\n\tpublic get maxDistance():number\n\t{\n\t\treturn this._maxDistance;\n\t}\n\n\tpublic set maxDistance(value:number)\n\t{\n\t\tthis._maxDistance = value;\n\t}\n\n\t/**\n\t * The colour of the fog.\n\t */\n\tpublic get fogColor():number /*uint*/\n\t{\n\t\treturn this._fogColor;\n\t}\n\n\tpublic set fogColor(value:number/*uint*/)\n\t{\n\t\tthis._fogColor = value;\n\t\tthis._fogR = ((value >> 16) & 0xff)/0xff;\n\t\tthis._fogG = ((value >> 8) & 0xff)/0xff;\n\t\tthis._fogB = (value & 0xff)/0xff;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iActivate(shader:ShaderBase, methodVO:MethodVO, stage:Stage)\n\t{\n\t\tvar data:Array<number> = shader.fragmentConstantData;\n\t\tvar index:number /*int*/ = methodVO.fragmentConstantsIndex;\n\t\tdata[index] = this._fogR;\n\t\tdata[index + 1] = this._fogG;\n\t\tdata[index + 2] = this._fogB;\n\t\tdata[index + 4] = this._minDistance;\n\t\tdata[index + 5] = 1/(this._maxDistance - this._minDistance);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentCode(shader:ShaderBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar fogColor:ShaderRegisterElement = registerCache.getFreeFragmentConstant();\n\t\tvar fogData:ShaderRegisterElement = registerCache.getFreeFragmentConstant();\n\t\tvar temp:ShaderRegisterElement = registerCache.getFreeFragmentVectorTemp();\n\t\tregisterCache.addFragmentTempUsages(temp, 1);\n\t\tvar temp2:ShaderRegisterElement = registerCache.getFreeFragmentVectorTemp();\n\t\tvar code:string = \"\";\n\t\tmethodVO.fragmentConstantsIndex = fogColor.index*4;\n\n\t\tcode += \"sub \" + temp2 + \".w, \" + sharedRegisters.projectionFragment + \".z, \" + fogData + \".x\\n\" +\n\t\t\t\t\"mul \" + temp2 + \".w, \" + temp2 + \".w, \" + fogData + \".y\\n\" +\n\t\t\t\t\"sat \" + temp2 + \".w, \" + temp2 + \".w\\n\" +\n\t\t\t\t\"sub \" + temp + \", \" + fogColor + \", \" + targetReg + \"\\n\" + // (fogColor- col)\n\t\t\t\t\"mul \" + temp + \", \" + temp + \", \" + temp2 + \".w\\n\" + // (fogColor- col)*fogRatio\n\t\t\t\t\"add \" + targetReg + \", \" + targetReg + \", \" + temp + \"\\n\"; // fogRatio*(fogColor- col) + col\n\n\t\tregisterCache.removeFragmentTempUsage(temp);\n\n\t\treturn code;\n\t}\n}\n\nexport = EffectFogMethod;",
    "import TextureBase\t\t\t\t\t\t= require(\"awayjs-display/lib/textures/TextureBase\");\n\nimport Stage\t\t\t\t\t\t\t= require(\"awayjs-stagegl/lib/base/Stage\");\n\nimport ShaderBase\t\t\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderBase\");\nimport ShaderRegisterCache\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterCache\");\nimport ShaderRegisterData\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterData\");\nimport ShaderRegisterElement\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterElement\");\n\nimport MethodVO\t\t\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/data/MethodVO\");\nimport EffectMethodBase\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/methods/EffectMethodBase\");\n\n/**\n * EffectFresnelEnvMapMethod provides a method to add fresnel-based reflectivity to an object using cube maps, which gets\n * stronger as the viewing angle becomes more grazing.\n */\nclass EffectFresnelEnvMapMethod extends EffectMethodBase\n{\n\tprivate _envMap:TextureBase;\n\tprivate _fresnelPower:number = 5;\n\tprivate _normalReflectance:number = 0;\n\tprivate _alpha:number;\n\tprivate _mask:TextureBase;\n\n\t/**\n\t * Creates a new <code>EffectFresnelEnvMapMethod</code> object.\n\t *\n\t * @param envMap The environment map containing the reflected scene.\n\t * @param alpha The reflectivity of the material.\n\t */\n\tconstructor(envMap:TextureBase, alpha:number = 1)\n\t{\n\t\tsuper();\n\n\t\tthis._envMap = envMap;\n\t\tthis._alpha = alpha;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitVO(shader:ShaderBase, methodVO:MethodVO)\n\t{\n\t\tmethodVO.needsNormals = true;\n\t\tmethodVO.needsView = true;\n\n\t\tmethodVO.textureVO = shader.getTextureVO(this._envMap);\n\n\t\tif (this._mask != null) {\n\t\t\tmethodVO.secondaryTextureVO = shader.getTextureVO(this._mask);\n\t\t\tshader.uvDependencies++;\n\t\t}\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitConstants(shader:ShaderBase, methodVO:MethodVO)\n\t{\n\t\tshader.fragmentConstantData[methodVO.fragmentConstantsIndex + 3] = 1;\n\t}\n\n\t/**\n\t * An optional texture to modulate the reflectivity of the surface.\n\t */\n\tpublic get mask():TextureBase\n\t{\n\t\treturn this._mask;\n\t}\n\n\tpublic set mask(value:TextureBase)\n\t{\n\t\tif (this._mask == value)\n\t\t\treturn;\n\t\t\n\t\tthis._mask = value;\n\n\t\tthis.iInvalidateShaderProgram();\n\t}\n\n\t/**\n\t * The power used in the Fresnel equation. Higher values make the fresnel effect more pronounced. Defaults to 5.\n\t */\n\tpublic get fresnelPower():number\n\t{\n\t\treturn this._fresnelPower;\n\t}\n\n\tpublic set fresnelPower(value:number)\n\t{\n\t\tthis._fresnelPower = value;\n\t}\n\n\t/**\n\t * The cubic environment map containing the reflected scene.\n\t */\n\tpublic get envMap():TextureBase\n\t{\n\t\treturn this._envMap;\n\t}\n\n\tpublic set envMap(value:TextureBase)\n\t{\n\t\tthis._envMap = value;\n\t}\n\n\t/**\n\t * The reflectivity of the surface.\n\t */\n\tpublic get alpha():number\n\t{\n\t\treturn this._alpha;\n\t}\n\n\tpublic set alpha(value:number)\n\t{\n\t\tthis._alpha = value;\n\t}\n\n\t/**\n\t * The minimum amount of reflectance, ie the reflectance when the view direction is normal to the surface or light direction.\n\t */\n\tpublic get normalReflectance():number\n\t{\n\t\treturn this._normalReflectance;\n\t}\n\n\tpublic set normalReflectance(value:number)\n\t{\n\t\tthis._normalReflectance = value;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iActivate(shader:ShaderBase, methodVO:MethodVO, stage:Stage)\n\t{\n\t\tvar data:Array<number> = shader.fragmentConstantData;\n\t\tvar index:number /*int*/ = methodVO.fragmentConstantsIndex;\n\t\tdata[index] = this._alpha;\n\t\tdata[index + 1] = this._normalReflectance;\n\t\tdata[index + 2] = this._fresnelPower;\n\n\t\tmethodVO.textureVO.activate(shader);\n\n\t\tif (this._mask)\n\t\t\tmethodVO.secondaryTextureVO.activate(shader);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentCode(shader:ShaderBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar dataRegister:ShaderRegisterElement = registerCache.getFreeFragmentConstant();\n\t\tvar code:string = \"\";\n\t\tvar viewDirReg:ShaderRegisterElement = sharedRegisters.viewDirFragment;\n\t\tvar normalReg:ShaderRegisterElement = sharedRegisters.normalFragment;\n\n\t\tmethodVO.fragmentConstantsIndex = dataRegister.index*4;\n\n\t\tvar temp:ShaderRegisterElement = registerCache.getFreeFragmentVectorTemp();\n\t\tregisterCache.addFragmentTempUsages(temp, 1);\n\t\tvar temp2:ShaderRegisterElement = registerCache.getFreeFragmentVectorTemp();\n\t\tregisterCache.addFragmentTempUsages(temp2, 1);\n\n\t\tmethodVO.textureVO._iInitRegisters(shader, registerCache);\n\n\t\t// r = V - 2(V.N)*N\n\t\tcode += \"dp3 \" + temp + \".w, \" + viewDirReg + \".xyz, \" + normalReg + \".xyz\\n\" +\n\t\t\t\t\"add \" + temp + \".w, \" + temp + \".w, \" + temp + \".w\\n\" +\n\t\t\t\t\"mul \" + temp + \".xyz, \" + normalReg + \".xyz, \" + temp + \".w\\n\" +\n\t\t\t\t\"sub \" + temp + \".xyz, \" + temp + \".xyz, \" + viewDirReg + \".xyz\\n\" +\n\t\t\tmethodVO.textureVO._iGetFragmentCode(shader, temp, registerCache, temp) +\n\t\t\t\t\"sub \" + temp2 + \".w, \" + temp + \".w, fc0.x\\n\" +               \t// -.5\n\t\t\t\t\"kil \" + temp2 + \".w\\n\" +\t// used for real time reflection mapping - if alpha is not 1 (mock texture) kil output\n\t\t\t\t\"sub \" + temp + \", \" + temp + \", \" + targetReg + \"\\n\";\n\n\t\t// calculate fresnel term\n\t\tcode += \"dp3 \" + viewDirReg + \".w, \" + viewDirReg + \".xyz, \" + normalReg + \".xyz\\n\" +  // dot(V, H)\n\t\t\t\t\"sub \" + viewDirReg + \".w, \" + dataRegister + \".w, \" + viewDirReg + \".w\\n\" +       // base = 1-dot(V, H)\n\t\t\t\t\"pow \" + viewDirReg + \".w, \" + viewDirReg + \".w, \" + dataRegister + \".z\\n\" +       // exp = pow(base, 5)\n\t\t\t\t\"sub \" + normalReg + \".w, \" + dataRegister + \".w, \" + viewDirReg + \".w\\n\" +        // 1 - exp\n\t\t\t\t\"mul \" + normalReg + \".w, \" + dataRegister + \".y, \" + normalReg + \".w\\n\" +         // f0*(1 - exp)\n\t\t\t\t\"add \" + viewDirReg + \".w, \" + viewDirReg + \".w, \" + normalReg + \".w\\n\" +          // exp + f0*(1 - exp)\n\n\t\t\t\t// total alpha\n\t\t\t\t\"mul \" + viewDirReg + \".w, \" + dataRegister + \".x, \" + viewDirReg + \".w\\n\";\n\n\t\tif (this._mask) {\n\t\t\tmethodVO.secondaryTextureVO._iInitRegisters(shader, registerCache);\n\n\t\t\tcode += methodVO.secondaryTextureVO._iGetFragmentCode(shader, temp2, registerCache, sharedRegisters.uvVarying) +\n\t\t\t\t\"mul \" + viewDirReg + \".w, \" + temp2 + \".x, \" + viewDirReg + \".w\\n\";\n\t\t}\n\n\t\t// blend\n\t\tcode += \"mul \" + temp + \", \" + temp + \", \" + viewDirReg + \".w\\n\" +\n\t\t\t\t\"add \" + targetReg + \", \" + targetReg + \", \" + temp + \"\\n\";\n\n\t\tregisterCache.removeFragmentTempUsage(temp);\n\t\tregisterCache.removeFragmentTempUsage(temp2);\n\n\t\treturn code;\n\t}\n}\n\nexport = EffectFresnelEnvMapMethod;",
    "import TextureBase\t\t\t\t\t\t= require(\"awayjs-display/lib/textures/TextureBase\");\n\nimport Stage\t\t\t\t\t\t\t= require(\"awayjs-stagegl/lib/base/Stage\");\n\nimport ShaderBase\t\t\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderBase\");\nimport ShaderRegisterCache\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterCache\");\nimport ShaderRegisterData\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterData\");\nimport ShaderRegisterElement\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterElement\");\n\nimport MethodVO\t\t\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/data/MethodVO\");\nimport EffectMethodBase\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/methods/EffectMethodBase\");\n\n/**\n * EffectLightMapMethod provides a method that allows applying a light map texture to the calculated pixel colour.\n * It is different from DiffuseLightMapMethod in that the latter only modulates the diffuse shading value rather\n * than the whole pixel colour.\n */\nclass EffectLightMapMethod extends EffectMethodBase\n{\n\t/**\n\t * Indicates the light map should be multiplied with the calculated shading result.\n\t */\n\tpublic static MULTIPLY:string = \"multiply\";\n\n\t/**\n\t * Indicates the light map should be added into the calculated shading result.\n\t */\n\tpublic static ADD:string = \"add\";\n\n\tprivate _lightMap:TextureBase;\n\n\tprivate _blendMode:string;\n\tprivate _useSecondaryUV:boolean;\n\n\t/**\n\t * Creates a new EffectLightMapMethod object.\n\t *\n\t * @param lightMap The texture containing the light map.\n\t * @param blendMode The blend mode with which the light map should be applied to the lighting result.\n\t * @param useSecondaryUV Indicates whether the secondary UV set should be used to map the light map.\n\t */\n\tconstructor(lightMap:TextureBase, blendMode:string = \"multiply\", useSecondaryUV:boolean = false)\n\t{\n\t\tsuper();\n\n\t\tif (blendMode != EffectLightMapMethod.ADD && blendMode != EffectLightMapMethod.MULTIPLY)\n\t\t\tthrow new Error(\"Unknown blendmode!\");\n\n\t\tthis._lightMap = lightMap;\n\t\tthis._blendMode = blendMode;\n\t\tthis._useSecondaryUV = useSecondaryUV;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitVO(shader:ShaderBase, methodVO:MethodVO)\n\t{\n\t\tmethodVO.textureVO = shader.getTextureVO(this._lightMap);\n\n\t\tif (this._useSecondaryUV)\n\t\t\tshader.secondaryUVDependencies++;\n\t\telse\n\t\t\tshader.uvDependencies++;\n\t}\n\n\t/**\n\t * The blend mode with which the light map should be applied to the lighting result.\n\t *\n\t * @see EffectLightMapMethod.ADD\n\t * @see EffectLightMapMethod.MULTIPLY\n\t */\n\tpublic get blendMode():string\n\t{\n\t\treturn this._blendMode;\n\t}\n\n\tpublic set blendMode(value:string)\n\t{\n\t\tif (this._blendMode == value)\n\t\t\treturn;\n\n\t\tif (value != EffectLightMapMethod.ADD && value != EffectLightMapMethod.MULTIPLY)\n\t\t\tthrow new Error(\"Unknown blendmode!\");\n\n\t\tthis._blendMode = value;\n\n\t\tthis.iInvalidateShaderProgram();\n\t}\n\n\t/**\n\t * The lightMap containing the light map.\n\t */\n\tpublic get lightMap():TextureBase\n\t{\n\t\treturn this._lightMap;\n\t}\n\n\tpublic set lightMap(value:TextureBase)\n\t{\n\t\tif (this._lightMap == value)\n\t\t\treturn;\n\n\t\tthis._lightMap = value;\n\n\t\tthis.iInvalidateShaderProgram();\n\t}\n\n\t/**\n\t * Indicates whether the secondary UV set should be used to map the light map.\n\t */\n\tpublic get useSecondaryUV():boolean\n\t{\n\t\treturn this._useSecondaryUV;\n\t}\n\n\tpublic set useSecondaryUV(value:boolean)\n\t{\n\t\tif (this._useSecondaryUV == value)\n\t\t\treturn;\n\n\t\tthis._useSecondaryUV = value;\n\n\t\tthis.iInvalidateShaderProgram();\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentCode(shader:ShaderBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string;\n\t\tvar temp:ShaderRegisterElement = registerCache.getFreeFragmentVectorTemp();\n\n\t\tcode = methodVO.secondaryTextureVO._iGetFragmentCode(shader, temp, registerCache, this._useSecondaryUV? sharedRegisters.secondaryUVVarying : sharedRegisters.uvVarying);\n\n\t\tswitch (this._blendMode) {\n\t\t\tcase EffectLightMapMethod.MULTIPLY:\n\t\t\t\tcode += \"mul \" + targetReg + \", \" + targetReg + \", \" + temp + \"\\n\";\n\t\t\t\tbreak;\n\t\t\tcase EffectLightMapMethod.ADD:\n\t\t\t\tcode += \"add \" + targetReg + \", \" + targetReg + \", \" + temp + \"\\n\";\n\t\t\t\tbreak;\n\t\t}\n\n\t\treturn code;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iActivate(shader:ShaderBase, methodVO:MethodVO, stage:Stage)\n\t{\n\t\tsuper.iActivate(shader, methodVO, stage);\n\n\t\tmethodVO.textureVO.activate(shader);\n\t}\n}\n\nexport = EffectLightMapMethod;",
    "import IAsset\t\t\t\t\t\t= require(\"awayjs-core/lib/library/IAsset\");\nimport AbstractMethodError\t\t\t= require(\"awayjs-core/lib/errors/AbstractMethodError\");\n\nimport ShaderBase\t\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderBase\");\nimport ShaderRegisterCache\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterCache\");\nimport ShaderRegisterData\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterData\");\nimport ShaderRegisterElement\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterElement\");\n\nimport MethodVO\t\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/data/MethodVO\");\nimport ShadingMethodBase\t\t\t= require(\"awayjs-methodmaterials/lib/methods/ShadingMethodBase\");\n\n/**\n * EffectMethodBase forms an abstract base class for shader methods that are not dependent on light sources,\n * and are in essence post-process effects on the materials.\n */\nclass EffectMethodBase extends ShadingMethodBase implements IAsset\n{\n\tpublic static assetType:string = \"[asset EffectMethod]\";\n\n\tconstructor()\n\t{\n\t\tsuper();\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic get assetType():string\n\t{\n\t\treturn EffectMethodBase.assetType;\n\t}\n\n\t/**\n\t * Get the fragment shader code that should be added after all per-light code. Usually composits everything to the target register.\n\t * @param methodVO The MethodVO object containing the method data for the currently compiled material pass.\n\t * @param regCache The register cache used during the compilation.\n\t * @param targetReg The register that will be containing the method's output.\n\t * @private\n\t */\n\tpublic iGetFragmentCode(shader:ShaderBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tthrow new AbstractMethodError();\n\t\treturn \"\";\n\t}\n}\n\nexport = EffectMethodBase;",
    "import TextureBase\t\t\t\t\t\t= require(\"awayjs-display/lib/textures/TextureBase\");\n\nimport Stage\t\t\t\t\t\t\t= require(\"awayjs-stagegl/lib/base/Stage\");\n\nimport ShaderBase\t\t\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderBase\");\nimport ShaderRegisterCache\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterCache\");\nimport ShaderRegisterData\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterData\");\nimport ShaderRegisterElement\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterElement\");\n\nimport MethodVO\t\t\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/data/MethodVO\");\nimport EffectMethodBase\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/methods/EffectMethodBase\");\n\n/**\n * EffectRefractionEnvMapMethod provides a method to add refracted transparency based on cube maps.\n */\nclass EffectRefractionEnvMapMethod extends EffectMethodBase\n{\n\tprivate _envMap:TextureBase;\n\n\tprivate _dispersionR:number = 0;\n\tprivate _dispersionG:number = 0;\n\tprivate _dispersionB:number = 0;\n\tprivate _useDispersion:boolean;\n\tprivate _refractionIndex:number;\n\tprivate _alpha:number = 1;\n\n\t/**\n\t * Creates a new EffectRefractionEnvMapMethod object. Example values for dispersion are: dispersionR: -0.03, dispersionG: -0.01, dispersionB: = .0015\n\t *\n\t * @param envMap The environment map containing the refracted scene.\n\t * @param refractionIndex The refractive index of the material.\n\t * @param dispersionR The amount of chromatic dispersion of the red channel. Defaults to 0 (none).\n\t * @param dispersionG The amount of chromatic dispersion of the green channel. Defaults to 0 (none).\n\t * @param dispersionB The amount of chromatic dispersion of the blue channel. Defaults to 0 (none).\n\t */\n\tconstructor(envMap:TextureBase, refractionIndex:number = .1, dispersionR:number = 0, dispersionG:number = 0, dispersionB:number = 0)\n\t{\n\t\tsuper();\n\t\tthis._envMap = envMap;\n\t\tthis._dispersionR = dispersionR;\n\t\tthis._dispersionG = dispersionG;\n\t\tthis._dispersionB = dispersionB;\n\t\tthis._useDispersion = !(this._dispersionR == this._dispersionB && this._dispersionR == this._dispersionG);\n\t\tthis._refractionIndex = refractionIndex;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitConstants(shader:ShaderBase, methodVO:MethodVO)\n\t{\n\t\tvar index:number /*int*/ = methodVO.fragmentConstantsIndex;\n\t\tvar data:Array<number> = shader.fragmentConstantData;\n\t\tdata[index + 4] = 1;\n\t\tdata[index + 5] = 0;\n\t\tdata[index + 7] = 1;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitVO(shader:ShaderBase, methodVO:MethodVO)\n\t{\n\t\tmethodVO.needsNormals = true;\n\t\tmethodVO.needsView = true;\n\n\t\tmethodVO.textureVO = shader.getTextureVO(this._envMap);\n\t}\n\n\t/**\n\t * The cube environment map to use for the refraction.\n\t */\n\tpublic get envMap():TextureBase\n\t{\n\t\treturn this._envMap;\n\t}\n\n\tpublic set envMap(value:TextureBase)\n\t{\n\t\tthis._envMap = value;\n\t}\n\n\t/**\n\t * The refractive index of the material.\n\t */\n\tpublic get refractionIndex():number\n\t{\n\t\treturn this._refractionIndex;\n\t}\n\n\tpublic set refractionIndex(value:number)\n\t{\n\t\tthis._refractionIndex = value;\n\t}\n\n\t/**\n\t * The amount of chromatic dispersion of the red channel. Defaults to 0 (none).\n\t */\n\tpublic get dispersionR():number\n\t{\n\t\treturn this._dispersionR;\n\t}\n\n\tpublic set dispersionR(value:number)\n\t{\n\t\tthis._dispersionR = value;\n\n\t\tvar useDispersion:boolean = !(this._dispersionR == this._dispersionB && this._dispersionR == this._dispersionG);\n\t\tif (this._useDispersion != useDispersion) {\n\t\t\tthis.iInvalidateShaderProgram();\n\t\t\tthis._useDispersion = useDispersion;\n\t\t}\n\t}\n\n\t/**\n\t * The amount of chromatic dispersion of the green channel. Defaults to 0 (none).\n\t */\n\tpublic get dispersionG():number\n\t{\n\t\treturn this._dispersionG;\n\t}\n\n\tpublic set dispersionG(value:number)\n\t{\n\t\tthis._dispersionG = value;\n\n\t\tvar useDispersion:boolean = !(this._dispersionR == this._dispersionB && this._dispersionR == this._dispersionG);\n\t\tif (this._useDispersion != useDispersion) {\n\t\t\tthis.iInvalidateShaderProgram();\n\t\t\tthis._useDispersion = useDispersion;\n\t\t}\n\t}\n\n\t/**\n\t * The amount of chromatic dispersion of the blue channel. Defaults to 0 (none).\n\t */\n\tpublic get dispersionB():number\n\t{\n\t\treturn this._dispersionB;\n\t}\n\n\tpublic set dispersionB(value:number)\n\t{\n\t\tthis._dispersionB = value;\n\n\t\tvar useDispersion:boolean = !(this._dispersionR == this._dispersionB && this._dispersionR == this._dispersionG);\n\t\tif (this._useDispersion != useDispersion) {\n\t\t\tthis.iInvalidateShaderProgram();\n\t\t\tthis._useDispersion = useDispersion;\n\t\t}\n\t}\n\n\t/**\n\t * The amount of transparency of the object. Warning: the alpha applies to the refracted color, not the actual\n\t * material. A value of 1 will make it appear fully transparent.\n\t */\n\tpublic get alpha():number\n\t{\n\t\treturn this._alpha;\n\t}\n\n\tpublic set alpha(value:number)\n\t{\n\t\tthis._alpha = value;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iActivate(shader:ShaderBase, methodVO:MethodVO, stage:Stage)\n\t{\n\t\tvar index:number /*int*/ = methodVO.fragmentConstantsIndex;\n\t\tvar data:Array<number> = shader.fragmentConstantData;\n\n\t\tdata[index] = this._dispersionR + this._refractionIndex;\n\n\t\tif (this._useDispersion) {\n\t\t\tdata[index + 1] = this._dispersionG + this._refractionIndex;\n\t\t\tdata[index + 2] = this._dispersionB + this._refractionIndex;\n\t\t}\n\t\tdata[index + 3] = this._alpha;\n\n\t\tmethodVO.textureVO.activate(shader);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentCode(shader:ShaderBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\t// todo: data2.x could use common reg, so only 1 reg is used\n\t\tvar data:ShaderRegisterElement = registerCache.getFreeFragmentConstant();\n\t\tvar data2:ShaderRegisterElement = registerCache.getFreeFragmentConstant();\n\t\tvar code:string = \"\";\n\t\tvar refractionDir:ShaderRegisterElement;\n\t\tvar refractionColor:ShaderRegisterElement;\n\t\tvar temp:ShaderRegisterElement;\n\n\t\tmethodVO.fragmentConstantsIndex = data.index*4;\n\n\t\trefractionDir = registerCache.getFreeFragmentVectorTemp();\n\t\tregisterCache.addFragmentTempUsages(refractionDir, 1);\n\t\trefractionColor = registerCache.getFreeFragmentVectorTemp();\n\t\tregisterCache.addFragmentTempUsages(refractionColor, 1);\n\t\ttemp = registerCache.getFreeFragmentVectorTemp();\n\t\tregisterCache.addFragmentTempUsages(temp, 1);\n\n\t\tvar viewDirReg:ShaderRegisterElement = sharedRegisters.viewDirFragment;\n\t\tvar normalReg:ShaderRegisterElement = sharedRegisters.normalFragment;\n\n\t\tmethodVO.textureVO._iInitRegisters(shader, registerCache);\n\n\t\tcode += \"neg \" + viewDirReg + \".xyz, \" + viewDirReg + \".xyz\\n\";\n\n\t\tcode += \"dp3 \" + temp + \".x, \" + viewDirReg + \".xyz, \" + normalReg + \".xyz\\n\" +\n\t\t\t\"mul \" + temp + \".w, \" + temp + \".x, \" + temp + \".x\\n\" +\n\t\t\t\"sub \" + temp + \".w, \" + data2 + \".x, \" + temp + \".w\\n\" +\n\t\t\t\"mul \" + temp + \".w, \" + data + \".x, \" + temp + \".w\\n\" +\n\t\t\t\"mul \" + temp + \".w, \" + data + \".x, \" + temp + \".w\\n\" +\n\t\t\t\"sub \" + temp + \".w, \" + data2 + \".x, \" + temp + \".w\\n\" +\n\t\t\t\"sqt \" + temp + \".y, \" + temp + \".w\\n\" +\n\n\t\t\t\"mul \" + temp + \".x, \" + data + \".x, \" + temp + \".x\\n\" +\n\t\t\t\"add \" + temp + \".x, \" + temp + \".x, \" + temp + \".y\\n\" +\n\t\t\t\"mul \" + temp + \".xyz, \" + temp + \".x, \" + normalReg + \".xyz\\n\" +\n\n\t\t\t\"mul \" + refractionDir + \", \" + data + \".x, \" + viewDirReg + \"\\n\" +\n\t\t\t\"sub \" + refractionDir + \".xyz, \" + refractionDir + \".xyz, \" + temp + \".xyz\\n\" +\n\t\t\t\"nrm \" + refractionDir + \".xyz, \" + refractionDir + \".xyz\\n\" +\n\t\tmethodVO.textureVO._iGetFragmentCode(shader, refractionColor, registerCache, refractionDir) +\n\t\t\t\"sub \" + refractionColor + \".w, \" + refractionColor + \".w, fc0.x\t\\n\" +\n\t\t\t\"kil \" + refractionColor + \".w\\n\";\n\n\t\tif (this._useDispersion) {\n\t\t\t// GREEN\n\t\t\tcode += \"dp3 \" + temp + \".x, \" + viewDirReg + \".xyz, \" + normalReg + \".xyz\\n\" +\n\t\t\t\t\"mul \" + temp + \".w, \" + temp + \".x, \" + temp + \".x\\n\" +\n\t\t\t\t\"sub \" + temp + \".w, \" + data2 + \".x, \" + temp + \".w\\n\" +\n\t\t\t\t\"mul \" + temp + \".w, \" + data + \".y, \" + temp + \".w\\n\" +\n\t\t\t\t\"mul \" + temp + \".w, \" + data + \".y, \" + temp + \".w\\n\" +\n\t\t\t\t\"sub \" + temp + \".w, \" + data2 + \".x, \" + temp + \".w\\n\" +\n\t\t\t\t\"sqt \" + temp + \".y, \" + temp + \".w\\n\" +\n\n\t\t\t\t\"mul \" + temp + \".x, \" + data + \".y, \" + temp + \".x\\n\" +\n\t\t\t\t\"add \" + temp + \".x, \" + temp + \".x, \" + temp + \".y\\n\" +\n\t\t\t\t\"mul \" + temp + \".xyz, \" + temp + \".x, \" + normalReg + \".xyz\\n\" +\n\n\t\t\t\t\"mul \" + refractionDir + \", \" + data + \".y, \" + viewDirReg + \"\\n\" +\n\t\t\t\t\"sub \" + refractionDir + \".xyz, \" + refractionDir + \".xyz, \" + temp + \".xyz\\n\" +\n\t\t\t\t\"nrm \" + refractionDir + \".xyz, \" + refractionDir + \".xyz\\n\" +\n\t\t\tmethodVO.textureVO._iGetFragmentCode(shader, temp, registerCache, refractionDir) +\n\t\t\t\t\"mov \" + refractionColor + \".y, \" + temp + \".y\\n\";\n\n\t\t\t// BLUE\n\t\t\tcode += \"dp3 \" + temp + \".x, \" + viewDirReg + \".xyz, \" + normalReg + \".xyz\\n\" +\n\t\t\t\t\"mul \" + temp + \".w, \" + temp + \".x, \" + temp + \".x\\n\" +\n\t\t\t\t\"sub \" + temp + \".w, \" + data2 + \".x, \" + temp + \".w\\n\" +\n\t\t\t\t\"mul \" + temp + \".w, \" + data + \".z, \" + temp + \".w\\n\" +\n\t\t\t\t\"mul \" + temp + \".w, \" + data + \".z, \" + temp + \".w\\n\" +\n\t\t\t\t\"sub \" + temp + \".w, \" + data2 + \".x, \" + temp + \".w\\n\" +\n\t\t\t\t\"sqt \" + temp + \".y, \" + temp + \".w\\n\" +\n\n\t\t\t\t\"mul \" + temp + \".x, \" + data + \".z, \" + temp + \".x\\n\" +\n\t\t\t\t\"add \" + temp + \".x, \" + temp + \".x, \" + temp + \".y\\n\" +\n\t\t\t\t\"mul \" + temp + \".xyz, \" + temp + \".x, \" + normalReg + \".xyz\\n\" +\n\n\t\t\t\t\"mul \" + refractionDir + \", \" + data + \".z, \" + viewDirReg + \"\\n\" +\n\t\t\t\t\"sub \" + refractionDir + \".xyz, \" + refractionDir + \".xyz, \" + temp + \".xyz\\n\" +\n\t\t\t\t\"nrm \" + refractionDir + \".xyz, \" + refractionDir + \".xyz\\n\" +\n\t\t\tmethodVO.textureVO._iGetFragmentCode(shader, temp, registerCache, refractionDir) +\n\t\t\t\t\"mov \" + refractionColor + \".z, \" + temp + \".z\\n\";\n\t\t}\n\n\t\tcode += \"sub \" + refractionColor + \".xyz, \" + refractionColor + \".xyz, \" + targetReg + \".xyz\\n\" +\n\t\t\t\"mul \" + refractionColor + \".xyz, \" + refractionColor + \".xyz, \" + data + \".w\\n\" +\n\t\t\t\"add \" + targetReg + \".xyz, \" + targetReg + \".xyz, \" + refractionColor + \".xyz\\n\";\n\n\t\tregisterCache.removeFragmentTempUsage(temp);\n\t\tregisterCache.removeFragmentTempUsage(refractionDir);\n\t\tregisterCache.removeFragmentTempUsage(refractionColor);\n\n\t\t// restore\n\t\tcode += \"neg \" + viewDirReg + \".xyz, \" + viewDirReg + \".xyz\\n\";\n\n\t\treturn code;\n\t}\n}\n\nexport = EffectRefractionEnvMapMethod;",
    "import Stage\t\t\t\t\t\t\t= require(\"awayjs-stagegl/lib/base/Stage\");\n\nimport ShaderBase\t\t\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderBase\");\nimport ShaderRegisterCache\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterCache\");\nimport ShaderRegisterData\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterData\");\nimport ShaderRegisterElement\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterElement\");\n\nimport MethodVO\t\t\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/data/MethodVO\");\nimport EffectMethodBase\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/methods/EffectMethodBase\");\n\n/**\n * EffectRimLightMethod provides a method to add rim lighting to a material. This adds a glow-like effect to edges of objects.\n */\nclass EffectRimLightMethod extends EffectMethodBase\n{\n\tpublic static ADD:string = \"add\";\n\tpublic static MULTIPLY:string = \"multiply\";\n\tpublic static MIX:string = \"mix\";\n\n\tprivate _color:number /*uint*/;\n\tprivate _blendMode:string;\n\tprivate _colorR:number;\n\tprivate _colorG:number;\n\tprivate _colorB:number;\n\tprivate _strength:number;\n\tprivate _power:number;\n\n\t/**\n\t * Creates a new <code>EffectRimLightMethod</code> object.\n\t *\n\t * @param color The colour of the rim light.\n\t * @param strength The strength of the rim light.\n\t * @param power The power of the rim light. Higher values will result in a higher edge fall-off.\n\t * @param blend The blend mode with which to add the light to the object.\n\t */\n\tconstructor(color:number /*uint*/ = 0xffffff, strength:number = .4, power:number = 2, blend:string = \"mix\")\n\t{\n\t\tsuper();\n\n\t\tthis._blendMode = blend;\n\t\tthis._strength = strength;\n\t\tthis._power = power;\n\n\t\tthis.color = color;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitConstants(shader:ShaderBase, methodVO:MethodVO)\n\t{\n\t\tshader.fragmentConstantData[methodVO.fragmentConstantsIndex + 3] = 1;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitVO(shader:ShaderBase, methodVO:MethodVO)\n\t{\n\t\tmethodVO.needsNormals = true;\n\t\tmethodVO.needsView = true;\n\t}\n\n\n\t/**\n\t * The blend mode with which to add the light to the object.\n\t *\n\t * EffectRimLightMethod.MULTIPLY multiplies the rim light with the material's colour.\n\t * EffectRimLightMethod.ADD adds the rim light with the material's colour.\n\t * EffectRimLightMethod.MIX provides normal alpha blending.\n\t */\n\tpublic get blendMode():string\n\t{\n\t\treturn this._blendMode;\n\t}\n\n\tpublic set blendMode(value:string)\n\t{\n\t\tif (this._blendMode == value)\n\t\t\treturn;\n\n\t\tthis._blendMode = value;\n\n\t\tthis.iInvalidateShaderProgram();\n\t}\n\n\t/**\n\t * The color of the rim light.\n\t */\n\tpublic get color():number /*uint*/\n\t{\n\t\treturn this._color;\n\t}\n\n\tpublic set color(value:number /*uint*/)\n\t{\n\t\tthis._color = value;\n\t\tthis._colorR = ((value >> 16) & 0xff)/0xff;\n\t\tthis._colorG = ((value >> 8) & 0xff)/0xff;\n\t\tthis._colorB = (value & 0xff)/0xff;\n\t}\n\n\t/**\n\t * The strength of the rim light.\n\t */\n\tpublic get strength():number\n\t{\n\t\treturn this._strength;\n\t}\n\n\tpublic set strength(value:number)\n\t{\n\t\tthis._strength = value;\n\t}\n\n\t/**\n\t * The power of the rim light. Higher values will result in a higher edge fall-off.\n\t */\n\tpublic get power():number\n\t{\n\t\treturn this._power;\n\t}\n\n\tpublic set power(value:number)\n\t{\n\t\tthis._power = value;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iActivate(shader:ShaderBase, methodVO:MethodVO, stage:Stage)\n\t{\n\t\tvar index:number /*int*/ = methodVO.fragmentConstantsIndex;\n\t\tvar data:Array<number> = shader.fragmentConstantData;\n\t\tdata[index] = this._colorR;\n\t\tdata[index + 1] = this._colorG;\n\t\tdata[index + 2] = this._colorB;\n\t\tdata[index + 4] = this._strength;\n\t\tdata[index + 5] = this._power;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentCode(shader:ShaderBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar dataRegister:ShaderRegisterElement = registerCache.getFreeFragmentConstant();\n\t\tvar dataRegister2:ShaderRegisterElement = registerCache.getFreeFragmentConstant();\n\t\tvar temp:ShaderRegisterElement = registerCache.getFreeFragmentVectorTemp();\n\t\tvar code:string = \"\";\n\n\t\tmethodVO.fragmentConstantsIndex = dataRegister.index*4;\n\n\t\tcode += \"dp3 \" + temp + \".x, \" + sharedRegisters.viewDirFragment + \".xyz, \" + sharedRegisters.normalFragment + \".xyz\\n\" +\n\t\t\t\"sat \" + temp + \".x, \" + temp + \".x\\n\" +\n\t\t\t\"sub \" + temp + \".x, \" + dataRegister + \".w, \" + temp + \".x\\n\" +\n\t\t\t\"pow \" + temp + \".x, \" + temp + \".x, \" + dataRegister2 + \".y\\n\" +\n\t\t\t\"mul \" + temp + \".x, \" + temp + \".x, \" + dataRegister2 + \".x\\n\" +\n\t\t\t\"sub \" + temp + \".x, \" + dataRegister + \".w, \" + temp + \".x\\n\" +\n\t\t\t\"mul \" + targetReg + \".xyz, \" + targetReg + \".xyz, \" + temp + \".x\\n\" +\n\t\t\t\"sub \" + temp + \".w, \" + dataRegister + \".w, \" + temp + \".x\\n\";\n\n\t\tif (this._blendMode == EffectRimLightMethod.ADD) {\n\t\t\tcode += \"mul \" + temp + \".xyz, \" + temp + \".w, \" + dataRegister + \".xyz\\n\" +\n\t\t\t\t\"add \" + targetReg + \".xyz, \" + targetReg + \".xyz, \" + temp + \".xyz\\n\";\n\t\t} else if (this._blendMode == EffectRimLightMethod.MULTIPLY) {\n\t\t\tcode += \"mul \" + temp + \".xyz, \" + temp + \".w, \" + dataRegister + \".xyz\\n\" +\n\t\t\t\t\"mul \" + targetReg + \".xyz, \" + targetReg + \".xyz, \" + temp + \".xyz\\n\";\n\t\t} else {\n\t\t\tcode += \"sub \" + temp + \".xyz, \" + dataRegister + \".xyz, \" + targetReg + \".xyz\\n\" +\n\t\t\t\t\"mul \" + temp + \".xyz, \" + temp + \".xyz, \" + temp + \".w\\n\" +\n\t\t\t\t\"add \" + targetReg + \".xyz, \" + targetReg + \".xyz, \" + temp + \".xyz\\n\";\n\t\t}\n\n\t\treturn code;\n\t}\n}\n\nexport = EffectRimLightMethod;",
    "import ShaderBase\t\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderBase\");\nimport LightingShader\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/LightingShader\");\nimport ShaderRegisterCache\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterCache\");\nimport ShaderRegisterData\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterData\");\nimport ShaderRegisterElement\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterElement\");\n\nimport MethodVO\t\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/data/MethodVO\");\nimport ShadingMethodBase\t\t\t= require(\"awayjs-methodmaterials/lib/methods/ShadingMethodBase\");\n\n/**\n * LightingMethodBase provides an abstract base method for shading methods that uses lights.\n * Used for diffuse and specular shaders only.\n */\nclass LightingMethodBase extends ShadingMethodBase\n{\n\t/**\n\t * A method that is exposed to wrappers in case the strength needs to be controlled\n\t */\n\tpublic _iModulateMethod:(shader:ShaderBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData) => string;\n\n\t/**\n\t * Creates a new LightingMethodBase.\n\t */\n\tconstructor()\n\t{\n\t\tsuper();\n\t}\n\n\t/**\n\t * Get the fragment shader code that will be needed before any per-light code is added.\n\t * @param methodVO The MethodVO object containing the method data for the currently compiled material pass.\n\t * @param regCache The register cache used during the compilation.\n\t * @private\n\t */\n\tpublic iGetFragmentPreLightingCode(shader:LightingShader, methodVO:MethodVO, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\treturn \"\";\n\t}\n\n\t/**\n\t * Get the fragment shader code that will generate the code relevant to a single light.\n\t *\n\t * @param methodVO The MethodVO object containing the method data for the currently compiled material pass.\n\t * @param lightDirReg The register containing the light direction vector.\n\t * @param lightColReg The register containing the light colour.\n\t * @param regCache The register cache used during the compilation.\n\t */\n\tpublic iGetFragmentCodePerLight(shader:LightingShader, methodVO:MethodVO, lightDirReg:ShaderRegisterElement, lightColReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\treturn \"\";\n\t}\n\n\t/**\n\t * Get the fragment shader code that will generate the code relevant to a single light probe object.\n\t *\n\t * @param methodVO The MethodVO object containing the method data for the currently compiled material pass.\n\t * @param cubeMapReg The register containing the cube map for the current probe\n\t * @param weightRegister A string representation of the register + component containing the current weight\n\t * @param regCache The register cache providing any necessary registers to the shader\n\t */\n\tpublic iGetFragmentCodePerProbe(shader:LightingShader, methodVO:MethodVO, cubeMapReg:ShaderRegisterElement, weightRegister:string, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\treturn \"\";\n\t}\n\n\t/**\n\t * Get the fragment shader code that should be added after all per-light code. Usually composits everything to the target register.\n\t *\n\t * @param methodVO The MethodVO object containing the method data for the currently compiled material pass.\n\t * @param regCache The register cache used during the compilation.\n\t * @param targetReg The register containing the final shading output.\n\t * @private\n\t */\n\tpublic iGetFragmentPostLightingCode(shader:LightingShader, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\treturn \"\";\n\t}\n}\n\nexport = LightingMethodBase;",
    "import TextureBase\t\t\t\t\t= require(\"awayjs-display/lib/textures/TextureBase\");\n\nimport Stage\t\t\t\t\t\t= require(\"awayjs-stagegl/lib/base/Stage\");\n\nimport ShaderBase\t\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderBase\");\nimport ShaderRegisterCache\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterCache\");\nimport ShaderRegisterData\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterData\");\nimport ShaderRegisterElement\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterElement\");\n\nimport MethodVO\t\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/data/MethodVO\");\nimport ShadingMethodBase\t\t\t= require(\"awayjs-methodmaterials/lib/methods/ShadingMethodBase\");\n\n/**\n * NormalBasicMethod is the default method for standard tangent-space normal mapping.\n */\nclass NormalBasicMethod extends ShadingMethodBase\n{\n\tprivate _normalMap:TextureBase;\n\n\t/**\n\t * Creates a new NormalBasicMethod object.\n\t */\n\tconstructor(normalMap:TextureBase = null)\n\t{\n\t\tsuper();\n\n\t\tthis._normalMap = normalMap;\n\t}\n\n\tpublic iIsUsed(shader:ShaderBase):boolean\n\t{\n\t\tif (this._normalMap && shader.normalDependencies)\n\t\t\treturn true;\n\n\t\treturn false;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitVO(shader:ShaderBase, methodVO:MethodVO)\n\t{\n\t\tif (this._normalMap) {\n\t\t\tmethodVO.textureVO = shader.getTextureVO(this._normalMap);\n\t\t\tshader.uvDependencies++;\n\t\t}\n\t}\n\n\t/**\n\t * Indicates whether or not this method outputs normals in tangent space. Override for object-space normals.\n\t */\n\tpublic iOutputsTangentNormals():boolean\n\t{\n\t\treturn true;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic copyFrom(method:ShadingMethodBase)\n\t{\n\t\tvar s:any = method;\n\t\tvar bnm:NormalBasicMethod = <NormalBasicMethod> method;\n\n\t\tif (bnm.normalMap != null)\n\t\t\tthis.normalMap = bnm.normalMap;\n\t}\n\n\t/**\n\t * The texture containing the normals per pixel.\n\t */\n\tpublic get normalMap():TextureBase\n\t{\n\t\treturn this._normalMap;\n\t}\n\n\tpublic set normalMap(value:TextureBase)\n\t{\n\t\tif (this._normalMap == value)\n\t\t\treturn;\n\n\t\tthis._normalMap = value;\n\n\t\tthis.iInvalidateShaderProgram();\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic dispose()\n\t{\n\t\tif (this._normalMap)\n\t\t\tthis._normalMap = null;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iActivate(shader:ShaderBase, methodVO:MethodVO, stage:Stage)\n\t{\n\t\tif (this._normalMap)\n\t\t\tmethodVO.textureVO.activate(shader);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentCode(shader:ShaderBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = \"\";\n\n\t\tif (this._normalMap) {\n\t\t\tmethodVO.textureVO._iInitRegisters(shader, registerCache);\n\n\t\t\tcode += methodVO.textureVO._iGetFragmentCode(shader, targetReg, registerCache, sharedRegisters.uvVarying);\n\t\t}\n\n\t\tcode += \"sub \" + targetReg + \".xyz, \" + targetReg + \".xyz, \" + sharedRegisters.commons + \".xxx\\n\" +\n\t\t\t\"nrm \" + targetReg + \".xyz, \" + targetReg + \"\\n\";\n\n\t\treturn code;\n\t}\n}\n\nexport = NormalBasicMethod;",
    "import TextureBase\t\t\t\t\t\t= require(\"awayjs-display/lib/textures/TextureBase\");\n\nimport ShaderBase\t\t\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderBase\");\nimport ShaderRegisterCache\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterCache\");\nimport ShaderRegisterData\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterData\");\nimport ShaderRegisterElement\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterElement\");\n\nimport MethodVO\t\t\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/data/MethodVO\");\nimport NormalBasicMethod\t\t\t\t= require(\"awayjs-methodmaterials/lib/methods/NormalBasicMethod\");\nimport ShadingMethodBase\t\t\t\t= require(\"awayjs-methodmaterials/lib/methods/ShadingMethodBase\");\n\n/**\n * NormalHeightMapMethod provides a normal map method that uses a height map to calculate the normals.\n */\nclass NormalHeightMapMethod extends NormalBasicMethod\n{\n\tprivate _worldXYRatio:number;\n\tprivate _worldXZRatio:number;\n\n\t/**\n\t * Creates a new NormalHeightMapMethod method.\n\t *\n\t * @param heightMap The texture containing the height data. 0 means low, 1 means high.\n\t * @param worldWidth The width of the 'world'. This is used to map uv coordinates' u component to scene dimensions.\n\t * @param worldHeight The height of the 'world'. This is used to map the height map values to scene dimensions.\n\t * @param worldDepth The depth of the 'world'. This is used to map uv coordinates' v component to scene dimensions.\n\t */\n\tconstructor(heightMap:TextureBase, worldWidth:number, worldHeight:number, worldDepth:number)\n\t{\n\t\tsuper();\n\n\t\tthis.normalMap = heightMap;\n\t\tthis._worldXYRatio = worldWidth/worldHeight;\n\t\tthis._worldXZRatio = worldDepth/worldHeight;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitConstants(shader:ShaderBase, methodVO:MethodVO)\n\t{\n\t\tvar index:number /*int*/ = methodVO.fragmentConstantsIndex;\n\t\tvar data:Array<number> = shader.fragmentConstantData;\n\t\tdata[index] = 1/this.normalMap.width;\n\t\tdata[index + 1] = 1/this.normalMap.height;\n\t\tdata[index + 2] = 0;\n\t\tdata[index + 3] = 1;\n\t\tdata[index + 4] = this._worldXYRatio;\n\t\tdata[index + 5] = this._worldXZRatio;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic get tangentSpace():boolean\n\t{\n\t\treturn false;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic copyFrom(method:ShadingMethodBase)\n\t{\n\t\tsuper.copyFrom(method);\n\n\t\tthis._worldXYRatio = (<NormalHeightMapMethod> method)._worldXYRatio;\n\t\tthis._worldXZRatio = (<NormalHeightMapMethod> method)._worldXZRatio;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentCode(shader:ShaderBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = \"\";\n\t\tvar temp:ShaderRegisterElement = registerCache.getFreeFragmentVectorTemp();\n\t\tregisterCache.addFragmentTempUsages(temp, 1);\n\n\t\tvar dataReg:ShaderRegisterElement = registerCache.getFreeFragmentConstant();\n\t\tvar dataReg2:ShaderRegisterElement = registerCache.getFreeFragmentConstant();\n\n\t\tmethodVO.fragmentConstantsIndex = dataReg.index*4;\n\n\t\tcode+= methodVO.textureVO._iGetFragmentCode(shader, targetReg, registerCache, sharedRegisters.uvVarying) +\n\n\t\t\t\"add \" + temp + \", \" + sharedRegisters.uvVarying + \", \" + dataReg + \".xzzz\\n\" +\n\n\t\tmethodVO.textureVO._iGetFragmentCode(shader, temp, registerCache, temp) +\n\n\t\t\t\"sub \" + targetReg + \".x, \" + targetReg + \".x, \" + temp + \".x\\n\" +\n\t\t\t\"add \" + temp + \", \" + sharedRegisters.uvVarying + \", \" + dataReg + \".zyzz\\n\" +\n\n\t\tmethodVO.textureVO._iGetFragmentCode(shader, temp, registerCache, temp) +\n\n\t\t\t\"sub \" + targetReg + \".z, \" + targetReg + \".z, \" + temp + \".x\\n\" +\n\t\t\t\"mov \" + targetReg + \".y, \" + dataReg + \".w\\n\" +\n\t\t\t\"mul \" + targetReg + \".xz, \" + targetReg + \".xz, \" + dataReg2 + \".xy\\n\" +\n\t\t\t\"nrm \" + targetReg + \".xyz, \" + targetReg + \".xyz\\n\";\n\n\t\tregisterCache.removeFragmentTempUsage(temp);\n\n\t\treturn code;\n\t}\n}\n\nexport = NormalHeightMapMethod;",
    "import TextureBase\t\t\t\t\t\t= require(\"awayjs-display/lib/textures/TextureBase\");\n\nimport Stage\t\t\t\t\t\t\t= require(\"awayjs-stagegl/lib/base/Stage\");\n\nimport ShaderBase\t\t\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderBase\");\nimport ShaderRegisterCache\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterCache\");\nimport ShaderRegisterData\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterData\");\nimport ShaderRegisterElement\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterElement\");\n\nimport MethodVO\t\t\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/data/MethodVO\");\nimport NormalBasicMethod\t\t\t\t= require(\"awayjs-methodmaterials/lib/methods/NormalBasicMethod\");\n\n/**\n * NormalSimpleWaterMethod provides a basic normal map method to create water ripples by translating two wave normal maps.\n */\nclass NormalSimpleWaterMethod extends NormalBasicMethod\n{\n\tprivate _secondaryNormalMap:TextureBase;\n\tprivate _water1OffsetX:number = 0;\n\tprivate _water1OffsetY:number = 0;\n\tprivate _water2OffsetX:number = 0;\n\tprivate _water2OffsetY:number = 0;\n\n\t/**\n\t * Creates a new NormalSimpleWaterMethod object.\n\t * @param waveMap1 A normal map containing one layer of a wave structure.\n\t * @param waveMap2 A normal map containing a second layer of a wave structure.\n\t */\n\tconstructor(normalMap:TextureBase = null, secondaryNormalMap:TextureBase = null)\n\t{\n\t\tsuper(normalMap);\n\n\t\tthis._secondaryNormalMap = secondaryNormalMap;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitConstants(shader:ShaderBase, methodVO:MethodVO)\n\t{\n\t\tvar index:number = methodVO.fragmentConstantsIndex;\n\t\tvar data:Array<number> = shader.fragmentConstantData;\n\t\tdata[index] = .5;\n\t\tdata[index + 1] = 0;\n\t\tdata[index + 2] = 0;\n\t\tdata[index + 3] = 1;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitVO(shader:ShaderBase, methodVO:MethodVO)\n\t{\n\t\tsuper.iInitVO(shader, methodVO);\n\t\t\n\t\tif (this._secondaryNormalMap) {\n\t\t\tmethodVO.secondaryTextureVO = shader.getTextureVO(this._secondaryNormalMap);\n\t\t\tshader.uvDependencies++;\n\t\t}\n\t}\n\n\t/**\n\t * The translation of the first wave layer along the X-axis.\n\t */\n\tpublic get water1OffsetX():number\n\t{\n\t\treturn this._water1OffsetX;\n\t}\n\n\tpublic set water1OffsetX(value:number)\n\t{\n\t\tthis._water1OffsetX = value;\n\t}\n\n\t/**\n\t * The translation of the first wave layer along the Y-axis.\n\t */\n\tpublic get water1OffsetY():number\n\t{\n\t\treturn this._water1OffsetY;\n\t}\n\n\tpublic set water1OffsetY(value:number)\n\t{\n\t\tthis._water1OffsetY = value;\n\t}\n\n\t/**\n\t * The translation of the second wave layer along the X-axis.\n\t */\n\tpublic get water2OffsetX():number\n\t{\n\t\treturn this._water2OffsetX;\n\t}\n\n\tpublic set water2OffsetX(value:number)\n\t{\n\t\tthis._water2OffsetX = value;\n\t}\n\n\t/**\n\t * The translation of the second wave layer along the Y-axis.\n\t */\n\tpublic get water2OffsetY():number\n\t{\n\t\treturn this._water2OffsetY;\n\t}\n\n\tpublic set water2OffsetY(value:number)\n\t{\n\t\tthis._water2OffsetY = value;\n\t}\n\n\t/**\n\t * A second normal map that will be combined with the first to create a wave-like animation pattern.\n\t */\n\tpublic get secondaryNormalMap():TextureBase\n\t{\n\t\treturn this._secondaryNormalMap;\n\t}\n\n\tpublic set secondaryNormalMap(value:TextureBase)\n\t{\n\t\tif (this._secondaryNormalMap == value)\n\t\t\treturn;\n\n\t\tthis._secondaryNormalMap = value;\n\n\t\tthis.iInvalidateShaderProgram();\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic dispose()\n\t{\n\t\tsuper.dispose();\n\n\t\tthis._secondaryNormalMap = null;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iActivate(shader:ShaderBase, methodVO:MethodVO, stage:Stage)\n\t{\n\t\tsuper.iActivate(shader, methodVO, stage);\n\n\t\tvar data:Array<number> = shader.fragmentConstantData;\n\t\tvar index:number = methodVO.fragmentConstantsIndex;\n\n\t\tdata[index + 4] = this._water1OffsetX;\n\t\tdata[index + 5] = this._water1OffsetY;\n\t\tdata[index + 6] = this._water2OffsetX;\n\t\tdata[index + 7] = this._water2OffsetY;\n\n\t\tif (this._secondaryNormalMap)\n\t\t\tmethodVO.secondaryTextureVO.activate(shader);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentCode(shader:ShaderBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = \"\";\n\t\tvar temp:ShaderRegisterElement = registerCache.getFreeFragmentVectorTemp();\n\t\tregisterCache.addFragmentTempUsages(temp, 1);\n\n\t\tvar dataReg:ShaderRegisterElement = registerCache.getFreeFragmentConstant();\n\t\tvar dataReg2:ShaderRegisterElement = registerCache.getFreeFragmentConstant();\n\t\tmethodVO.fragmentConstantsIndex = dataReg.index*4;\n\n\t\tcode += \"add \" + temp + \", \" + sharedRegisters.uvVarying + \", \" + dataReg2 + \".xyxy\\n\";\n\n\t\tif (this.normalMap) {\n\t\t\tmethodVO.textureVO._iInitRegisters(shader, registerCache);\n\n\t\t\tcode += methodVO.textureVO._iGetFragmentCode(shader, targetReg, registerCache, temp);\n\t\t}\n\n\t\tcode += \"add \" + temp + \", \" + sharedRegisters.uvVarying + \", \" + dataReg2 + \".zwzw\\n\";\n\n\t\tif (this._secondaryNormalMap) {\n\t\t\tmethodVO.secondaryTextureVO._iInitRegisters(shader, registerCache);\n\n\t\t\tcode += methodVO.secondaryTextureVO._iGetFragmentCode(shader, temp, registerCache, temp);\n\t\t}\n\n\t\tcode +=\t\"add \" + targetReg + \", \" + targetReg + \", \" + temp + \"\t\t\\n\" +\n\t\t\t\"mul \" + targetReg + \", \" + targetReg + \", \" + dataReg + \".x\t\\n\" +\n\t\t\t\"sub \" + targetReg + \".xyz, \" + targetReg + \".xyz, \" + sharedRegisters.commons + \".xxx\t\\n\" +\n\t\t\t\"nrm \" + targetReg + \".xyz, \" + targetReg + \".xyz\t\t\t\t\t\t\t\\n\";\n\n\t\treturn code;\n\t}\n}\n\nexport = NormalSimpleWaterMethod;",
    "import AssetBase\t\t\t\t\t= require(\"awayjs-core/lib/library/AssetBase\");\n\nimport Camera\t\t\t\t\t\t= require(\"awayjs-display/lib/entities/Camera\");\n\nimport Stage\t\t\t\t\t\t= require(\"awayjs-stagegl/lib/base/Stage\");\n\nimport RenderableBase\t\t\t\t= require(\"awayjs-renderergl/lib/renderables/RenderableBase\");\nimport ShadingMethodEvent\t\t\t= require(\"awayjs-renderergl/lib/events/ShadingMethodEvent\");\nimport ShaderBase\t\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderBase\");\nimport ShaderRegisterCache\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterCache\");\nimport ShaderRegisterData\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterData\");\nimport ShaderRegisterElement\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterElement\");\n\nimport MethodVO\t\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/data/MethodVO\");\n\n\n/**\n * ShadingMethodBase provides an abstract base method for shading methods, used by compiled passes to compile\n * the final shading program.\n */\nclass ShadingMethodBase extends AssetBase\n{\n\tpublic static assetType:string = \"[asset ShadingMethod]\";\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic get assetType():string\n\t{\n\t\treturn ShadingMethodBase.assetType;\n\t}\n\n\t/**\n\t * Create a new ShadingMethodBase object.\n\t */\n\tconstructor()\n\t{\n\t\tsuper();\n\t}\n\n\tpublic iIsUsed(shader:ShaderBase):boolean\n\t{\n\t\treturn true;\n\t}\n\n\t/**\n\t * Initializes the properties for a MethodVO, including register and texture indices.\n\t *\n\t * @param methodVO The MethodVO object linking this method with the pass currently being compiled.\n\t *\n\t * @internal\n\t */\n\tpublic iInitVO(shader:ShaderBase, methodVO:MethodVO)\n\t{\n\n\t}\n\n\t/**\n\t * Initializes unchanging shader constants using the data from a MethodVO.\n\t *\n\t * @param methodVO The MethodVO object linking this method with the pass currently being compiled.\n\t *\n\t * @internal\n\t */\n\tpublic iInitConstants(shader:ShaderBase, methodVO:MethodVO)\n\t{\n\n\n\t}\n\n\t/**\n\t * Indicates whether or not this method expects normals in tangent space. Override for object-space normals.\n\t */\n\tpublic iUsesTangentSpace():boolean\n\t{\n\t\treturn true;\n\t}\n\n\t/**\n\t * Cleans up any resources used by the current object.\n\t */\n\tpublic dispose()\n\t{\n\n\t}\n\n\t/**\n\t * Resets the compilation state of the method.\n\t *\n\t * @internal\n\t */\n\tpublic iReset()\n\t{\n\t\tthis.iCleanCompilationData();\n\t}\n\n\t/**\n\t * Resets the method's state for compilation.\n\t *\n\t * @internal\n\t */\n\tpublic iCleanCompilationData()\n\t{\n\t}\n\n\t/**\n\t * Get the vertex shader code for this method.\n\t * @param vo The MethodVO object linking this method with the pass currently being compiled.\n\t * @param regCache The register cache used during the compilation.\n\t *\n\t * @internal\n\t */\n\tpublic iGetVertexCode(shader:ShaderBase, methodVO:MethodVO, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\treturn \"\";\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentCode(shader:ShaderBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\treturn null;\n\t}\n\n\t/**\n\t * Sets the render state for this method.\n\t *\n\t * @param methodVO The MethodVO object linking this method with the pass currently being compiled.\n\t * @param stage The Stage object currently used for rendering.\n\t *\n\t * @internal\n\t */\n\tpublic iActivate(shader:ShaderBase, methodVO:MethodVO, stage:Stage)\n\t{\n\n\t}\n\n\t/**\n\t * Sets the render state for a single renderable.\n\t *\n\t * @param vo The MethodVO object linking this method with the pass currently being compiled.\n\t * @param renderable The renderable currently being rendered.\n\t * @param stage The Stage object currently used for rendering.\n\t * @param camera The camera from which the scene is currently rendered.\n\t *\n\t * @internal\n\t */\n\tpublic iSetRenderState(shader:ShaderBase, methodVO:MethodVO, renderable:RenderableBase, stage:Stage, camera:Camera)\n\t{\n\n\t}\n\n\t/**\n\t * Clears the render state for this method.\n\t * @param vo The MethodVO object linking this method with the pass currently being compiled.\n\t * @param stage The Stage object currently used for rendering.\n\t *\n\t * @internal\n\t */\n\tpublic iDeactivate(shader:ShaderBase, methodVO:MethodVO, stage:Stage)\n\t{\n\n\t}\n\n\t/**\n\t * Marks the shader program as invalid, so it will be recompiled before the next render.\n\t *\n\t * @internal\n\t */\n\tpublic iInvalidateShaderProgram()\n\t{\n\t\tthis.dispatchEvent(new ShadingMethodEvent(ShadingMethodEvent.SHADER_INVALIDATED));\n\t}\n\n\t/**\n\t * Copies the state from a ShadingMethodBase object into the current object.\n\t */\n\tpublic copyFrom(method:ShadingMethodBase)\n\t{\n\t}\n}\n\nexport = ShadingMethodBase;",
    "import Event\t\t\t\t\t\t\t= require(\"awayjs-core/lib/events/Event\");\n\nimport Camera\t\t\t\t\t\t\t= require(\"awayjs-display/lib/entities/Camera\");\nimport DirectionalLight\t\t\t\t\t= require(\"awayjs-display/lib/entities/DirectionalLight\");\nimport CascadeShadowMapper\t\t\t\t= require(\"awayjs-display/lib/materials/shadowmappers/CascadeShadowMapper\");\nimport TextureBase\t\t\t\t\t\t= require(\"awayjs-display/lib/textures/TextureBase\");\n\nimport Stage\t\t\t\t\t\t\t= require(\"awayjs-stagegl/lib/base/Stage\");\n\nimport RenderableBase\t\t\t\t\t= require(\"awayjs-renderergl/lib/renderables/RenderableBase\");\nimport ShadingMethodEvent\t\t\t\t= require(\"awayjs-renderergl/lib/events/ShadingMethodEvent\");\nimport LightingShader\t\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/LightingShader\");\nimport ShaderBase\t\t\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderBase\");\nimport ShaderRegisterCache\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterCache\");\nimport ShaderRegisterData\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterData\");\nimport ShaderRegisterElement\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterElement\");\n\nimport MethodVO\t\t\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/data/MethodVO\");\nimport ShadowMapMethodBase\t\t\t\t= require(\"awayjs-methodmaterials/lib/methods/ShadowMapMethodBase\");\nimport ShadowMethodBase\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/methods/ShadowMethodBase\");\n\n/**\n * ShadowCascadeMethod is a shadow map method to apply cascade shadow mapping on materials.\n * Must be used with a DirectionalLight with a CascadeShadowMapper assigned to its shadowMapper property.\n *\n * @see away.lights.CascadeShadowMapper\n */\nclass ShadowCascadeMethod extends ShadowMapMethodBase\n{\n\tprivate _baseMethod:ShadowMethodBase;\n\tprivate _cascadeShadowMapper:CascadeShadowMapper;\n\tprivate _depthMapCoordVaryings:Array<ShaderRegisterElement>;\n\tprivate _cascadeProjections:Array<ShaderRegisterElement>;\n\n\t/**\n\t * Creates a new ShadowCascadeMethod object.\n\t *\n\t * @param shadowMethodBase The shadow map sampling method used to sample individual cascades (fe: ShadowHardMethod, ShadowSoftMethod)\n\t */\n\tconstructor(shadowMethodBase:ShadowMethodBase)\n\t{\n\t\tsuper(shadowMethodBase.castingLight);\n\n\t\tthis._baseMethod = shadowMethodBase;\n\t\tif (!(this._pCastingLight instanceof DirectionalLight))\n\t\t\tthrow new Error(\"ShadowCascadeMethod is only compatible with DirectionalLight\");\n\n\t\tthis._cascadeShadowMapper = <CascadeShadowMapper> this._pCastingLight.shadowMapper;\n\n\t\tif (!this._cascadeShadowMapper)\n\t\t\tthrow new Error(\"ShadowCascadeMethod requires a light that has a CascadeShadowMapper instance assigned to shadowMapper.\");\n\n\t\tthis._cascadeShadowMapper.addEventListener(Event.CHANGE, (event:Event) => this.onCascadeChange(event));\n\t\tthis._baseMethod.addEventListener(ShadingMethodEvent.SHADER_INVALIDATED, (event:ShadingMethodEvent) => this.onShaderInvalidated(event));\n\t}\n\n\t/**\n\t * The shadow map sampling method used to sample individual cascades. These are typically those used in conjunction\n\t * with a DirectionalShadowMapper.\n\t *\n\t * @see ShadowHardMethod\n\t * @see ShadowSoftMethod\n\t */\n\tpublic get baseMethod():ShadowMethodBase\n\t{\n\t\treturn this._baseMethod;\n\t}\n\n\tpublic set baseMethod(value:ShadowMethodBase)\n\t{\n\t\tif (this._baseMethod == value)\n\t\t\treturn;\n\n\t\tthis._baseMethod.removeEventListener(ShadingMethodEvent.SHADER_INVALIDATED, (event:ShadingMethodEvent) => this.onShaderInvalidated(event));\n\n\t\tthis._baseMethod = value;\n\n\t\tthis._baseMethod.addEventListener(ShadingMethodEvent.SHADER_INVALIDATED, (event:ShadingMethodEvent) => this.onShaderInvalidated(event));\n\n\t\tthis.iInvalidateShaderProgram();\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitVO(shader:LightingShader, methodVO:MethodVO)\n\t{\n\t\tvar tempVO:MethodVO = new MethodVO(this._baseMethod);\n\t\tthis._baseMethod.iInitVO(shader, tempVO);\n\n\t\tmethodVO.needsGlobalVertexPos = true;\n\t\tmethodVO.needsProjection = true;\n\n\t\tmethodVO.textureVO = shader.getTextureVO(this._pCastingLight.shadowMapper.depthMap);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitConstants(shader:ShaderBase, methodVO:MethodVO)\n\t{\n\t\tvar fragmentData:Array<number> = shader.fragmentConstantData;\n\t\tvar vertexData:Array<number> = shader.vertexConstantData;\n\t\tvar index:number = methodVO.fragmentConstantsIndex;\n\t\tfragmentData[index] = 1.0;\n\t\tfragmentData[index + 1] = 1/255.0;\n\t\tfragmentData[index + 2] = 1/65025.0;\n\t\tfragmentData[index + 3] = 1/16581375.0;\n\n\t\tfragmentData[index + 6] = .5;\n\t\tfragmentData[index + 7] = -.5;\n\n\t\tindex = methodVO.vertexConstantsIndex;\n\t\tvertexData[index] = .5;\n\t\tvertexData[index + 1] = -.5;\n\t\tvertexData[index + 2] = 0;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iCleanCompilationData()\n\t{\n\t\tsuper.iCleanCompilationData();\n\t\tthis._cascadeProjections = null;\n\t\tthis._depthMapCoordVaryings = null;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetVertexCode(shader:ShaderBase, methodVO:MethodVO, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = \"\";\n\t\tvar dataReg:ShaderRegisterElement = registerCache.getFreeVertexConstant();\n\n\t\tthis.initProjectionsRegs(registerCache);\n\t\tmethodVO.vertexConstantsIndex = dataReg.index*4;\n\n\t\tvar temp:ShaderRegisterElement = registerCache.getFreeVertexVectorTemp();\n\n\t\tfor (var i:number = 0; i < this._cascadeShadowMapper.numCascades; ++i) {\n\t\t\tcode += \"m44 \" + temp + \", \" + sharedRegisters.globalPositionVertex + \", \" + this._cascadeProjections[i] + \"\\n\" +\n\t\t\t\t\"add \" + this._depthMapCoordVaryings[i] + \", \" + temp + \", \" + dataReg + \".zzwz\\n\";\n\t\t}\n\n\t\treturn code;\n\t}\n\n\t/**\n\t * Creates the registers for the cascades' projection coordinates.\n\t */\n\tprivate initProjectionsRegs(registerCache:ShaderRegisterCache)\n\t{\n\t\tthis._cascadeProjections = new Array<ShaderRegisterElement>(this._cascadeShadowMapper.numCascades);\n\t\tthis._depthMapCoordVaryings = new Array<ShaderRegisterElement>(this._cascadeShadowMapper.numCascades);\n\n\t\tfor (var i:number = 0; i < this._cascadeShadowMapper.numCascades; ++i) {\n\t\t\tthis._depthMapCoordVaryings[i] = registerCache.getFreeVarying();\n\t\t\tthis._cascadeProjections[i] = registerCache.getFreeVertexConstant();\n\t\t\tregisterCache.getFreeVertexConstant();\n\t\t\tregisterCache.getFreeVertexConstant();\n\t\t\tregisterCache.getFreeVertexConstant();\n\t\t}\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentCode(shader:ShaderBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar numCascades:number = this._cascadeShadowMapper.numCascades;\n\t\tvar decReg:ShaderRegisterElement = registerCache.getFreeFragmentConstant();\n\t\tvar dataReg:ShaderRegisterElement = registerCache.getFreeFragmentConstant();\n\t\tvar planeDistanceReg:ShaderRegisterElement = registerCache.getFreeFragmentConstant();\n\t\tvar planeDistances:Array<string> = Array<string>( planeDistanceReg + \".x\", planeDistanceReg + \".y\", planeDistanceReg + \".z\", planeDistanceReg + \".w\" );\n\t\tvar code:string;\n\n\t\tmethodVO.fragmentConstantsIndex = decReg.index*4;\n\n\t\tvar inQuad:ShaderRegisterElement = registerCache.getFreeFragmentVectorTemp();\n\t\tregisterCache.addFragmentTempUsages(inQuad, 1);\n\t\tvar uvCoord:ShaderRegisterElement = registerCache.getFreeFragmentVectorTemp();\n\t\tregisterCache.addFragmentTempUsages(uvCoord, 1);\n\n\t\t// assume lowest partition is selected, will be overwritten later otherwise\n\t\tcode = \"mov \" + uvCoord + \", \" + this._depthMapCoordVaryings[numCascades - 1] + \"\\n\";\n\n\t\tfor (var i:number = numCascades - 2; i >= 0; --i) {\n\t\t\tvar uvProjection:ShaderRegisterElement = this._depthMapCoordVaryings[i];\n\n\t\t\t// calculate if in texturemap (result == 0 or 1, only 1 for a single partition)\n\t\t\tcode += \"slt \" + inQuad + \".z, \" + sharedRegisters.projectionFragment + \".z, \" + planeDistances[i] + \"\\n\"; // z = x > minX, w = y > minY\n\n\t\t\tvar temp:ShaderRegisterElement = registerCache.getFreeFragmentVectorTemp();\n\n\t\t\t// linearly interpolate between old and new uv coords using predicate value == conditional toggle to new value if predicate == 1 (true)\n\t\t\tcode += \"sub \" + temp + \", \" + uvProjection + \", \" + uvCoord + \"\\n\" +\n\t\t\t\t\"mul \" + temp + \", \" + temp + \", \" + inQuad + \".z\\n\" +\n\t\t\t\t\"add \" + uvCoord + \", \" + uvCoord + \", \" + temp + \"\\n\";\n\t\t}\n\n\t\tregisterCache.removeFragmentTempUsage(inQuad);\n\n\t\tcode += \"div \" + uvCoord + \", \" + uvCoord + \", \" + uvCoord + \".w\\n\" +\n\t\t\t\"mul \" + uvCoord + \".xy, \" + uvCoord + \".xy, \" + dataReg + \".zw\\n\" +\n\t\t\t\"add \" + uvCoord + \".xy, \" + uvCoord + \".xy, \" + dataReg + \".zz\\n\";\n\n\t\tcode += this._baseMethod._iGetCascadeFragmentCode(shader, methodVO, decReg, uvCoord, targetReg, registerCache, sharedRegisters) +\n\t\t\t\"add \" + targetReg + \".w, \" + targetReg + \".w, \" + dataReg + \".y\\n\";\n\n\t\tregisterCache.removeFragmentTempUsage(uvCoord);\n\n\t\treturn code;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iActivate(shader:ShaderBase, methodVO:MethodVO, stage:Stage)\n\t{\n\t\tmethodVO.textureVO.activate(shader);\n\n\t\tvar vertexData:Array<number> = shader.vertexConstantData;\n\t\tvar vertexIndex:number = methodVO.vertexConstantsIndex;\n\n\t\tshader.vertexConstantData[methodVO.vertexConstantsIndex + 3] = -1/(this._cascadeShadowMapper.depth*this._pEpsilon);\n\n\t\tvar numCascades:number = this._cascadeShadowMapper.numCascades;\n\t\tvertexIndex += 4;\n\t\tfor (var k:number = 0; k < numCascades; ++k) {\n\t\t\tthis._cascadeShadowMapper.getDepthProjections(k).copyRawDataTo(vertexData, vertexIndex, true);\n\t\t\tvertexIndex += 16;\n\t\t}\n\n\t\tvar fragmentData:Array<number> = shader.fragmentConstantData;\n\t\tvar fragmentIndex:number = methodVO.fragmentConstantsIndex;\n\t\tfragmentData[fragmentIndex + 5] = 1 - this._pAlpha;\n\n\t\tvar nearPlaneDistances:Array<number> = this._cascadeShadowMapper._iNearPlaneDistances;\n\n\t\tfragmentIndex += 8;\n\t\tfor (var i:number = 0; i < numCascades; ++i)\n\t\t\tfragmentData[fragmentIndex + i] = nearPlaneDistances[i];\n\n\t\tthis._baseMethod.iActivateForCascade(shader, methodVO, stage);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iSetRenderState(shader:ShaderBase, methodVO:MethodVO, renderable:RenderableBase, stage:Stage, camera:Camera)\n\t{\n\t}\n\n\t/**\n\t * Called when the shadow mappers cascade configuration changes.\n\t */\n\tprivate onCascadeChange(event:Event)\n\t{\n\t\tthis.iInvalidateShaderProgram();\n\t}\n\n\t/**\n\t * Called when the base method's shader code is invalidated.\n\t */\n\tprivate onShaderInvalidated(event:ShadingMethodEvent)\n\t{\n\t\tthis.iInvalidateShaderProgram();\n\t}\n}\n\nexport = ShadowCascadeMethod;",
    "import BitmapImage2D\t\t\t\t\t= require(\"awayjs-core/lib/data/BitmapImage2D\");\n\nimport DirectionalLight\t\t\t\t\t= require(\"awayjs-display/lib/entities/DirectionalLight\");\nimport Single2DTexture\t\t\t\t\t= require(\"awayjs-display/lib/textures/Single2DTexture\");\n\nimport Stage\t\t\t\t\t\t\t= require(\"awayjs-stagegl/lib/base/Stage\");\n\nimport LightingShader\t\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/LightingShader\");\nimport ShaderBase\t\t\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderBase\");\nimport ShaderRegisterCache\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterCache\");\nimport ShaderRegisterData\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterData\");\nimport ShaderRegisterElement\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterElement\");\n\nimport MethodVO\t\t\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/data/MethodVO\");\nimport ShadowMethodBase\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/methods/ShadowMethodBase\");\n\n/**\n * ShadowDitheredMethod provides a soft shadowing technique by randomly distributing sample points differently for each fragment.\n */\nclass ShadowDitheredMethod extends ShadowMethodBase\n{\n\tprivate static _grainTexture:Single2DTexture;\n\tprivate static _grainUsages:number /*int*/;\n\tprivate static _grainBitmapImage2D:BitmapImage2D;\n\tprivate _depthMapSize:number /*int*/;\n\tprivate _range:number;\n\tprivate _numSamples:number /*int*/;\n\n\t/**\n\t * Creates a new ShadowDitheredMethod object.\n\t * @param castingLight The light casting the shadows\n\t * @param numSamples The amount of samples to take for dithering. Minimum 1, maximum 24.\n\t */\n\tconstructor(castingLight:DirectionalLight, numSamples:number /*int*/ = 4, range:number = 1)\n\t{\n\t\tsuper(castingLight);\n\n\t\tthis._depthMapSize = this._pCastingLight.shadowMapper.depthMapSize;\n\n\t\tthis.numSamples = numSamples;\n\t\tthis.range = range;\n\n\t\t++ShadowDitheredMethod._grainUsages;\n\n\t\tif (!ShadowDitheredMethod._grainTexture)\n\t\t\tthis.initGrainTexture();\n\t}\n\n\t/**\n\t * The amount of samples to take for dithering. Minimum 1, maximum 24. The actual maximum may depend on the\n\t * complexity of the shader.\n\t */\n\tpublic get numSamples():number /*int*/\n\t{\n\t\treturn this._numSamples;\n\t}\n\n\tpublic set numSamples(value:number /*int*/)\n\t{\n\t\tif (value < 1)\n\t\t\tvalue = 1;\n\t\telse if (value > 24)\n\t\t\tvalue = 24;\n\n\t\tif (this._numSamples == value)\n\t\t\treturn;\n\n\t\tthis._numSamples = value;\n\n\t\tthis.iInvalidateShaderProgram();\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitVO(shader:LightingShader, methodVO:MethodVO)\n\t{\n\t\tsuper.iInitVO(shader, methodVO);\n\n\t\tmethodVO.needsProjection = true;\n\n\t\tmethodVO.secondaryTextureVO = shader.getTextureVO(ShadowDitheredMethod._grainTexture);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitConstants(shader:ShaderBase, methodVO:MethodVO)\n\t{\n\t\tsuper.iInitConstants(shader, methodVO);\n\n\t\tvar fragmentData:Array<number> = shader.fragmentConstantData;\n\t\tvar index:number /*int*/ = methodVO.fragmentConstantsIndex;\n\t\tfragmentData[index + 8] = 1/this._numSamples;\n\t}\n\n\t/**\n\t * The range in the shadow map in which to distribute the samples.\n\t */\n\tpublic get range():number\n\t{\n\t\treturn this._range*2;\n\t}\n\n\tpublic set range(value:number)\n\t{\n\t\tthis._range = value/2;\n\t}\n\n\t/**\n\t * Creates a texture containing the dithering noise texture.\n\t */\n\tprivate initGrainTexture()\n\t{\n\t\tShadowDitheredMethod._grainBitmapImage2D = new BitmapImage2D(64, 64, false);\n\t\tvar vec:Array<number> /*uint*/ = new Array<number>();\n\t\tvar len:number /*uint*/ = 4096;\n\t\tvar step:number = 1/(this._depthMapSize*this._range);\n\t\tvar r:number, g:number;\n\n\t\tfor (var i:number /*uint*/ = 0; i < len; ++i) {\n\t\t\tr = 2*(Math.random() - .5);\n\t\t\tg = 2*(Math.random() - .5);\n\t\t\tif (r < 0)\n\t\t\t\tr -= step; else\n\t\t\t\tr += step;\n\t\t\tif (g < 0)\n\t\t\t\tg -= step; else\n\t\t\t\tg += step;\n\t\t\tif (r > 1)\n\t\t\t\tr = 1; else if (r < -1)\n\t\t\t\tr = -1;\n\t\t\tif (g > 1)\n\t\t\t\tg = 1; else if (g < -1)\n\t\t\t\tg = -1;\n\t\t\tvec[i] = (Math.floor((r*.5 + .5)*0xff) << 16) | (Math.floor((g*.5 + .5)*0xff) << 8);\n\t\t}\n\n\t\tShadowDitheredMethod._grainBitmapImage2D.setArray(ShadowDitheredMethod._grainBitmapImage2D.rect, vec);\n\t\tShadowDitheredMethod._grainTexture = new Single2DTexture(ShadowDitheredMethod._grainBitmapImage2D);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic dispose()\n\t{\n\t\tif (--ShadowDitheredMethod._grainUsages == 0) {\n\t\t\tShadowDitheredMethod._grainTexture.dispose();\n\t\t\tShadowDitheredMethod._grainBitmapImage2D.dispose();\n\t\t\tShadowDitheredMethod._grainTexture = null;\n\t\t}\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iActivate(shader:ShaderBase, methodVO:MethodVO, stage:Stage)\n\t{\n\t\tsuper.iActivate(shader, methodVO, stage);\n\n\t\tvar data:Array<number> = shader.fragmentConstantData;\n\t\tvar index:number /*uint*/ = methodVO.fragmentConstantsIndex;\n\t\tdata[index + 9] = (stage.width - 1)/63;\n\t\tdata[index + 10] = (stage.height - 1)/63;\n\t\tdata[index + 11] = 2*this._range/this._depthMapSize;\n\n\t\tmethodVO.secondaryTextureVO.activate(shader);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic _pGetPlanarFragmentCode(shader:ShaderBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, regCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar decReg:ShaderRegisterElement = regCache.getFreeFragmentConstant();\n\t\tvar dataReg:ShaderRegisterElement = regCache.getFreeFragmentConstant();\n\t\tvar customDataReg:ShaderRegisterElement = regCache.getFreeFragmentConstant();\n\n\t\tmethodVO.fragmentConstantsIndex = decReg.index*4;\n\n\t\treturn this.getSampleCode(shader, methodVO, customDataReg, decReg, targetReg, regCache, sharedRegisters);\n\t}\n\n\t/**\n\t * Get the actual shader code for shadow mapping\n\t * @param regCache The register cache managing the registers.\n\t * @param depthMapRegister The texture register containing the depth map.\n\t * @param decReg The register containing the depth map decoding data.\n\t * @param targetReg The target register to add the shadow coverage.\n\t */\n\tprivate getSampleCode(shader:ShaderBase, methodVO:MethodVO, customDataReg:ShaderRegisterElement, decReg:ShaderRegisterElement, targetReg:ShaderRegisterElement, regCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = \"\";\n\t\tvar numSamples:number /*int*/ = this._numSamples;\n\t\tvar uvReg:ShaderRegisterElement = regCache.getFreeFragmentVectorTemp();\n\t\tregCache.addFragmentTempUsages(uvReg, 1);\n\t\tvar temp:ShaderRegisterElement = regCache.getFreeFragmentVectorTemp();\n\t\tregCache.addFragmentTempUsages(temp, 1);\n\n\t\tvar projectionReg:ShaderRegisterElement = sharedRegisters.projectionFragment;\n\n\t\tmethodVO.textureVO._iInitRegisters(shader, regCache);\n\t\tmethodVO.secondaryTextureVO._iInitRegisters(shader, regCache);\n\n\t\tcode += \"div \" + uvReg + \", \" + projectionReg + \", \" + projectionReg + \".w\\n\" +\n\t\t\t\"mul \" + uvReg + \".xy, \" + uvReg + \".xy, \" + customDataReg + \".yz\\n\";\n\n\t\twhile (numSamples > 0) {\n\t\t\tif (numSamples == this._numSamples) {\n\t\t\t\tcode += methodVO.secondaryTextureVO._iGetFragmentCode(shader, uvReg, regCache, uvReg);\n\t\t\t} else {\n\t\t\t\tcode += \"mov \" + temp + \", \" + uvReg + \".zwxy \\n\" +\n\t\t\t\t\tmethodVO.secondaryTextureVO._iGetFragmentCode(shader, uvReg, regCache, temp);\n\t\t\t}\n\n\t\t\t// keep grain in uvReg.zw\n\t\t\tcode += \"sub \" + uvReg + \".zw, \" + uvReg + \".xy, fc0.xx\\n\" + // uv-.5\n\t\t\t\t\"mul \" + uvReg + \".zw, \" + uvReg + \".zw, \" + customDataReg + \".w\\n\"; // (tex unpack scale and tex scale in one)\n\n\t\t\tif (numSamples == this._numSamples) {\n\t\t\t\t// first sample\n\t\t\t\tcode += \"add \" + uvReg + \".xy, \" + uvReg + \".zw, \" + this._pDepthMapCoordReg + \".xy\\n\" +\n\t\t\t\t\tmethodVO.textureVO._iGetFragmentCode(shader, temp, regCache, uvReg) +\n\t\t\t\t\t\"dp4 \" + temp + \".z, \" + temp + \", \" + decReg + \"\\n\" +\n\t\t\t\t\t\"slt \" + targetReg + \".w, \" + this._pDepthMapCoordReg + \".z, \" + temp + \".z\\n\"; // 0 if in shadow\n\t\t\t} else {\n\t\t\t\tcode += this.addSample(shader, methodVO, uvReg, decReg, targetReg, regCache);\n\t\t\t}\n\n\t\t\tif (numSamples > 4)\n\t\t\t\tcode += \"add \" + uvReg + \".xy, \" + uvReg + \".xy, \" + uvReg + \".zw\\n\" + this.addSample(shader, methodVO, uvReg, decReg, targetReg, regCache);\n\n\t\t\tif (numSamples > 1)\n\t\t\t\tcode += \"sub \" + uvReg + \".xy, \" + this._pDepthMapCoordReg + \".xy, \" + uvReg + \".zw\\n\" + this.addSample(shader, methodVO, uvReg, decReg, targetReg, regCache);\n\n\t\t\tif (numSamples > 5)\n\t\t\t\tcode += \"sub \" + uvReg + \".xy, \" + uvReg + \".xy, \" + uvReg + \".zw\\n\" + this.addSample(shader, methodVO, uvReg, decReg, targetReg, regCache);\n\n\t\t\tif (numSamples > 2) {\n\t\t\t\tcode += \"neg \" + uvReg + \".w, \" + uvReg + \".w\\n\"; // will be rotated 90 degrees when being accessed as wz\n\t\t\t\tcode += \"add \" + uvReg + \".xy, \" + uvReg + \".wz, \" + this._pDepthMapCoordReg + \".xy\\n\" + this.addSample(shader, methodVO, uvReg, decReg, targetReg, regCache);\n\t\t\t}\n\n\t\t\tif (numSamples > 6)\n\t\t\t\tcode += \"add \" + uvReg + \".xy, \" + uvReg + \".xy, \" + uvReg + \".wz\\n\" + this.addSample(shader, methodVO, uvReg, decReg, targetReg, regCache);\n\n\t\t\tif (numSamples > 3)\n\t\t\t\tcode += \"sub \" + uvReg + \".xy, \" + this._pDepthMapCoordReg + \".xy, \" + uvReg + \".wz\\n\" + this.addSample(shader, methodVO, uvReg, decReg, targetReg, regCache);\n\n\t\t\tif (numSamples > 7)\n\t\t\t\tcode += \"sub \" + uvReg + \".xy, \" + uvReg + \".xy, \" + uvReg + \".wz\\n\" + this.addSample(shader, methodVO, uvReg, decReg, targetReg, regCache);\n\n\t\t\tnumSamples -= 8;\n\t\t}\n\n\t\tregCache.removeFragmentTempUsage(temp);\n\t\tregCache.removeFragmentTempUsage(uvReg);\n\t\tcode += \"mul \" + targetReg + \".w, \" + targetReg + \".w, \" + customDataReg + \".x\\n\"; // average\n\t\treturn code;\n\t}\n\n\t/**\n\t * Adds the code for another tap to the shader code.\n\t * @param uvReg The uv register for the tap.\n\t * @param depthMapRegister The texture register containing the depth map.\n\t * @param decReg The register containing the depth map decoding data.\n\t * @param targetReg The target register to add the tap comparison result.\n\t * @param regCache The register cache managing the registers.\n\t * @return\n\t */\n\tprivate addSample(shader:ShaderBase, methodVO:MethodVO, uvReg:ShaderRegisterElement, decReg:ShaderRegisterElement, targetReg:ShaderRegisterElement, regCache:ShaderRegisterCache):string\n\t{\n\t\tvar temp:ShaderRegisterElement = regCache.getFreeFragmentVectorTemp();\n\n\t\treturn methodVO.textureVO._iGetFragmentCode(shader, temp, regCache, uvReg) +\n\t\t\t\"dp4 \" + temp + \".z, \" + temp + \", \" + decReg + \"\\n\" +\n\t\t\t\"slt \" + temp + \".z, \" + this._pDepthMapCoordReg + \".z, \" + temp + \".z\\n\" + // 0 if in shadow\n\t\t\t\"add \" + targetReg + \".w, \" + targetReg + \".w, \" + temp + \".z\\n\";\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iActivateForCascade(shader:ShaderBase, methodVO:MethodVO, stage:Stage)\n\t{\n\t\tvar data:Array<number> = shader.fragmentConstantData;\n\t\tvar index:number /*uint*/ = methodVO.secondaryFragmentConstantsIndex;\n\t\tdata[index] = 1/this._numSamples;\n\t\tdata[index + 1] = (stage.width - 1)/63;\n\t\tdata[index + 2] = (stage.height - 1)/63;\n\t\tdata[index + 3] = 2*this._range/this._depthMapSize;\n\n\t\tmethodVO.secondaryTextureVO.activate(shader);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic _iGetCascadeFragmentCode(shader:ShaderBase, methodVO:MethodVO, decodeRegister:ShaderRegisterElement, depthProjection:ShaderRegisterElement, targetRegister:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tthis._pDepthMapCoordReg = depthProjection;\n\n\t\tvar dataReg:ShaderRegisterElement = registerCache.getFreeFragmentConstant();\n\t\tmethodVO.secondaryFragmentConstantsIndex = dataReg.index*4;\n\n\t\treturn this.getSampleCode(shader, methodVO, dataReg, decodeRegister, targetRegister, registerCache, sharedRegisters);\n\t}\n}\n\nexport = ShadowDitheredMethod;",
    "import DirectionalLight\t\t\t\t\t= require(\"awayjs-display/lib/entities/DirectionalLight\");\n\nimport Stage\t\t\t\t\t\t\t= require(\"awayjs-stagegl/lib/base/Stage\");\n\nimport LightingShader\t\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/LightingShader\");\nimport ShaderBase\t\t\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderBase\");\nimport ShaderRegisterCache\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterCache\");\nimport ShaderRegisterData\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterData\");\nimport ShaderRegisterElement\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterElement\");\n\nimport MethodVO\t\t\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/data/MethodVO\");\nimport ShadowMethodBase\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/methods/ShadowMethodBase\");\n\n/**\n * ShadowFilteredMethod provides a softened shadowing technique by bilinearly interpolating shadow comparison\n * results of neighbouring pixels.\n */\nclass ShadowFilteredMethod extends ShadowMethodBase\n{\n\t/**\n\t * Creates a new DiffuseBasicMethod object.\n\t *\n\t * @param castingLight The light casting the shadow\n\t */\n\tconstructor(castingLight:DirectionalLight)\n\t{\n\t\tsuper(castingLight);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitConstants(shader:LightingShader, methodVO:MethodVO)\n\t{\n\t\tsuper.iInitConstants(shader, methodVO);\n\n\t\tvar fragmentData:Array<number> = shader.fragmentConstantData;\n\t\tvar index:number /*int*/ = methodVO.fragmentConstantsIndex;\n\t\tfragmentData[index + 8] = .5;\n\t\tvar size:number /*int*/ = this.castingLight.shadowMapper.depthMapSize;\n\t\tfragmentData[index + 9] = size;\n\t\tfragmentData[index + 10] = 1/size;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic _pGetPlanarFragmentCode(shader:ShaderBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, regCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = \"\";\n\t\tvar decReg:ShaderRegisterElement = regCache.getFreeFragmentConstant();\n\t\tregCache.getFreeFragmentConstant();\n\t\tvar customDataReg:ShaderRegisterElement = regCache.getFreeFragmentConstant();\n\n\t\tmethodVO.fragmentConstantsIndex = decReg.index*4;\n\n\t\tvar depthCol:ShaderRegisterElement = regCache.getFreeFragmentVectorTemp();\n\t\tregCache.addFragmentTempUsages(depthCol, 1);\n\t\tvar uvReg:ShaderRegisterElement = regCache.getFreeFragmentVectorTemp();\n\t\tregCache.addFragmentTempUsages(uvReg, 1);\n\n\t\tmethodVO.textureVO._iInitRegisters(shader, regCache);\n\n\t\tcode += \"mov \" + uvReg + \", \" + this._pDepthMapCoordReg + \"\\n\" +\n\n\t\t\tmethodVO.textureVO._iGetFragmentCode(shader, depthCol, regCache, this._pDepthMapCoordReg) +\n\t\t\t\"dp4 \" + depthCol + \".z, \" + depthCol + \", \" + decReg + \"\\n\" +\n\t\t\t\"slt \" + uvReg + \".z, \" + this._pDepthMapCoordReg + \".z, \" + depthCol + \".z\\n\" +   // 0 if in shadow\n\n\t\t\t\"add \" + uvReg + \".x, \" + this._pDepthMapCoordReg + \".x, \" + customDataReg + \".z\\n\" + \t// (1, 0)\n\t\t\tmethodVO.textureVO._iGetFragmentCode(shader, depthCol, regCache, uvReg) +\n\t\t\t\"dp4 \" + depthCol + \".z, \" + depthCol + \", \" + decReg + \"\\n\" +\n\t\t\t\"slt \" + uvReg + \".w, \" + this._pDepthMapCoordReg + \".z, \" + depthCol + \".z\\n\" +   // 0 if in shadow\n\n\t\t\t\"mul \" + depthCol + \".x, \" + this._pDepthMapCoordReg + \".x, \" + customDataReg + \".y\\n\" +\n\t\t\t\"frc \" + depthCol + \".x, \" + depthCol + \".x\\n\" +\n\t\t\t\"sub \" + uvReg + \".w, \" + uvReg + \".w, \" + uvReg + \".z\\n\" +\n\t\t\t\"mul \" + uvReg + \".w, \" + uvReg + \".w, \" + depthCol + \".x\\n\" +\n\t\t\t\"add \" + targetReg + \".w, \" + uvReg + \".z, \" + uvReg + \".w\\n\" +\n\n\t\t\t\"mov \" + uvReg + \".x, \" + this._pDepthMapCoordReg + \".x\\n\" +\n\t\t\t\"add \" + uvReg + \".y, \" + this._pDepthMapCoordReg + \".y, \" + customDataReg + \".z\\n\" +\t// (0, 1)\n\t\t\tmethodVO.textureVO._iGetFragmentCode(shader, depthCol, regCache, uvReg) +\n\t\t\t\"dp4 \" + depthCol + \".z, \" + depthCol + \", \" + decReg + \"\\n\" +\n\t\t\t\"slt \" + uvReg + \".z, \" + this._pDepthMapCoordReg + \".z, \" + depthCol + \".z\\n\" +   // 0 if in shadow\n\n\t\t\t\"add \" + uvReg + \".x, \" + this._pDepthMapCoordReg + \".x, \" + customDataReg + \".z\\n\" +\t// (1, 1)\n\t\t\tmethodVO.textureVO._iGetFragmentCode(shader, depthCol, regCache, uvReg) +\n\t\t\t\"dp4 \" + depthCol + \".z, \" + depthCol + \", \" + decReg + \"\\n\" +\n\t\t\t\"slt \" + uvReg + \".w, \" + this._pDepthMapCoordReg + \".z, \" + depthCol + \".z\\n\" +   // 0 if in shadow\n\n\t\t\t// recalculate fraction, since we ran out of registers :(\n\t\t\t\"mul \" + depthCol + \".x, \" + this._pDepthMapCoordReg + \".x, \" + customDataReg + \".y\\n\" +\n\t\t\t\"frc \" + depthCol + \".x, \" + depthCol + \".x\\n\" + \"sub \" + uvReg + \".w, \" + uvReg + \".w, \" + uvReg + \".z\\n\" +\n\t\t\t\"mul \" + uvReg + \".w, \" + uvReg + \".w, \" + depthCol + \".x\\n\" +\n\t\t\t\"add \" + uvReg + \".w, \" + uvReg + \".z, \" + uvReg + \".w\\n\" +\n\n\t\t\t\"mul \" + depthCol + \".x, \" + this._pDepthMapCoordReg + \".y, \" + customDataReg + \".y\\n\" +\n\t\t\t\"frc \" + depthCol + \".x, \" + depthCol + \".x\\n\" +\n\t\t\t\"sub \" + uvReg + \".w, \" + uvReg + \".w, \" + targetReg + \".w\\n\" +\n\t\t\t\"mul \" + uvReg + \".w, \" + uvReg + \".w, \" + depthCol + \".x\\n\" +\n\t\t\t\"add \" + targetReg + \".w, \" + targetReg + \".w, \" + uvReg + \".w\\n\";\n\n\t\tregCache.removeFragmentTempUsage(depthCol);\n\t\tregCache.removeFragmentTempUsage(uvReg);\n\n\t\treturn code;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iActivateForCascade(shader:ShaderBase, methodVO:MethodVO, stage:Stage)\n\t{\n\t\tvar size:number /*int*/ = this.castingLight.shadowMapper.depthMapSize;\n\t\tvar index:number /*int*/ = methodVO.secondaryFragmentConstantsIndex;\n\t\tvar data:Array<number> = shader.fragmentConstantData;\n\t\tdata[index] = size;\n\t\tdata[index + 1] = 1/size;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic _iGetCascadeFragmentCode(shader:ShaderBase, methodVO:MethodVO, decodeRegister:ShaderRegisterElement, depthProjection:ShaderRegisterElement, targetRegister:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string;\n\t\tvar dataReg:ShaderRegisterElement = registerCache.getFreeFragmentConstant();\n\t\tmethodVO.secondaryFragmentConstantsIndex = dataReg.index*4;\n\n\t\tvar temp:ShaderRegisterElement = registerCache.getFreeFragmentVectorTemp();\n\t\tregisterCache.addFragmentTempUsages(temp, 1);\n\t\tvar predicate:ShaderRegisterElement = registerCache.getFreeFragmentVectorTemp();\n\t\tregisterCache.addFragmentTempUsages(predicate, 1);\n\n\t\tmethodVO.textureVO._iInitRegisters(shader, registerCache);\n\n\t\tcode = methodVO.textureVO._iGetFragmentCode(shader, temp, registerCache, depthProjection) +\n\t\t\t\"dp4 \" + temp + \".z, \" + temp + \", \" + decodeRegister + \"\\n\" +\n\t\t\t\"slt \" + predicate + \".x, \" + depthProjection + \".z, \" + temp + \".z\\n\" +\n\n\t\t\t\"add \" + depthProjection + \".x, \" + depthProjection + \".x, \" + dataReg + \".y\\n\" +\n\t\t\tmethodVO.textureVO._iGetFragmentCode(shader, temp, registerCache, depthProjection) +\n\t\t\t\"dp4 \" + temp + \".z, \" + temp + \", \" + decodeRegister + \"\\n\" +\n\t\t\t\"slt \" + predicate + \".z, \" + depthProjection + \".z, \" + temp + \".z\\n\" +\n\n\t\t\t\"add \" + depthProjection + \".y, \" + depthProjection + \".y, \" + dataReg + \".y\\n\" +\n\t\t\tmethodVO.textureVO._iGetFragmentCode(shader, temp, registerCache, depthProjection) +\n\t\t\t\"dp4 \" + temp + \".z, \" + temp + \", \" + decodeRegister + \"\\n\" +\n\t\t\t\"slt \" + predicate + \".w, \" + depthProjection + \".z, \" + temp + \".z\\n\" +\n\n\t\t\t\"sub \" + depthProjection + \".x, \" + depthProjection + \".x, \" + dataReg + \".y\\n\" +\n\t\t\tmethodVO.textureVO._iGetFragmentCode(shader, temp, registerCache, depthProjection) +\n\t\t\t\"dp4 \" + temp + \".z, \" + temp + \", \" + decodeRegister + \"\\n\" +\n\t\t\t\"slt \" + predicate + \".y, \" + depthProjection + \".z, \" + temp + \".z\\n\" +\n\n\t\t\t\"mul \" + temp + \".xy, \" + depthProjection + \".xy, \" + dataReg + \".x\\n\" +\n\t\t\t\"frc \" + temp + \".xy, \" + temp + \".xy\\n\" +\n\n\t\t\t// some strange register juggling to prevent agal bugging out\n\t\t\t\"sub \" + depthProjection + \", \" + predicate + \".xyzw, \" + predicate + \".zwxy\\n\" +\n\t\t\t\"mul \" + depthProjection + \", \" + depthProjection + \", \" + temp + \".x\\n\" +\n\n\t\t\t\"add \" + predicate + \".xy, \" + predicate + \".xy, \" + depthProjection + \".zw\\n\" +\n\n\t\t\t\"sub \" + predicate + \".y, \" + predicate + \".y, \" + predicate + \".x\\n\" +\n\t\t\t\"mul \" + predicate + \".y, \" + predicate + \".y, \" + temp + \".y\\n\" +\n\t\t\t\"add \" + targetRegister + \".w, \" + predicate + \".x, \" + predicate + \".y\\n\";\n\n\t\tregisterCache.removeFragmentTempUsage(temp);\n\t\tregisterCache.removeFragmentTempUsage(predicate);\n\t\treturn code;\n\t}\n}\n\nexport = ShadowFilteredMethod;",
    "import LightBase\t\t\t\t\t= require(\"awayjs-display/lib/base/LightBase\");\n\nimport Stage\t\t\t\t\t\t= require(\"awayjs-stagegl/lib/base/Stage\");\n\nimport ShaderBase\t\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderBase\");\nimport ShaderRegisterCache\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterCache\");\nimport ShaderRegisterData\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterData\");\nimport ShaderRegisterElement\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterElement\");\n\nimport MethodVO\t\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/data/MethodVO\");\nimport ShadowMethodBase\t\t\t\t= require(\"awayjs-methodmaterials/lib/methods/ShadowMethodBase\");\n\n/**\n * ShadowHardMethod provides the cheapest shadow map method by using a single tap without any filtering.\n */\nclass ShadowHardMethod extends ShadowMethodBase\n{\n\t/**\n\t * Creates a new ShadowHardMethod object.\n\t */\n\tconstructor(castingLight:LightBase)\n\t{\n\t\tsuper(castingLight);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic _pGetPlanarFragmentCode(shader:ShaderBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, regCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = \"\";\n\t\tvar decReg:ShaderRegisterElement = regCache.getFreeFragmentConstant();\n\t\tregCache.getFreeFragmentConstant();\n\n\t\tvar depthCol:ShaderRegisterElement = regCache.getFreeFragmentVectorTemp();\n\n\t\tmethodVO.fragmentConstantsIndex = decReg.index*4;\n\n\t\tmethodVO.textureVO._iInitRegisters(shader, regCache);\n\n\t\tcode += methodVO.textureVO._iGetFragmentCode(shader, depthCol, regCache, this._pDepthMapCoordReg) +\n\t\t\t\"dp4 \" + depthCol + \".z, \" + depthCol + \", \" + decReg + \"\\n\" +\n\t\t\t\"slt \" + targetReg + \".w, \" + this._pDepthMapCoordReg + \".z, \" + depthCol + \".z\\n\"; // 0 if in shadow\n\n\t\treturn code;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic _pGetPointFragmentCode(shader:ShaderBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, regCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = \"\";\n\t\tvar decReg:ShaderRegisterElement = regCache.getFreeFragmentConstant();\n\t\tvar epsReg:ShaderRegisterElement = regCache.getFreeFragmentConstant();\n\t\tvar posReg:ShaderRegisterElement = regCache.getFreeFragmentConstant();\n\t\tvar depthSampleCol:ShaderRegisterElement = regCache.getFreeFragmentVectorTemp();\n\t\tregCache.addFragmentTempUsages(depthSampleCol, 1);\n\t\tvar lightDir:ShaderRegisterElement = regCache.getFreeFragmentVectorTemp();\n\t\tregCache.addFragmentTempUsages(lightDir, 1);\n\n\t\tmethodVO.fragmentConstantsIndex = decReg.index*4;\n\n\t\tmethodVO.textureVO._iInitRegisters(shader, regCache);\n\n\t\tcode += \"sub \" + lightDir + \", \" + sharedRegisters.globalPositionVarying + \", \" + posReg + \"\\n\" +\n\t\t\t\"dp3 \" + lightDir + \".w, \" + lightDir + \".xyz, \" + lightDir + \".xyz\\n\" +\n\t\t\t\"mul \" + lightDir + \".w, \" + lightDir + \".w, \" + posReg + \".w\\n\" +\n\t\t\t\"nrm \" + lightDir + \".xyz, \" + lightDir + \".xyz\\n\" +\n\n\t\t\tmethodVO.textureVO._iGetFragmentCode(shader, depthSampleCol, regCache, lightDir) +\n\t\t\t\"dp4 \" + depthSampleCol + \".z, \" + depthSampleCol + \", \" + decReg + \"\\n\" +\n\t\t\t\"add \" + targetReg + \".w, \" + lightDir + \".w, \" + epsReg + \".x\\n\" +    // offset by epsilon\n\n\t\t\t\"slt \" + targetReg + \".w, \" + targetReg + \".w, \" + depthSampleCol + \".z\\n\"; // 0 if in shadow\n\n\t\tregCache.removeFragmentTempUsage(lightDir);\n\t\tregCache.removeFragmentTempUsage(depthSampleCol);\n\n\t\treturn code;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic _iGetCascadeFragmentCode(shader:ShaderBase, methodVO:MethodVO, decodeRegister:ShaderRegisterElement, depthProjection:ShaderRegisterElement, targetRegister:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar temp:ShaderRegisterElement = registerCache.getFreeFragmentVectorTemp();\n\t\treturn methodVO.textureVO._iGetFragmentCode(shader, temp, registerCache, depthProjection) +\n\t\t\t\"dp4 \" + temp + \".z, \" + temp + \", \" + decodeRegister + \"\\n\" +\n\t\t\t\"slt \" + targetRegister + \".w, \" + depthProjection + \".z, \" + temp + \".z\\n\"; // 0 if in shadow\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iActivateForCascade(shader:ShaderBase, methodVO:MethodVO, stage:Stage)\n\t{\n\t}\n}\n\nexport = ShadowHardMethod;",
    "import IAsset\t\t\t\t\t\t= require(\"awayjs-core/lib/library/IAsset\");\n\nimport LightBase\t\t\t\t\t= require(\"awayjs-display/lib/base/LightBase\");\nimport ShadowMapperBase\t\t\t\t= require(\"awayjs-display/lib/materials/shadowmappers/ShadowMapperBase\");\n\nimport ShadingMethodBase\t\t\t= require(\"awayjs-methodmaterials/lib/methods/ShadingMethodBase\");\n\n/**\n * ShadowMapMethodBase provides an abstract base method for shadow map methods.\n */\nclass ShadowMapMethodBase extends ShadingMethodBase implements IAsset\n{\n\tpublic static assetType:string = \"[asset ShadowMapMethod]\";\n\n\tpublic _pCastingLight:LightBase;\n\tpublic _pShadowMapper:ShadowMapperBase;\n\n\tpublic _pEpsilon:number = .02;\n\tpublic _pAlpha:number = 1;\n\n\t/**\n\t * Creates a new ShadowMapMethodBase object.\n\t * @param castingLight The light used to cast shadows.\n\t */\n\tconstructor(castingLight:LightBase)\n\t{\n\t\tsuper();\n\t\tthis._pCastingLight = castingLight;\n\t\tcastingLight.castsShadows = true;\n\t\tthis._pShadowMapper = castingLight.shadowMapper;\n\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic get assetType():string\n\t{\n\t\treturn ShadowMapMethodBase.assetType;\n\t}\n\n\t/**\n\t * The \"transparency\" of the shadows. This allows making shadows less strong.\n\t */\n\tpublic get alpha():number\n\t{\n\t\treturn this._pAlpha;\n\t}\n\n\tpublic set alpha(value:number)\n\t{\n\t\tthis._pAlpha = value;\n\t}\n\n\t/**\n\t * The light casting the shadows.\n\t */\n\tpublic get castingLight():LightBase\n\t{\n\t\treturn this._pCastingLight;\n\t}\n\n\t/**\n\t * A small value to counter floating point precision errors when comparing values in the shadow map with the\n\t * calculated depth value. Increase this if shadow banding occurs, decrease it if the shadow seems to be too detached.\n\t */\n\tpublic get epsilon():number\n\t{\n\t\treturn this._pEpsilon;\n\t}\n\n\tpublic set epsilon(value:number)\n\t{\n\t\tthis._pEpsilon = value;\n\t}\n}\n\nexport = ShadowMapMethodBase;",
    "import Vector3D\t\t\t\t\t\t= require(\"awayjs-core/lib/geom/Vector3D\");\nimport AbstractMethodError\t\t\t= require(\"awayjs-core/lib/errors/AbstractMethodError\");\n\nimport LightBase\t\t\t\t\t= require(\"awayjs-display/lib/base/LightBase\");\nimport Camera\t\t\t\t\t\t= require(\"awayjs-display/lib/entities/Camera\");\nimport DirectionalLight\t\t\t\t= require(\"awayjs-display/lib/entities/DirectionalLight\");\nimport PointLight\t\t\t\t\t= require(\"awayjs-display/lib/entities/PointLight\");\nimport DirectionalShadowMapper\t\t= require(\"awayjs-display/lib/materials/shadowmappers/DirectionalShadowMapper\");\nimport TextureBase\t\t\t\t\t= require(\"awayjs-display/lib/textures/TextureBase\");\n\nimport Stage\t\t\t\t\t\t= require(\"awayjs-stagegl/lib/base/Stage\");\n\nimport RenderableBase\t\t\t\t= require(\"awayjs-renderergl/lib/renderables/RenderableBase\");\nimport LightingShader\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/LightingShader\");\nimport ShaderBase\t\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderBase\");\nimport ShaderRegisterCache\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterCache\");\nimport ShaderRegisterData\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterData\");\nimport ShaderRegisterElement\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterElement\");\n\nimport MethodVO\t\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/data/MethodVO\");\nimport ShadowMapMethodBase\t\t\t= require(\"awayjs-methodmaterials/lib/methods/ShadowMapMethodBase\");\n\n/**\n * ShadowMethodBase provides an abstract method for simple (non-wrapping) shadow map methods.\n */\nclass ShadowMethodBase extends ShadowMapMethodBase\n{\n\tpublic _pDepthMapCoordReg:ShaderRegisterElement;\n\tpublic _pUsePoint:boolean;\n\n\t/**\n\t * Creates a new ShadowMethodBase object.\n\t * @param castingLight The light used to cast shadows.\n\t */\n\tconstructor(castingLight:LightBase)\n\t{\n\t\tthis._pUsePoint = (castingLight instanceof PointLight);\n\n\t\tsuper(castingLight);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitVO(shader:LightingShader, methodVO:MethodVO)\n\t{\n\t\tmethodVO.needsView = true;\n\t\tmethodVO.needsGlobalVertexPos = true;\n\t\tmethodVO.needsGlobalFragmentPos = this._pUsePoint;\n\t\tmethodVO.needsNormals = shader.numLights > 0;\n\n\t\tmethodVO.textureVO = shader.getTextureVO(this._pCastingLight.shadowMapper.depthMap);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitConstants(shader:ShaderBase, methodVO:MethodVO)\n\t{\n\t\tvar fragmentData:Array<number> = shader.fragmentConstantData;\n\t\tvar vertexData:Array<number> = shader.vertexConstantData;\n\t\tvar index:number /*int*/ = methodVO.fragmentConstantsIndex;\n\t\tfragmentData[index] = 1.0;\n\t\tfragmentData[index + 1] = 1/255.0;\n\t\tfragmentData[index + 2] = 1/65025.0;\n\t\tfragmentData[index + 3] = 1/16581375.0;\n\n\t\tfragmentData[index + 6] = 0;\n\t\tfragmentData[index + 7] = 1;\n\n\t\tif (this._pUsePoint) {\n\t\t\tfragmentData[index + 8] = 0;\n\t\t\tfragmentData[index + 9] = 0;\n\t\t\tfragmentData[index + 10] = 0;\n\t\t\tfragmentData[index + 11] = 1;\n\t\t}\n\n\t\tindex = methodVO.vertexConstantsIndex;\n\t\tif (index != -1) {\n\t\t\tvertexData[index] = .5;\n\t\t\tvertexData[index + 1] = .5;\n\t\t\tvertexData[index + 2] = 0.0;\n\t\t\tvertexData[index + 3] = 1.0;\n\t\t}\n\t}\n\n\t/**\n\t * Wrappers that override the vertex shader need to set this explicitly\n\t */\n\tpublic get _iDepthMapCoordReg():ShaderRegisterElement\n\t{\n\t\treturn this._pDepthMapCoordReg;\n\t}\n\n\tpublic set _iDepthMapCoordReg(value:ShaderRegisterElement)\n\t{\n\t\tthis._pDepthMapCoordReg = value;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iCleanCompilationData()\n\t{\n\t\tsuper.iCleanCompilationData();\n\n\t\tthis._pDepthMapCoordReg = null;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetVertexCode(shader:ShaderBase, methodVO:MethodVO, regCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\treturn this._pUsePoint? this._pGetPointVertexCode(methodVO, regCache, sharedRegisters):this.pGetPlanarVertexCode(methodVO, regCache, sharedRegisters);\n\t}\n\n\t/**\n\t * Gets the vertex code for shadow mapping with a point light.\n\t *\n\t * @param methodVO The MethodVO object linking this method with the pass currently being compiled.\n\t * @param regCache The register cache used during the compilation.\n\t */\n\tpublic _pGetPointVertexCode(methodVO:MethodVO, regCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tmethodVO.vertexConstantsIndex = -1;\n\t\treturn \"\";\n\t}\n\n\t/**\n\t * Gets the vertex code for shadow mapping with a planar shadow map (fe: directional lights).\n\t *\n\t * @param methodVO The MethodVO object linking this method with the pass currently being compiled.\n\t * @param regCache The register cache used during the compilation.\n\t */\n\tpublic pGetPlanarVertexCode(methodVO:MethodVO, regCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = \"\";\n\t\tvar temp:ShaderRegisterElement = regCache.getFreeVertexVectorTemp();\n\t\tvar dataReg:ShaderRegisterElement = regCache.getFreeVertexConstant();\n\t\tvar depthMapProj:ShaderRegisterElement = regCache.getFreeVertexConstant();\n\t\tregCache.getFreeVertexConstant();\n\t\tregCache.getFreeVertexConstant();\n\t\tregCache.getFreeVertexConstant();\n\t\tthis._pDepthMapCoordReg = regCache.getFreeVarying();\n\t\tmethodVO.vertexConstantsIndex = dataReg.index*4;\n\n\t\t// todo: can epsilon be applied here instead of fragment shader?\n\n\t\tcode += \"m44 \" + temp + \", \" + sharedRegisters.globalPositionVertex + \", \" + depthMapProj + \"\\n\" +\n\t\t\t\"div \" + temp + \", \" + temp + \", \" + temp + \".w\\n\" +\n\t\t\t\"mul \" + temp + \".xy, \" + temp + \".xy, \" + dataReg + \".xy\\n\" +\n\t\t\t\"add \" + this._pDepthMapCoordReg + \", \" + temp + \", \" + dataReg + \".xxwz\\n\";\n\t\t//\"sub \" + this._pDepthMapCoordReg + \".z, \" + this._pDepthMapCoordReg + \".z, \" + this._pDepthMapCoordReg + \".w\\n\";\n\n\t\treturn code;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentCode(shader:ShaderBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = this._pUsePoint? this._pGetPointFragmentCode(shader, methodVO, targetReg, registerCache, sharedRegisters) : this._pGetPlanarFragmentCode(shader, methodVO, targetReg, registerCache, sharedRegisters);\n\t\tcode += \"add \" + targetReg + \".w, \" + targetReg + \".w, fc\" + (methodVO.fragmentConstantsIndex/4 + 1) + \".y\\n\" +\n\t\t\t\"sat \" + targetReg + \".w, \" + targetReg + \".w\\n\";\n\t\treturn code;\n\t}\n\n\t/**\n\t * Gets the fragment code for shadow mapping with a planar shadow map.\n\t * @param methodVO The MethodVO object linking this method with the pass currently being compiled.\n\t * @param regCache The register cache used during the compilation.\n\t * @param targetReg The register to contain the shadow coverage\n\t * @return\n\t */\n\tpublic _pGetPlanarFragmentCode(shader:ShaderBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, regCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tthrow new AbstractMethodError();\n\t\treturn \"\";\n\t}\n\n\t/**\n\t * Gets the fragment code for shadow mapping with a point light.\n\t * @param methodVO The MethodVO object linking this method with the pass currently being compiled.\n\t * @param regCache The register cache used during the compilation.\n\t * @param targetReg The register to contain the shadow coverage\n\t * @return\n\t */\n\tpublic _pGetPointFragmentCode(shader:ShaderBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, regCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tthrow new AbstractMethodError();\n\t\treturn \"\";\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iSetRenderState(shader:ShaderBase, methodVO:MethodVO, renderable:RenderableBase, stage:Stage, camera:Camera)\n\t{\n\t\tif (!this._pUsePoint)\n\t\t\t(<DirectionalShadowMapper> this._pShadowMapper).iDepthProjection.copyRawDataTo(shader.vertexConstantData, methodVO.vertexConstantsIndex + 4, true);\n\t}\n\n\t/**\n\t * Gets the fragment code for combining this method with a cascaded shadow map method.\n\t * @param methodVO The MethodVO object linking this method with the pass currently being compiled.\n\t * @param regCache The register cache used during the compilation.\n\t * @param decodeRegister The register containing the data to decode the shadow map depth value.\n\t * @param depthTexture The texture containing the shadow map.\n\t * @param depthProjection The projection of the fragment relative to the light.\n\t * @param targetRegister The register to contain the shadow coverage\n\t * @return\n\t */\n\tpublic _iGetCascadeFragmentCode(shader:ShaderBase, methodVO:MethodVO, decodeRegister:ShaderRegisterElement, depthProjection:ShaderRegisterElement, targetRegister:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tthrow new Error(\"This shadow method is incompatible with cascade shadows\");\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iActivate(shader:ShaderBase, methodVO:MethodVO, stage:Stage)\n\t{\n\t\tvar fragmentData:Array<number> = shader.fragmentConstantData;\n\t\tvar index:number /*int*/ = methodVO.fragmentConstantsIndex;\n\n\t\tif (this._pUsePoint)\n\t\t\tfragmentData[index + 4] = -Math.pow(1/((<PointLight> this._pCastingLight).fallOff*this._pEpsilon), 2);\n\t\telse\n\t\t\tshader.vertexConstantData[methodVO.vertexConstantsIndex + 3] = -1/((<DirectionalShadowMapper> this._pShadowMapper).depth*this._pEpsilon);\n\n\t\tfragmentData[index + 5] = 1 - this._pAlpha;\n\n\t\tif (this._pUsePoint) {\n\t\t\tvar pos:Vector3D = this._pCastingLight.scenePosition;\n\t\t\tfragmentData[index + 8] = pos.x;\n\t\t\tfragmentData[index + 9] = pos.y;\n\t\t\tfragmentData[index + 10] = pos.z;\n\t\t\t// used to decompress distance\n\t\t\tvar f:number = (<PointLight> this._pCastingLight).fallOff;\n\t\t\tfragmentData[index + 11] = 1/(2*f*f);\n\t\t}\n\n\t\tmethodVO.textureVO.activate(shader);\n\t}\n\n\t/**\n\t * Sets the method state for cascade shadow mapping.\n\t */\n\tpublic iActivateForCascade(shader:ShaderBase, methodVO:MethodVO, stage:Stage)\n\t{\n\t\tthrow new Error(\"This shadow method is incompatible with cascade shadows\");\n\t}\n}\n\nexport = ShadowMethodBase;",
    "import NearDirectionalShadowMapper\t\t= require(\"awayjs-display/lib/materials/shadowmappers/NearDirectionalShadowMapper\");\nimport Camera\t\t\t\t\t\t\t= require(\"awayjs-display/lib/entities/Camera\");\n\nimport Stage\t\t\t\t\t\t\t= require(\"awayjs-stagegl/lib/base/Stage\");\n\nimport RenderableBase\t\t\t\t\t= require(\"awayjs-renderergl/lib/renderables/RenderableBase\");\nimport ShadingMethodEvent\t\t\t\t= require(\"awayjs-renderergl/lib/events/ShadingMethodEvent\");\nimport LightingShader\t\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/LightingShader\");\nimport ShaderBase\t\t\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderBase\");\nimport ShaderRegisterCache\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterCache\");\nimport ShaderRegisterData\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterData\");\nimport ShaderRegisterElement\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterElement\");\n\nimport MethodVO\t\t\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/data/MethodVO\");\nimport ShadowMethodBase\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/methods/ShadowMethodBase\");\n\n// TODO: shadow mappers references in materials should be an interface so that this class should NOT extend ShadowMapMethodBase just for some delegation work\n/**\n * ShadowNearMethod provides a shadow map method that restricts the shadowed area near the camera to optimize\n * shadow map usage. This method needs to be used in conjunction with a NearDirectionalShadowMapper.\n *\n * @see away.lights.NearDirectionalShadowMapper\n */\nclass ShadowNearMethod extends ShadowMethodBase\n{\n\tprivate _baseMethod:ShadowMethodBase;\n\n\tprivate _fadeRatio:number;\n\tprivate _nearShadowMapper:NearDirectionalShadowMapper;\n\n\tprivate _onShaderInvalidatedDelegate:Function;\n\n\t/**\n\t * Creates a new ShadowNearMethod object.\n\t * @param baseMethod The shadow map sampling method used to sample individual cascades (fe: ShadowHardMethod, ShadowSoftMethod)\n\t * @param fadeRatio The amount of shadow fading to the outer shadow area. A value of 1 would mean the shadows start fading from the camera's near plane.\n\t */\n\tconstructor(baseMethod:ShadowMethodBase, fadeRatio:number = .1)\n\t{\n\t\tsuper(baseMethod.castingLight);\n\n\t\tthis._onShaderInvalidatedDelegate = (event:ShadingMethodEvent) => this.onShaderInvalidated(event);\n\n\t\tthis._baseMethod = baseMethod;\n\t\tthis._fadeRatio = fadeRatio;\n\t\tthis._nearShadowMapper = <NearDirectionalShadowMapper> this._pCastingLight.shadowMapper;\n\t\tif (!this._nearShadowMapper)\n\t\t\tthrow new Error(\"ShadowNearMethod requires a light that has a NearDirectionalShadowMapper instance assigned to shadowMapper.\");\n\t\tthis._baseMethod.addEventListener(ShadingMethodEvent.SHADER_INVALIDATED, this._onShaderInvalidatedDelegate);\n\t}\n\n\t/**\n\t * The base shadow map method on which this method's shading is based.\n\t */\n\tpublic get baseMethod():ShadowMethodBase\n\t{\n\t\treturn this._baseMethod;\n\t}\n\n\tpublic set baseMethod(value:ShadowMethodBase)\n\t{\n\t\tif (this._baseMethod == value)\n\t\t\treturn;\n\n\t\tthis._baseMethod.removeEventListener(ShadingMethodEvent.SHADER_INVALIDATED, this._onShaderInvalidatedDelegate);\n\n\t\tthis._baseMethod = value;\n\n\t\tthis._baseMethod.addEventListener(ShadingMethodEvent.SHADER_INVALIDATED, this._onShaderInvalidatedDelegate);\n\n\t\tthis.iInvalidateShaderProgram();\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitConstants(shader:ShaderBase, methodVO:MethodVO)\n\t{\n\t\tsuper.iInitConstants(shader, methodVO);\n\t\tthis._baseMethod.iInitConstants(shader, methodVO);\n\n\t\tvar fragmentData:Array<number> = shader.fragmentConstantData;\n\t\tvar index:number /*int*/ = methodVO.secondaryFragmentConstantsIndex;\n\t\tfragmentData[index + 2] = 0;\n\t\tfragmentData[index + 3] = 1;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitVO(shader:LightingShader, methodVO:MethodVO)\n\t{\n\t\tthis._baseMethod.iInitVO(shader, methodVO);\n\n\t\tmethodVO.needsProjection = true;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic dispose()\n\t{\n\t\tthis._baseMethod.removeEventListener(ShadingMethodEvent.SHADER_INVALIDATED, this._onShaderInvalidatedDelegate);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic get alpha():number\n\t{\n\t\treturn this._baseMethod.alpha;\n\t}\n\n\tpublic set alpha(value:number)\n\t{\n\t\tthis._baseMethod.alpha = value;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic get epsilon():number\n\t{\n\t\treturn this._baseMethod.epsilon;\n\t}\n\n\tpublic set epsilon(value:number)\n\t{\n\t\tthis._baseMethod.epsilon = value;\n\t}\n\n\t/**\n\t * The amount of shadow fading to the outer shadow area. A value of 1 would mean the shadows start fading from the camera's near plane.\n\t */\n\tpublic get fadeRatio():number\n\t{\n\t\treturn this._fadeRatio;\n\t}\n\n\tpublic set fadeRatio(value:number)\n\t{\n\t\tthis._fadeRatio = value;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentCode(shader:ShaderBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = this._baseMethod.iGetFragmentCode(shader, methodVO, targetReg, registerCache, sharedRegisters);\n\n\t\tvar dataReg:ShaderRegisterElement = registerCache.getFreeFragmentConstant();\n\t\tvar temp:ShaderRegisterElement = registerCache.getFreeFragmentSingleTemp();\n\t\tmethodVO.secondaryFragmentConstantsIndex = dataReg.index*4;\n\n\t\tcode += \"abs \" + temp + \", \" + sharedRegisters.projectionFragment + \".w\\n\" +\n\t\t\t\"sub \" + temp + \", \" + temp + \", \" + dataReg + \".x\\n\" +\n\t\t\t\"mul \" + temp + \", \" + temp + \", \" + dataReg + \".y\\n\" +\n\t\t\t\"sat \" + temp + \", \" + temp + \"\\n\" +\n\t\t\t\"sub \" + temp + \", \" + dataReg + \".w,\" + temp + \"\\n\" +\n\t\t\t\"sub \" + targetReg + \".w, \" + dataReg + \".w,\" + targetReg + \".w\\n\" +\n\t\t\t\"mul \" + targetReg + \".w, \" + targetReg + \".w, \" + temp + \"\\n\" +\n\t\t\t\"sub \" + targetReg + \".w, \" + dataReg + \".w,\" + targetReg + \".w\\n\";\n\n\t\treturn code;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iActivate(shader:ShaderBase, methodVO:MethodVO, stage:Stage)\n\t{\n\t\tthis._baseMethod.iActivate(shader, methodVO, stage);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iDeactivate(shader:ShaderBase, methodVO:MethodVO, stage:Stage)\n\t{\n\t\tthis._baseMethod.iDeactivate(shader, methodVO, stage);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iSetRenderState(shader:ShaderBase, methodVO:MethodVO, renderable:RenderableBase, stage:Stage, camera:Camera)\n\t{\n\t\t// todo: move this to activate (needs camera)\n\t\tvar near:number = camera.projection.near;\n\t\tvar d:number = camera.projection.far - near;\n\t\tvar maxDistance:number = this._nearShadowMapper.coverageRatio;\n\t\tvar minDistance:number = maxDistance*(1 - this._fadeRatio);\n\n\t\tmaxDistance = near + maxDistance*d;\n\t\tminDistance = near + minDistance*d;\n\n\t\tvar fragmentData:Array<number> = shader.fragmentConstantData;\n\t\tvar index:number /*int*/ = methodVO.secondaryFragmentConstantsIndex;\n\t\tfragmentData[index] = minDistance;\n\t\tfragmentData[index + 1] = 1/(maxDistance - minDistance);\n\n\t\tthis._baseMethod.iSetRenderState(shader, methodVO, renderable, stage, camera);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetVertexCode(shader:ShaderBase, methodVO:MethodVO, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\treturn this._baseMethod.iGetVertexCode(shader, methodVO, registerCache, sharedRegisters);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iReset()\n\t{\n\t\tthis._baseMethod.iReset();\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iCleanCompilationData()\n\t{\n\t\tsuper.iCleanCompilationData();\n\t\tthis._baseMethod.iCleanCompilationData();\n\t}\n\n\t/**\n\t * Called when the base method's shader code is invalidated.\n\t */\n\tprivate onShaderInvalidated(event:ShadingMethodEvent)\n\t{\n\t\tthis.iInvalidateShaderProgram();\n\t}\n}\n\nexport = ShadowNearMethod;",
    "import PoissonLookup\t\t\t\t\t= require(\"awayjs-core/lib/geom/PoissonLookup\");\n\nimport DirectionalLight\t\t\t\t\t= require(\"awayjs-display/lib/entities/DirectionalLight\");\n\nimport Stage\t\t\t\t\t\t\t= require(\"awayjs-stagegl/lib/base/Stage\");\n\nimport ShaderBase\t\t\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderBase\");\nimport ShaderRegisterCache\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterCache\");\nimport ShaderRegisterData\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterData\");\nimport ShaderRegisterElement\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterElement\");\n\nimport MethodVO\t\t\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/data/MethodVO\");\nimport ShadowMethodBase\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/methods/ShadowMethodBase\");\n\n/**\n * ShadowSoftMethod provides a soft shadowing technique by randomly distributing sample points.\n */\nclass ShadowSoftMethod extends ShadowMethodBase\n{\n\tprivate _range:number = 1;\n\tprivate _numSamples:number /*int*/;\n\tprivate _offsets:Array<number>;\n\n\t/**\n\t * Creates a new DiffuseBasicMethod object.\n\t *\n\t * @param castingLight The light casting the shadows\n\t * @param numSamples The amount of samples to take for dithering. Minimum 1, maximum 32.\n\t */\n\tconstructor(castingLight:DirectionalLight, numSamples:number /*int*/ = 5, range:number = 1)\n\t{\n\t\tsuper(castingLight);\n\n\t\tthis.numSamples = numSamples;\n\t\tthis.range = range;\n\t}\n\n\t/**\n\t * The amount of samples to take for dithering. Minimum 1, maximum 32. The actual maximum may depend on the\n\t * complexity of the shader.\n\t */\n\tpublic get numSamples():number /*int*/\n\t{\n\t\treturn this._numSamples;\n\t}\n\n\tpublic set numSamples(value:number /*int*/)\n\t{\n\t\tthis._numSamples = value;\n\t\t\n\t\tif (this._numSamples < 1)\n\t\t\tthis._numSamples = 1;\n\t\telse if (this._numSamples > 32)\n\t\t\tthis._numSamples = 32;\n\n\t\tthis._offsets = PoissonLookup.getDistribution(this._numSamples);\n\t\t\n\t\tthis.iInvalidateShaderProgram();\n\t}\n\n\t/**\n\t * The range in the shadow map in which to distribute the samples.\n\t */\n\tpublic get range():number\n\t{\n\t\treturn this._range;\n\t}\n\n\tpublic set range(value:number)\n\t{\n\t\tthis._range = value;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitConstants(shader:ShaderBase, methodVO:MethodVO)\n\t{\n\t\tsuper.iInitConstants(shader, methodVO);\n\n\t\tshader.fragmentConstantData[methodVO.fragmentConstantsIndex + 8] = 1/this._numSamples;\n\t\tshader.fragmentConstantData[methodVO.fragmentConstantsIndex + 9] = 0;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iActivate(shader:ShaderBase, methodVO:MethodVO, stage:Stage)\n\t{\n\t\tsuper.iActivate(shader, methodVO, stage);\n\n\t\tvar texRange:number = .5*this._range/this._pCastingLight.shadowMapper.depthMapSize;\n\t\tvar data:Array<number> = shader.fragmentConstantData;\n\t\tvar index:number /*uint*/ = methodVO.fragmentConstantsIndex + 10;\n\t\tvar len:number /*uint*/ = this._numSamples << 1;\n\n\t\tfor (var i:number /*int*/ = 0; i < len; ++i)\n\t\t\tdata[index + i] = this._offsets[i]*texRange;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic _pGetPlanarFragmentCode(shader:ShaderBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, regCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\t// todo: move some things to super\n\t\tvar decReg:ShaderRegisterElement = regCache.getFreeFragmentConstant();\n\t\tregCache.getFreeFragmentConstant();\n\t\tvar dataReg:ShaderRegisterElement = regCache.getFreeFragmentConstant();\n\n\t\tmethodVO.fragmentConstantsIndex = decReg.index*4;\n\n\t\tmethodVO.textureVO._iInitRegisters(shader, regCache);\n\n\t\treturn this.getSampleCode(shader, methodVO, decReg, targetReg, regCache, dataReg);\n\t}\n\n\t/**\n\t * Adds the code for another tap to the shader code.\n\t * @param uv The uv register for the tap.\n\t * @param texture The texture register containing the depth map.\n\t * @param decode The register containing the depth map decoding data.\n\t * @param target The target register to add the tap comparison result.\n\t * @param regCache The register cache managing the registers.\n\t * @return\n\t */\n\tprivate addSample(shader:ShaderBase, methodVO:MethodVO, decodeRegister:ShaderRegisterElement, targetRegister:ShaderRegisterElement, registerCache:ShaderRegisterCache, uvReg:ShaderRegisterElement):string\n\t{\n\t\tvar temp:ShaderRegisterElement = registerCache.getFreeFragmentVectorTemp();\n\t\treturn methodVO.textureVO._iGetFragmentCode(shader, temp, registerCache, uvReg) +\n\t\t\t\"dp4 \" + temp + \".z, \" + temp + \", \" + decodeRegister + \"\\n\" +\n\t\t\t\"slt \" + uvReg + \".w, \" + this._pDepthMapCoordReg + \".z, \" + temp + \".z\\n\" + // 0 if in shadow\n\t\t\t\"add \" + targetRegister + \".w, \" + targetRegister + \".w, \" + uvReg + \".w\\n\";\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iActivateForCascade(shader:ShaderBase, methodVO:MethodVO, stage:Stage)\n\t{\n\t\tsuper.iActivate(shader, methodVO, stage);\n\n\t\tvar texRange:number = this._range/this._pCastingLight.shadowMapper.depthMapSize;\n\t\tvar data:Array<number> = shader.fragmentConstantData;\n\t\tvar index:number /*uint*/ = methodVO.secondaryFragmentConstantsIndex;\n\t\tvar len:number /*uint*/ = this._numSamples << 1;\n\t\tdata[index] = 1/this._numSamples;\n\t\tdata[index + 1] = 0;\n\t\tindex += 2;\n\n\t\tfor (var i:number /*int*/ = 0; i < len; ++i)\n\t\t\tdata[index + i] = this._offsets[i]*texRange;\n\n\t\tif (len%4 == 0) {\n\t\t\tdata[index + len] = 0;\n\t\t\tdata[index + len + 1] = 0;\n\t\t}\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic _iGetCascadeFragmentCode(shader:ShaderBase, methodVO:MethodVO, decodeRegister:ShaderRegisterElement, depthProjection:ShaderRegisterElement, targetRegister:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tthis._pDepthMapCoordReg = depthProjection;\n\n\t\tvar dataReg:ShaderRegisterElement = registerCache.getFreeFragmentConstant();\n\t\tmethodVO.secondaryFragmentConstantsIndex = dataReg.index*4;\n\n\t\treturn this.getSampleCode(shader, methodVO, decodeRegister, targetRegister, registerCache, dataReg);\n\t}\n\n\t/**\n\t * Get the actual shader code for shadow mapping\n\t * @param regCache The register cache managing the registers.\n\t * @param depthTexture The texture register containing the depth map.\n\t * @param decodeRegister The register containing the depth map decoding data.\n\t * @param targetReg The target register to add the shadow coverage.\n\t * @param dataReg The register containing additional data.\n\t */\n\tprivate getSampleCode(shader:ShaderBase, methodVO:MethodVO, decodeRegister:ShaderRegisterElement, targetRegister:ShaderRegisterElement, registerCache:ShaderRegisterCache, dataReg:ShaderRegisterElement):string\n\t{\n\t\tvar code:string;\n\t\tvar uvReg:ShaderRegisterElement = registerCache.getFreeFragmentVectorTemp();\n\t\tregisterCache.addFragmentTempUsages(uvReg, 1);\n\n\t\tvar offsets:Array<string> = new Array<string>(dataReg + \".zw\");\n\t\tvar numRegs:number /*int*/ = this._numSamples >> 1;\n\n\t\tfor (var i:number /*int*/ = 0; i < numRegs; ++i) {\n\t\t\tvar reg:ShaderRegisterElement = registerCache.getFreeFragmentConstant();\n\t\t\toffsets.push(reg + \".xy\");\n\t\t\toffsets.push(reg + \".zw\");\n\t\t}\n\n\t\tfor (i = 0; i < this._numSamples; ++i) {\n\t\t\tif (i == 0) {\n\t\t\t\tvar temp:ShaderRegisterElement = registerCache.getFreeFragmentVectorTemp();\n\n\t\t\t\tcode = \"add \" + uvReg + \", \" + this._pDepthMapCoordReg + \", \" + dataReg + \".zwyy\\n\" +\n\t\t\t\t\tmethodVO.textureVO._iGetFragmentCode(shader, temp, registerCache, uvReg) +\n\t\t\t\t\t\"dp4 \" + temp + \".z, \" + temp + \", \" + decodeRegister + \"\\n\" +\n\t\t\t\t\t\"slt \" + targetRegister + \".w, \" + this._pDepthMapCoordReg + \".z, \" + temp + \".z\\n\"; // 0 if in shadow;\n\t\t\t} else {\n\t\t\t\tcode += \"add \" + uvReg + \".xy, \" + this._pDepthMapCoordReg + \".xy, \" + offsets[i] + \"\\n\" +\n\t\t\t\t\tthis.addSample(shader, methodVO, decodeRegister, targetRegister, registerCache, uvReg);\n\t\t\t}\n\t\t}\n\n\t\tregisterCache.removeFragmentTempUsage(uvReg);\n\n\t\tcode += \"mul \" + targetRegister + \".w, \" + targetRegister + \".w, \" + dataReg + \".x\\n\"; // average\n\n\t\treturn code;\n\t}\n}\n\nexport = ShadowSoftMethod;",
    "import LightingShader\t\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/LightingShader\");\nimport ShaderRegisterCache\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterCache\");\nimport ShaderRegisterData\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterData\");\nimport ShaderRegisterElement\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterElement\");\n\nimport MethodVO\t\t\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/data/MethodVO\");\nimport SpecularBasicMethod\t\t\t\t= require(\"awayjs-methodmaterials/lib/methods/SpecularBasicMethod\");\n\n/**\n * SpecularAnisotropicMethod provides a specular method resulting in anisotropic highlights. These are typical for\n * surfaces with microfacet details such as tiny grooves. In particular, this uses the Heidrich-Seidel distrubution.\n * The tangent vectors are used as the surface groove directions.\n */\nclass SpecularAnisotropicMethod extends SpecularBasicMethod\n{\n\t/**\n\t * Creates a new SpecularAnisotropicMethod object.\n\t */\n\tconstructor()\n\t{\n\t\tsuper();\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitVO(shader:LightingShader, methodVO:MethodVO)\n\t{\n\t\tmethodVO.needsTangents = true;\n\t\tmethodVO.needsView = true;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentCodePerLight(shader:LightingShader, methodVO:MethodVO, lightDirReg:ShaderRegisterElement, lightColReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = \"\";\n\t\tvar t:ShaderRegisterElement;\n\n\t\tif (this._pIsFirstLight)\n\t\t\tt = this._pTotalLightColorReg;\n\t\telse {\n\t\t\tt = registerCache.getFreeFragmentVectorTemp();\n\t\t\tregisterCache.addFragmentTempUsages(t, 1);\n\t\t}\n\n\t\t// (sin(l,t) * sin(v,t) - cos(l,t)*cos(v,t)) ^ k\n\n\t\tcode += \"nrm \" + t + \".xyz, \" + sharedRegisters.tangentVarying + \".xyz\\n\" +\n\t\t\t\"dp3 \" + t + \".w, \" + t + \".xyz, \" + lightDirReg + \".xyz\\n\" +\n\t\t\t\"dp3 \" + t + \".z, \" + t + \".xyz, \" + sharedRegisters.viewDirFragment + \".xyz\\n\";\n\n\t\t// (sin(t.w) * sin(t.z) - cos(t.w)*cos(t.z)) ^ k\n\t\tcode += \"sin \" + t + \".x, \" + t + \".w\\n\" +\n\t\t\t\"sin \" + t + \".y, \" + t + \".z\\n\" +\n\t\t\t// (t.x * t.y - cos(t.w)*cos(t.z)) ^ k\n\t\t\t\"mul \" + t + \".x, \" + t + \".x, \" + t + \".y\\n\" +\n\t\t\t// (t.x - cos(t.w)*cos(t.z)) ^ k\n\t\t\t\"cos \" + t + \".z, \" + t + \".z\\n\" +\n\t\t\t\"cos \" + t + \".w, \" + t + \".w\\n\" +\n\t\t\t// (t.x - t.w*t.z) ^ k\n\t\t\t\"mul \" + t + \".w, \" + t + \".w, \" + t + \".z\\n\" +\n\t\t\t// (t.x - t.w) ^ k\n\t\t\t\"sub \" + t + \".w, \" + t + \".x, \" + t + \".w\\n\";\n\n\t\tif (this.texture) {\n\t\t\t// apply gloss modulation from texture\n\t\t\tcode += \"mul \" + this._pSpecularTexData + \".w, \" + this._pSpecularTexData + \".y, \" + this._pSpecularDataRegister + \".w\\n\" +\n\t\t\t\t\"pow \" + t + \".w, \" + t + \".w, \" + this._pSpecularTexData + \".w\\n\";\n\t\t} else\n\t\t\tcode += \"pow \" + t + \".w, \" + t + \".w, \" + this._pSpecularDataRegister + \".w\\n\";\n\n\t\t// attenuate\n\t\tcode += \"mul \" + t + \".w, \" + t + \".w, \" + lightDirReg + \".w\\n\";\n\n\t\tif (this._iModulateMethod != null)\n\t\t\tcode += this._iModulateMethod(shader, methodVO, t, registerCache, sharedRegisters);\n\n\t\tcode += \"mul \" + t + \".xyz, \" + lightColReg + \".xyz, \" + t + \".w\\n\";\n\n\t\tif (!this._pIsFirstLight) {\n\t\t\tcode += \"add \" + this._pTotalLightColorReg + \".xyz, \" + this._pTotalLightColorReg + \".xyz, \" + t + \".xyz\\n\";\n\t\t\tregisterCache.removeFragmentTempUsage(t);\n\t\t}\n\n\t\tthis._pIsFirstLight = false;\n\n\t\treturn code;\n\t}\n}\n\nexport = SpecularAnisotropicMethod;",
    "import TextureBase\t\t\t\t\t= require(\"awayjs-display/lib/textures/TextureBase\");\n\nimport Stage\t\t\t\t\t\t= require(\"awayjs-stagegl/lib/base/Stage\");\n\nimport LightingShader\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/LightingShader\");\nimport ShaderRegisterCache\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterCache\");\nimport ShaderRegisterData\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterData\");\nimport ShaderRegisterElement\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterElement\");\n\nimport MethodVO\t\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/data/MethodVO\");\nimport LightingMethodBase\t\t\t= require(\"awayjs-methodmaterials/lib/methods/LightingMethodBase\");\nimport ShadingMethodBase\t\t\t= require(\"awayjs-methodmaterials/lib/methods/ShadingMethodBase\");\n\n/**\n * SpecularBasicMethod provides the default shading method for Blinn-Phong specular highlights (an optimized but approximated\n * version of Phong specularity).\n */\nclass SpecularBasicMethod extends LightingMethodBase\n{\n\tpublic _pTotalLightColorReg:ShaderRegisterElement;\n\tpublic _pSpecularTexData:ShaderRegisterElement;\n\tpublic _pSpecularDataRegister:ShaderRegisterElement;\n\n\tprivate _texture:TextureBase;\n\n\tprivate _gloss:number = 50;\n\tprivate _specular:number = 1;\n\tprivate _specularColor:number = 0xffffff;\n\tpublic _iSpecularR:number = 1;\n\tpublic _iSpecularG:number = 1;\n\tpublic _iSpecularB:number = 1;\n\tpublic _pIsFirstLight:boolean;\n\n\t/**\n\t * Creates a new SpecularBasicMethod object.\n\t */\n\tconstructor()\n\t{\n\t\tsuper();\n\t}\n\n\tpublic iIsUsed(shader:LightingShader):boolean\n\t{\n\t\tif (!shader.numLights)\n\t\t\treturn false;\n\n\t\treturn true;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitVO(shader:LightingShader, methodVO:MethodVO)\n\t{\n\t\tmethodVO.needsNormals = shader.numLights > 0;\n\t\tmethodVO.needsView = shader.numLights > 0;\n\n\t\tif (this._texture) {\n\t\t\tmethodVO.textureVO = shader.getTextureVO(this._texture);\n\t\t\tshader.uvDependencies++;\n\t\t} else if (methodVO.textureVO) {\n\t\t\tmethodVO.textureVO.dispose();\n\t\t\tmethodVO.textureVO = null;\n\t\t}\n\t}\n\n\t/**\n\t * The sharpness of the specular highlight.\n\t */\n\tpublic get gloss():number\n\t{\n\t\treturn this._gloss;\n\t}\n\n\tpublic set gloss(value:number)\n\t{\n\t\tthis._gloss = value;\n\t}\n\n\t/**\n\t * The overall strength of the specular highlights.\n\t */\n\tpublic get specular():number\n\t{\n\t\treturn this._specular;\n\t}\n\n\tpublic set specular(value:number)\n\t{\n\t\tif (value == this._specular)\n\t\t\treturn;\n\n\t\tthis._specular = value;\n\t\tthis.updateSpecular();\n\t}\n\n\t/**\n\t * The colour of the specular reflection of the surface.\n\t */\n\tpublic get specularColor():number\n\t{\n\t\treturn this._specularColor;\n\t}\n\n\tpublic set specularColor(value:number)\n\t{\n\t\tif (this._specularColor == value)\n\t\t\treturn;\n\n\t\t// specular is now either enabled or disabled\n\t\tif (this._specularColor == 0 || value == 0)\n\t\t\tthis.iInvalidateShaderProgram();\n\n\t\tthis._specularColor = value;\n\t\tthis.updateSpecular();\n\t}\n\n\t/**\n\t * The bitmapData that encodes the specular highlight strength per texel in the red channel, and the sharpness\n\t * in the green channel. You can use SpecularTextureBase if you want to easily set specular and gloss maps\n\t * from grayscale images, but prepared images are preferred.\n\t */\n\tpublic get texture():TextureBase\n\t{\n\t\treturn this._texture;\n\t}\n\n\tpublic set texture(value:TextureBase)\n\t{\n\t\tif (this._texture == value)\n\t\t\treturn;\n\n\t\tthis._texture = value;\n\n\t\tthis.iInvalidateShaderProgram();\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic copyFrom(method:ShadingMethodBase)\n\t{\n\n\t\tvar m:any = method;\n\t\tvar bsm:SpecularBasicMethod = <SpecularBasicMethod> method;\n\n\t\tvar spec:SpecularBasicMethod = bsm;//SpecularBasicMethod(method);\n\t\tthis.texture = spec.texture;\n\t\tthis.specular = spec.specular;\n\t\tthis.specularColor = spec.specularColor;\n\t\tthis.gloss = spec.gloss;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iCleanCompilationData()\n\t{\n\t\tsuper.iCleanCompilationData();\n\t\tthis._pTotalLightColorReg = null;\n\t\tthis._pSpecularTexData = null;\n\t\tthis._pSpecularDataRegister = null;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentPreLightingCode(shader:LightingShader, methodVO:MethodVO, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = \"\";\n\n\t\tthis._pIsFirstLight = true;\n\n\t\tthis._pSpecularDataRegister = registerCache.getFreeFragmentConstant();\n\t\tmethodVO.fragmentConstantsIndex = this._pSpecularDataRegister.index*4;\n\n\t\tif (this._texture) {\n\n\t\t\tthis._pSpecularTexData = registerCache.getFreeFragmentVectorTemp();\n\t\t\tregisterCache.addFragmentTempUsages(this._pSpecularTexData, 1);\n\n\t\t\tmethodVO.textureVO._iInitRegisters(shader, registerCache);\n\n\t\t\tcode += methodVO.textureVO._iGetFragmentCode(shader, this._pSpecularTexData, registerCache, sharedRegisters.uvVarying);\n\t\t}\n\n\t\tthis._pTotalLightColorReg = registerCache.getFreeFragmentVectorTemp();\n\t\tregisterCache.addFragmentTempUsages(this._pTotalLightColorReg, 1);\n\n\t\treturn code;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentCodePerLight(shader:LightingShader, methodVO:MethodVO, lightDirReg:ShaderRegisterElement, lightColReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = \"\";\n\t\tvar t:ShaderRegisterElement;\n\n\t\tif (this._pIsFirstLight) {\n\t\t\tt = this._pTotalLightColorReg;\n\t\t} else {\n\t\t\tt = registerCache.getFreeFragmentVectorTemp();\n\t\t\tregisterCache.addFragmentTempUsages(t, 1);\n\t\t}\n\n\t\tvar viewDirReg:ShaderRegisterElement = sharedRegisters.viewDirFragment;\n\t\tvar normalReg:ShaderRegisterElement = sharedRegisters.normalFragment;\n\n\t\t// blinn-phong half vector model\n\t\tcode += \"add \" + t + \", \" + lightDirReg + \", \" + viewDirReg + \"\\n\" +\n\t\t\t\t\"nrm \" + t + \".xyz, \" + t + \"\\n\" +\n\t\t\t\t\"dp3 \" + t + \".w, \" + normalReg + \", \" + t + \"\\n\" +\n\t\t\t\t\"sat \" + t + \".w, \" + t + \".w\\n\";\n\n\t\tif (this._texture) {\n\t\t\t// apply gloss modulation from texture\n\t\t\tcode += \"mul \" + this._pSpecularTexData + \".w, \" + this._pSpecularTexData + \".y, \" + this._pSpecularDataRegister + \".w\\n\" +\n\t\t\t\t\t\"pow \" + t + \".w, \" + t + \".w, \" + this._pSpecularTexData + \".w\\n\";\n\t\t} else {\n\t\t\tcode += \"pow \" + t + \".w, \" + t + \".w, \" + this._pSpecularDataRegister + \".w\\n\";\n\t\t}\n\n\t\t// attenuate\n\t\tif (shader.usesLightFallOff)\n\t\t\tcode += \"mul \" + t + \".w, \" + t + \".w, \" + lightDirReg + \".w\\n\";\n\n\t\tif (this._iModulateMethod != null)\n\t\t\tcode += this._iModulateMethod(shader, methodVO, t, registerCache, sharedRegisters);\n\n\t\tcode += \"mul \" + t + \".xyz, \" + lightColReg + \", \" + t + \".w\\n\";\n\n\t\tif (!this._pIsFirstLight) {\n\t\t\tcode += \"add \" + this._pTotalLightColorReg + \".xyz, \" + this._pTotalLightColorReg + \", \" + t + \"\\n\";\n\t\t\tregisterCache.removeFragmentTempUsage(t);\n\t\t}\n\n\t\tthis._pIsFirstLight = false;\n\n\t\treturn code;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentCodePerProbe(shader:LightingShader, methodVO:MethodVO, cubeMapReg:ShaderRegisterElement, weightRegister:string, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = \"\";\n\t\tvar t:ShaderRegisterElement;\n\n\t\t// write in temporary if not first light, so we can add to total diffuse colour\n\t\tif (this._pIsFirstLight) {\n\t\t\tt = this._pTotalLightColorReg;\n\t\t} else {\n\t\t\tt = registerCache.getFreeFragmentVectorTemp();\n\t\t\tregisterCache.addFragmentTempUsages(t, 1);\n\t\t}\n\n\t\tvar normalReg:ShaderRegisterElement = sharedRegisters.normalFragment;\n\t\tvar viewDirReg:ShaderRegisterElement = sharedRegisters.viewDirFragment;\n\n\t\tcode += \"dp3 \" + t + \".w, \" + normalReg + \", \" + viewDirReg + \"\\n\" +\n\t\t\t\t\"add \" + t + \".w, \" + t + \".w, \" + t + \".w\\n\" +\n\t\t\t\t\"mul \" + t + \", \" + t + \".w, \" + normalReg + \"\\n\" +\n\t\t\t\t\"sub \" + t + \", \" + t + \", \" + viewDirReg + \"\\n\" +\n\t\t\t\t\"tex \" + t + \", \" + t + \", \" + cubeMapReg + \" <cube,\" + (shader.useSmoothTextures? \"linear\":\"nearest\") + \",miplinear>\\n\" +\n\t\t\t\t\"mul \" + t + \".xyz, \" + t + \", \" + weightRegister + \"\\n\";\n\n\t\tif (this._iModulateMethod != null)\n\t\t\tcode += this._iModulateMethod(shader, methodVO, t, registerCache, sharedRegisters);\n\n\t\tif (!this._pIsFirstLight) {\n\t\t\tcode += \"add \" + this._pTotalLightColorReg + \".xyz, \" + this._pTotalLightColorReg + \", \" + t + \"\\n\";\n\t\t\tregisterCache.removeFragmentTempUsage(t);\n\t\t}\n\n\t\tthis._pIsFirstLight = false;\n\n\t\treturn code;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentPostLightingCode(shader:LightingShader, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = \"\";\n\n\t\tif (sharedRegisters.shadowTarget)\n\t\t\tcode += \"mul \" + this._pTotalLightColorReg + \".xyz, \" + this._pTotalLightColorReg + \", \" + sharedRegisters.shadowTarget + \".w\\n\";\n\n\t\tif (this._texture) {\n\t\t\t// apply strength modulation from texture\n\t\t\tcode += \"mul \" + this._pTotalLightColorReg + \".xyz, \" + this._pTotalLightColorReg + \", \" + this._pSpecularTexData + \".x\\n\";\n\t\t\tregisterCache.removeFragmentTempUsage(this._pSpecularTexData);\n\t\t}\n\n\t\t// apply material's specular reflection\n\t\tcode += \"mul \" + this._pTotalLightColorReg + \".xyz, \" + this._pTotalLightColorReg + \", \" + this._pSpecularDataRegister + \"\\n\" +\n\t\t\t\"add \" + targetReg + \".xyz, \" + targetReg + \", \" + this._pTotalLightColorReg + \"\\n\";\n\t\tregisterCache.removeFragmentTempUsage(this._pTotalLightColorReg);\n\n\t\treturn code;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iActivate(shader:LightingShader, methodVO:MethodVO, stage:Stage)\n\t{\n\t\tif (this._texture)\n\t\t\tmethodVO.textureVO.activate(shader);\n\n\t\tvar index:number = methodVO.fragmentConstantsIndex;\n\t\tvar data:Array<number> = shader.fragmentConstantData;\n\t\tdata[index] = this._iSpecularR;\n\t\tdata[index + 1] = this._iSpecularG;\n\t\tdata[index + 2] = this._iSpecularB;\n\t\tdata[index + 3] = this._gloss;\n\t}\n\n\t/**\n\t * Updates the specular color data used by the render state.\n\t */\n\tprivate updateSpecular()\n\t{\n\t\tthis._iSpecularR = (( this._specularColor >> 16) & 0xff)/0xff*this._specular;\n\t\tthis._iSpecularG = (( this._specularColor >> 8) & 0xff)/0xff*this._specular;\n\t\tthis._iSpecularB = ( this._specularColor & 0xff)/0xff*this._specular;\n\t}\n}\n\nexport = SpecularBasicMethod;",
    "import Stage\t\t\t\t\t\t\t= require(\"awayjs-stagegl/lib/base/Stage\");\n\nimport LightingShader\t\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/LightingShader\");\nimport ShaderBase\t\t\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderBase\");\nimport ShaderRegisterCache\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterCache\");\nimport ShaderRegisterData\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterData\");\nimport ShaderRegisterElement\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterElement\");\n\nimport MethodVO\t\t\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/data/MethodVO\");\nimport SpecularBasicMethod\t\t\t\t= require(\"awayjs-methodmaterials/lib/methods/SpecularBasicMethod\");\nimport SpecularCompositeMethod\t\t\t= require(\"awayjs-methodmaterials/lib/methods/SpecularCompositeMethod\");\n\n/**\n * SpecularCelMethod provides a shading method to add specular cel (cartoon) shading.\n */\nclass SpecularCelMethod extends SpecularCompositeMethod\n{\n\tprivate _dataReg:ShaderRegisterElement;\n\tprivate _smoothness:number = .1;\n\tprivate _specularCutOff:number = .1;\n\n\t/**\n\t * Creates a new SpecularCelMethod object.\n\t * @param specularCutOff The threshold at which the specular highlight should be shown.\n\t * @param baseMethod An optional specular method on which the cartoon shading is based. If ommitted, SpecularBasicMethod is used.\n\t */\n\tconstructor(specularCutOff:number = .5, baseMethod:SpecularBasicMethod = null)\n\t{\n\t\tsuper(null, baseMethod);\n\n\t\tthis.baseMethod._iModulateMethod = (shader:ShaderBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData) => this.clampSpecular(shader, methodVO, targetReg, registerCache, sharedRegisters);\n\n\t\tthis._specularCutOff = specularCutOff;\n\t}\n\n\t/**\n\t * The smoothness of the highlight edge.\n\t */\n\tpublic get smoothness():number\n\t{\n\t\treturn this._smoothness;\n\t}\n\n\tpublic set smoothness(value:number)\n\t{\n\t\tthis._smoothness = value;\n\t}\n\n\t/**\n\t * The threshold at which the specular highlight should be shown.\n\t */\n\tpublic get specularCutOff():number\n\t{\n\t\treturn this._specularCutOff;\n\t}\n\n\tpublic set specularCutOff(value:number)\n\t{\n\t\tthis._specularCutOff = value;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iActivate(shader:LightingShader, methodVO:MethodVO, stage:Stage)\n\t{\n\t\tsuper.iActivate(shader, methodVO, stage);\n\n\t\tvar index:number /*int*/ = methodVO.secondaryFragmentConstantsIndex;\n\t\tvar data:Array<number> = shader.fragmentConstantData;\n\t\tdata[index] = this._smoothness;\n\t\tdata[index + 1] = this._specularCutOff;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iCleanCompilationData()\n\t{\n\t\tsuper.iCleanCompilationData();\n\t\tthis._dataReg = null;\n\t}\n\n\t/**\n\t * Snaps the specular shading strength of the wrapped method to zero or one, depending on whether or not it exceeds the specularCutOff\n\t * @param vo The MethodVO used to compile the current shader.\n\t * @param t The register containing the specular strength in the \"w\" component, and either the half-vector or the reflection vector in \"xyz\".\n\t * @param regCache The register cache used for the shader compilation.\n\t * @param sharedRegisters The shared register data for this shader.\n\t * @return The AGAL fragment code for the method.\n\t */\n\tprivate clampSpecular(shader:ShaderBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\treturn \"sub \" + targetReg + \".y, \" + targetReg + \".w, \" + this._dataReg + \".y\\n\" + // x - cutoff\n\t\t\t\"div \" + targetReg + \".y, \" + targetReg + \".y, \" + this._dataReg + \".x\\n\" + // (x - cutoff)/epsilon\n\t\t\t\"sat \" + targetReg + \".y, \" + targetReg + \".y\\n\" +\n\t\t\t\"sge \" + targetReg + \".w, \" + targetReg + \".w, \" + this._dataReg + \".y\\n\" +\n\t\t\t\"mul \" + targetReg + \".w, \" + targetReg + \".w, \" + targetReg + \".y\\n\";\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentPreLightingCode(shader:LightingShader, methodVO:MethodVO, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tthis._dataReg = registerCache.getFreeFragmentConstant();\n\t\tmethodVO.secondaryFragmentConstantsIndex = this._dataReg.index*4;\n\n\t\treturn super.iGetFragmentPreLightingCode(shader, methodVO, registerCache, sharedRegisters);\n\t}\n}\n\nexport = SpecularCelMethod;",
    "import Camera\t\t\t\t\t\t\t= require(\"awayjs-display/lib/entities/Camera\");\nimport TextureBase\t\t\t\t\t\t= require(\"awayjs-display/lib/textures/TextureBase\");\n\nimport Stage\t\t\t\t\t\t\t= require(\"awayjs-stagegl/lib/base/Stage\");\n\nimport RenderableBase\t\t\t\t\t= require(\"awayjs-renderergl/lib/renderables/RenderableBase\");\nimport ShadingMethodEvent\t\t\t\t= require(\"awayjs-renderergl/lib/events/ShadingMethodEvent\");\nimport LightingShader\t\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/LightingShader\");\nimport ShaderBase\t\t\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderBase\");\nimport ShaderRegisterCache\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterCache\");\nimport ShaderRegisterData\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterData\");\nimport ShaderRegisterElement\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterElement\");\n\nimport MethodVO\t\t\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/data/MethodVO\");\nimport SpecularBasicMethod\t\t\t\t= require(\"awayjs-methodmaterials/lib/methods/SpecularBasicMethod\");\n\n/**\n * SpecularCompositeMethod provides a base class for specular methods that wrap a specular method to alter the\n * calculated specular reflection strength.\n */\nclass SpecularCompositeMethod extends SpecularBasicMethod\n{\n\tprivate _baseMethod:SpecularBasicMethod;\n\n\tprivate _onShaderInvalidatedDelegate:Function;\n\n\t/**\n\t * Creates a new <code>SpecularCompositeMethod</code> object.\n\t *\n\t * @param modulateMethod The method which will add the code to alter the base method's strength. It needs to have the signature modSpecular(t:ShaderRegisterElement, regCache:ShaderRegisterCache):string, in which t.w will contain the specular strength and t.xyz will contain the half-vector or the reflection vector.\n\t * @param baseMethod The base specular method on which this method's shading is based.\n\t */\n\tconstructor(modulateMethod:(shader:ShaderBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData) => string, baseMethod:SpecularBasicMethod = null)\n\t{\n\t\tsuper();\n\n\t\tthis._onShaderInvalidatedDelegate = (event:ShadingMethodEvent) => this.onShaderInvalidated(event);\n\n\t\tthis._baseMethod = baseMethod || new SpecularBasicMethod();\n\t\tthis._baseMethod._iModulateMethod = modulateMethod;\n\t\tthis._baseMethod.addEventListener(ShadingMethodEvent.SHADER_INVALIDATED, this._onShaderInvalidatedDelegate);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitVO(shader:LightingShader, methodVO:MethodVO)\n\t{\n\t\tthis._baseMethod.iInitVO(shader, methodVO);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitConstants(shader:ShaderBase, methodVO:MethodVO)\n\t{\n\t\tthis._baseMethod.iInitConstants(shader, methodVO);\n\t}\n\n\t/**\n\t * The base specular method on which this method's shading is based.\n\t */\n\tpublic get baseMethod():SpecularBasicMethod\n\t{\n\t\treturn this._baseMethod;\n\t}\n\n\tpublic set baseMethod(value:SpecularBasicMethod)\n\t{\n\t\tif (this._baseMethod == value)\n\t\t\treturn;\n\n\t\tthis._baseMethod.removeEventListener(ShadingMethodEvent.SHADER_INVALIDATED, this._onShaderInvalidatedDelegate);\n\n\t\tthis._baseMethod = value;\n\n\t\tthis._baseMethod.addEventListener(ShadingMethodEvent.SHADER_INVALIDATED, this._onShaderInvalidatedDelegate);\n\n\t\tthis.iInvalidateShaderProgram();\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic get gloss():number\n\t{\n\t\treturn this._baseMethod.gloss;\n\t}\n\n\tpublic set gloss(value:number)\n\t{\n\t\tthis._baseMethod.gloss = value;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic get specular():number\n\t{\n\t\treturn this._baseMethod.specular;\n\t}\n\n\tpublic set specular(value:number)\n\t{\n\t\tthis._baseMethod.specular = value;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic dispose()\n\t{\n\t\tthis._baseMethod.removeEventListener(ShadingMethodEvent.SHADER_INVALIDATED, this._onShaderInvalidatedDelegate);\n\t\tthis._baseMethod.dispose();\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic get texture():TextureBase\n\t{\n\t\treturn this._baseMethod.texture;\n\t}\n\n\tpublic set texture(value:TextureBase)\n\t{\n\t\tthis._baseMethod.texture = value;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iActivate(shader:LightingShader, methodVO:MethodVO, stage:Stage)\n\t{\n\t\tthis._baseMethod.iActivate(shader, methodVO, stage);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iSetRenderState(shader:LightingShader, methodVO:MethodVO, renderable:RenderableBase, stage:Stage, camera:Camera)\n\t{\n\t\tthis._baseMethod.iSetRenderState(shader, methodVO, renderable, stage, camera);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iDeactivate(shader:ShaderBase, methodVO:MethodVO, stage:Stage)\n\t{\n\t\tthis._baseMethod.iDeactivate(shader, methodVO, stage);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetVertexCode(shader:ShaderBase, methodVO:MethodVO, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\treturn this._baseMethod.iGetVertexCode(shader, methodVO, registerCache, sharedRegisters);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentPreLightingCode(shader:LightingShader, methodVO:MethodVO, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\treturn this._baseMethod.iGetFragmentPreLightingCode(shader, methodVO, registerCache, sharedRegisters);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentCodePerLight(shader:LightingShader, methodVO:MethodVO, lightDirReg:ShaderRegisterElement, lightColReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\treturn this._baseMethod.iGetFragmentCodePerLight(shader, methodVO, lightDirReg, lightColReg, registerCache, sharedRegisters);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t * @return\n\t */\n\tpublic iGetFragmentCodePerProbe(shader:LightingShader, methodVO:MethodVO, cubeMapReg:ShaderRegisterElement, weightRegister:string, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\treturn this._baseMethod.iGetFragmentCodePerProbe(shader, methodVO, cubeMapReg, weightRegister, registerCache, sharedRegisters);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentPostLightingCode(shader:LightingShader, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\treturn this._baseMethod.iGetFragmentPostLightingCode(shader, methodVO, targetReg, registerCache, sharedRegisters);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iReset()\n\t{\n\t\tthis._baseMethod.iReset();\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iCleanCompilationData()\n\t{\n\t\tsuper.iCleanCompilationData();\n\t\tthis._baseMethod.iCleanCompilationData();\n\t}\n\n\t/**\n\t * Called when the base method's shader code is invalidated.\n\t */\n\tprivate onShaderInvalidated(event:ShadingMethodEvent)\n\t{\n\t\tthis.iInvalidateShaderProgram();\n\t}\n}\n\nexport = SpecularCompositeMethod;",
    "import Camera\t\t\t\t\t\t\t= require(\"awayjs-display/lib/entities/Camera\");\n\nimport Stage\t\t\t\t\t\t\t= require(\"awayjs-stagegl/lib/base/Stage\");\n\nimport LightingShader\t\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/LightingShader\");\nimport ShaderBase\t\t\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderBase\");\nimport ShaderRegisterCache\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterCache\");\nimport ShaderRegisterData\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterData\");\nimport ShaderRegisterElement\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterElement\");\n\nimport MethodVO\t\t\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/data/MethodVO\");\nimport SpecularBasicMethod\t\t\t\t= require(\"awayjs-methodmaterials/lib/methods/SpecularBasicMethod\");\nimport SpecularCompositeMethod\t\t\t= require(\"awayjs-methodmaterials/lib/methods/SpecularCompositeMethod\");\n\n/**\n * SpecularFresnelMethod provides a specular shading method that causes stronger highlights on grazing view angles.\n */\nclass SpecularFresnelMethod extends SpecularCompositeMethod\n{\n\tprivate _dataReg:ShaderRegisterElement;\n\tprivate _incidentLight:boolean;\n\tprivate _fresnelPower:number = 5;\n\tprivate _normalReflectance:number = .028; // default value for skin\n\n\t/**\n\t * Creates a new SpecularFresnelMethod object.\n\t * @param basedOnSurface Defines whether the fresnel effect should be based on the view angle on the surface (if true), or on the angle between the light and the view.\n\t * @param baseMethod The specular method to which the fresnel equation. Defaults to SpecularBasicMethod.\n\t */\n\tconstructor(basedOnSurface:boolean = true, baseMethod:SpecularBasicMethod = null)\n\t{\n\t\t// may want to offer diff speculars\n\t\tsuper(null, baseMethod);\n\n\t\tthis.baseMethod._iModulateMethod = (shader:ShaderBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData) => this.modulateSpecular(shader, methodVO, targetReg, registerCache, sharedRegisters);\n\n\t\tthis._incidentLight = !basedOnSurface;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitConstants(shader:ShaderBase, methodVO:MethodVO)\n\t{\n\n\t\tvar index:number = methodVO.secondaryFragmentConstantsIndex;\n\t\tshader.fragmentConstantData[index + 2] = 1;\n\t\tshader.fragmentConstantData[index + 3] = 0;\n\t}\n\n\t/**\n\t * Defines whether the fresnel effect should be based on the view angle on the surface (if true), or on the angle between the light and the view.\n\t */\n\tpublic get basedOnSurface():boolean\n\t{\n\t\treturn !this._incidentLight;\n\t}\n\n\tpublic set basedOnSurface(value:boolean)\n\t{\n\t\tif (this._incidentLight != value)\n\t\t\treturn;\n\n\t\tthis._incidentLight = !value;\n\n\t\tthis.iInvalidateShaderProgram();\n\t}\n\n\t/**\n\t * The power used in the Fresnel equation. Higher values make the fresnel effect more pronounced. Defaults to 5.\n\t */\n\tpublic get fresnelPower():number\n\t{\n\t\treturn this._fresnelPower;\n\t}\n\n\tpublic set fresnelPower(value:number)\n\t{\n\t\tthis._fresnelPower = value;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iCleanCompilationData()\n\t{\n\t\tsuper.iCleanCompilationData();\n\t\tthis._dataReg = null;\n\t}\n\n\t/**\n\t * The minimum amount of reflectance, ie the reflectance when the view direction is normal to the surface or light direction.\n\t */\n\tpublic get normalReflectance():number\n\t{\n\t\treturn this._normalReflectance;\n\t}\n\n\tpublic set normalReflectance(value:number)\n\t{\n\t\tthis._normalReflectance = value;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iActivate(shader:LightingShader, methodVO:MethodVO, stage:Stage)\n\t{\n\t\tsuper.iActivate(shader, methodVO, stage);\n\n\t\tvar fragmentData:Array<number> = shader.fragmentConstantData;\n\n\t\tvar index:number = methodVO.secondaryFragmentConstantsIndex;\n\t\tfragmentData[index] = this._normalReflectance;\n\t\tfragmentData[index + 1] = this._fresnelPower;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentPreLightingCode(shader:LightingShader, methodVO:MethodVO, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tthis._dataReg = registerCache.getFreeFragmentConstant();\n\n\t\tmethodVO.secondaryFragmentConstantsIndex = this._dataReg.index*4;\n\n\t\treturn super.iGetFragmentPreLightingCode(shader, methodVO, registerCache, sharedRegisters);\n\t}\n\n\t/**\n\t * Applies the fresnel effect to the specular strength.\n\t *\n\t * @param vo The MethodVO object containing the method data for the currently compiled material pass.\n\t * @param target The register containing the specular strength in the \"w\" component, and the half-vector/reflection vector in \"xyz\".\n\t * @param regCache The register cache used for the shader compilation.\n\t * @param sharedRegisters The shared registers created by the compiler.\n\t * @return The AGAL fragment code for the method.\n\t */\n\tprivate modulateSpecular(shader:ShaderBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string;\n\n\t\tcode = \"dp3 \" + targetReg + \".y, \" + sharedRegisters.viewDirFragment + \".xyz, \" + (this._incidentLight? targetReg : sharedRegisters.normalFragment) + \".xyz\\n\" +   // dot(V, H)\n\t\t\t\"sub \" + targetReg + \".y, \" + this._dataReg + \".z, \" + targetReg + \".y\\n\" +             // base = 1-dot(V, H)\n\t\t\t\"pow \" + targetReg + \".x, \" + targetReg + \".y, \" + this._dataReg + \".y\\n\" +             // exp = pow(base, 5)\n\t\t\t\"sub \" + targetReg + \".y, \" + this._dataReg + \".z, \" + targetReg + \".y\\n\" +             // 1 - exp\n\t\t\t\"mul \" + targetReg + \".y, \" + this._dataReg + \".x, \" + targetReg + \".y\\n\" +             // f0*(1 - exp)\n\t\t\t\"add \" + targetReg + \".y, \" + targetReg + \".x, \" + targetReg + \".y\\n\" +          // exp + f0*(1 - exp)\n\t\t\t\"mul \" + targetReg + \".w, \" + targetReg + \".w, \" + targetReg + \".y\\n\";\n\n\t\treturn code;\n\t}\n\n}\n\nexport = SpecularFresnelMethod;",
    "import LightingShader\t\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/LightingShader\");\nimport ShaderRegisterCache\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterCache\");\nimport ShaderRegisterData\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterData\");\nimport ShaderRegisterElement\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterElement\");\n\nimport MethodVO\t\t\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/data/MethodVO\");\nimport SpecularBasicMethod\t\t\t\t= require(\"awayjs-methodmaterials/lib/methods/SpecularBasicMethod\");\n\n/**\n * SpecularPhongMethod provides a specular method that provides Phong highlights.\n */\nclass SpecularPhongMethod extends SpecularBasicMethod\n{\n\t/**\n\t * Creates a new SpecularPhongMethod object.\n\t */\n\tconstructor()\n\t{\n\t\tsuper();\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentCodePerLight(shader:LightingShader, methodVO:MethodVO, lightDirReg:ShaderRegisterElement, lightColReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = \"\";\n\t\tvar t:ShaderRegisterElement;\n\n\t\tif (this._pIsFirstLight) {\n\t\t\tt = this._pTotalLightColorReg;\n\t\t} else {\n\t\t\tt = registerCache.getFreeFragmentVectorTemp();\n\t\t\tregisterCache.addFragmentTempUsages(t, 1);\n\t\t}\n\n\t\tvar viewDirReg:ShaderRegisterElement =sharedRegisters.viewDirFragment;\n\t\tvar normalReg:ShaderRegisterElement =sharedRegisters.normalFragment;\n\n\t\t// phong model\n\t\tcode += \"dp3 \" + t + \".w, \" + lightDirReg + \", \" + normalReg + \"\\n\" + // sca1 = light.normal\n\n\t\t\t//find the reflected light vector R\n\t\t\t\"add \" + t + \".w, \" + t + \".w, \" + t + \".w\\n\" + // sca1 = sca1*2\n\t\t\t\"mul \" + t + \".xyz, \" + normalReg + \", \" + t + \".w\\n\" + // vec1 = normal*sca1\n\t\t\t\"sub \" + t + \".xyz, \" + t + \", \" + lightDirReg + \"\\n\" + // vec1 = vec1 - light (light vector is negative)\n\n\t\t\t//smooth the edge as incidence angle approaches 90\n\t\t\t\"add \" + t + \".w, \" + t + \".w, \" +sharedRegisters.commons + \".w\\n\" + // sca1 = sca1 + smoothtep;\n\t\t\t\"sat \" + t + \".w, \" + t + \".w\\n\" + // sca1 range 0 - 1\n\t\t\t\"mul \" + t + \".xyz, \" + t + \", \" + t + \".w\\n\" + // vec1 = vec1*sca1\n\n\t\t\t//find the dot product between R and V\n\t\t\t\"dp3 \" + t + \".w, \" + t + \", \" + viewDirReg + \"\\n\" + // sca1 = vec1.view\n\t\t\t\"sat \" + t + \".w, \" + t + \".w\\n\";\n\n\t\tif (this.texture) {\n\t\t\t// apply gloss modulation from texture\n\t\t\tcode += \"mul \" + this._pSpecularTexData + \".w, \" + this._pSpecularTexData + \".y, \" + this._pSpecularDataRegister + \".w\\n\" +\n\t\t\t\t\"pow \" + t + \".w, \" + t + \".w, \" + this._pSpecularTexData + \".w\\n\";\n\t\t} else\n\t\t\tcode += \"pow \" + t + \".w, \" + t + \".w, \" + this._pSpecularDataRegister + \".w\\n\";\n\n\t\t// attenuate\n\t\tif (shader.usesLightFallOff)\n\t\t\tcode += \"mul \" + t + \".w, \" + t + \".w, \" + lightDirReg + \".w\\n\";\n\n\t\tif (this._iModulateMethod != null)\n\t\t\tcode += this._iModulateMethod(shader, methodVO, t, registerCache, sharedRegisters);\n\n\t\tcode += \"mul \" + t + \".xyz, \" + lightColReg + \".xyz, \" + t + \".w\\n\";\n\n\t\tif (!this._pIsFirstLight) {\n\t\t\tcode += \"add \" + this._pTotalLightColorReg + \".xyz, \" + this._pTotalLightColorReg + \".xyz, \" + t + \".xyz\\n\";\n\t\t\tregisterCache.removeFragmentTempUsage(t);\n\t\t}\n\n\t\tthis._pIsFirstLight = false;\n\n\t\treturn code;\n\t}\n}\n\nexport = SpecularPhongMethod;",
    "import BlendMode\t\t\t\t\t\t= require(\"awayjs-core/lib/data/BlendMode\");\nimport TriangleSubGeometry\t\t\t\t= require(\"awayjs-core/lib/data/TriangleSubGeometry\");\nimport ColorTransform\t\t\t\t\t= require(\"awayjs-core/lib/geom/ColorTransform\");\nimport Matrix\t\t\t\t\t\t\t= require(\"awayjs-core/lib/geom/Matrix\");\nimport Matrix3D\t\t\t\t\t\t\t= require(\"awayjs-core/lib/geom/Matrix3D\");\nimport Matrix3DUtils\t\t\t\t\t= require(\"awayjs-core/lib/geom/Matrix3DUtils\");\nimport Vector3D\t\t\t\t\t\t\t= require(\"awayjs-core/lib/geom/Vector3D\");\nimport AbstractMethodError\t\t\t\t= require(\"awayjs-core/lib/errors/AbstractMethodError\");\n\n\nimport Camera\t\t\t\t\t\t\t= require(\"awayjs-display/lib/entities/Camera\");\nimport IRenderOwner\t\t\t\t= require(\"awayjs-display/lib/base/IRenderOwner\");\nimport StaticLightPicker\t\t\t\t= require(\"awayjs-display/lib/materials/lightpickers/StaticLightPicker\");\n\nimport Stage\t\t\t\t\t\t\t= require(\"awayjs-stagegl/lib/base/Stage\");\nimport ContextGLCompareMode\t\t\t\t= require(\"awayjs-stagegl/lib/base/ContextGLCompareMode\");\n\nimport RendererBase\t\t\t\t\t\t= require(\"awayjs-renderergl/lib/RendererBase\");\nimport ShaderBase\t\t\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderBase\");\nimport ShadingMethodEvent\t\t\t\t= require(\"awayjs-renderergl/lib/events/ShadingMethodEvent\");\nimport RenderableBase\t\t\t\t\t= require(\"awayjs-renderergl/lib/renderables/RenderableBase\");\nimport IRenderableClass\t\t\t\t\t= require(\"awayjs-renderergl/lib/renderables/IRenderableClass\");\nimport RenderBase\t\t\t\t\t\t= require(\"awayjs-renderergl/lib/render/RenderBase\");\nimport RenderPool\t\t\t\t\t\t= require(\"awayjs-renderergl/lib/render/RenderPool\");\n\nimport MethodMaterial\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/MethodMaterial\");\nimport MethodMaterialMode\t\t\t\t= require(\"awayjs-methodmaterials/lib/MethodMaterialMode\");\nimport MethodPassMode\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/render/passes/MethodPassMode\");\nimport MethodPass\t\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/render/passes/MethodPass\");\nimport AmbientBasicMethod\t\t\t\t= require(\"awayjs-methodmaterials/lib/methods/AmbientBasicMethod\");\nimport DiffuseBasicMethod\t\t\t\t= require(\"awayjs-methodmaterials/lib/methods/DiffuseBasicMethod\");\nimport EffectColorTransformMethod\t\t= require(\"awayjs-methodmaterials/lib/methods/EffectColorTransformMethod\");\nimport EffectMethodBase\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/methods/EffectMethodBase\");\nimport LightingMethodBase\t\t\t\t= require(\"awayjs-methodmaterials/lib/methods/LightingMethodBase\");\nimport NormalBasicMethod\t\t\t\t= require(\"awayjs-methodmaterials/lib/methods/NormalBasicMethod\");\nimport ShadowMapMethodBase\t\t\t\t= require(\"awayjs-methodmaterials/lib/methods/ShadowMapMethodBase\");\nimport SpecularBasicMethod\t\t\t\t= require(\"awayjs-methodmaterials/lib/methods/SpecularBasicMethod\");\n\n/**\n * CompiledPass forms an abstract base class for the default compiled pass materials provided by Away3D,\n * using material methods to define their appearance.\n */\nclass MethodMaterialRender extends RenderBase\n{\n\tprivate _material:MethodMaterial;\n\tprivate _pass:MethodPass;\n\tprivate _casterLightPass:MethodPass;\n\tprivate _nonCasterLightPasses:Array<MethodPass>;\n\t\n\t/**\n\t * The maximum total number of lights provided by the light picker.\n\t */\n\tprivate get numLights():number\n\t{\n\t\treturn this._material.lightPicker? this._material.lightPicker.numLightProbes + this._material.lightPicker.numDirectionalLights + this._material.lightPicker.numPointLights + this._material.lightPicker.numCastingDirectionalLights + this._material.lightPicker.numCastingPointLights : 0;\n\t}\n\n\t/**\n\t * The amount of lights that don't cast shadows.\n\t */\n\tprivate get numNonCasters():number\n\t{\n\t\treturn this._material.lightPicker? this._material.lightPicker.numLightProbes + this._material.lightPicker.numDirectionalLights + this._material.lightPicker.numPointLights : 0;\n\t}\n\n\t/**\n\t * Creates a new CompiledPass object.\n\t *\n\t * @param material The material to which this pass belongs.\n\t */\n\tconstructor(pool:RenderPool, material:MethodMaterial, renderableClass:IRenderableClass, stage:Stage)\n\t{\n\t\tsuper(pool, material, renderableClass, stage);\n\n\t\tthis._material = material;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic _pUpdateRender()\n\t{\n\t\tsuper._pUpdateRender();\n\n\t\tthis.initPasses();\n\n\t\tthis.setBlendAndCompareModes();\n\n\t\tthis._pClearPasses();\n\n\t\tif (this._material.mode == MethodMaterialMode.MULTI_PASS) {\n\t\t\tif (this._casterLightPass)\n\t\t\t\tthis._pAddPass(this._casterLightPass);\n\n\t\t\tif (this._nonCasterLightPasses)\n\t\t\t\tfor (var i:number = 0; i < this._nonCasterLightPasses.length; ++i)\n\t\t\t\t\tthis._pAddPass(this._nonCasterLightPasses[i]);\n\t\t}\n\n\t\tif (this._pass)\n\t\t\tthis._pAddPass(this._pass);\n\t}\n\n\t/**\n\t * Initializes all the passes and their dependent passes.\n\t */\n\tprivate initPasses()\n\t{\n\t\t// let the effects pass handle everything if there are no lights, when there are effect methods applied\n\t\t// after shading, or when the material mode is single pass.\n\t\tif (this.numLights == 0 || this._material.numEffectMethods > 0 || this._material.mode == MethodMaterialMode.SINGLE_PASS)\n\t\t\tthis.initEffectPass();\n\t\telse if (this._pass)\n\t\t\tthis.removeEffectPass();\n\n\t\t// only use a caster light pass if shadows need to be rendered\n\t\tif (this._material.shadowMethod && this._material.mode == MethodMaterialMode.MULTI_PASS)\n\t\t\tthis.initCasterLightPass();\n\t\telse if (this._casterLightPass)\n\t\t\tthis.removeCasterLightPass();\n\n\t\t// only use non caster light passes if there are lights that don't cast\n\t\tif (this.numNonCasters > 0 && this._material.mode == MethodMaterialMode.MULTI_PASS)\n\t\t\tthis.initNonCasterLightPasses();\n\t\telse if (this._nonCasterLightPasses)\n\t\t\tthis.removeNonCasterLightPasses();\n\t}\n\n\t/**\n\t * Sets up the various blending modes for all screen passes, based on whether or not there are previous passes.\n\t */\n\tprivate setBlendAndCompareModes()\n\t{\n\t\tvar forceSeparateMVP:boolean = Boolean(this._casterLightPass || this._pass);\n\n\t\t// caster light pass is always first if it exists, hence it uses normal blending\n\t\tif (this._casterLightPass) {\n\t\t\tthis._casterLightPass.forceSeparateMVP = forceSeparateMVP;\n\t\t\tthis._casterLightPass.shader.setBlendMode(BlendMode.NORMAL);\n\t\t\tthis._casterLightPass.shader.depthCompareMode = this._material.depthCompareMode;\n\t\t}\n\n\t\tif (this._nonCasterLightPasses) {\n\t\t\tvar firstAdditiveIndex:number = 0;\n\n\t\t\t// if there's no caster light pass, the first non caster light pass will be the first\n\t\t\t// and should use normal blending\n\t\t\tif (!this._casterLightPass) {\n\t\t\t\tthis._nonCasterLightPasses[0].forceSeparateMVP = forceSeparateMVP;\n\t\t\t\tthis._nonCasterLightPasses[0].shader.setBlendMode(BlendMode.NORMAL);\n\t\t\t\tthis._nonCasterLightPasses[0].shader.depthCompareMode = this._material.depthCompareMode;\n\t\t\t\tfirstAdditiveIndex = 1;\n\t\t\t}\n\n\t\t\t// all lighting passes following the first light pass should use additive blending\n\t\t\tfor (var i:number = firstAdditiveIndex; i < this._nonCasterLightPasses.length; ++i) {\n\t\t\t\tthis._nonCasterLightPasses[i].forceSeparateMVP = forceSeparateMVP;\n\t\t\t\tthis._nonCasterLightPasses[i].shader.setBlendMode(BlendMode.ADD);\n\t\t\t\tthis._nonCasterLightPasses[i].shader.depthCompareMode = ContextGLCompareMode.LESS_EQUAL;\n\t\t\t}\n\t\t}\n\n\t\tif (this._casterLightPass || this._nonCasterLightPasses) {\n\t\t\t//cannot be blended by blendmode property if multipass enabled\n\t\t\tthis._pRequiresBlending = false;\n\n\t\t\t// there are light passes, so this should be blended in\n\t\t\tif (this._pass) {\n\t\t\t\tthis._pass.mode = MethodPassMode.EFFECTS;\n\t\t\t\tthis._pass.forceSeparateMVP = forceSeparateMVP;\n\t\t\t\tthis._pass.shader.depthCompareMode = ContextGLCompareMode.LESS_EQUAL;\n\t\t\t\tthis._pass.shader.setBlendMode(BlendMode.LAYER);\n\t\t\t}\n\n\t\t} else if (this._pass) {\n\t\t\tthis._pRequiresBlending = (this._material.blendMode != BlendMode.NORMAL || this._material.alphaBlending || (this._material.colorTransform && this._material.colorTransform.alphaMultiplier < 1));\n\t\t\t// effects pass is the only pass, so it should just blend normally\n\t\t\tthis._pass.mode = MethodPassMode.SUPER_SHADER;\n\t\t\tthis._pass.preserveAlpha = this._pRequiresBlending;\n\t\t\tthis._pass.forceSeparateMVP = false;\n\t\t\tthis._pass.colorTransform = this._material.colorTransform;\n\t\t\tthis._pass.shader.setBlendMode((this._material.blendMode == BlendMode.NORMAL && this._pRequiresBlending)? BlendMode.LAYER : this._material.blendMode);\n\t\t\tthis._pass.shader.depthCompareMode = this._material.depthCompareMode;\n\t\t}\n\t}\n\n\tprivate initCasterLightPass()\n\t{\n\n\t\tif (this._casterLightPass == null)\n\t\t\tthis._casterLightPass = new MethodPass(MethodPassMode.LIGHTING, this, this._material, this._renderableClass, this._stage);\n\n\t\tthis._casterLightPass.lightPicker = new StaticLightPicker([this._material.shadowMethod.castingLight]);\n\t\tthis._casterLightPass.shadowMethod = this._material.shadowMethod;\n\t\tthis._casterLightPass.diffuseMethod = this._material.diffuseMethod;\n\t\tthis._casterLightPass.ambientMethod = this._material.ambientMethod;\n\t\tthis._casterLightPass.normalMethod = this._material.normalMethod;\n\t\tthis._casterLightPass.specularMethod = this._material.specularMethod;\n\t}\n\n\tprivate removeCasterLightPass()\n\t{\n\t\tthis._casterLightPass.dispose();\n\t\tthis._pRemovePass(this._casterLightPass);\n\t\tthis._casterLightPass = null;\n\t}\n\n\tprivate initNonCasterLightPasses()\n\t{\n\t\tthis.removeNonCasterLightPasses();\n\t\tvar pass:MethodPass;\n\t\tvar numDirLights:number = this._material.lightPicker.numDirectionalLights;\n\t\tvar numPointLights:number = this._material.lightPicker.numPointLights;\n\t\tvar numLightProbes:number = this._material.lightPicker.numLightProbes;\n\t\tvar dirLightOffset:number = 0;\n\t\tvar pointLightOffset:number = 0;\n\t\tvar probeOffset:number = 0;\n\n\t\tif (!this._casterLightPass) {\n\t\t\tnumDirLights += this._material.lightPicker.numCastingDirectionalLights;\n\t\t\tnumPointLights += this._material.lightPicker.numCastingPointLights;\n\t\t}\n\n\t\tthis._nonCasterLightPasses = new Array<MethodPass>();\n\n\t\twhile (dirLightOffset < numDirLights || pointLightOffset < numPointLights || probeOffset < numLightProbes) {\n\t\t\tpass = new MethodPass(MethodPassMode.LIGHTING, this, this._material, this._renderableClass, this._stage);\n\t\t\tpass.includeCasters = this._material.shadowMethod == null;\n\t\t\tpass.directionalLightsOffset = dirLightOffset;\n\t\t\tpass.pointLightsOffset = pointLightOffset;\n\t\t\tpass.lightProbesOffset = probeOffset;\n\t\t\tpass.lightPicker = this._material.lightPicker;\n\t\t\tpass.diffuseMethod = this._material.diffuseMethod;\n\t\t\tpass.ambientMethod = this._material.ambientMethod;\n\t\t\tpass.normalMethod = this._material.normalMethod;\n\t\t\tpass.specularMethod = this._material.specularMethod;\n\t\t\tthis._nonCasterLightPasses.push(pass);\n\n\t\t\tdirLightOffset += pass.numDirectionalLights;\n\t\t\tpointLightOffset += pass.numPointLights;\n\t\t\tprobeOffset += pass.numLightProbes;\n\t\t}\n\t}\n\n\tprivate removeNonCasterLightPasses()\n\t{\n\t\tif (!this._nonCasterLightPasses)\n\t\t\treturn;\n\n\t\tfor (var i:number = 0; i < this._nonCasterLightPasses.length; ++i)\n\t\t\tthis._pRemovePass(this._nonCasterLightPasses[i]);\n\n\t\tthis._nonCasterLightPasses = null;\n\t}\n\n\tprivate removeEffectPass()\n\t{\n\t\tif (this._pass.ambientMethod != this._material.ambientMethod)\n\t\t\tthis._pass.ambientMethod.dispose();\n\n\t\tif (this._pass.diffuseMethod != this._material.diffuseMethod)\n\t\t\tthis._pass.diffuseMethod.dispose();\n\n\t\tif (this._pass.specularMethod != this._material.specularMethod)\n\t\t\tthis._pass.specularMethod.dispose();\n\n\t\tif (this._pass.normalMethod != this._material.normalMethod)\n\t\t\tthis._pass.normalMethod.dispose();\n\n\t\tthis._pRemovePass(this._pass);\n\t\tthis._pass = null;\n\t}\n\n\tprivate initEffectPass()\n\t{\n\t\tif (this._pass == null)\n\t\t\tthis._pass = new MethodPass(MethodPassMode.SUPER_SHADER, this, this._material, this._renderableClass, this._stage);\n\n\t\tif (this._material.mode == MethodMaterialMode.SINGLE_PASS) {\n\t\t\tthis._pass.ambientMethod = this._material.ambientMethod;\n\t\t\tthis._pass.diffuseMethod = this._material.diffuseMethod;\n\t\t\tthis._pass.specularMethod = this._material.specularMethod;\n\t\t\tthis._pass.normalMethod = this._material.normalMethod;\n\t\t\tthis._pass.shadowMethod = this._material.shadowMethod;\n\t\t} else if (this._material.mode == MethodMaterialMode.MULTI_PASS) {\n\t\t\tif (this.numLights == 0) {\n\t\t\t\tthis._pass.ambientMethod = this._material.ambientMethod;\n\t\t\t} else {\n\t\t\t\tthis._pass.ambientMethod = null;\n\t\t\t}\n\n\t\t\tthis._pass.preserveAlpha = false;\n\t\t\tthis._pass.normalMethod = this._material.normalMethod;\n\t\t}\n\n\t\t//update effect methods\n\t\tvar i:number = 0;\n\t\tvar effectMethod:EffectMethodBase;\n\t\tvar len:number = Math.max(this._material.numEffectMethods, this._pass.numEffectMethods);\n\n\t\twhile (i < len) {\n\t\t\teffectMethod = this._material.getEffectMethodAt(i);\n\t\t\tif (effectMethod != this._pass.getEffectMethodAt(i)) {\n\t\t\t\tthis._pass.removeEffectMethodAt(i);\n\n\t\t\t\tif (effectMethod != null) {\n\t\t\t\t\tif (i < this._pass.numEffectMethods)\n\t\t\t\t\t\tthis._pass.addEffectMethodAt(effectMethod, i);\n\t\t\t\t\telse\n\t\t\t\t\t\tthis._pass.addEffectMethod(effectMethod);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\ti++;\n\t\t}\n\t}\n\t\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic dispose()\n\t{\n\t\tsuper.dispose();\n\n\t\t//TODO\n\t}\n}\n\nexport = MethodMaterialRender;",
    "class PassMode\n{\n\t/**\n\t *\n\t */\n\tpublic static EFFECTS:number = 0x01;\n\n\t/**\n\t *\n\t */\n\tpublic static LIGHTING:number = 0x02;\n\n\t/**\n\t *\n\t */\n\tpublic static SUPER_SHADER:number = 0x03;\n}\n\nexport = PassMode;",
    "import TriangleSubGeometry\t\t\t\t= require(\"awayjs-core/lib/data/TriangleSubGeometry\");\nimport ColorTransform\t\t\t\t\t= require(\"awayjs-core/lib/geom/ColorTransform\");\nimport Matrix\t\t\t\t\t\t\t= require(\"awayjs-core/lib/geom/Matrix\");\nimport Matrix3D\t\t\t\t\t\t\t= require(\"awayjs-core/lib/geom/Matrix3D\");\nimport Matrix3DUtils\t\t\t\t\t= require(\"awayjs-core/lib/geom/Matrix3DUtils\");\nimport Vector3D\t\t\t\t\t\t\t= require(\"awayjs-core/lib/geom/Vector3D\");\nimport AbstractMethodError\t\t\t\t= require(\"awayjs-core/lib/errors/AbstractMethodError\");\nimport Event\t\t\t\t\t\t\t= require(\"awayjs-core/lib/events/Event\");\nimport MaterialBase\t\t\t\t\t\t= require(\"awayjs-display/lib/materials/MaterialBase\");\n\nimport Camera\t\t\t\t\t\t\t= require(\"awayjs-display/lib/entities/Camera\");\nimport IRenderOwner\t\t\t\t\t\t= require(\"awayjs-display/lib/base/IRenderOwner\");\nimport LightPickerBase\t\t\t\t\t= require(\"awayjs-display/lib/materials/lightpickers/LightPickerBase\");\nimport LightSources\t\t\t\t\t\t= require(\"awayjs-display/lib/materials/LightSources\");\n\nimport Stage\t\t\t\t\t\t\t= require(\"awayjs-stagegl/lib/base/Stage\");\n\nimport RendererBase\t\t\t\t\t\t= require(\"awayjs-renderergl/lib/RendererBase\");\nimport LightingShader\t\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/LightingShader\");\nimport ShadingMethodEvent\t\t\t\t= require(\"awayjs-renderergl/lib/events/ShadingMethodEvent\");\nimport ShaderBase\t\t\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderBase\");\nimport ShaderRegisterCache\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterCache\");\nimport ShaderRegisterData\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterData\");\nimport ShaderRegisterElement\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterElement\");\nimport RenderableBase\t\t\t\t\t= require(\"awayjs-renderergl/lib/renderables/RenderableBase\");\nimport PassBase\t\t\t\t\t\t\t= require(\"awayjs-renderergl/lib/render/passes/PassBase\");\nimport ILightingPass\t\t\t\t\t= require(\"awayjs-renderergl/lib/render/passes/ILightingPass\");\nimport IRenderableClass\t\t\t\t\t= require(\"awayjs-renderergl/lib/renderables/IRenderableClass\");\n\nimport MethodVO\t\t\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/data/MethodVO\");\nimport AmbientBasicMethod\t\t\t\t= require(\"awayjs-methodmaterials/lib/methods/AmbientBasicMethod\");\nimport DiffuseBasicMethod\t\t\t\t= require(\"awayjs-methodmaterials/lib/methods/DiffuseBasicMethod\");\nimport EffectColorTransformMethod\t\t= require(\"awayjs-methodmaterials/lib/methods/EffectColorTransformMethod\");\nimport EffectMethodBase\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/methods/EffectMethodBase\");\nimport LightingMethodBase\t\t\t\t= require(\"awayjs-methodmaterials/lib/methods/LightingMethodBase\");\nimport NormalBasicMethod\t\t\t\t= require(\"awayjs-methodmaterials/lib/methods/NormalBasicMethod\");\nimport ShadowMapMethodBase\t\t\t\t= require(\"awayjs-methodmaterials/lib/methods/ShadowMapMethodBase\");\nimport SpecularBasicMethod\t\t\t\t= require(\"awayjs-methodmaterials/lib/methods/SpecularBasicMethod\");\nimport MethodPassMode\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/render/passes/MethodPassMode\");\nimport MethodMaterialRender\t\t\t\t= require(\"awayjs-methodmaterials/lib/render/MethodMaterialRender\");\n\n/**\n * CompiledPass forms an abstract base class for the default compiled pass materials provided by Away3D,\n * using material methods to define their appearance.\n */\nclass MethodPass extends PassBase implements ILightingPass\n{\n\tprivate _maxLights:number = 3;\n\n\tprivate _mode:number = 0x03;\n\tprivate _material:MaterialBase;\n\tprivate _lightPicker:LightPickerBase;\n\n\tprivate _includeCasters:boolean = true;\n\n\tpublic _iColorTransformMethodVO:MethodVO;\n\tpublic _iNormalMethodVO:MethodVO;\n\tpublic _iAmbientMethodVO:MethodVO;\n\tpublic _iShadowMethodVO:MethodVO;\n\tpublic _iDiffuseMethodVO:MethodVO;\n\tpublic _iSpecularMethodVO:MethodVO;\n\tpublic _iMethodVOs:Array<MethodVO> = new Array<MethodVO>();\n\n\tpublic _numEffectDependencies:number = 0;\n\n\tprivate _onLightsChangeDelegate:(event:Event) => void;\n\tprivate _onMethodInvalidatedDelegate:(event:ShadingMethodEvent) => void;\n\n\tpublic numDirectionalLights:number = 0;\n\n\tpublic numPointLights:number = 0;\n\n\tpublic numLightProbes:number = 0;\n\n\tpublic pointLightsOffset:number = 0;\n\t\n\tpublic directionalLightsOffset:number= 0;\n\t\n\tpublic lightProbesOffset:number = 0;\n\t\n\t/**\n\t *\n\t */\n\tpublic get mode():number\n\t{\n\t\treturn this._mode;\n\t}\n\n\tpublic set mode(value:number)\n\t{\n\t\tif (this._mode == value)\n\t\t\treturn;\n\t\t\n\t\tthis._mode = value;\n\n\t\tthis._updateLights();\n\t}\n\n\t/**\n\t * Indicates whether or not shadow casting lights need to be included.\n\t */\n\tpublic get includeCasters():boolean\n\t{\n\t\treturn this._includeCasters;\n\t}\n\n\tpublic set includeCasters(value:boolean)\n\t{\n\t\tif (this._includeCasters == value)\n\t\t\treturn;\n\n\t\tthis._includeCasters = value;\n\n\t\tthis._updateLights();\n\t}\n\n\t/**\n\t * \n\t * @returns {LightPickerBase}\n\t */\n\tpublic get lightPicker():LightPickerBase\n\t{\n\t\treturn this._lightPicker;\n\t}\n\n\tpublic set lightPicker(value:LightPickerBase)\n\t{\n\t\t//if (this._lightPicker == value)\n\t\t//\treturn;\n\n\t\tif (this._lightPicker)\n\t\t\tthis._lightPicker.removeEventListener(Event.CHANGE, this._onLightsChangeDelegate);\n\n\t\tthis._lightPicker = value;\n\n\t\tif (this._lightPicker)\n\t\t\tthis._lightPicker.addEventListener(Event.CHANGE, this._onLightsChangeDelegate);\n\n\t\tthis._updateLights();\n\t}\n\t\n\t/**\n\t * Whether or not to use fallOff and radius properties for lights. This can be used to improve performance and\n\t * compatibility for constrained mode.\n\t */\n\tpublic get enableLightFallOff():boolean\n\t{\n\t\treturn this._material.enableLightFallOff;\n\t}\n\n\t/**\n\t * Define which light source types to use for diffuse reflections. This allows choosing between regular lights\n\t * and/or light probes for diffuse reflections.\n\t *\n\t * @see away3d.materials.LightSources\n\t */\n\tpublic get diffuseLightSources():number\n\t{\n\t\treturn this._material.diffuseLightSources;\n\t}\n\n\t/**\n\t * Define which light source types to use for specular reflections. This allows choosing between regular lights\n\t * and/or light probes for specular reflections.\n\t *\n\t * @see away3d.materials.LightSources\n\t */\n\tpublic get specularLightSources():number\n\t{\n\t\treturn this._material.specularLightSources;\n\t}\n\n\t/**\n\t * Creates a new CompiledPass object.\n\t *\n\t * @param material The material to which this pass belongs.\n\t */\n\tconstructor(mode:number, render:MethodMaterialRender, renderOwner:MaterialBase, renderableClass:IRenderableClass, stage:Stage)\n\t{\n\t\tsuper(render, renderOwner, renderableClass, stage);\n\n\t\tthis._mode = mode;\n\n\t\tthis._material = renderOwner;\n\n\t\tthis._onLightsChangeDelegate = (event:Event) => this.onLightsChange(event);\n\t\t\n\t\tthis._onMethodInvalidatedDelegate = (event:ShadingMethodEvent) => this.onMethodInvalidated(event);\n\n\t\tthis.lightPicker = renderOwner.lightPicker;\n\n\t\tif (this._shader == null)\n\t\t\tthis._updateShader();\n\t}\n\n\tprivate _updateShader()\n\t{\n\t\tif ((this.numDirectionalLights || this.numPointLights || this.numLightProbes) && !(this._shader instanceof LightingShader)) {\n\t\t\tif (this._shader != null)\n\t\t\t\tthis._shader.dispose();\n\n\t\t\tthis._shader = new LightingShader(this._renderableClass, this, this._stage);\n\t\t} else if (!(this._shader instanceof ShaderBase)) {\n\t\t\tif (this._shader != null)\n\t\t\t\tthis._shader.dispose();\n\n\t\t\tthis._shader = new ShaderBase(this._renderableClass, this, this._stage);\n\t\t}\n\t}\n\n\t/**\n\t * Initializes the unchanging constant data for this material.\n\t */\n\tpublic _iInitConstantData(shader:ShaderBase)\n\t{\n\t\tsuper._iInitConstantData(shader);\n\n\t\t//Updates method constants if they have changed.\n\t\tvar len:number = this._iMethodVOs.length;\n\t\tfor (var i:number = 0; i < len; ++i)\n\t\t\tthis._iMethodVOs[i].method.iInitConstants(shader, this._iMethodVOs[i]);\n\t}\n\n\t/**\n\t * The ColorTransform object to transform the colour of the material with. Defaults to null.\n\t */\n\tpublic get colorTransform():ColorTransform\n\t{\n\t\treturn this.colorTransformMethod? this.colorTransformMethod.colorTransform : null;\n\t}\n\n\tpublic set colorTransform(value:ColorTransform)\n\t{\n\t\tif (value) {\n\t\t\tif (this.colorTransformMethod == null)\n\t\t\t\tthis.colorTransformMethod = new EffectColorTransformMethod();\n\n\t\t\tthis.colorTransformMethod.colorTransform = value;\n\n\t\t} else if (!value) {\n\t\t\tif (this.colorTransformMethod)\n\t\t\t\tthis.colorTransformMethod = null;\n\t\t}\n\t}\n\n\t/**\n\t * The EffectColorTransformMethod object to transform the colour of the material with. Defaults to null.\n\t */\n\tpublic get colorTransformMethod():EffectColorTransformMethod\n\t{\n\t\treturn this._iColorTransformMethodVO? <EffectColorTransformMethod> this._iColorTransformMethodVO.method : null;\n\t}\n\n\tpublic set colorTransformMethod(value:EffectColorTransformMethod)\n\t{\n\t\tif (this._iColorTransformMethodVO && this._iColorTransformMethodVO.method == value)\n\t\t\treturn;\n\n\t\tif (this._iColorTransformMethodVO) {\n\t\t\tthis._removeDependency(this._iColorTransformMethodVO);\n\t\t\tthis._iColorTransformMethodVO = null;\n\t\t}\n\n\t\tif (value) {\n\t\t\tthis._iColorTransformMethodVO = new MethodVO(value);\n\t\t\tthis._addDependency(this._iColorTransformMethodVO);\n\t\t}\n\t}\n\n\tprivate _removeDependency(methodVO:MethodVO, effectsDependency:boolean = false)\n\t{\n\t\tvar index:number = this._iMethodVOs.indexOf(methodVO);\n\n\t\tif (!effectsDependency)\n\t\t\tthis._numEffectDependencies--;\n\n\t\tmethodVO.method.removeEventListener(ShadingMethodEvent.SHADER_INVALIDATED, this._onMethodInvalidatedDelegate);\n\t\tthis._iMethodVOs.splice(index, 1);\n\n\t\tthis.invalidatePass();\n\t}\n\n\tprivate _addDependency(methodVO:MethodVO, effectsDependency:boolean = false, index:number = -1)\n\t{\n\t\tmethodVO.method.addEventListener(ShadingMethodEvent.SHADER_INVALIDATED, this._onMethodInvalidatedDelegate);\n\n\t\tif (effectsDependency) {\n\t\t\tif (index != -1)\n\t\t\t\tthis._iMethodVOs.splice(index + this._iMethodVOs.length - this._numEffectDependencies, 0, methodVO);\n\t\t\telse\n\t\t\t\tthis._iMethodVOs.push(methodVO);\n\t\t\tthis._numEffectDependencies++;\n\t\t} else {\n\t\t\tthis._iMethodVOs.splice(this._iMethodVOs.length - this._numEffectDependencies, 0, methodVO);\n\t\t}\n\n\t\tthis.invalidatePass();\n\t}\n\n\t/**\n\t * Appends an \"effect\" shading method to the shader. Effect methods are those that do not influence the lighting\n\t * but modulate the shaded colour, used for fog, outlines, etc. The method will be applied to the result of the\n\t * methods added prior.\n\t */\n\tpublic addEffectMethod(method:EffectMethodBase)\n\t{\n\t\tthis._addDependency(new MethodVO(method), true);\n\t}\n\n\t/**\n\t * The number of \"effect\" methods added to the material.\n\t */\n\tpublic get numEffectMethods():number\n\t{\n\t\treturn this._numEffectDependencies;\n\t}\n\n\t/**\n\t * Queries whether a given effects method was added to the material.\n\t *\n\t * @param method The method to be queried.\n\t * @return true if the method was added to the material, false otherwise.\n\t */\n\tpublic hasEffectMethod(method:EffectMethodBase):boolean\n\t{\n\t\treturn this.getDependencyForMethod(method) != null;\n\t}\n\n\t/**\n\t * Returns the method added at the given index.\n\t * @param index The index of the method to retrieve.\n\t * @return The method at the given index.\n\t */\n\tpublic getEffectMethodAt(index:number):EffectMethodBase\n\t{\n\t\tif (index < 0 || index > this._numEffectDependencies - 1)\n\t\t\treturn null;\n\n\t\treturn <EffectMethodBase> this._iMethodVOs[index + this._iMethodVOs.length - this._numEffectDependencies].method;\n\t}\n\n\t/**\n\t * Adds an effect method at the specified index amongst the methods already added to the material. Effect\n\t * methods are those that do not influence the lighting but modulate the shaded colour, used for fog, outlines,\n\t * etc. The method will be applied to the result of the methods with a lower index.\n\t */\n\tpublic addEffectMethodAt(method:EffectMethodBase, index:number)\n\t{\n\t\tthis._addDependency(new MethodVO(method), true, index);\n\t}\n\n\t/**\n\t * Removes an effect method from the material.\n\t * @param method The method to be removed.\n\t */\n\tpublic removeEffectMethod(method:EffectMethodBase)\n\t{\n\t\tvar methodVO:MethodVO = this.getDependencyForMethod(method);\n\n\t\tif (methodVO != null)\n\t\t\tthis._removeDependency(methodVO, true);\n\t}\n\n\n\t/**\n\t * remove an effect method at the specified index from the material.\n\t */\n\tpublic removeEffectMethodAt(index:number)\n\t{\n\t\tif (index < 0 || index > this._numEffectDependencies - 1)\n\t\t\treturn;\n\n\t\tvar methodVO:MethodVO = this._iMethodVOs[index + this._iMethodVOs.length - this._numEffectDependencies];\n\n\t\tif (methodVO != null)\n\t\t\tthis._removeDependency(methodVO, true);\n\t}\n\n\n\tprivate getDependencyForMethod(method:EffectMethodBase):MethodVO\n\t{\n\t\tvar len:number = this._iMethodVOs.length;\n\t\tfor (var i:number = 0; i < len; ++i)\n\t\t\tif (this._iMethodVOs[i].method == method)\n\t\t\t\treturn this._iMethodVOs[i];\n\n\t\treturn null;\n\t}\n\n\t/**\n\t * The method used to generate the per-pixel normals. Defaults to NormalBasicMethod.\n\t */\n\tpublic get normalMethod():NormalBasicMethod\n\t{\n\t\treturn this._iNormalMethodVO? <NormalBasicMethod> this._iNormalMethodVO.method : null;\n\t}\n\n\tpublic set normalMethod(value:NormalBasicMethod)\n\t{\n\t\tif (this._iNormalMethodVO && this._iNormalMethodVO.method == value)\n\t\t\treturn;\n\n\t\tif (this._iNormalMethodVO) {\n\t\t\tthis._removeDependency(this._iNormalMethodVO);\n\t\t\tthis._iNormalMethodVO = null;\n\t\t}\n\n\t\tif (value) {\n\t\t\tthis._iNormalMethodVO = new MethodVO(value);\n\t\t\tthis._addDependency(this._iNormalMethodVO);\n\t\t}\n\t}\n\n\t/**\n\t * The method that provides the ambient lighting contribution. Defaults to AmbientBasicMethod.\n\t */\n\tpublic get ambientMethod():AmbientBasicMethod\n\t{\n\t\treturn this._iAmbientMethodVO? <AmbientBasicMethod> this._iAmbientMethodVO.method : null;\n\t}\n\n\tpublic set ambientMethod(value:AmbientBasicMethod)\n\t{\n\t\tif (this._iAmbientMethodVO && this._iAmbientMethodVO.method == value)\n\t\t\treturn;\n\n\t\tif (this._iAmbientMethodVO) {\n\t\t\tthis._removeDependency(this._iAmbientMethodVO);\n\t\t\tthis._iAmbientMethodVO = null;\n\t\t}\n\n\t\tif (value) {\n\t\t\tthis._iAmbientMethodVO = new MethodVO(value);\n\t\t\tthis._addDependency(this._iAmbientMethodVO);\n\t\t}\n\t}\n\n\t/**\n\t * The method used to render shadows cast on this surface, or null if no shadows are to be rendered. Defaults to null.\n\t */\n\tpublic get shadowMethod():ShadowMapMethodBase\n\t{\n\t\treturn this._iShadowMethodVO? <ShadowMapMethodBase> this._iShadowMethodVO.method : null;\n\t}\n\n\tpublic set shadowMethod(value:ShadowMapMethodBase)\n\t{\n\t\tif (this._iShadowMethodVO && this._iShadowMethodVO.method == value)\n\t\t\treturn;\n\n\t\tif (this._iShadowMethodVO) {\n\t\t\tthis._removeDependency(this._iShadowMethodVO);\n\t\t\tthis._iShadowMethodVO = null;\n\t\t}\n\n\t\tif (value) {\n\t\t\tthis._iShadowMethodVO = new MethodVO(value);\n\t\t\tthis._addDependency(this._iShadowMethodVO);\n\t\t}\n\t}\n\n\t/**\n\t * The method that provides the diffuse lighting contribution. Defaults to DiffuseBasicMethod.\n\t */\n\tpublic get diffuseMethod():DiffuseBasicMethod\n\t{\n\t\treturn this._iDiffuseMethodVO? <DiffuseBasicMethod> this._iDiffuseMethodVO.method : null;\n\t}\n\n\tpublic set diffuseMethod(value:DiffuseBasicMethod)\n\t{\n\t\tif (this._iDiffuseMethodVO && this._iDiffuseMethodVO.method == value)\n\t\t\treturn;\n\n\t\tif (this._iDiffuseMethodVO) {\n\t\t\tthis._removeDependency(this._iDiffuseMethodVO);\n\t\t\tthis._iDiffuseMethodVO = null;\n\t\t}\n\n\t\tif (value) {\n\t\t\tthis._iDiffuseMethodVO = new MethodVO(value);\n\t\t\tthis._addDependency(this._iDiffuseMethodVO);\n\t\t}\n\t}\n\n\t/**\n\t * The method that provides the specular lighting contribution. Defaults to SpecularBasicMethod.\n\t */\n\tpublic get specularMethod():SpecularBasicMethod\n\t{\n\t\treturn this._iSpecularMethodVO? <SpecularBasicMethod> this._iSpecularMethodVO.method : null;\n\t}\n\n\tpublic set specularMethod(value:SpecularBasicMethod)\n\t{\n\t\tif (this._iSpecularMethodVO && this._iSpecularMethodVO.method == value)\n\t\t\treturn;\n\n\t\tif (this._iSpecularMethodVO) {\n\t\t\tthis._removeDependency(this._iSpecularMethodVO);\n\t\t\tthis._iSpecularMethodVO = null;\n\t\t}\n\n\t\tif (value) {\n\t\t\tthis._iSpecularMethodVO = new MethodVO(value);\n\t\t\tthis._addDependency(this._iSpecularMethodVO);\n\t\t}\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic dispose()\n\t{\n\t\tsuper.dispose();\n\n\t\tif (this._lightPicker)\n\t\t\tthis._lightPicker.removeEventListener(Event.CHANGE, this._onLightsChangeDelegate);\n\t\t\n\t\twhile (this._iMethodVOs.length)\n\t\t\tthis._removeDependency(this._iMethodVOs[0]);\n\n\t\tthis._iMethodVOs = null;\n\t}\n\n\t/**\n\t * Called when any method's shader code is invalidated.\n\t */\n\tprivate onMethodInvalidated(event:ShadingMethodEvent)\n\t{\n\t\tthis.invalidatePass();\n\t}\n\n\t// RENDER LOOP\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic _iActivate(camera:Camera)\n\t{\n\t\tsuper._iActivate(camera);\n\n\t\tvar methodVO:MethodVO;\n\t\tvar len:number = this._iMethodVOs.length;\n\t\tfor (var i:number = 0; i < len; ++i) {\n\t\t\tmethodVO = this._iMethodVOs[i];\n\t\t\tif (methodVO.useMethod)\n\t\t\t\tmethodVO.method.iActivate(this._shader, methodVO, this._stage);\n\t\t}\n\t}\n\n\t/**\n\t *\n\t *\n\t * @param renderable\n\t * @param stage\n\t * @param camera\n\t */\n\tpublic _iRender(renderable:RenderableBase, camera:Camera, viewProjection:Matrix3D)\n\t{\n\t\tsuper._iRender(renderable, camera, viewProjection);\n\n\t\tvar methodVO:MethodVO;\n\t\tvar len:number = this._iMethodVOs.length;\n\t\tfor (var i:number = 0; i < len; ++i) {\n\t\t\tmethodVO = this._iMethodVOs[i];\n\t\t\tif (methodVO.useMethod)\n\t\t\t\tmethodVO.method.iSetRenderState(this._shader, methodVO, renderable, this._stage, camera);\n\t\t}\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic _iDeactivate()\n\t{\n\t\tsuper._iDeactivate();\n\n\t\tvar methodVO:MethodVO;\n\t\tvar len:number = this._iMethodVOs.length;\n\t\tfor (var i:number = 0; i < len; ++i) {\n\t\t\tmethodVO = this._iMethodVOs[i];\n\t\t\tif (methodVO.useMethod)\n\t\t\t\tmethodVO.method.iDeactivate(this._shader, methodVO, this._stage);\n\t\t}\n\t}\n\n\tpublic _iIncludeDependencies(shader:LightingShader)\n\t{\n\t\tsuper._iIncludeDependencies(shader);\n\n\t\t//TODO: fragment animtion should be compatible with lighting pass\n\t\tshader.usesFragmentAnimation = Boolean(this._mode == MethodPassMode.SUPER_SHADER);\n\n\t\tvar i:number;\n\t\tvar len:number = this._iMethodVOs.length;\n\t\tfor (i = 0; i < len; ++i)\n\t\t\tthis.setupAndCountDependencies(shader, this._iMethodVOs[i]);\n\n\t\tvar usesTangentSpace:boolean = true;\n\n\t\tvar methodVO:MethodVO;\n\t\tfor (i = 0; i < len; ++i) {\n\t\t\tmethodVO = this._iMethodVOs[i];\n\t\t\tif ((methodVO.useMethod = methodVO.method.iIsUsed(shader)) && !methodVO.method.iUsesTangentSpace())\n\t\t\t\tusesTangentSpace = false;\n\t\t}\n\n\t\tshader.outputsNormals = this._iNormalMethodVO && this._iNormalMethodVO.useMethod;\n\t\tshader.outputsTangentNormals = shader.outputsNormals && (<NormalBasicMethod> this._iNormalMethodVO.method).iOutputsTangentNormals();\n\t\tshader.usesTangentSpace = shader.outputsTangentNormals && !shader.usesProbes && usesTangentSpace;\n\n\t\tif (!shader.usesTangentSpace) {\n\t\t\tif (shader.viewDirDependencies > 0) {\n\t\t\t\tshader.globalPosDependencies++;\n\t\t\t} else if (this.numPointLights > 0 && shader.usesLights) {\n\t\t\t\tshader.globalPosDependencies++;\n\t\t\t\tif (Boolean(this._mode & MethodPassMode.EFFECTS))\n\t\t\t\t\tshader.usesGlobalPosFragment = true;\n\t\t\t}\n\t\t}\n\t}\n\n\n\t/**\n\t * Counts the dependencies for a given method.\n\t * @param method The method to count the dependencies for.\n\t * @param methodVO The method's data for this material.\n\t */\n\tprivate setupAndCountDependencies(shader:ShaderBase, methodVO:MethodVO)\n\t{\n\t\tmethodVO.reset();\n\n\t\tmethodVO.method.iInitVO(shader, methodVO);\n\n\t\tif (methodVO.needsProjection)\n\t\t\tshader.projectionDependencies++;\n\n\t\tif (methodVO.needsGlobalVertexPos || methodVO.needsGlobalFragmentPos) {\n\n\t\t\tshader.globalPosDependencies++;\n\n\t\t\tif (methodVO.needsGlobalFragmentPos)\n\t\t\t\tshader.usesGlobalPosFragment = true;\n\n\t\t}\n\n\t\tif (methodVO.needsNormals)\n\t\t\tshader.normalDependencies++;\n\n\t\tif (methodVO.needsTangents)\n\t\t\tshader.tangentDependencies++;\n\n\t\tif (methodVO.needsView)\n\t\t\tshader.viewDirDependencies++;\n\t}\n\n\tpublic _iGetPreLightingVertexCode(shader:ShaderBase, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = \"\";\n\n\t\tif (this._iAmbientMethodVO && this._iAmbientMethodVO.useMethod)\n\t\t\tcode += this._iAmbientMethodVO.method.iGetVertexCode(shader, this._iAmbientMethodVO, registerCache, sharedRegisters);\n\n\t\tif (this._iDiffuseMethodVO && this._iDiffuseMethodVO.useMethod)\n\t\t\tcode += this._iDiffuseMethodVO.method.iGetVertexCode(shader, this._iDiffuseMethodVO, registerCache, sharedRegisters);\n\n\t\tif (this._iSpecularMethodVO && this._iSpecularMethodVO.useMethod)\n\t\t\tcode += this._iSpecularMethodVO.method.iGetVertexCode(shader, this._iSpecularMethodVO, registerCache, sharedRegisters);\n\n\t\treturn code;\n\t}\n\n\tpublic _iGetPreLightingFragmentCode(shader:ShaderBase, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = \"\";\n\n\t\tif (this._iAmbientMethodVO && this._iAmbientMethodVO.useMethod) {\n\t\t\tcode += this._iAmbientMethodVO.method.iGetFragmentCode(shader, this._iAmbientMethodVO, sharedRegisters.shadedTarget, registerCache, sharedRegisters);\n\n\t\t\tif (this._iAmbientMethodVO.needsNormals)\n\t\t\t\tregisterCache.removeFragmentTempUsage(sharedRegisters.normalFragment);\n\n\t\t\tif (this._iAmbientMethodVO.needsView)\n\t\t\t\tregisterCache.removeFragmentTempUsage(sharedRegisters.viewDirFragment);\n\t\t}\n\n\t\tif (this._iDiffuseMethodVO && this._iDiffuseMethodVO.useMethod)\n\t\t\tcode += (<LightingMethodBase> this._iDiffuseMethodVO.method).iGetFragmentPreLightingCode(<LightingShader> shader, this._iDiffuseMethodVO, registerCache, sharedRegisters);\n\n\t\tif (this._iSpecularMethodVO && this._iSpecularMethodVO.useMethod)\n\t\t\tcode += (<LightingMethodBase> this._iSpecularMethodVO.method).iGetFragmentPreLightingCode(<LightingShader> shader, this._iSpecularMethodVO, registerCache, sharedRegisters);\n\n\t\treturn code;\n\t}\n\n\tpublic _iGetPerLightDiffuseFragmentCode(shader:LightingShader, lightDirReg:ShaderRegisterElement, diffuseColorReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\treturn (<LightingMethodBase> this._iDiffuseMethodVO.method).iGetFragmentCodePerLight(shader, this._iDiffuseMethodVO, lightDirReg, diffuseColorReg, registerCache, sharedRegisters);\n\t}\n\n\tpublic _iGetPerLightSpecularFragmentCode(shader:LightingShader, lightDirReg:ShaderRegisterElement, specularColorReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\treturn (<LightingMethodBase> this._iSpecularMethodVO.method).iGetFragmentCodePerLight(shader, this._iSpecularMethodVO, lightDirReg, specularColorReg, registerCache, sharedRegisters);\n\t}\n\n\tpublic _iGetPerProbeDiffuseFragmentCode(shader:LightingShader, texReg:ShaderRegisterElement, weightReg:string, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\treturn (<LightingMethodBase> this._iDiffuseMethodVO.method).iGetFragmentCodePerProbe(shader, this._iDiffuseMethodVO, texReg, weightReg, registerCache, sharedRegisters);\n\t}\n\n\tpublic _iGetPerProbeSpecularFragmentCode(shader:LightingShader, texReg:ShaderRegisterElement, weightReg:string, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\treturn (<LightingMethodBase> this._iSpecularMethodVO.method).iGetFragmentCodePerProbe(shader, this._iSpecularMethodVO, texReg, weightReg, registerCache, sharedRegisters);\n\t}\n\n\tpublic _iGetPostLightingVertexCode(shader:LightingShader, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = \"\";\n\n\t\tif (this._iShadowMethodVO)\n\t\t\tcode += this._iShadowMethodVO.method.iGetVertexCode(shader, this._iShadowMethodVO, registerCache, sharedRegisters);\n\n\t\treturn code;\n\t}\n\n\tpublic _iGetPostLightingFragmentCode(shader:LightingShader, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = \"\";\n\n\t\tif (shader.useAlphaPremultiplied && shader.usesBlending) {\n\t\t\tcode += \"add \" + sharedRegisters.shadedTarget + \".w, \" + sharedRegisters.shadedTarget + \".w, \" + sharedRegisters.commons + \".z\\n\" +\n\t\t\t\"div \" + sharedRegisters.shadedTarget + \".xyz, \" + sharedRegisters.shadedTarget + \", \" + sharedRegisters.shadedTarget + \".w\\n\" +\n\t\t\t\"sub \" + sharedRegisters.shadedTarget + \".w, \" + sharedRegisters.shadedTarget + \".w, \" + sharedRegisters.commons + \".z\\n\" +\n\t\t\t\"sat \" + sharedRegisters.shadedTarget + \".xyz, \" + sharedRegisters.shadedTarget + \"\\n\";\n\t\t}\n\n\t\tif (this._iShadowMethodVO)\n\t\t\tcode += this._iShadowMethodVO.method.iGetFragmentCode(shader, this._iShadowMethodVO, sharedRegisters.shadowTarget, registerCache, sharedRegisters);\n\n\t\tif (this._iDiffuseMethodVO && this._iDiffuseMethodVO.useMethod) {\n\t\t\tcode += (<LightingMethodBase> this._iDiffuseMethodVO.method).iGetFragmentPostLightingCode(shader, this._iDiffuseMethodVO, sharedRegisters.shadedTarget, registerCache, sharedRegisters);\n\n\t\t\t// resolve other dependencies as well?\n\t\t\tif (this._iDiffuseMethodVO.needsNormals)\n\t\t\t\tregisterCache.removeFragmentTempUsage(sharedRegisters.normalFragment);\n\n\t\t\tif (this._iDiffuseMethodVO.needsView)\n\t\t\t\tregisterCache.removeFragmentTempUsage(sharedRegisters.viewDirFragment);\n\t\t}\n\n\t\tif (this._iSpecularMethodVO && this._iSpecularMethodVO.useMethod) {\n\t\t\tcode += (<LightingMethodBase> this._iSpecularMethodVO.method).iGetFragmentPostLightingCode(shader, this._iSpecularMethodVO, sharedRegisters.shadedTarget, registerCache, sharedRegisters);\n\t\t\tif (this._iSpecularMethodVO.needsNormals)\n\t\t\t\tregisterCache.removeFragmentTempUsage(sharedRegisters.normalFragment);\n\t\t\tif (this._iSpecularMethodVO.needsView)\n\t\t\t\tregisterCache.removeFragmentTempUsage(sharedRegisters.viewDirFragment);\n\t\t}\n\n\t\tif (this._iShadowMethodVO)\n\t\t\tregisterCache.removeFragmentTempUsage(sharedRegisters.shadowTarget);\n\n\t\treturn code;\n\t}\n\n\n\tpublic _iGetNormalVertexCode(shader:ShaderBase, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\treturn this._iNormalMethodVO.method.iGetVertexCode(shader, this._iNormalMethodVO, registerCache, sharedRegisters);\n\t}\n\n\tpublic _iGetNormalFragmentCode(shader:ShaderBase, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = this._iNormalMethodVO.method.iGetFragmentCode(shader, this._iNormalMethodVO, sharedRegisters.normalFragment, registerCache, sharedRegisters);\n\n\t\tif (this._iNormalMethodVO.needsView)\n\t\t\tregisterCache.removeFragmentTempUsage(sharedRegisters.viewDirFragment);\n\n\t\tif (this._iNormalMethodVO.needsGlobalFragmentPos || this._iNormalMethodVO.needsGlobalVertexPos)\n\t\t\tregisterCache.removeVertexTempUsage(sharedRegisters.globalPositionVertex);\n\n\t\treturn code;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic _iGetVertexCode(shader:ShaderBase, regCache:ShaderRegisterCache, sharedReg:ShaderRegisterData):string\n\t{\n\t\tvar code:string = \"\";\n\t\tvar methodVO:MethodVO;\n\t\tvar len:number = this._iMethodVOs.length;\n\t\tfor (var i:number = len - this._numEffectDependencies; i < len; i++) {\n\t\t\tmethodVO = this._iMethodVOs[i];\n\t\t\tif (methodVO.useMethod) {\n\t\t\t\tcode += methodVO.method.iGetVertexCode(shader, methodVO, regCache, sharedReg);\n\n\t\t\t\tif (methodVO.needsGlobalVertexPos || methodVO.needsGlobalFragmentPos)\n\t\t\t\t\tregCache.removeVertexTempUsage(sharedReg.globalPositionVertex);\n\t\t\t}\n\t\t}\n\n\t\tif (this._iColorTransformMethodVO && this._iColorTransformMethodVO.useMethod)\n\t\t\tcode += this._iColorTransformMethodVO.method.iGetVertexCode(shader, this._iColorTransformMethodVO, regCache, sharedReg);\n\n\t\treturn code;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic _iGetFragmentCode(shader:ShaderBase, regCache:ShaderRegisterCache, sharedReg:ShaderRegisterData):string\n\t{\n\t\tvar code:string = \"\";\n\t\tvar alphaReg:ShaderRegisterElement;\n\n\t\tif (this.preserveAlpha && this._numEffectDependencies > 0) {\n\t\t\talphaReg = regCache.getFreeFragmentSingleTemp();\n\t\t\tregCache.addFragmentTempUsages(alphaReg, 1);\n\t\t\tcode += \"mov \" + alphaReg + \", \" + sharedReg.shadedTarget + \".w\\n\";\n\t\t}\n\n\t\tvar methodVO:MethodVO;\n\t\tvar len:number = this._iMethodVOs.length;\n\t\tfor (var i:number = len - this._numEffectDependencies; i < len; i++) {\n\t\t\tmethodVO = this._iMethodVOs[i];\n\t\t\tif (methodVO.useMethod) {\n\t\t\t\tcode += methodVO.method.iGetFragmentCode(shader, methodVO, sharedReg.shadedTarget, regCache, sharedReg);\n\n\t\t\t\tif (methodVO.needsNormals)\n\t\t\t\t\tregCache.removeFragmentTempUsage(sharedReg.normalFragment);\n\n\t\t\t\tif (methodVO.needsView)\n\t\t\t\t\tregCache.removeFragmentTempUsage(sharedReg.viewDirFragment);\n\n\t\t\t}\n\t\t}\n\n\t\tif (this.preserveAlpha && this._numEffectDependencies > 0) {\n\t\t\tcode += \"mov \" + sharedReg.shadedTarget + \".w, \" + alphaReg + \"\\n\";\n\t\t\tregCache.removeFragmentTempUsage(alphaReg);\n\t\t}\n\n\t\tif (this._iColorTransformMethodVO && this._iColorTransformMethodVO.useMethod)\n\t\t\tcode += this._iColorTransformMethodVO.method.iGetFragmentCode(shader, this._iColorTransformMethodVO, sharedReg.shadedTarget, regCache, sharedReg);\n\n\t\treturn code;\n\t}\n\t/**\n\t * Indicates whether the shader uses any shadows.\n\t */\n\tpublic _iUsesShadows(shader:ShaderBase):boolean\n\t{\n\t\treturn Boolean(this._iShadowMethodVO && (this._lightPicker.castingDirectionalLights.length > 0 || this._lightPicker.castingPointLights.length > 0));\n\t}\n\n\t/**\n\t * Indicates whether the shader uses any specular component.\n\t */\n\tpublic _iUsesSpecular(shader:ShaderBase):boolean\n\t{\n\t\treturn Boolean(this._iSpecularMethodVO);\n\t}\n\n\t/**\n\t * Indicates whether the shader uses any specular component.\n\t */\n\tpublic _iUsesDiffuse(shader:ShaderBase):boolean\n\t{\n\t\treturn Boolean(this._iDiffuseMethodVO);\n\t}\n\n\n\tprivate onLightsChange(event:Event)\n\t{\n\t\tthis._updateLights();\n\t}\n\n\tprivate _updateLights()\n\t{\n\t\tvar numDirectionalLightsOld:number = this.numDirectionalLights;\n\t\tvar numPointLightsOld:number = this.numPointLights;\n\t\tvar numLightProbesOld:number = this.numLightProbes;\n\n\t\tif (this._lightPicker && (this._mode & MethodPassMode.LIGHTING)) {\n\t\t\tthis.numDirectionalLights = this.calculateNumDirectionalLights(this._lightPicker.numDirectionalLights);\n\t\t\tthis.numPointLights = this.calculateNumPointLights(this._lightPicker.numPointLights);\n\t\t\tthis.numLightProbes = this.calculateNumProbes(this._lightPicker.numLightProbes);\n\n\t\t\tif (this._includeCasters) {\n\t\t\t\tthis.numDirectionalLights += this._lightPicker.numCastingDirectionalLights;\n\t\t\t\tthis.numPointLights += this._lightPicker.numCastingPointLights;\n\t\t\t}\n\n\t\t} else {\n\t\t\tthis.numDirectionalLights = 0;\n\t\t\tthis.numPointLights = 0;\n\t\t\tthis.numLightProbes = 0;\n\t\t}\n\n\t\tif (numDirectionalLightsOld != this.numDirectionalLights || numPointLightsOld != this.numPointLights || numLightProbesOld != this.numLightProbes) {\n\t\t\tthis._updateShader();\n\n\t\t\tthis.invalidatePass();\n\t\t}\n\t}\n\n\t/**\n\t * Calculates the amount of directional lights this material will support.\n\t * @param numDirectionalLights The maximum amount of directional lights to support.\n\t * @return The amount of directional lights this material will support, bounded by the amount necessary.\n\t */\n\tprivate calculateNumDirectionalLights(numDirectionalLights:number):number\n\t{\n\t\treturn Math.min(numDirectionalLights - this.directionalLightsOffset, this._maxLights);\n\t}\n\n\t/**\n\t * Calculates the amount of point lights this material will support.\n\t * @param numDirectionalLights The maximum amount of point lights to support.\n\t * @return The amount of point lights this material will support, bounded by the amount necessary.\n\t */\n\tprivate calculateNumPointLights(numPointLights:number):number\n\t{\n\t\tvar numFree:number = this._maxLights - this.numDirectionalLights;\n\t\treturn Math.min(numPointLights - this.pointLightsOffset, numFree);\n\t}\n\n\t/**\n\t * Calculates the amount of light probes this material will support.\n\t * @param numDirectionalLights The maximum amount of light probes to support.\n\t * @return The amount of light probes this material will support, bounded by the amount necessary.\n\t */\n\tprivate calculateNumProbes(numLightProbes:number):number\n\t{\n\t\tvar numChannels:number = 0;\n\n\t\tif ((this.specularLightSources & LightSources.PROBES) != 0)\n\t\t\t++numChannels;\n\n\t\tif ((this.diffuseLightSources & LightSources.PROBES) != 0)\n\t\t\t++numChannels;\n\n\t\t// 4 channels available\n\t\treturn Math.min(numLightProbes - this.lightProbesOffset, (4/numChannels) | 0);\n\t}\n}\n\nexport = MethodPass;",
    "import Image2D\t\t\t\t\t\t\t= require(\"awayjs-core/lib/data/Image2D\");\nimport TriangleSubGeometry\t\t\t\t= require(\"awayjs-core/lib/data/TriangleSubGeometry\");\nimport Matrix3D\t\t\t\t\t\t\t= require(\"awayjs-core/lib/geom/Matrix3D\");\n\nimport LightBase\t\t\t\t\t\t= require(\"awayjs-display/lib/base/LightBase\");\nimport Camera\t\t\t\t\t\t\t= require(\"awayjs-display/lib/entities/Camera\");\nimport MaterialBase\t\t\t\t\t\t= require(\"awayjs-display/lib/materials/MaterialBase\");\nimport IRenderOwner\t\t\t\t= require(\"awayjs-display/lib/base/IRenderOwner\");\nimport Single2DTexture\t\t\t\t\t= require(\"awayjs-display/lib/textures/Single2DTexture\");\nimport TextureBase\t\t\t\t\t\t= require(\"awayjs-display/lib/textures/TextureBase\");\n\nimport ContextGLProgramType\t\t\t\t= require(\"awayjs-stagegl/lib/base/ContextGLProgramType\");\nimport IContextGL\t\t\t\t\t\t= require(\"awayjs-stagegl/lib/base/IContextGL\");\nimport Stage\t\t\t\t\t\t\t= require(\"awayjs-stagegl/lib/base/Stage\");\n\nimport RendererBase\t\t\t\t\t\t= require(\"awayjs-renderergl/lib/RendererBase\");\nimport ShaderBase\t\t\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderBase\");\nimport ShaderRegisterCache\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterCache\");\nimport ShaderRegisterData\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterData\");\nimport PassBase\t\t\t\t\t\t\t= require(\"awayjs-renderergl/lib/render/passes/PassBase\");\nimport IRenderableClass\t\t\t\t\t= require(\"awayjs-renderergl/lib/renderables/IRenderableClass\");\nimport RenderableBase\t\t\t\t\t= require(\"awayjs-renderergl/lib/renderables/RenderableBase\");\nimport RenderBase\t\t\t\t\t\t= require(\"awayjs-renderergl/lib/render/RenderBase\");\n\n/**\n * The SingleObjectDepthPass provides a material pass that renders a single object to a depth map from the point\n * of view from a light.\n */\nclass SingleObjectDepthPass extends PassBase\n{\n\tprivate _textures:Object;\n\tprivate _projections:Object;\n\tprivate _textureSize:number /*uint*/ = 512;\n\tprivate _polyOffset:Array<number> = Array<number>(15, 0, 0, 0);\n\tprivate _enc:Array<number>;\n\tprivate _projectionTexturesInvalid:Boolean = true;\n\n\t/**\n\t * The size of the depth map texture to render to.\n\t */\n\tpublic get textureSize():number\n\t{\n\t\treturn this._textureSize;\n\t}\n\n\tpublic set textureSize(value:number)\n\t{\n\t\tthis._textureSize = value;\n\t}\n\n\t/**\n\t * The amount by which the rendered object will be inflated, to prevent depth map rounding errors.\n\t */\n\tpublic get polyOffset():number\n\t{\n\t\treturn this._polyOffset[0];\n\t}\n\n\tpublic set polyOffset(value:number)\n\t{\n\t\tthis._polyOffset[0] = value;\n\t}\n\n\t/**\n\t * Creates a new SingleObjectDepthPass object.\n\t */\n\tconstructor(render:RenderBase, renderOwner:IRenderOwner, renderableClass:IRenderableClass, stage:Stage)\n\t{\n\t\tsuper(render, renderOwner, renderableClass, stage);\n\n\t\t//this._pNumUsedStreams = 2;\n\t\t//this._pNumUsedVertexConstants = 7;\n\t\t//this._enc = Array<number>(1.0, 255.0, 65025.0, 16581375.0, 1.0/255.0, 1.0/255.0, 1.0/255.0, 0.0);\n\t\t//\n\t\t//this._pAnimatableAttributes = Array<string>(\"va0\", \"va1\");\n\t\t//this._pAnimationTargetRegisters = Array<string>(\"vt0\", \"vt1\");\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic dispose()\n\t{\n\t\tif (this._textures) {\n\t\t\tfor (var key in this._textures) {\n\t\t\t\tvar texture:TextureBase = this._textures[key];\n\t\t\t\ttexture.dispose();\n\t\t\t}\n\t\t\tthis._textures = null;\n\t\t}\n\t}\n\n\t/**\n\t * Updates the projection textures used to contain the depth renders.\n\t */\n\tprivate updateProjectionTextures()\n\t{\n\t\tif (this._textures) {\n\t\t\tfor (var key in this._textures) {\n\t\t\t\tvar texture:TextureBase = this._textures[key];\n\t\t\t\ttexture.dispose();\n\t\t\t}\n\t\t}\n\n\t\tthis._textures = new Object();\n\t\tthis._projections = new Object();\n\t\tthis._projectionTexturesInvalid = false;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic _iGetVertexCode():string\n\t{\n\t\tvar code:string;\n\t\t// offset\n\t\tcode = \"mul vt7, vt1, vc4.x\t\\n\" +\n\t\t\t\t\"add vt7, vt7, vt0\\n\" +\n\t\t\t\t\"mov vt7.w, vt0.w\\n\";\n\t\t// project\n\t\tcode += \"m44 vt2, vt7, vc0\\n\" +\n\t\t\t\t\"mov op, vt2\\n\";\n\n\t\t// perspective divide\n\t\tcode += \"div v0, vt2, vt2.w\\n\";\n\n\t\treturn code;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic _iGetFragmentCode(shader:ShaderBase, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = \"\";\n\n\t\t// encode float -> rgba\n\t\tcode += \"mul ft0, fc0, v0.z\\n\" +\n\t\t\t\t\"frc ft0, ft0\\n\" +\n\t\t\t\t\"mul ft1, ft0.yzww, fc1\\n\" +\n\t\t\t\t\"sub ft0, ft0, ft1\\n\" +\n\t\t\t\t\"mov oc, ft0\\n\";\n\n\t\treturn code;\n\t}\n\n\t/**\n\t * Gets the depth maps rendered for this object from all lights.\n\t * @param renderable The renderable for which to retrieve the depth maps.\n\t * @param stage3DProxy The Stage3DProxy object currently used for rendering.\n\t * @return A list of depth map textures for all supported lights.\n\t */\n\tpublic _iGetDepthMap(renderable:RenderableBase):TextureBase\n\t{\n\t\treturn this._textures[renderable.renderableOwner.id];\n\t}\n\n\t/**\n\t * Retrieves the depth map projection maps for all lights.\n\t * @param renderable The renderable for which to retrieve the projection maps.\n\t * @return A list of projection maps for all supported lights.\n\t */\n\tpublic _iGetProjection(renderable:RenderableBase):Matrix3D\n\t{\n\t\treturn this._projections[renderable.renderableOwner.id];\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic _iRender(renderable:RenderableBase, camera:Camera, viewProjection:Matrix3D)\n\t{\n\t\tvar matrix:Matrix3D;\n\t\tvar context:IContextGL = this._stage.context;\n\t\tvar len:number /*uint*/;\n\t\tvar light:LightBase;\n\t\tvar lights:Array<LightBase> = this._renderOwner.lightPicker.allPickedLights;\n\t\tvar rId:number = renderable.renderableOwner.id;\n\n\t\tif (!this._textures[rId])\n\t\t\tthis._textures[rId] = new Single2DTexture(new Image2D(this._textureSize, this._textureSize));\n\n\t\tif (!this._projections[rId])\n\t\t\tthis._projections[rId] = new Matrix3D();\n\n\t\tlen = lights.length;\n\n\t\t// local position = enough\n\t\tlight = lights[0];\n\n\t\tmatrix = light.iGetObjectProjectionMatrix(renderable.sourceEntity, camera, this._projections[rId]);\n\n\t\tthis._stage.setRenderTarget(this._textures[rId], true);\n\t\tcontext.clear(1.0, 1.0, 1.0);\n\t\tcontext.setProgramConstantsFromMatrix(ContextGLProgramType.VERTEX, 0, matrix, true);\n\t\tcontext.setProgramConstantsFromArray(ContextGLProgramType.FRAGMENT, 0, this._enc, 2);\n\n\t\tthis._stage.activateBuffer(0, renderable.getVertexData(TriangleSubGeometry.POSITION_DATA), renderable.getVertexOffset(TriangleSubGeometry.POSITION_DATA), TriangleSubGeometry.POSITION_FORMAT);\n\t\tthis._stage.activateBuffer(1, renderable.getVertexData(TriangleSubGeometry.NORMAL_DATA), renderable.getVertexOffset(TriangleSubGeometry.NORMAL_DATA), TriangleSubGeometry.NORMAL_FORMAT);\n\t\tcontext.drawTriangles(this._stage.getIndexBuffer(renderable.getIndexData()), 0, renderable.numTriangles);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic _iActivate(camera:Camera)\n\t{\n\t\tif (this._projectionTexturesInvalid)\n\t\t\tthis.updateProjectionTextures();\n\n\t\t// never scale\n\t\tsuper._iActivate(camera);\n\n\t\tthis._stage.context.setProgramConstantsFromArray(ContextGLProgramType.VERTEX, 4, this._polyOffset, 1);\n\t}\n}\n\nexport = SingleObjectDepthPass;"
  ],
  "sourceRoot": ""
}