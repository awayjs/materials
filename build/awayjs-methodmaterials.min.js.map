{
  "version": 3,
  "sources": [
    "node_modules/browserify/node_modules/browser-pack/_prelude.js",
    "awayjs-methodmaterials/lib/MethodMaterialMode.ts",
    "awayjs-methodmaterials.js",
    "awayjs-methodmaterials/lib/MethodMaterial.ts",
    "awayjs-methodmaterials/lib/data/MethodVO.ts",
    "awayjs-methodmaterials/lib/methods/AmbientBasicMethod.ts",
    "awayjs-methodmaterials/lib/methods/AmbientEnvMapMethod.ts",
    "awayjs-methodmaterials/lib/methods/CurveBasicMethod.ts",
    "awayjs-methodmaterials/lib/methods/DiffuseBasicMethod.ts",
    "awayjs-methodmaterials/lib/methods/DiffuseCelMethod.ts",
    "awayjs-methodmaterials/lib/methods/DiffuseCompositeMethod.ts",
    "awayjs-methodmaterials/lib/methods/DiffuseDepthMethod.ts",
    "awayjs-methodmaterials/lib/methods/DiffuseGradientMethod.ts",
    "awayjs-methodmaterials/lib/methods/DiffuseLightMapMethod.ts",
    "awayjs-methodmaterials/lib/methods/DiffuseSubSurfaceMethod.ts",
    "awayjs-methodmaterials/lib/methods/DiffuseWrapMethod.ts",
    "awayjs-methodmaterials/lib/methods/EffectAlphaMaskMethod.ts",
    "awayjs-methodmaterials/lib/methods/EffectColorMatrixMethod.ts",
    "awayjs-methodmaterials/lib/methods/EffectColorTransformMethod.ts",
    "awayjs-methodmaterials/lib/methods/EffectEnvMapMethod.ts",
    "awayjs-methodmaterials/lib/methods/EffectFogMethod.ts",
    "awayjs-methodmaterials/lib/methods/EffectFresnelEnvMapMethod.ts",
    "awayjs-methodmaterials/lib/methods/EffectLightMapMethod.ts",
    "awayjs-methodmaterials/lib/methods/EffectMethodBase.ts",
    "awayjs-methodmaterials/lib/methods/EffectRefractionEnvMapMethod.ts",
    "awayjs-methodmaterials/lib/methods/EffectRimLightMethod.ts",
    "awayjs-methodmaterials/lib/methods/LightingMethodBase.ts",
    "awayjs-methodmaterials/lib/methods/NormalBasicMethod.ts",
    "awayjs-methodmaterials/lib/methods/NormalHeightMapMethod.ts",
    "awayjs-methodmaterials/lib/methods/NormalSimpleWaterMethod.ts",
    "awayjs-methodmaterials/lib/methods/ShadingMethodBase.ts",
    "awayjs-methodmaterials/lib/methods/ShadowCascadeMethod.ts",
    "awayjs-methodmaterials/lib/methods/ShadowDitheredMethod.ts",
    "awayjs-methodmaterials/lib/methods/ShadowFilteredMethod.ts",
    "awayjs-methodmaterials/lib/methods/ShadowHardMethod.ts",
    "awayjs-methodmaterials/lib/methods/ShadowMapMethodBase.ts",
    "awayjs-methodmaterials/lib/methods/ShadowMethodBase.ts",
    "awayjs-methodmaterials/lib/methods/ShadowNearMethod.ts",
    "awayjs-methodmaterials/lib/methods/ShadowSoftMethod.ts",
    "awayjs-methodmaterials/lib/methods/SpecularAnisotropicMethod.ts",
    "awayjs-methodmaterials/lib/methods/SpecularBasicMethod.ts",
    "awayjs-methodmaterials/lib/methods/SpecularCelMethod.ts",
    "awayjs-methodmaterials/lib/methods/SpecularCompositeMethod.ts",
    "awayjs-methodmaterials/lib/methods/SpecularFresnelMethod.ts",
    "awayjs-methodmaterials/lib/methods/SpecularPhongMethod.ts",
    "awayjs-methodmaterials/lib/render/MethodMaterialRender.ts",
    "awayjs-methodmaterials/lib/render/passes/MethodPassMode.ts",
    "awayjs-methodmaterials/lib/render/passes/MethodPass.ts",
    "awayjs-methodmaterials/lib/render/passes/SingleObjectDepthPass.ts"
  ],
  "names": [
    "require",
    "e",
    "t",
    "n",
    "r",
    "s",
    "o",
    "u",
    "a",
    "i",
    "f",
    "Error",
    "code",
    "l",
    "exports",
    "call",
    "length",
    "awayjs-methodmaterials/lib/MethodMaterialMode",
    "module",
    "MethodMaterialMode",
    "SINGLE_PASS",
    "MULTI_PASS",
    "awayjs-methodmaterials/lib/MethodMaterial",
    "__extends",
    "this",
    "d",
    "b",
    "p",
    "hasOwnProperty",
    "__",
    "constructor",
    "prototype",
    "Image2D",
    "MaterialBase",
    "Single2DTexture",
    "TextureBase",
    "ContextGLCompareMode",
    "RenderPool",
    "AmbientBasicMethod",
    "DiffuseBasicMethod",
    "NormalBasicMethod",
    "SpecularBasicMethod",
    "MethodMaterialRender",
    "MethodMaterial",
    "_super",
    "textureColor",
    "smoothAlpha",
    "repeat",
    "mipmap",
    "_effectMethods",
    "Array",
    "_ambientMethod",
    "_diffuseMethod",
    "_normalMethod",
    "_specularMethod",
    "_depthCompareMode",
    "LESS_EQUAL",
    "_mode",
    "texture",
    "smooth",
    "color",
    "Number",
    "alpha",
    "iAddOwner",
    "addRenderable",
    "registerClass",
    "Object",
    "defineProperty",
    "get",
    "assetType",
    "enumerable",
    "configurable",
    "set",
    "value",
    "_pInvalidateRender",
    "copyFrom",
    "iRemoveOwner",
    "_shadowMethod",
    "addEffectMethod",
    "method",
    "push",
    "getEffectMethodAt",
    "index",
    "addEffectMethodAt",
    "splice",
    "removeEffectMethod",
    "indexOf",
    "normalMap",
    "gloss",
    "ambient",
    "specular",
    "ambientColor",
    "diffuseColor",
    "specularColor",
    "register",
    "awayjs-core/lib/data/Image2D",
    "undefined",
    "awayjs-display/lib/materials/MaterialBase",
    "awayjs-display/lib/textures/Single2DTexture",
    "awayjs-display/lib/textures/TextureBase",
    "awayjs-methodmaterials/lib/methods/AmbientBasicMethod",
    "awayjs-methodmaterials/lib/methods/DiffuseBasicMethod",
    "awayjs-methodmaterials/lib/methods/NormalBasicMethod",
    "awayjs-methodmaterials/lib/methods/SpecularBasicMethod",
    "awayjs-methodmaterials/lib/render/MethodMaterialRender",
    "awayjs-renderergl/lib/render/RenderPool",
    "awayjs-stagegl/lib/base/ContextGLCompareMode",
    "awayjs-methodmaterials/lib/data/MethodVO",
    "MethodVO",
    "useMethod",
    "reset",
    "iReset",
    "vertexConstantsIndex",
    "secondaryVertexConstantsIndex",
    "fragmentConstantsIndex",
    "secondaryFragmentConstantsIndex",
    "needsProjection",
    "needsView",
    "needsNormals",
    "needsTangents",
    "needsGlobalVertexPos",
    "needsGlobalFragmentPos",
    "ShadingMethodBase",
    "_color",
    "_alpha",
    "_colorR",
    "_colorG",
    "_colorB",
    "_ambient",
    "iInitVO",
    "shader",
    "methodVO",
    "uvDependencies",
    "iInitConstants",
    "updateColor",
    "m",
    "iGetFragmentCode",
    "targetReg",
    "registerCache",
    "sharedRegisters",
    "_iGetFragmentCode",
    "uvVarying",
    "alphaThreshold",
    "cutOffReg",
    "getFreeFragmentConstant",
    "ambientInputRegister",
    "iActivate",
    "stage",
    "activate",
    "fragmentConstantData",
    "data",
    "iSetRenderState",
    "renderable",
    "camera",
    "_setRenderState",
    "awayjs-methodmaterials/lib/methods/ShadingMethodBase",
    "awayjs-methodmaterials/lib/methods/AmbientEnvMapMethod",
    "AmbientEnvMapMethod",
    "regCache",
    "normalFragment",
    "awayjs-methodmaterials/lib/methods/CurveBasicMethod",
    "CurveBasicMethod",
    "textureVO",
    "LightingMethodBase",
    "_multiply",
    "_diffuseColor",
    "_ambientColor",
    "_diffuseR",
    "_diffuseG",
    "_diffuseB",
    "_ambientR",
    "_ambientG",
    "_ambientB",
    "iIsUsed",
    "numLights",
    "iInvalidateShaderProgram",
    "_texture",
    "getTextureVO",
    "dispose",
    "usesCommonData",
    "updateDiffuse",
    "updateAmbient",
    "iRemoveTexture",
    "iAddTexture",
    "diff",
    "multiply",
    "iCleanCompilationData",
    "_pTotalLightColorReg",
    "iGetFragmentPreLightingCode",
    "_pIsFirstLight",
    "addFragmentTempUsages",
    "getFreeFragmentVectorTemp",
    "iGetFragmentCodePerLight",
    "lightDirReg",
    "lightColReg",
    "commons",
    "usesLightFallOff",
    "_iModulateMethod",
    "removeFragmentTempUsage",
    "iGetFragmentCodePerProbe",
    "cubeMapReg",
    "weightRegister",
    "iGetFragmentPostLightingCode",
    "albedo",
    "shadowTarget",
    "pApplyShadow",
    "ambientColorRegister",
    "diffuseInputRegister",
    "ambientR",
    "ambientG",
    "ambientB",
    "awayjs-methodmaterials/lib/methods/LightingMethodBase",
    "awayjs-methodmaterials/lib/methods/DiffuseCelMethod",
    "DiffuseCompositeMethod",
    "DiffuseCelMethod",
    "levels",
    "baseMethod",
    "_this",
    "_smoothness",
    "clampDiffuse",
    "_levels",
    "_dataReg",
    "awayjs-methodmaterials/lib/methods/DiffuseCompositeMethod",
    "ShadingMethodEvent",
    "modulateMethod",
    "_onShaderInvalidatedDelegate",
    "event",
    "onShaderInvalidated",
    "pBaseMethod",
    "addEventListener",
    "SHADER_INVALIDATED",
    "removeEventListener",
    "owner",
    "iDeactivate",
    "iGetVertexCode",
    "awayjs-renderergl/lib/events/ShadingMethodEvent",
    "awayjs-methodmaterials/lib/methods/DiffuseDepthMethod",
    "DiffuseDepthMethod",
    "temp",
    "decReg",
    "awayjs-methodmaterials/lib/methods/DiffuseGradientMethod",
    "DiffuseGradientMethod",
    "gradient",
    "_gradient",
    "secondaryTextureVO",
    "awayjs-methodmaterials/lib/methods/DiffuseLightMapMethod",
    "DiffuseLightMapMethod",
    "lightMap",
    "blendMode",
    "useSecondaryUV",
    "_useSecondaryUV",
    "_lightMap",
    "secondaryUVDependencies",
    "_blendMode",
    "ADD",
    "MULTIPLY",
    "secondaryUVVarying",
    "awayjs-methodmaterials/lib/methods/DiffuseSubSurfaceMethod",
    "DiffuseSubSurfaceMethod",
    "depthMapSize",
    "depthMapOffset",
    "_translucency",
    "_scatterColor",
    "_scatterR",
    "_scatterG",
    "_scatterB",
    "scatterLight",
    "_scattering",
    "vertexConstantData",
    "_lightProjVarying",
    "_propReg",
    "_lightColorReg",
    "_colorReg",
    "_decReg",
    "_targetReg",
    "scatterColor",
    "lightProjection",
    "toTexRegister",
    "getFreeVertexVectorTemp",
    "getFreeVertexConstant",
    "getFreeVarying",
    "viewDirFragment",
    "_depthPass",
    "_iGetDepthMap",
    "_iGetProjection",
    "copyRawDataTo",
    "awayjs-methodmaterials/lib/methods/DiffuseWrapMethod",
    "DiffuseWrapMethod",
    "wrapFactor",
    "_wrapDataRegister",
    "_wrapFactor",
    "awayjs-methodmaterials/lib/methods/EffectAlphaMaskMethod",
    "EffectMethodBase",
    "EffectAlphaMaskMethod",
    "awayjs-methodmaterials/lib/methods/EffectMethodBase",
    "awayjs-methodmaterials/lib/methods/EffectColorMatrixMethod",
    "EffectColorMatrixMethod",
    "matrix",
    "_matrix",
    "colorMultReg",
    "colorOffsetReg",
    "awayjs-methodmaterials/lib/methods/EffectColorTransformMethod",
    "EffectColorTransformMethod",
    "_colorTransform",
    "colorOffsReg",
    "inv",
    "redMultiplier",
    "greenMultiplier",
    "blueMultiplier",
    "alphaMultiplier",
    "redOffset",
    "greenOffset",
    "blueOffset",
    "alphaOffset",
    "awayjs-methodmaterials/lib/methods/EffectEnvMapMethod",
    "EffectEnvMapMethod",
    "envMap",
    "_envMap",
    "_mask",
    "dataRegister",
    "temp2",
    "awayjs-methodmaterials/lib/methods/EffectFogMethod",
    "EffectFogMethod",
    "minDistance",
    "maxDistance",
    "fogColor",
    "_minDistance",
    "_maxDistance",
    "_fogColor",
    "_fogR",
    "_fogG",
    "_fogB",
    "fogData",
    "projectionFragment",
    "awayjs-methodmaterials/lib/methods/EffectFresnelEnvMapMethod",
    "EffectFresnelEnvMapMethod",
    "_fresnelPower",
    "_normalReflectance",
    "viewDirReg",
    "normalReg",
    "awayjs-methodmaterials/lib/methods/EffectLightMapMethod",
    "EffectLightMapMethod",
    "AbstractMethodError",
    "awayjs-core/lib/errors/AbstractMethodError",
    "awayjs-methodmaterials/lib/methods/EffectRefractionEnvMapMethod",
    "EffectRefractionEnvMapMethod",
    "refractionIndex",
    "dispersionR",
    "dispersionG",
    "dispersionB",
    "_dispersionR",
    "_dispersionG",
    "_dispersionB",
    "_useDispersion",
    "_refractionIndex",
    "useDispersion",
    "data2",
    "refractionDir",
    "refractionColor",
    "awayjs-methodmaterials/lib/methods/EffectRimLightMethod",
    "EffectRimLightMethod",
    "strength",
    "power",
    "blend",
    "_strength",
    "_power",
    "dataRegister2",
    "MIX",
    "_normalMap",
    "normalDependencies",
    "iOutputsTangentNormals",
    "bnm",
    "awayjs-methodmaterials/lib/methods/NormalHeightMapMethod",
    "NormalHeightMapMethod",
    "heightMap",
    "worldWidth",
    "worldHeight",
    "worldDepth",
    "_worldXYRatio",
    "_worldXZRatio",
    "image2D",
    "width",
    "height",
    "dataReg",
    "dataReg2",
    "awayjs-methodmaterials/lib/methods/NormalSimpleWaterMethod",
    "NormalSimpleWaterMethod",
    "secondaryNormalMap",
    "_water1OffsetX",
    "_water1OffsetY",
    "_water2OffsetX",
    "_water2OffsetY",
    "_secondaryNormalMap",
    "AssetBase",
    "_textures",
    "_owners",
    "_counts",
    "iUsesTangentSpace",
    "len",
    "dispatchEvent",
    "awayjs-core/lib/library/AssetBase",
    "awayjs-methodmaterials/lib/methods/ShadowCascadeMethod",
    "Event",
    "DirectionalLight",
    "ShadowMapMethodBase",
    "ShadowCascadeMethod",
    "shadowMethodBase",
    "castingLight",
    "_baseMethod",
    "_pCastingLight",
    "_cascadeShadowMapper",
    "shadowMapper",
    "CHANGE",
    "onCascadeChange",
    "tempVO",
    "depthMap",
    "fragmentData",
    "vertexData",
    "_cascadeProjections",
    "_depthMapCoordVaryings",
    "initProjectionsRegs",
    "numCascades",
    "globalPositionVertex",
    "planeDistanceReg",
    "planeDistances",
    "inQuad",
    "uvCoord",
    "uvProjection",
    "_iGetCascadeFragmentCode",
    "vertexIndex",
    "depth",
    "_pEpsilon",
    "k",
    "getDepthProjections",
    "fragmentIndex",
    "_pAlpha",
    "nearPlaneDistances",
    "_iNearPlaneDistances",
    "iActivateForCascade",
    "awayjs-core/lib/events/Event",
    "awayjs-display/lib/entities/DirectionalLight",
    "awayjs-methodmaterials/lib/methods/ShadowMapMethodBase",
    "awayjs-methodmaterials/lib/methods/ShadowDitheredMethod",
    "BitmapImage2D",
    "ShadowMethodBase",
    "ShadowDitheredMethod",
    "numSamples",
    "range",
    "_depthMapSize",
    "_grainUsages",
    "_grainTexture",
    "initGrainTexture",
    "_numSamples",
    "_range",
    "_grainBitmapImage2D",
    "vec",
    "step",
    "g",
    "Math",
    "random",
    "floor",
    "setArray",
    "rect",
    "_pGetPlanarFragmentCode",
    "customDataReg",
    "getSampleCode",
    "uvReg",
    "projectionReg",
    "_pDepthMapCoordReg",
    "addSample",
    "decodeRegister",
    "depthProjection",
    "targetRegister",
    "awayjs-core/lib/data/BitmapImage2D",
    "awayjs-methodmaterials/lib/methods/ShadowMethodBase",
    "awayjs-methodmaterials/lib/methods/ShadowFilteredMethod",
    "ShadowFilteredMethod",
    "size",
    "depthCol",
    "predicate",
    "awayjs-methodmaterials/lib/methods/ShadowHardMethod",
    "ShadowHardMethod",
    "_pGetPointFragmentCode",
    "epsReg",
    "posReg",
    "depthSampleCol",
    "lightDir",
    "globalPositionVarying",
    "castsShadows",
    "_pShadowMapper",
    "PointLight",
    "_pUsePoint",
    "_pGetPointVertexCode",
    "pGetPlanarVertexCode",
    "depthMapProj",
    "iDepthProjection",
    "pow",
    "fallOff",
    "pos",
    "scenePosition",
    "x",
    "y",
    "z",
    "awayjs-display/lib/entities/PointLight",
    "awayjs-methodmaterials/lib/methods/ShadowNearMethod",
    "ShadowNearMethod",
    "fadeRatio",
    "_fadeRatio",
    "_nearShadowMapper",
    "epsilon",
    "getFreeFragmentSingleTemp",
    "near",
    "projection",
    "far",
    "coverageRatio",
    "awayjs-methodmaterials/lib/methods/ShadowSoftMethod",
    "PoissonLookup",
    "ShadowSoftMethod",
    "_offsets",
    "getDistribution",
    "texRange",
    "offsets",
    "numRegs",
    "reg",
    "awayjs-core/lib/geom/PoissonLookup",
    "awayjs-methodmaterials/lib/methods/SpecularAnisotropicMethod",
    "SpecularAnisotropicMethod",
    "tangentVarying",
    "_pSpecularTexData",
    "_pSpecularDataRegister",
    "_gloss",
    "_specular",
    "_specularColor",
    "_iSpecularR",
    "_iSpecularG",
    "_iSpecularB",
    "updateSpecular",
    "bsm",
    "spec",
    "useSmoothTextures",
    "awayjs-methodmaterials/lib/methods/SpecularCelMethod",
    "SpecularCompositeMethod",
    "SpecularCelMethod",
    "specularCutOff",
    "_specularCutOff",
    "clampSpecular",
    "awayjs-methodmaterials/lib/methods/SpecularCompositeMethod",
    "awayjs-methodmaterials/lib/methods/SpecularFresnelMethod",
    "SpecularFresnelMethod",
    "basedOnSurface",
    "modulateSpecular",
    "_incidentLight",
    "awayjs-methodmaterials/lib/methods/SpecularPhongMethod",
    "SpecularPhongMethod",
    "BlendMode",
    "StaticLightPicker",
    "RenderBase",
    "MethodPassMode",
    "MethodPass",
    "pool",
    "material",
    "renderableClass",
    "_material",
    "lightPicker",
    "numLightProbes",
    "numDirectionalLights",
    "numPointLights",
    "numCastingDirectionalLights",
    "numCastingPointLights",
    "_pUpdateRender",
    "initPasses",
    "setBlendAndCompareModes",
    "_pClearPasses",
    "mode",
    "_casterLightPass",
    "_pAddPass",
    "_nonCasterLightPasses",
    "_pass",
    "numEffectMethods",
    "initEffectPass",
    "removeEffectPass",
    "shadowMethod",
    "initCasterLightPass",
    "removeCasterLightPass",
    "numNonCasters",
    "initNonCasterLightPasses",
    "removeNonCasterLightPasses",
    "forceSeparateMVP",
    "Boolean",
    "setBlendMode",
    "NORMAL",
    "depthCompareMode",
    "firstAdditiveIndex",
    "_pRequiresBlending",
    "EFFECTS",
    "LAYER",
    "alphaBlending",
    "colorTransform",
    "SUPER_SHADER",
    "preserveAlpha",
    "LIGHTING",
    "_renderableClass",
    "_stage",
    "diffuseMethod",
    "ambientMethod",
    "normalMethod",
    "specularMethod",
    "_pRemovePass",
    "pass",
    "numDirLights",
    "dirLightOffset",
    "pointLightOffset",
    "probeOffset",
    "includeCasters",
    "directionalLightsOffset",
    "pointLightsOffset",
    "lightProbesOffset",
    "effectMethod",
    "max",
    "removeEffectMethodAt",
    "awayjs-core/lib/data/BlendMode",
    "awayjs-display/lib/materials/lightpickers/StaticLightPicker",
    "awayjs-methodmaterials/lib/render/passes/MethodPass",
    "awayjs-methodmaterials/lib/render/passes/MethodPassMode",
    "awayjs-renderergl/lib/render/RenderBase",
    "PassMode",
    "LightSources",
    "LightingShader",
    "ShaderBase",
    "PassBase",
    "render",
    "renderOwner",
    "_maxLights",
    "_includeCasters",
    "_iMethodVOs",
    "_numEffectDependencies",
    "_onLightsChangeDelegate",
    "onLightsChange",
    "_onMethodInvalidatedDelegate",
    "onMethodInvalidated",
    "_shader",
    "_updateShader",
    "_updateLights",
    "_lightPicker",
    "enableLightFallOff",
    "diffuseLightSources",
    "specularLightSources",
    "_iInitConstantData",
    "colorTransformMethod",
    "_iColorTransformMethodVO",
    "_removeDependency",
    "_addDependency",
    "effectsDependency",
    "invalidatePass",
    "hasEffectMethod",
    "getDependencyForMethod",
    "_iNormalMethodVO",
    "_iAmbientMethodVO",
    "_iShadowMethodVO",
    "_iDiffuseMethodVO",
    "_iSpecularMethodVO",
    "_iActivate",
    "_iRender",
    "viewProjection",
    "_iDeactivate",
    "_iIncludeDependencies",
    "usesFragmentAnimation",
    "useAlphaPremultiplied",
    "usesBlending",
    "setupAndCountDependencies",
    "usesTangentSpace",
    "outputsNormals",
    "outputsTangentNormals",
    "usesProbes",
    "viewDirDependencies",
    "globalPosDependencies",
    "usesLights",
    "usesGlobalPosFragment",
    "projectionDependencies",
    "tangentDependencies",
    "_iGetPreLightingVertexCode",
    "_iGetPreLightingFragmentCode",
    "shadedTarget",
    "_iGetPerLightDiffuseFragmentCode",
    "diffuseColorReg",
    "_iGetPerLightSpecularFragmentCode",
    "specularColorReg",
    "_iGetPerProbeDiffuseFragmentCode",
    "texReg",
    "weightReg",
    "_iGetPerProbeSpecularFragmentCode",
    "_iGetPostLightingVertexCode",
    "_iGetPostLightingFragmentCode",
    "_iGetNormalVertexCode",
    "_iGetNormalFragmentCode",
    "removeVertexTempUsage",
    "_iGetVertexCode",
    "sharedReg",
    "alphaReg",
    "_iUsesShadows",
    "castingDirectionalLights",
    "castingPointLights",
    "_iUsesSpecular",
    "_iUsesDiffuse",
    "numDirectionalLightsOld",
    "numPointLightsOld",
    "numLightProbesOld",
    "calculateNumDirectionalLights",
    "calculateNumPointLights",
    "calculateNumProbes",
    "min",
    "numFree",
    "numChannels",
    "PROBES",
    "awayjs-display/lib/materials/LightSources",
    "awayjs-renderergl/lib/render/passes/PassBase",
    "awayjs-renderergl/lib/shaders/LightingShader",
    "awayjs-renderergl/lib/shaders/ShaderBase",
    "awayjs-methodmaterials/lib/render/passes/SingleObjectDepthPass",
    "Matrix3D",
    "ContextGLDrawMode",
    "ContextGLProgramType",
    "SubGeometryVOPool",
    "SingleObjectDepthPass",
    "_textureSize",
    "_polyOffset",
    "Float32Array",
    "_projectionTexturesInvalid",
    "_subGeometryVOPool",
    "getPool",
    "key",
    "updateProjectionTextures",
    "_projections",
    "renderableOwner",
    "id",
    "context",
    "light",
    "lights",
    "_renderOwner",
    "allPickedLights",
    "rId",
    "iGetObjectProjectionMatrix",
    "sourceEntity",
    "setRenderTarget",
    "clear",
    "setProgramConstantsFromMatrix",
    "VERTEX",
    "setProgramConstantsFromArray",
    "FRAGMENT",
    "_enc",
    "subGeometryVO",
    "subGeom",
    "subGeometry",
    "activateVertexBufferVO",
    "positions",
    "normals",
    "getIndexBufferVO",
    "draw",
    "TRIANGLES",
    "numElements",
    "awayjs-core/lib/geom/Matrix3D",
    "awayjs-renderergl/lib/vos/SubGeometryVOPool",
    "awayjs-stagegl/lib/base/ContextGLDrawMode",
    "awayjs-stagegl/lib/base/ContextGLProgramType"
  ],
  "mappings": "AAAAA,QAAA,QAAAC,GAAAC,EAAAC,EAAAC,GAAA,QAAAC,GAAAC,EAAAC,GAAA,IAAAJ,EAAAG,GAAA,CAAA,IAAAJ,EAAAI,GAAA,CAAA,GAAAE,SAAAR,UAAA,YAAAA,OAAA,KAAAO,GAAAC,EAAA,MAAAA,GAAAF,GAAA,EAAA,IAAAG,EAAA,MAAAA,GAAAH,GAAA,EAAA,IAAAI,GAAA,GAAAC,OAAA,uBAAAL,EAAA,IAAA,MAAAI,GAAAE,KAAA,mBAAAF,EAAA,GAAAG,GAAAV,EAAAG,IAAAQ,WAAAZ,GAAAI,GAAA,GAAAS,KAAAF,EAAAC,QAAA,SAAAb,GAAA,GAAAE,GAAAD,EAAAI,GAAA,GAAAL,EAAA,OAAAI,GAAAF,EAAAA,EAAAF,IAAAY,EAAAA,EAAAC,QAAAb,EAAAC,EAAAC,EAAAC,GAAA,MAAAD,GAAAG,GAAAQ,QAAA,GAAAL,SAAAT,UAAA,YAAAA,OAAA,KAAA,GAAAM,GAAA,EAAAA,EAAAF,EAAAY,OAAAV,IAAAD,EAAAD,EAAAE,GAAA,OAAAD,KAAAY,iDAAA,SAAAjB,EAAAkB,EAAAJ,GCAA,GAAMK,GAAkB,WAAxB,QAAMA,MAKSA,EAAAC,YAAqB,YAKrBD,GAAAE,WAAoB,WACnC,OAAAF,KAEAD,GAA4BJ,QAAnBK,OCGHG,6CAA6C,SAAStB,EAAQkB,EAAOJ,GAC3E,GAAIS,GAAYC,KAAKD,WAAa,SAAUE,EAAGC,GAC3C,IAAK,GAAIC,KAAKD,GAAG,GAAIA,EAAEE,eAAeD,GAAIF,EAAEE,GAAKD,EAAEC,EACnD,SAASE,KAAOL,KAAKM,YAAcL,EACnCI,EAAGE,UAAYL,EAAEK,SACjBN,GAAEM,UAAY,GAAIF,GCpBtB,IAAOG,GAAOhC,EAAgB,+BAK9B,IAAOiC,GAAYjC,EAAe,4CAElC,IAAOkC,GAAelC,EAAc,8CACpC,IAAOmC,GAAWnC,EAAe,0CAEjC,IAAOoC,GAAoBpC,EAAa,+CAExC,IAAOqC,GAAUrC,EAAe,0CAEhC,IAAOmB,GAAkBnB,EAAa,gDACtC,IAAOsC,GAAkBtC,EAAa,wDACtC,IAAOuC,GAAkBvC,EAAa,wDAEtC,IAAOwC,GAAiBxC,EAAa,uDAErC,IAAOyC,GAAmBzC,EAAa,yDACvC,IAAO0C,GAAoB1C,EAAa,yDDiBxC,ICXM2C,GAAc,SAAAC,GAASrB,EAAvBoB,EAAcC,EA0CnB,SA1CKD,GA0COE,EAAyBC,EAAwBC,EAAwBC,GAAzE,GAAAH,QAAA,GAAuB,CAAvBA,EAAA,KAAyB,GAAAC,QAAA,GAAsB,CAAtBA,EAAA,KAAwB,GAAAC,QAAA,GAAsB,CAAtBA,EAAA,MAAwB,GAAAC,QAAA,GAAqB,CAArBA,EAAA,KAEpFJ,EAAA7B,KAAAS,KAxCOA,MAAAyB,eAAyC,GAAIC,MAG7C1B,MAAA2B,eAAoC,GAAIb,EAExCd,MAAA4B,eAAoC,GAAIb,EACxCf,MAAA6B,cAAkC,GAAIb,EACtChB,MAAA8B,gBAAsC,GAAIb,EAG1CjB,MAAA+B,kBAA2BnB,EAAqBoB,UAgCvDhC,MAAKiC,MAAQtC,EAAmBC,WAEhC,IAAIyB,YAAwBb,GAC3Ba,EAAe,GAAIX,GAAgBW,EAEpC,IAAIA,YAAwBV,GAAa,CACxCX,KAAKkC,QAAwBb,CAE7BrB,MAAKmC,OAAUb,GAAe,KAAO,KAAO,KAC5CtB,MAAKuB,OAASA,CACdvB,MAAKwB,OAASA,MACR,CACNxB,KAAKoC,MAASf,GAAgB,KAAO,SAAWgB,OAAOhB,EACvDrB,MAAKsC,MAAShB,GAAe,KAAO,EAAIe,OAAOf,GAIhDtB,KAAK2B,eAAeY,UAAUvC,KAC9BA,MAAK4B,eAAeW,UAAUvC,KAC9BA,MAAK6B,cAAcU,UAAUvC,KAC7BA,MAAK8B,gBAAgBS,UAAUvC,MAhDjBmB,EAAAqB,cAAf,WAEC3B,EAAW4B,cAAcvB,EAAsBC,GAMhDuB,QAAAC,eAAWxB,EAAAZ,UAAA,aDyBJqC,ICzBP,WAEC,MAAOzB,GAAe0B,WD0BhBC,WAAY,KACZC,aAAc,MCerBL,QAAAC,eAAWxB,EAAAZ,UAAA,QDZJqC,ICYP,WAEC,MAAO5C,MAAKiC,ODXNe,ICcP,SAAgBC,GAEf,GAAIjD,KAAKiC,OAASgB,EACjB,MAEDjD,MAAKiC,MAAQgB,CAEbjD,MAAKkD,sBDfCJ,WAAY,KACZC,aAAc,MCuBrBL,QAAAC,eAAWxB,EAAAZ,UAAA,oBDfJqC,ICeP,WAEC,MAAO5C,MAAK+B,mBDdNiB,ICiBP,SAA4BC,GAE3B,GAAIjD,KAAK+B,mBAAqBkB,EAC7B,MAEDjD,MAAK+B,kBAAoBkB,CAEzBjD,MAAKkD,sBDlBCJ,WAAY,KACZC,aAAc,MCuBrBL,QAAAC,eAAWxB,EAAAZ,UAAA,kBDjBJqC,ICiBP,WAEC,MAAO5C,MAAK4B,eAAeM,SDhBrBc,ICmBP,SAA0BC,GAEzBjD,KAAK4B,eAAeM,QAAUe,GDlBxBH,WAAY,KACZC,aAAc,MCuBrBL,QAAAC,eAAWxB,EAAAZ,UAAA,iBDjBJqC,ICiBP,WAEC,MAAO5C,MAAK2B,gBDhBNqB,ICmBP,SAAyBC,GAExB,GAAIjD,KAAK2B,gBAAkBsB,EAC1B,MAED,IAAIA,GAASjD,KAAK2B,eACjBsB,EAAME,SAASnD,KAAK2B,eAErB,IAAI3B,KAAK2B,eACR3B,KAAK2B,eAAeyB,aAAapD,KAElCA,MAAK2B,eAAiBsB,CAEtB,IAAIjD,KAAK2B,eACR3B,KAAK2B,eAAeY,UAAUvC,KAE/BA,MAAKkD,sBDvBCJ,WAAY,KACZC,aAAc,MC4BrBL,QAAAC,eAAWxB,EAAAZ,UAAA,gBDtBJqC,ICsBP,WAEC,MAAO5C,MAAKqD,eDrBNL,ICwBP,SAAwBC,GAEvB,GAAIjD,KAAKqD,eAAiBJ,EACzB,MAED,IAAIA,GAASjD,KAAKqD,cACjBJ,EAAME,SAASnD,KAAKqD,cAErB,IAAIrD,KAAKqD,cACRrD,KAAKqD,cAAcD,aAAapD,KAEjCA,MAAKqD,cAAgBJ,CAErB,IAAIjD,KAAKqD,cACRrD,KAAKqD,cAAcd,UAAUvC,KAE9BA,MAAKkD,sBD5BCJ,WAAY,KACZC,aAAc,MCiCrBL,QAAAC,eAAWxB,EAAAZ,UAAA,iBD3BJqC,IC2BP,WAEC,MAAO5C,MAAK4B,gBD1BNoB,IC6BP,SAAyBC,GAExB,GAAIjD,KAAK4B,gBAAkBqB,EAC1B,MAED,IAAIA,GAASjD,KAAK4B,eACjBqB,EAAME,SAASnD,KAAK4B,eAErB,IAAI5B,KAAK4B,eACR5B,KAAK4B,eAAewB,aAAapD,KAElCA,MAAK4B,eAAiBqB,CAEtB,IAAIjD,KAAK4B,eACR5B,KAAK4B,eAAeW,UAAUvC,KAE/BA,MAAKkD,sBDjCCJ,WAAY,KACZC,aAAc,MCsCrBL,QAAAC,eAAWxB,EAAAZ,UAAA,kBDhCJqC,ICgCP,WAEC,MAAO5C,MAAK8B,iBD/BNkB,ICkCP,SAA0BC,GAEzB,GAAIjD,KAAK8B,iBAAmBmB,EAC3B,MAED,IAAIA,GAASjD,KAAK8B,gBACjBmB,EAAME,SAASnD,KAAK8B,gBAErB,IAAI9B,KAAK8B,gBACR9B,KAAK8B,gBAAgBsB,aAAapD,KAEnCA,MAAK8B,gBAAkBmB,CAEvB,IAAIjD,KAAK8B,gBACR9B,KAAK8B,gBAAgBS,UAAUvC,KAEhCA,MAAKkD,sBDtCCJ,WAAY,KACZC,aAAc,MC2CrBL,QAAAC,eAAWxB,EAAAZ,UAAA,gBDrCJqC,ICqCP,WAEC,MAAO5C,MAAK6B,eDpCNmB,ICuCP,SAAwBC,GAEvB,GAAIjD,KAAK6B,eAAiBoB,EACzB,MAED,IAAIA,GAASjD,KAAK6B,cACjBoB,EAAME,SAASnD,KAAK6B,cAErB,IAAI7B,KAAK6B,cACR7B,KAAK6B,cAAcuB,aAAapD,KAEjCA,MAAK6B,cAAgBoB,CAErB,IAAIjD,KAAK6B,cACR7B,KAAK6B,cAAcU,UAAUvC,KAE9BA,MAAKkD,sBD3CCJ,WAAY,KACZC,aAAc,MC6CrBL,QAAAC,eAAWxB,EAAAZ,UAAA,oBD1CJqC,IC0CP,WAEC,MAAO5C,MAAKyB,eAAejC,QDzCrBsD,WAAY,KACZC,aAAc,MCgDd5B,GAAAZ,UAAA+C,gBAAP,SAAuBC,GAEtBA,EAAOhB,UAAUvC,KAEjBA,MAAKyB,eAAe+B,KAAKD,EAEzBvD,MAAKkD,qBAQC/B,GAAAZ,UAAAkD,kBAAP,SAAyBC,GAExB,MAAO1D,MAAKyB,eAAeiC,GAQrBvC,GAAAZ,UAAAoD,kBAAP,SAAyBJ,EAAyBG,GAEjDH,EAAOhB,UAAUvC,KAEjBA,MAAKyB,eAAemC,OAAOF,EAAO,EAAGH,EAErCvD,MAAKkD,qBAOC/B,GAAAZ,UAAAsD,mBAAP,SAA0BN,GAEzBA,EAAOH,aAAapD,KAEpBA,MAAKyB,eAAemC,OAAO5D,KAAKyB,eAAeqC,QAAQP,GAAS,EAEhEvD,MAAKkD,qBAONR,QAAAC,eAAWxB,EAAAZ,UAAA,aDtDJqC,ICsDP,WAEC,MAAO5C,MAAK6B,cAAckC,WDrDpBf,ICwDP,SAAqBC,GAEpBjD,KAAK6B,cAAckC,UAAYd,GDvDzBH,WAAY,KACZC,aAAc,MC8DrBL,QAAAC,eAAWxB,EAAAZ,UAAA,eDtDJqC,ICsDP,WAEC,MAAO5C,MAAK8B,gBAAgBI,SDrDtBc,ICwDP,SAAuBC,GAEtBjD,KAAK8B,gBAAgBI,QAAUe,GDvDzBH,WAAY,KACZC,aAAc,MC4DrBL,QAAAC,eAAWxB,EAAAZ,UAAA,SDtDJqC,ICsDP,WAEC,MAAO5C,MAAK8B,gBAAgBkC,ODrDtBhB,ICwDP,SAAiBC,GAEhBjD,KAAK8B,gBAAgBkC,MAAQf,GDvDvBH,WAAY,KACZC,aAAc,MC4DrBL,QAAAC,eAAWxB,EAAAZ,UAAA,WDtDJqC,ICsDP,WAEC,MAAO5C,MAAK2B,eAAesC,SDrDrBjB,ICwDP,SAAmBC,GAElBjD,KAAK2B,eAAesC,QAAUhB,GDvDxBH,WAAY,KACZC,aAAc,MC4DrBL,QAAAC,eAAWxB,EAAAZ,UAAA,YDtDJqC,ICsDP,WAEC,MAAO5C,MAAK8B,gBAAgBoC,UDrDtBlB,ICwDP,SAAoBC,GAEnBjD,KAAK8B,gBAAgBoC,SAAWjB,GDvD1BH,WAAY,KACZC,aAAc,MC4DrBL,QAAAC,eAAWxB,EAAAZ,UAAA,gBDtDJqC,ICsDP,WAEC,MAAO5C,MAAK4B,eAAeuC,cDrDrBnB,ICwDP,SAAwBC,GAEvBjD,KAAK4B,eAAeuC,aAAelB,GDvD7BH,WAAY,KACZC,aAAc,MC4DrBL,QAAAC,eAAWxB,EAAAZ,UAAA,gBDtDJqC,ICsDP,WAEC,MAAO5C,MAAK4B,eAAewC,cDrDrBpB,ICwDP,SAAwBC,GAEvBjD,KAAK4B,eAAewC,aAAenB,GDvD7BH,WAAY,KACZC,aAAc,MC4DrBL,QAAAC,eAAWxB,EAAAZ,UAAA,iBDtDJqC,ICsDP,WAEC,MAAO5C,MAAK8B,gBAAgBuC,eDrDtBrB,ICwDP,SAAyBC,GAExBjD,KAAK8B,gBAAgBuC,cAAgBpB,GDvD/BH,WAAY,KACZC,aAAc,MCtWP5B,GAAA0B,UAAmB,4BAclB1B,GAAAmD,SAAWnD,EAAeqB,eAgZ1C,OAAArB,IAha6BV,EAka7Bf,GAAwBJ,QAAf6B,IDlDNoD,+BAA+BC,UAAUC,4CAA4CD,UAAUE,8CAA8CF,UAAUG,0CAA0CH,UAAU/E,gDAAgD,gDAAgDmF,wDAAwD,wDAAwDC,wDAAwD,wDAAwDC,uDAAuD,uDAAuDC,yDAAyD,yDAAyDC,yDAAyD,yDAAyDC,0CAA0CT,UAAUU,+CAA+CV,YAAYW,4CAA4C,SAAS3G,EAAQkB,EAAOJ,GAKnhC,GEzYM8F,GAAQ,WAwBb,QAxBKA,GAwBO7B,GAtBLvD,KAAAqF,UAAoB,IAwB1BrF,MAAKuD,OAASA,EAMR6B,EAAA7E,UAAA+E,MAAP,WAECtF,KAAKuD,OAAOgC,QAEZvF,MAAKwF,sBAAwB,CAC7BxF,MAAKyF,+BAAiC,CACtCzF,MAAK0F,wBAA0B,CAC/B1F,MAAK2F,iCAAmC,CAExC3F,MAAK4F,gBAAkB,KACvB5F,MAAK6F,UAAY,KACjB7F,MAAK8F,aAAe,KACpB9F,MAAK+F,cAAgB,KACrB/F,MAAKgG,qBAAuB,KAC5BhG,MAAKiG,uBAAyB,MAEhC,OAAAb,KAEkB1F,GAAAJ,QAAT8F,OFmXHR,yDAAyD,SAASpG,EAAQkB,EAAOJ,GACvF,GAAIS,GAAYC,KAAKD,WAAa,SAAUE,EAAGC,GAC3C,IAAK,GAAIC,KAAKD,GAAG,GAAIA,EAAEE,eAAeD,GAAIF,EAAEE,GAAKD,EAAEC,EACnD,SAASE,KAAOL,KAAKM,YAAcL,EACnCI,EAAGE,UAAYL,EAAEK,SACjBN,GAAEM,UAAY,GAAIF,GGvatB,IAAO6F,GAAiB1H,EAAc,uDH6atC,IGxaMsC,GAAkB,SAAAM,GAASrB,EAA3Be,EAAkBM,EAcvB,SAdKN,KAgBJM,EAAA7B,KAAAS,KAdOA,MAAAmG,OAAgB,QAChBnG,MAAAoG,OAAgB,CAEhBpG,MAAAqG,QAAiB,CACjBrG,MAAAsG,QAAiB,CACjBtG,MAAAuG,QAAiB,CAEjBvG,MAAAwG,SAAkB,EAanB1F,EAAAP,UAAAkG,QAAP,SAAeC,EAAmBC,GAEjC,GAAID,EAAOxE,QACVwE,EAAOE,iBAMF9F,GAAAP,UAAAsG,eAAP,SAAsBH,EAAmBC,GAExC,IAAKD,EAAOxE,QAAS,CACpBlC,KAAKmG,OAASO,EAAOtE,KACrBpC,MAAK8G,eAOPpE,QAAAC,eAAW7B,EAAAP,UAAA,WHgaJqC,IGhaP,WAEC,MAAO5C,MAAKwG,UHiaNxD,IG9ZP,SAAmBC,GAElB,GAAIjD,KAAKwG,UAAYvD,EACpB,MAEDjD,MAAKwG,SAAWvD,CAEhBjD,MAAK8G,eH6ZChE,WAAY,KACZC,aAAc,MGxZrBL,QAAAC,eAAW7B,EAAAP,UAAA,SH8ZJqC,IG9ZP,WAEC,MAAO5C,MAAKoG,QH+ZNpD,IG5ZP,SAAiBC,GAEhB,GAAIjD,KAAKoG,QAAUnD,EAClB,MAEDjD,MAAKoG,OAASnD,CAEdjD,MAAK8G,eH2ZChE,WAAY,KACZC,aAAc,MGtZdjC,GAAAP,UAAA4C,SAAP,SAAgBI,GAEf,GAAIwD,GAAQxD,CACZ,IAAIrD,GAA4C6G,EAM1CjG,GAAAP,UAAAyG,iBAAP,SAAwBN,EAAmBC,EAAmBM,EAAiCC,EAAmCC,GAEjI,GAAI/H,GAAc,EAElB,IAAIsH,EAAOxE,QAAS,CACnB9C,GAAQsH,EAAOxE,QAAQkF,kBAAkBV,EAAQO,EAAWC,EAAeC,EAAiBA,EAAgBE,UAE5G,IAAIX,EAAOY,eAAiB,EAAG,CAC9B,GAAIC,GAAkCL,EAAcM,yBACpDb,GAASjB,uBAAyB6B,EAAU7D,MAAM,CAElDtE,IAAQ,OAAS6H,EAAY,OAASA,EAAY,OAASM,EAAY,OACtE,OAASN,EAAY,OACrB,OAASA,EAAY,OAASA,EAAY,OAASM,EAAY,YAG3D,CACN,GAAIE,GAA6CP,EAAcM,yBAC/Db,GAASjB,uBAAyB+B,EAAqB/D,MAAM,CAE7DtE,IAAQ,OAAS6H,EAAY,KAAOQ,EAAuB,KAG5D,MAAOrI,GAMD0B,GAAAP,UAAAmH,UAAP,SAAiBhB,EAAmBC,EAAmBgB,GAEtD,GAAIjB,EAAOxE,QAAS,CACnBwE,EAAOxE,QAAQ0F,SAASlB,EAExB,IAAIA,EAAOY,eAAiB,EAC3BZ,EAAOmB,qBAAqBlB,EAASjB,wBAA0BgB,EAAOY,mBACjE,CACN,GAAI5D,GAAeiD,EAASjB,sBAC5B,IAAIoC,GAAoBpB,EAAOmB,oBAC/BC,GAAKpE,GAAS1D,KAAKqG,OACnByB,GAAKpE,EAAQ,GAAK1D,KAAKsG,OACvBwB,GAAKpE,EAAQ,GAAK1D,KAAKuG,OACvBuB,GAAKpE,EAAQ,GAAK1D,KAAKoG,QAIlBtF,GAAAP,UAAAwH,gBAAP,SAAuBrB,EAAmBC,EAAmBqB,EAA2BL,EAAaM,GAEpG,GAAIvB,EAAOxE,QACVwE,EAAOxE,QAAQgG,gBAAgBF,EAAYtB,GAMrC5F,GAAAP,UAAAuG,YAAR,WAEC9G,KAAKqG,SAAYrG,KAAKmG,QAAU,GAAM,KAAM,IAAKnG,KAAKwG,QACtDxG,MAAKsG,SAAYtG,KAAKmG,QAAU,EAAK,KAAM,IAAKnG,KAAKwG,QACrDxG,MAAKuG,SAAWvG,KAAKmG,OAAS,KAAM,IAAKnG,KAAKwG,SAEhD,OAAA1F,IApJiCoF,EAsJjCxG,GAA4BJ,QAAnBwB,IH6YNqH,uDAAuD,yDAAyDC,0DAA0D,SAAS5J,EAAQkB,EAAOJ,GACrM,GAAIS,GAAYC,KAAKD,WAAa,SAAUE,EAAGC,GAC3C,IAAK,GAAIC,KAAKD,GAAG,GAAIA,EAAEE,eAAeD,GAAIF,EAAEE,GAAKD,EAAEC,EACnD,SAASE,KAAOL,KAAKM,YAAcL,EACnCI,EAAGE,UAAYL,EAAEK,SACjBN,GAAEM,UAAY,GAAIF,GIljBtB,IAAOS,GAAkBtC,EAAc,wDJyjBvC,IInjBM6J,GAAmB,SAAAjH,GAASrB,EAA5BsI,EAAmBjH,EAOxB,SAPKiH,KASJjH,EAAA7B,KAAAS,MAMMqI,EAAA9H,UAAAkG,QAAP,SAAeC,EAAmBC,GAEjCA,EAASb,aAAe,KAMlBuC,GAAA9H,UAAAyG,iBAAP,SAAwBN,EAAmBC,EAAmBM,EAAiCqB,EAA8BnB,GAE5H,MAAOT,GAAOxE,QAAQkF,kBAAkBV,EAAQO,EAAWqB,EAAUnB,EAAiBA,EAAgBoB,gBAExG,OAAAF,IA3BkCvH,EA6BLpB,GAAAJ,QAApB+I,IJgjBNzD,wDAAwD,0DAA0D4D,uDAAuD,SAAShK,EAAQkB,EAAOJ,GACpM,GAAIS,GAAYC,KAAKD,WAAa,SAAUE,EAAGC,GAC3C,IAAK,GAAIC,KAAKD,GAAG,GAAIA,EAAEE,eAAeD,GAAIF,EAAEE,GAAKD,EAAEC,EACnD,SAASE,KAAOL,KAAKM,YAAcL,EACnCI,EAAGE,UAAYL,EAAEK,SACjBN,GAAEM,UAAY,GAAIF,GKnlBtB,IAAO6F,GAAiB1H,EAAc,uDLylBtC,IKplBMiK,GAAgB,SAAArH,GAASrB,EAAzB0I,EAAgBrH,EAcrB,SAdKqH,KAgBJrH,EAAA7B,KAAAS,KAdOA,MAAAmG,OAAgB,QAChBnG,MAAAoG,OAAgB,CAEhBpG,MAAAqG,QAAiB,CACjBrG,MAAAsG,QAAiB,CACjBtG,MAAAuG,QAAiB,CAEjBvG,MAAAwG,SAAkB,EAanBiC,EAAAlI,UAAAkG,QAAP,SAAeC,EAAmBC,GAEjC,GAAID,EAAOxE,QACVwE,EAAOE,iBAMF6B,GAAAlI,UAAAsG,eAAP,SAAsBH,EAAmBC,GAExC,IAAKD,EAAOxE,QAAS,CACpBlC,KAAKmG,OAASO,EAAOtE,KACrBpC,MAAK8G,eAOPpE,QAAAC,eAAW8F,EAAAlI,UAAA,WL4kBJqC,IK5kBP,WAEC,MAAO5C,MAAKwG,UL6kBNxD,IK1kBP,SAAmBC,GAElB,GAAIjD,KAAKwG,UAAYvD,EACpB,MAEDjD,MAAKwG,SAAWvD,CAEhBjD,MAAK8G,eLykBChE,WAAY,KACZC,aAAc,MKpkBrBL,QAAAC,eAAW8F,EAAAlI,UAAA,SL0kBJqC,IK1kBP,WAEC,MAAO5C,MAAKoG,QL2kBNpD,IKxkBP,SAAiBC,GAEhB,GAAIjD,KAAKoG,QAAUnD,EAClB,MAEDjD,MAAKoG,OAASnD,CAEdjD,MAAK8G,eLukBChE,WAAY,KACZC,aAAc,MKlkBd0F,GAAAlI,UAAA4C,SAAP,SAAgBI,GAEf,GAAIwD,GAAQxD,CACZ,IAAIrD,GAAwC6G,EAWnC0B,GAAAlI,UAAAyG,iBAAP,SAAwBN,EAAmBC,EAAmBM,EAAiCC,EAAmCC,GAEpI,GAAI/H,GAAc,EAClB,IAAIqI,EAEJ,IAAIf,EAAOxE,QAAS,CACnB9C,GAAQsH,EAAOxE,QAAQkF,kBAAkBV,EAAQO,EAAWC,EAAeC,EAAiBA,EAAgBE,UAE5G,IAAIX,EAAOY,eAAiB,EAAG,CAC9B,GAAIC,GAAkCL,EAAcM,yBACpDb,GAASjB,uBAAyB6B,EAAU7D,MAAM,CAElDtE,IAAQ,OAAS6H,EAAY,OAASA,EAAY,OAASM,EAAY,OACtE,OAASN,EAAY,OACrB,OAASA,EAAY,OAASA,EAAY,OAASM,EAAY,YAG3D,CACNE,EAAuBP,EAAcM,yBACrCb,GAASjB,uBAAyB+B,EAAqB/D,MAAM,CAE7DtE,IAAQ,OAAS6H,EAAY,KAAOQ,EAAuB,KAEtDrI,EAAO,OAAS6H,EAAY,KAAOE,EAAgBE,UAAY,IACrE,OAAOjI,GAMDqJ,GAAAlI,UAAAmH,UAAP,SAAiBhB,EAAmBC,EAAmBgB,GAEtD,GAAIjB,EAAOxE,QAAS,CACnBwE,EAAOxE,QAAQ0F,SAASlB,EAExB,IAAIA,EAAOY,eAAiB,EAC3BZ,EAAOmB,qBAAqBlB,EAASjB,wBAA0BgB,EAAOY,mBACjE,CACN,GAAI5D,GAAeiD,EAASjB,sBAC5B,IAAIoC,GAAoBpB,EAAOmB,oBAC/BC,GAAKpE,GAAS1D,KAAKqG,OACnByB,GAAKpE,EAAQ,GAAK1D,KAAKsG,OACvBwB,GAAKpE,EAAQ,GAAK1D,KAAKuG,OACvBuB,GAAKpE,EAAQ,GAAK1D,KAAKoG,QAIlBqC,GAAAlI,UAAAwH,gBAAP,SAAuBrB,EAAmBC,EAAmBqB,EAA2BL,EAAaM,GAEpG,GAAIvB,EAAOxE,QACVyE,EAAS+B,UAAUR,gBAAgBF,EAAYtB,GAMzC+B,GAAAlI,UAAAuG,YAAR,WAEC9G,KAAKqG,SAAYrG,KAAKmG,QAAU,GAAM,KAAM,IAAKnG,KAAKwG,QACtDxG,MAAKsG,SAAYtG,KAAKmG,QAAU,EAAK,KAAM,IAAKnG,KAAKwG,QACrDxG,MAAKuG,SAAWvG,KAAKmG,OAAS,KAAM,IAAKnG,KAAKwG,SAEhD,OAAAiC,IA1J+BvC,EA2J/BxG,GAA0BJ,QAAjBmJ,IL2jBNN,uDAAuD,yDAAyDtD,yDAAyD,SAASrG,EAAQkB,EAAOJ,GACpM,GAAIS,GAAYC,KAAKD,WAAa,SAAUE,EAAGC,GAC3C,IAAK,GAAIC,KAAKD,GAAG,GAAIA,EAAEE,eAAeD,GAAIF,EAAEE,GAAKD,EAAEC,EACnD,SAASE,KAAOL,KAAKM,YAAcL,EACnCI,EAAGE,UAAYL,EAAEK,SACjBN,GAAEM,UAAY,GAAIF,GM9tBtB,IAAOsI,GAAkBnK,EAAc,wDNouBvC,IM/tBMuC,GAAkB,SAAAK,GAASrB,EAA3BgB,EAAkBK,EAqBvB,SArBKL,KAuBJK,EAAA7B,KAAAS,KArBOA,MAAA4I,UAAoB,IAKpB5I,MAAA6I,cAAuB,QACvB7I,MAAA8I,cAAuB,QACvB9I,MAAA+I,UAAmB,CACnB/I,MAAAgJ,UAAmB,CACnBhJ,MAAAiJ,UAAmB,CACnBjJ,MAAAkJ,UAAmB,CACnBlJ,MAAAmJ,UAAmB,CACnBnJ,MAAAoJ,UAAmB,EAYpBrI,EAAAR,UAAA8I,QAAP,SAAe3C,GAEd,IAAKA,EAAO4C,UACX,MAAO,MAER,OAAO,MAMR5G,QAAAC,eAAW5B,EAAAR,UAAA,YNotBJqC,IMptBP,WAEC,MAAO5C,MAAK4I,WNqtBN5F,IMltBP,SAAoBC,GAEnB,GAAIjD,KAAK4I,WAAa3F,EACrB,MAEDjD,MAAK4I,UAAY3F,CAEjBjD,MAAKuJ,4BNitBCzG,WAAY,KACZC,aAAc,MM/sBdhC,GAAAR,UAAAkG,QAAP,SAAeC,EAAuBC,GAErC,GAAI3G,KAAKwJ,SAAU,CAClB7C,EAAS+B,UAAYhC,EAAO+C,aAAazJ,KAAKwJ,SAC9C9C,GAAOE,qBACD,IAAID,EAAS+B,UAAW,CAC9B/B,EAAS+B,UAAUgB,SACnB/C,GAAS+B,UAAY,KAGtB,GAAIhC,EAAO4C,UAAY,EAAG,CACzB5C,EAAOiD,eAAiB,IACxBhD,GAASb,aAAe,MAO1BpD,QAAAC,eAAW5B,EAAAR,UAAA,gBNgtBJqC,IMhtBP,WAEC,MAAO5C,MAAK6I,eNitBN7F,IM9sBP,SAAwBC,GAEvB,GAAIjD,KAAK6I,eAAiB5F,EACzB,MAEDjD,MAAK6I,cAAgB5F,CAErBjD,MAAK4J,iBN6sBC9G,WAAY,KACZC,aAAc,MMxsBrBL,QAAAC,eAAW5B,EAAAR,UAAA,gBN8sBJqC,IM9sBP,WAEC,MAAO5C,MAAK8I,eN+sBN9F,IM5sBP,SAAwBC,GAEvB,GAAIjD,KAAK8I,eAAiB7F,EACzB,MAEDjD,MAAK8I,cAAgB7F,CAErBjD,MAAK6J,iBN2sBC/G,WAAY,KACZC,aAAc,MMrsBrBL,QAAAC,eAAW5B,EAAAR,UAAA,WN2sBJqC,IM3sBP,WAEC,MAAO5C,MAAKwJ,UN4sBNxG,IMzsBP,SAAmBC,GAElB,GAAIjD,KAAKwJ,UAAYvG,EACpB,MAED,IAAIjD,KAAKwJ,SACRxJ,KAAK8J,eAAe9J,KAAKwJ,SAE1BxJ,MAAKwJ,SAAWvG,CAEhB,IAAIjD,KAAKwJ,SACRxJ,KAAK+J,YAAY/J,KAAKwJ,SAEvBxJ,MAAKuJ,4BNssBCzG,WAAY,KACZC,aAAc,MMjsBdhC,GAAAR,UAAAmJ,QAAP,WAEC1J,KAAKwJ,SAAW,KAMVzI,GAAAR,UAAA4C,SAAP,SAAgBI,GAEf,GAAIyG,GAA+CzG,CAEnDvD,MAAKkC,QAAU8H,EAAK9H,OACpBlC,MAAKiK,SAAWD,EAAKC,QACrBjK,MAAKoE,aAAe4F,EAAK5F,YACzBpE,MAAKmE,aAAe6F,EAAK7F,aAMnBpD,GAAAR,UAAA2J,sBAAP,WAEC9I,EAAAb,UAAM2J,sBAAqB3K,KAAAS,KAE3BA,MAAKmK,qBAAuB,KAMtBpJ,GAAAR,UAAA6J,4BAAP,SAAmC1D,EAAuBC,EAAmBO,EAAmCC,GAE/G,GAAI/H,GAAc,EAElBY,MAAKqK,eAAiB,IAEtBnD,GAAcoD,sBAAsBtK,KAAKmK,qBAAuBjD,EAAcqD,4BAA6B,EAE3G,OAAOnL,GAMD2B,GAAAR,UAAAiK,yBAAP,SAAgC9D,EAAuBC,EAAmB8D,EAAmCC,EAAmCxD,EAAmCC,GAElL,GAAI/H,GAAc,EAClB,IAAIV,EAGJ,IAAIsB,KAAKqK,eAAgB,CACxB3L,EAAIsB,KAAKmK,yBACH,CACNzL,EAAIwI,EAAcqD,2BAClBrD,GAAcoD,sBAAsB5L,EAAG,GAGxCU,GAAQ,OAASV,EAAI,OAAS+L,EAAc,KAAOtD,EAAgBoB,eAAiB,KAClF,OAAS7J,EAAI,OAASA,EAAI,OAASyI,EAAgBwD,QAAU,MAE/D,IAAIjE,EAAOkE,iBACVxL,GAAQ,OAASV,EAAI,OAASA,EAAI,OAAS+L,EAAc,MAE1D,IAAIzK,KAAK6K,kBAAoB,KAC5BzL,GAAQY,KAAK6K,iBAAiBnE,EAAQC,EAAUjI,EAAGwI,EAAeC,EAEnE/H,IAAQ,OAASV,EAAI,KAAOA,EAAI,OAASgM,EAAc,IAEvD,KAAK1K,KAAKqK,eAAgB,CACzBjL,GAAQ,OAASY,KAAKmK,qBAAuB,SAAWnK,KAAKmK,qBAAuB,KAAOzL,EAAI,IAC/FwI,GAAc4D,wBAAwBpM,GAGvCsB,KAAKqK,eAAiB,KAEtB,OAAOjL,GAMD2B,GAAAR,UAAAwK,yBAAP,SAAgCrE,EAAuBC,EAAmBqE,EAAkCC,EAAuB/D,EAAmCC,GAErK,GAAI/H,GAAc,EAClB,IAAIV,EAGJ,IAAIsB,KAAKqK,eAAgB,CACxB3L,EAAIsB,KAAKmK,yBACH,CACNzL,EAAIwI,EAAcqD,2BAClBrD,GAAcoD,sBAAsB5L,EAAG,GAGxCU,GAAQ,OAASV,EAAI,KAAOyI,EAAgBoB,eAAiB,KAAOyC,EAAa,6BAC/E,OAAStM,EAAI,SAAWA,EAAI,SAAWuM,EAAiB,IAE1D,IAAIjL,KAAK6K,kBAAoB,KAC5BzL,GAAQY,KAAK6K,iBAAiBnE,EAAQC,EAAUjI,EAAGwI,EAAeC,EAEnE,KAAKnH,KAAKqK,eAAgB,CACzBjL,GAAQ,OAASY,KAAKmK,qBAAuB,SAAWnK,KAAKmK,qBAAuB,KAAOzL,EAAI,IAC/FwI,GAAc4D,wBAAwBpM,GAGvCsB,KAAKqK,eAAiB,KAEtB,OAAOjL,GAMD2B,GAAAR,UAAA2K,6BAAP,SAAoCxE,EAAuBC,EAAmBM,EAAiCC,EAAmCC,GAEjJ,GAAI/H,GAAc,EAElB,IAAI+L,EACJ,IAAI5D,EAGJ,IAAIJ,EAAgBiE,aACnBhM,GAAQY,KAAKqL,aAAa3E,EAAQC,EAAUO,EAAeC,EAE5DD,GAAcoD,sBAAsBa,EAASjE,EAAcqD,4BAA6B,EAExF,IAAIe,GAA6CpE,EAAcM,yBAC/Db,GAASjB,uBAAyB4F,EAAqB5H,MAAM,CAE7D,IAAI1D,KAAKwJ,SAAU,CAClBpK,GAAQuH,EAAS+B,UAAUtB,kBAAkBV,EAAQyE,EAAQjE,EAAeC,EAAiBA,EAAgBE,eACvG,CACN,GAAIkE,GAA6CrE,EAAcM,yBAE/DpI,IAAQ,OAAS+L,EAAS,KAAOI,EAAuB,KAGzDnM,GAAQ,OAASY,KAAKmK,qBAAuB,KAAOnK,KAAKmK,qBAAuB,KAC/E,OAASgB,EAAS,SAAWA,EAAS,KAAOnL,KAAKmK,qBAAuB,IAE1E,IAAInK,KAAK4I,UAAW,CACnBxJ,GAAQ,OAAS+L,EAAS,SAAWA,EAAS,KAAOG,EAAuB,KAC3E,OAASrE,EAAY,SAAWA,EAAY,KAAOkE,EAAS,SACvD,CACN/L,GAAQ,OAAS6H,EAAY,SAAWA,EAAY,KAAOqE,EAAuB,KACjF,OAAStL,KAAKmK,qBAAuB,SAAWlD,EAAY,KAAOjH,KAAKmK,qBAAuB,KAC/F,OAASlD,EAAY,SAAWA,EAAY,KAAOjH,KAAKmK,qBAAuB,KAC/E,OAASlD,EAAY,SAAWA,EAAY,KAAOkE,EAAS,KAG9DjE,EAAc4D,wBAAwB9K,KAAKmK,qBAC3CjD,GAAc4D,wBAAwBK,EAEtC,OAAO/L,GAQD2B,GAAAR,UAAA8K,aAAP,SAAoB3E,EAAuBC,EAAmB2B,EAA8BnB,GAE3F,MAAO,OAASnH,KAAKmK,qBAAuB,SAAWnK,KAAKmK,qBAAuB,KAAOhD,EAAgBiE,aAAe,OAMnHrK,GAAAR,UAAAmH,UAAP,SAAiBhB,EAAuBC,EAAmBgB,GAE1D,GAAI3H,KAAKwJ,SAAU,CAClB7C,EAAS+B,UAAUd,SAASlB,OACtB,CACN,GAAIhD,GAAeiD,EAASjB,sBAC5B,IAAIoC,GAAoBpB,EAAOmB,oBAC/BC,GAAKpE,EAAQ,GAAK1D,KAAK+I,SACvBjB,GAAKpE,EAAQ,GAAK1D,KAAKgJ,SACvBlB,GAAKpE,EAAQ,GAAK1D,KAAKiJ,SACvBnB,GAAKpE,EAAQ,GAAK,GAOZ3C,GAAAR,UAAAqJ,cAAR,WAEC5J,KAAK+I,WAAc/I,KAAK6I,eAAiB,GAAM,KAAM,GACrD7I,MAAKgJ,WAAchJ,KAAK6I,eAAiB,EAAK,KAAM,GACpD7I,MAAKiJ,WAAajJ,KAAK6I,cAAgB,KAAM,IAMtC9H,GAAAR,UAAAsJ,cAAR,WAEC7J,KAAKkJ,WAAclJ,KAAK8I,eAAiB,GAAM,KAAM,GACrD9I,MAAKmJ,WAAcnJ,KAAK8I,eAAiB,EAAK,KAAM,GACpD9I,MAAKoJ,WAAapJ,KAAK8I,cAAgB,KAAM,IAMvC/H,GAAAR,UAAAwH,gBAAP,SAAuBrB,EAAuBC,EAAmBqB,EAA2BL,EAAaM,GAExG,GAAIjI,KAAKwJ,SACR7C,EAAS+B,UAAUR,gBAAgBF,EAAYtB,EAGhD,IAAIA,EAAO4C,UAAY,EAAG,CACzB,GAAI5F,GAAeiD,EAASjB,sBAC5B,IAAIoC,GAAoBpB,EAAOmB,oBAC/BC,GAAKpE,GAASgD,EAAO8E,SAASxL,KAAKkJ,SACnCpB,GAAKpE,EAAQ,GAAKgD,EAAO+E,SAASzL,KAAKmJ,SACvCrB,GAAKpE,EAAQ,GAAKgD,EAAOgF,SAAS1L,KAAKoJ,SACvCtB,GAAKpE,EAAQ,GAAK,GAGrB,OAAA3C,IAlWiC4H,EAoWjCjJ,GAA4BJ,QAAnByB,INipBN4K,wDAAwD,0DAA0DC,uDAAuD,SAASpN,EAAQkB,EAAOJ,GACpM,GAAIS,GAAYC,KAAKD,WAAa,SAAUE,EAAGC,GAC3C,IAAK,GAAIC,KAAKD,GAAG,GAAIA,EAAEE,eAAeD,GAAIF,EAAEE,GAAKD,EAAEC,EACnD,SAASE,KAAOL,KAAKM,YAAcL,EACnCI,EAAGE,UAAYL,EAAEK,SACjBN,GAAEM,UAAY,GAAIF,GOlgCtB,IAAOwL,GAAsBrN,EAAa,4DPwgC1C,IOngCMsN,GAAgB,SAAA1K,GAASrB,EAAzB+L,EAAgB1K,EAWrB,SAXK0K,GAWOC,EAA4BC,GAXzC,GAAAC,GAAAjM,IAWa,IAAA+L,QAAA,GAA0B,CAA1BA,EAAA,EAA4B,GAAAC,QAAA,GAAoC,CAApCA,EAAA,KAEvC5K,EAAA7B,KAAAS,KAAM,KAAMgM,EATLhM,MAAAkM,YAAqB,EAW5BlM,MAAKgM,WAAWnB,iBAAmB,SAACnE,EAAmBC,EAAmBM,EAAiCC,EAAmCC,GAAuC,MAAA8E,GAAKE,aAAazF,EAAQC,EAAUM,EAAWC,EAAeC,GAEnPnH,MAAKoM,QAAUL,EAMTD,EAAAvL,UAAAsG,eAAP,SAAsBH,EAAuBC,GAE5C,GAAImB,GAAoBpB,EAAOmB,oBAC/B,IAAInE,GAAuBiD,EAAShB,+BACpCvE,GAAAb,UAAMsG,eAActH,KAAAS,KAAC0G,EAAQC,EAC7BmB,GAAKpE,EAAQ,GAAK,CAClBoE,GAAKpE,EAAQ,GAAK,EAMnBhB,QAAAC,eAAWmJ,EAAAvL,UAAA,UP8/BJqC,IO9/BP,WAEC,MAAO5C,MAAKoM,SP+/BNpJ,IO5/BP,SAAkBC,GAEjBjD,KAAKoM,QAAUnJ,GP6/BTH,WAAY,KACZC,aAAc,MOx/BrBL,QAAAC,eAAWmJ,EAAAvL,UAAA,cP8/BJqC,IO9/BP,WAEC,MAAO5C,MAAKkM,aP+/BNlJ,IO5/BP,SAAsBC,GAErBjD,KAAKkM,YAAcjJ,GP6/BbH,WAAY,KACZC,aAAc,MOx/Bd+I,GAAAvL,UAAA2J,sBAAP,WAEC9I,EAAAb,UAAM2J,sBAAqB3K,KAAAS,KAC3BA,MAAKqM,SAAW,KAMVP,GAAAvL,UAAA6J,4BAAP,SAAmC1D,EAAuBC,EAAmBO,EAAmCC,GAE/GnH,KAAKqM,SAAWnF,EAAcM,yBAC9Bb,GAAShB,gCAAkC3F,KAAKqM,SAAS3I,MAAM,CAE/D,OAAOtC,GAAAb,UAAM6J,4BAA2B7K,KAAAS,KAAC0G,EAAQC,EAAUO,EAAeC,GAMpE2E,GAAAvL,UAAAmH,UAAP,SAAiBhB,EAAuBC,EAAmBgB,GAE1DvG,EAAAb,UAAMmH,UAASnI,KAAAS,KAAC0G,EAAQC,EAAUgB,EAClC,IAAIG,GAAoBpB,EAAOmB,oBAC/B,IAAInE,GAAuBiD,EAAShB,+BACpCmC,GAAKpE,GAAS1D,KAAKoM,OACnBtE,GAAKpE,EAAQ,GAAK1D,KAAKkM,YAWhBJ,GAAAvL,UAAA4L,aAAR,SAAqBzF,EAAmBC,EAAmBM,EAAiCC,EAAmCC,GAE9H,MAAO,OAASF,EAAY,OAASA,EAAY,OAASjH,KAAKqM,SAAW,OACzE,OAASpF,EAAY,OAASA,EAAY,OAC1C,OAASA,EAAY,OAASA,EAAY,OAASA,EAAY,OAC/D,OAASA,EAAY,OAASjH,KAAKqM,SAAW,OAC9C,OAASpF,EAAY,OAASA,EAAY,OAASjH,KAAKqM,SAAW,OACnE,OAASpF,EAAY,MAAQA,EAAY,OACzC,OAASA,EAAY,OAASA,EAAY,OAASA,EAAY,OAG/D,OAASA,EAAY,OAASA,EAAY,OAASA,EAAY,OAG/D,OAASA,EAAY,OAASA,EAAY,OAASjH,KAAKqM,SAAW,OACnE,OAASpF,EAAY,OAASA,EAAY,OAE1C,OAASA,EAAY,OAASA,EAAY,OAASA,EAAY,OAE/D,OAASA,EAAY,OAASjH,KAAKqM,SAAW,OAASpF,EAAY,OACnE,OAASA,EAAY,OAASA,EAAY,OAASA,EAAY,OAC/D,OAASA,EAAY,OAASA,EAAY,OAASA,EAAY,OAC/D,OAASA,EAAY,OAASA,EAAY,OAE7C,OAAA6E,IA1H+BD,EA4H/BnM,GAA0BJ,QAAjBwM,IPm+BNQ,4DAA4D,8DAA8DA,6DAA6D,SAAS9N,EAAQkB,EAAOJ,GAClN,GAAIS,GAAYC,KAAKD,WAAa,SAAUE,EAAGC,GAC3C,IAAK,GAAIC,KAAKD,GAAG,GAAIA,EAAEE,eAAeD,GAAIF,EAAEE,GAAKD,EAAEC,EACnD,SAASE,KAAOL,KAAKM,YAAcL,EACnCI,EAAGE,UAAYL,EAAEK,SACjBN,GAAEM,UAAY,GAAIF,GQxmCtB,IAAOkM,GAAkB/N,EAAc,kDAIvC,IAAOuC,GAAkBvC,EAAc,wDR4mCvC,IQtmCMqN,GAAsB,SAAAzK,GAASrB,EAA/B8L,EAAsBzK,EAY3B,SAZKyK,GAYOW,EAAyKR,GAZtL,GAAAC,GAAAjM,IAYsL,IAAAgM,QAAA,GAAoC,CAApCA,EAAA,KAEpL5K,EAAA7B,KAAAS,KAEAA,MAAKyM,6BAA+B,SAACC,GAA6B,MAAAT,GAAKU,oBAAoBD,GAE3F1M,MAAK4M,YAAcZ,GAAc,GAAIjL,EACrCf,MAAK4M,YAAY/B,iBAAmB2B,CACpCxM,MAAK4M,YAAYC,iBAAiBN,EAAmBO,mBAAoB9M,KAAKyM,8BAM/E/J,OAAAC,eAAWkJ,EAAAtL,UAAA,cRimCJqC,IQjmCP,WAEC,MAAO5C,MAAK4M,aRkmCN5J,IQ/lCP,SAAsBC,GAErB,GAAIjD,KAAK4M,aAAe3J,EACvB,MAEDjD,MAAK4M,YAAYG,oBAAoBR,EAAmBO,mBAAoB9M,KAAKyM,6BACjFzM,MAAK4M,YAAc3J,CACnBjD,MAAK4M,YAAYC,iBAAiBN,EAAmBO,mBAAoB9M,KAAKyM,6BAC9EzM,MAAKuJ,4BR+lCCzG,WAAY,KACZC,aAAc,MQ1lCd8I,GAAAtL,UAAAkG,QAAP,SAAeC,EAAuBC,GAErC3G,KAAK4M,YAAYnG,QAAQC,EAAQC,GAM3BkF,GAAAtL,UAAAsG,eAAP,SAAsBH,EAAuBC,GAE5C3G,KAAK4M,YAAY/F,eAAeH,EAAQC,GAGlCkF,GAAAtL,UAAAgC,UAAP,SAAiByK,GAEhB5L,EAAAb,UAAMgC,UAAShD,KAAAS,KAACgN,EAEhBhN,MAAK4M,YAAYrK,UAAUyK,GAGrBnB,GAAAtL,UAAA6C,aAAP,SAAoB4J,GAEnB5L,EAAAb,UAAM6C,aAAY7D,KAAAS,KAACgN,EAEnBhN,MAAK4M,YAAYxJ,aAAa4J,GAMxBnB,GAAAtL,UAAAmJ,QAAP,WAEC1J,KAAK4M,YAAYG,oBAAoBR,EAAmBO,mBAAoB9M,KAAKyM,6BACjFzM,MAAK4M,YAAYlD,UAMlBhH,QAAAC,eAAWkJ,EAAAtL,UAAA,WRolCJqC,IQplCP,WAEC,MAAO5C,MAAK4M,YAAY1K,SRwlClBc,IQllCP,SAAmBC,GAElBjD,KAAK4M,YAAY1K,QAAUe,GRmlCrBH,WAAY,KACZC,aAAc,MQ9kCrBL,QAAAC,eAAWkJ,EAAAtL,UAAA,gBRolCJqC,IQplCP,WAEC,MAAO5C,MAAK4M,YAAYxI,cRwlClBpB,IQllCP,SAAwBC,GAEvBjD,KAAK4M,YAAYxI,aAAenB,GRmlC1BH,WAAY,KACZC,aAAc,MQ7kCrBL,QAAAC,eAAWkJ,EAAAtL,UAAA,gBRmlCJqC,IQnlCP,WAEC,MAAO5C,MAAK4M,YAAYzI,cRulClBnB,IQjlCP,SAAwBC,GAEvBjD,KAAK4M,YAAYzI,aAAelB,GRklC1BH,WAAY,KACZC,aAAc,MQ7kCd8I,GAAAtL,UAAA6J,4BAAP,SAAmC1D,EAAuBC,EAAmBO,EAAmCC,GAE/G,MAAOnH,MAAK4M,YAAYxC,4BAA4B1D,EAAQC,EAAUO,EAAeC,GAM/E0E,GAAAtL,UAAAiK,yBAAP,SAAgC9D,EAAuBC,EAAmB8D,EAAmCC,EAAmCxD,EAAmCC,GAElL,GAAI/H,GAAcY,KAAK4M,YAAYpC,yBAAyB9D,EAAQC,EAAU8D,EAAaC,EAAaxD,EAAeC,EACvHnH,MAAKmK,qBAAuBnK,KAAK4M,YAAYzC,oBAC7C,OAAO/K,GAMDyM,GAAAtL,UAAAwK,yBAAP,SAAgCrE,EAAuBC,EAAmBqE,EAAkCC,EAAuB/D,EAAmCC,GAErK,GAAI/H,GAAcY,KAAK4M,YAAY7B,yBAAyBrE,EAAQC,EAAUqE,EAAYC,EAAgB/D,EAAeC,EACzHnH,MAAKmK,qBAAuBnK,KAAK4M,YAAYzC,oBAC7C,OAAO/K,GAMDyM,GAAAtL,UAAAmH,UAAP,SAAiBhB,EAAuBC,EAAmBgB,GAE1D3H,KAAK4M,YAAYlF,UAAUhB,EAAQC,EAAUgB,GAMvCkE,GAAAtL,UAAAwH,gBAAP,SAAuBrB,EAAuBC,EAAmBqB,EAA2BL,EAAaM,GAExGjI,KAAK4M,YAAY7E,gBAAgBrB,EAAQC,EAAUqB,EAAYL,EAAOM,GAMhE4D,GAAAtL,UAAA0M,YAAP,SAAmBvG,EAAuBC,EAAmBgB,GAE5D3H,KAAK4M,YAAYK,YAAYvG,EAAQC,EAAUgB,GAMzCkE,GAAAtL,UAAA2M,eAAP,SAAsBxG,EAAmBC,EAAmBO,EAAmCC,GAE9F,MAAOnH,MAAK4M,YAAYM,eAAexG,EAAQC,EAAUO,EAAeC,GAMlE0E,GAAAtL,UAAA2K,6BAAP,SAAoCxE,EAAuBC,EAAmBM,EAAiCC,EAAmCC,GAEjJ,MAAOnH,MAAK4M,YAAY1B,6BAA6BxE,EAAQC,EAAUM,EAAWC,EAAeC,GAM3F0E,GAAAtL,UAAAgF,OAAP,WAECvF,KAAK4M,YAAYrH,SAMXsG,GAAAtL,UAAA2J,sBAAP,WAEC9I,EAAAb,UAAM2J,sBAAqB3K,KAAAS,KAC3BA,MAAK4M,YAAY1C,wBAMV2B,GAAAtL,UAAAoM,oBAAR,SAA4BD,GAE3B1M,KAAKuJ,2BAEP,OAAAsC,IA9NqC9K,EAgOLrB,GAAAJ,QAAvBuM,IR+jCNhH,wDAAwD,wDAAwDsI,kDAAkD3I,YAAY4I,yDAAyD,SAAS5O,EAAQkB,EAAOJ,GAClQ,GAAIS,GAAYC,KAAKD,WAAa,SAAUE,EAAGC,GAC3C,IAAK,GAAIC,KAAKD,GAAG,GAAIA,EAAEE,eAAeD,GAAIF,EAAEE,GAAKD,EAAEC,EACnD,SAASE,KAAOL,KAAKM,YAAcL,EACnCI,EAAGE,UAAYL,EAAEK,SACjBN,GAAEM,UAAY,GAAIF,GSjzCtB,IAAOU,GAAkBvC,EAAc,wDTuzCvC,ISlzCM6O,GAAkB,SAAAjM,GAASrB,EAA3BsN,EAAkBjM,EAKvB,SALKiM,KAOJjM,EAAA7B,KAAAS,MAMMqN,EAAA9M,UAAAsG,eAAP,SAAsBH,EAAmBC,GAExC,GAAImB,GAAoBpB,EAAOmB,oBAC/B,IAAInE,GAAuBiD,EAASjB,sBACpCoC,GAAKpE,GAAS,CACdoE,GAAKpE,EAAQ,GAAK,EAAE,GACpBoE,GAAKpE,EAAQ,GAAK,EAAE,KACpBoE,GAAKpE,EAAQ,GAAK,EAAE,SAMd2J,GAAA9M,UAAA2K,6BAAP,SAAoCxE,EAAuBC,EAAmBM,EAAiCC,EAAmCC,GAEjJ,GAAI/H,GAAc,EAClB,IAAIkO,EACJ,IAAIC,EAEJ,KAAKvN,KAAKwJ,SACT,KAAM,IAAIrK,OAAM,uCAGjB,IAAIuH,EAAO4C,UAAY,EAAG,CACzB,GAAInC,EAAgBiE,aACnBhM,GAAQ,OAASY,KAAKmK,qBAAuB,SAAWnK,KAAKmK,qBAAuB,SAAWhD,EAAgBiE,aAAe,MAC/HhM,IAAQ,OAAS6H,EAAY,SAAWjH,KAAKmK,qBAAuB,SAAWlD,EAAY,SAC1F,OAASA,EAAY,SAAWA,EAAY,QAC7CC,GAAc4D,wBAAwB9K,KAAKmK,qBAC3CjD,GAAcoD,sBAAsBgD,EAAOpG,EAAcqD,4BAA6B,OAChF,CACN+C,EAAOrG,EAGRsG,EAASrG,EAAcM,yBACvBb,GAASjB,uBAAyB6H,EAAO7J,MAAM,CAE/CtE,IAAQuH,EAAS+B,UAAUtB,kBAAkBV,EAAQ4G,EAAMpG,EAAeC,EAAiBA,EAAgBE,WAC1G,OAASiG,EAAO,OAASA,EAAO,KAAOC,EAAS,KAChD,OAASD,EAAO,QAAUA,EAAO,WACjC,OAASA,EAAO,OAASC,EAAS,OAClC,OAASD,EAAO,SAAWC,EAAS,SAAWD,EAAO,QAEvD,IAAI5G,EAAO4C,WAAa,EACvB,MAAOlK,EAERA,IAAQ,OAAS6H,EAAY,SAAWqG,EAAO,SAAWrG,EAAY,SACrE,OAASA,EAAY,OAASqG,EAAO,MAEtC,IAAI5G,EAAO4C,UAAY,EACtBpC,EAAc4D,wBAAwBwC,EAEvC,OAAOlO,GAET,OAAAiO,IAnEiCtM,EAqEjCrB,GAA4BJ,QAAnB+N,ITkyCNxI,wDAAwD,0DAA0D2I,4DAA4D,SAAShP,EAAQkB,EAAOJ,GACzM,GAAIS,GAAYC,KAAKD,WAAa,SAAUE,EAAGC,GAC3C,IAAK,GAAIC,KAAKD,GAAG,GAAIA,EAAEE,eAAeD,GAAIF,EAAEE,GAAKD,EAAEC,EACnD,SAASE,KAAOL,KAAKM,YAAcL,EACnCI,EAAGE,UAAYL,EAAEK,SACjBN,GAAEM,UAAY,GAAIF,GU72CtB,IAAOU,GAAkBvC,EAAc,wDVs3CvC,IU92CMiP,GAAqB,SAAArM,GAASrB,EAA9B0N,EAAqBrM,EAS1B,SATKqM,GASOC,GAEXtM,EAAA7B,KAAAS,KAEAA,MAAK2N,UAAYD,CAEjB,IAAI1N,KAAK2N,UACR3N,KAAK+J,YAAY/J,KAAK2N,WAGjBF,EAAAlN,UAAAkG,QAAP,SAAeC,EAAuBC,GAErCvF,EAAAb,UAAMkG,QAAOlH,KAAAS,KAAC0G,EAAQC,EAEtBA,GAASiH,mBAAqBlH,EAAO+C,aAAazJ,KAAK2N,WAOxDjL,QAAAC,eAAW8K,EAAAlN,UAAA,YVs2CJqC,IUt2CP,WAEC,MAAO5C,MAAK2N,WVu2CN3K,IUp2CP,SAAoBC,GAEnB,GAAIjD,KAAK2N,WAAa1K,EACrB,MAED,IAAIjD,KAAK2N,UACR3N,KAAK8J,eAAe9J,KAAK2N,UAE1B3N,MAAK2N,UAAY1K,CAEjB,IAAIjD,KAAK2N,UACR3N,KAAK+J,YAAY/J,KAAK2N,UAEvB3N,MAAKuJ,4BVi2CCzG,WAAY,KACZC,aAAc,MU51Cd0K,GAAAlN,UAAA2J,sBAAP,WAEC9I,EAAAb,UAAM2J,sBAAqB3K,KAAAS,MAMrByN,GAAAlN,UAAA6J,4BAAP,SAAmC1D,EAAuBC,EAAmBO,EAAmCC,GAE/G,GAAI/H,GAAcgC,EAAAb,UAAM6J,4BAA2B7K,KAAAS,KAAC0G,EAAQC,EAAUO,EAAeC,EACrFnH,MAAKqK,eAAiB,IAEtB,OAAOjL,GAMDqO,GAAAlN,UAAAiK,yBAAP,SAAgC9D,EAAuBC,EAAmB8D,EAAmCC,EAAmCxD,EAAmCC,GAElL,GAAI/H,GAAc,EAClB,IAAIV,EAGJ,IAAIsB,KAAKqK,eACR3L,EAAIsB,KAAKmK,yBACL,CACJzL,EAAIwI,EAAcqD,2BAClBrD,GAAcoD,sBAAsB5L,EAAG,GAGxCU,GAAQ,OAASV,EAAI,OAAS+L,EAAc,SAAWtD,EAAgBoB,eAAiB,SACvF,OAAS7J,EAAI,OAASA,EAAI,OAASyI,EAAgBwD,QAAU,OAC7D,OAASjM,EAAI,OAASA,EAAI,OAASyI,EAAgBwD,QAAU,OAC7D,OAASjM,EAAI,SAAWA,EAAI,OAAS+L,EAAc,MAEpD,IAAIzK,KAAK6K,kBAAoB,KAC5BzL,GAAQY,KAAK6K,iBAAiBnE,EAAQC,EAAUjI,EAAGwI,EAAeC,EAEnE/H,IAAQuH,EAASiH,mBAAmBxG,kBAAkBV,EAAQhI,EAAGwI,EAAeC,EAAiBzI,GAEhG,OAASA,EAAI,SAAWA,EAAI,SAAWgM,EAAc,QAEtD,KAAK1K,KAAKqK,eAAgB,CACzBjL,GAAQ,OAASY,KAAKmK,qBAAuB,SAAWnK,KAAKmK,qBAAuB,SAAWzL,EAAI,QACnGwI,GAAc4D,wBAAwBpM,GAGvCsB,KAAKqK,eAAiB,KAEtB,OAAOjL,GAMDqO,GAAAlN,UAAA8K,aAAP,SAAoB3E,EAAuBC,EAAmB2B,EAA8BnB,GAE3F,GAAIzI,GAA0B4J,EAASiC,2BAEvC,OAAO,OAAS7L,EAAI,KAAOyI,EAAgBiE,aAAe,UACzDzE,EAASiH,mBAAmBxG,kBAAkBV,EAAQhI,EAAG4J,EAAUnB,EAAiBA,EAAgBE,WACpG,OAASrH,KAAKmK,qBAAuB,SAAWnK,KAAKmK,qBAAuB,KAAOzL,EAAI,KAMlF+O,GAAAlN,UAAAmH,UAAP,SAAiBhB,EAAuBC,EAAmBgB,GAE1DvG,EAAAb,UAAMmH,UAASnI,KAAAS,KAAC0G,EAAQC,EAAUgB,EAElChB,GAASiH,mBAAmBhG,SAASlB,GAO/B+G,GAAAlN,UAAAwH,gBAAP,SAAuBrB,EAAuBC,EAAmBqB,EAA2BL,EAAaM,GAExG7G,EAAAb,UAAMwH,gBAAexI,KAAAS,KAAC0G,EAAQC,EAAUqB,EAAYL,EAAOM,EAE3D,IAAIvB,EAAO4C,UAAY,EACtB3C,EAASiH,mBAAmB1F,gBAAgBF,EAAYtB,GAE3D,OAAA+G,IA7IoC1M,EA+ILrB,GAAAJ,QAAtBmO,IVq0CN5I,wDAAwD,0DAA0DgJ,4DAA4D,SAASrP,EAAQkB,EAAOJ,GACzM,GAAIS,GAAYC,KAAKD,WAAa,SAAUE,EAAGC,GAC3C,IAAK,GAAIC,KAAKD,GAAG,GAAIA,EAAEE,eAAeD,GAAIF,EAAEE,GAAKD,EAAEC,EACnD,SAASE,KAAOL,KAAKM,YAAcL,EACnCI,EAAGE,UAAYL,EAAEK,SACjBN,GAAEM,UAAY,GAAIF,GWh+CtB,IAAOwL,GAAsBrN,EAAa,4DXw+C1C,IWj+CMsP,GAAqB,SAAA1M,GAASrB,EAA9B+N,EAAqB1M,EA0B1B,SA1BK0M,GA0BOC,EAAsBC,EAA+BC,EAAgCjC,GAA/D,GAAAgC,QAAA,GAA6B,CAA7BA,EAAA,WAA+B,GAAAC,QAAA,GAA8B,CAA9BA,EAAA,MAAgC,GAAAjC,QAAA,GAAoC,CAApCA,EAAA,KAEhG5K,EAAA7B,KAAAS,KAAM,KAAMgM,EAEZhM,MAAKkO,gBAAkBD,CACvBjO,MAAKmO,UAAYJ,CACjB/N,MAAKgO,UAAYA,CAEjB,IAAIhO,KAAKmO,UACRnO,KAAK+J,YAAY/J,KAAKmO,WAMjBL,EAAAvN,UAAAkG,QAAP,SAAeC,EAAuBC,GAErCA,EAASiH,mBAAqBlH,EAAO+C,aAAazJ,KAAKmO,UAEvD,IAAInO,KAAKkO,gBACRxH,EAAO0H,8BAEP1H,GAAOE,iBASTlE,QAAAC,eAAWmL,EAAAvN,UAAA,aX88CJqC,IW98CP,WAEC,MAAO5C,MAAKqO,YX+8CNrL,IW58CP,SAAqBC,GAEpB,GAAIA,GAAS6K,EAAsBQ,KAAOrL,GAAS6K,EAAsBS,SACxE,KAAM,IAAIpP,OAAM,qBAEjB,IAAIa,KAAKqO,YAAcpL,EACtB,MAEDjD,MAAKqO,WAAapL,CAElBjD,MAAKuJ,4BX08CCzG,WAAY,KACZC,aAAc,MWr8CrBL,QAAAC,eAAWmL,EAAAvN,UAAA,YX28CJqC,IW38CP,WAEC,MAAO5C,MAAKmO,WX48CNnL,IWz8CP,SAAoBC,GAEnB,GAAIjD,KAAKmO,WAAalL,EACrB,MAED,IAAIjD,KAAKmO,UACRnO,KAAK8J,eAAe9J,KAAKmO,UAE1BnO,MAAKmO,UAAYlL,CAEjB,IAAIjD,KAAKmO,UACRnO,KAAK+J,YAAY/J,KAAKmO,UAEvBnO,MAAKuJ,4BXs8CCzG,WAAY,KACZC,aAAc,MWj8CrBL,QAAAC,eAAWmL,EAAAvN,UAAA,kBXu8CJqC,IWv8CP,WAEC,MAAO5C,MAAKkO,iBXw8CNlL,IWr8CP,SAA0BC,GAEzB,GAAIjD,KAAKkO,iBAAmBjL,EAC3B,MAEDjD,MAAKkO,gBAAkBjL,CAEvBjD,MAAKuJ,4BXo8CCzG,WAAY,KACZC,aAAc,MW/7Cd+K,GAAAvN,UAAA2K,6BAAP,SAAoCxE,EAAuBC,EAAmBM,EAAiCC,EAAmCC,GAEjJ,GAAI/H,EACJ,IAAIkO,GAA6BpG,EAAcqD,2BAE/CnL,GAAOuH,EAASiH,mBAAmBxG,kBAAkBV,EAAQ4G,EAAMpG,EAAeC,EAAiBnH,KAAKkO,gBAAiB/G,EAAgBqH,mBAAqBrH,EAAgBE,UAE9K,QAAQrH,KAAKqO,YACZ,IAAKP,GAAsBS,SAC1BnP,GAAQ,OAASY,KAAKmK,qBAAuB,KAAOnK,KAAKmK,qBAAuB,KAAOmD,EAAO,IAC9F,MACD,KAAKQ,GAAsBQ,IAC1BlP,GAAQ,OAASY,KAAKmK,qBAAuB,KAAOnK,KAAKmK,qBAAuB,KAAOmD,EAAO,IAC9F,OAGFlO,GAAQgC,EAAAb,UAAM2K,6BAA4B3L,KAAAS,KAAC0G,EAAQC,EAAUM,EAAWC,EAAeC,EAEvF,OAAO/H,GAMD0O,GAAAvN,UAAAmH,UAAP,SAAiBhB,EAAuBC,EAAmBgB,GAE1DvG,EAAAb,UAAMmH,UAASnI,KAAAS,KAAC0G,EAAQC,EAAUgB,EAElChB,GAASiH,mBAAmBhG,SAASlB,GAM/BoH,GAAAvN,UAAAwH,gBAAP,SAAuBrB,EAAuBC,EAAmBqB,EAA2BL,EAAaM,GAExG7G,EAAAb,UAAMwH,gBAAexI,KAAAS,KAAC0G,EAAQC,EAAUqB,EAAYL,EAAOM,EAE3DtB,GAASiH,mBAAmB1F,gBAAgBF,EAAYtB,GAxJ3CoH,GAAAS,SAAkB,UAMlBT,GAAAQ,IAAa,KAoJ5B,OAAAR,IAhKoCjC,EAkKpCnM,GAA+BJ,QAAtBwO,IXq8CNxB,4DAA4D,8DAA8DmC,8DAA8D,SAASjQ,EAAQkB,EAAOJ,GACnN,GAAIS,GAAYC,KAAKD,WAAa,SAAUE,EAAGC,GAC3C,IAAK,GAAIC,KAAKD,GAAG,GAAIA,EAAEE,eAAeD,GAAIF,EAAEE,GAAKD,EAAEC,EACnD,SAASE,KAAOL,KAAKM,YAAcL,EACnCI,EAAGE,UAAYL,EAAEK,SACjBN,GAAEM,UAAY,GAAIF,GYnnDtB,IAAOwL,GAAsBrN,EAAa,4DZ2nD1C,IYnnDMkQ,GAAuB,SAAAtN,GAASrB,EAAhC2O,EAAuBtN,EAuB5B,SAvBKsN,GAuBOC,EAAmCC,EAA4B5C,GAvB5E,GAAAC,GAAAjM,IAuBa,IAAA2O,QAAA,GAAiC,CAAjCA,EAAA;CAAmC,GAAAC,QAAA,GAA0B,CAA1BA,EAAA,GAA4B,GAAA5C,QAAA,GAAoC,CAApCA,EAAA,KAE1E5K,EAAA7B,KAAAS,KAAM,KAAMgM,EAnBLhM,MAAA6O,cAAuB,CAEvB7O,MAAA8O,cAAgC,QAGhC9O,MAAA+O,UAAmB,CACnB/O,MAAAgP,UAAmB,CACnBhP,MAAAiP,UAAmB,CAc1BjP,MAAK4M,YAAY/B,iBAAmB,SAACnE,EAAmBC,EAAmBM,EAAiCC,EAAmCC,GAAuC,MAAA8E,GAAKiD,aAAaxI,EAAQC,EAAUM,EAAWC,EAAeC,GAOpPnH,MAAKmP,YAAc,EACnBnP,MAAK6O,cAAgB,EAMfH,EAAAnO,UAAAsG,eAAP,SAAsBH,EAAuBC,GAE5CvF,EAAAb,UAAMsG,eAActH,KAAAS,KAAC0G,EAAQC,EAE7B,IAAImB,GAAoBpB,EAAO0I,kBAC/B,IAAI1L,GAAuBiD,EAASlB,6BACpCqC,GAAKpE,GAAS,EACdoE,GAAKpE,EAAQ,IAAM,EACnBoE,GAAKpE,EAAQ,GAAK,CAClBoE,GAAKpE,EAAQ,GAAK,CAElBoE,GAAOpB,EAAOmB,oBACdnE,GAAQiD,EAAShB,+BACjBmC,GAAKpE,EAAQ,GAAK,CAClBoE,GAAKpE,EAAQ,GAAK,CAClBoE,GAAKpE,EAAQ,GAAK,EAAE,GACpBoE,GAAKpE,EAAQ,GAAK,EAAE,KACpBoE,GAAKpE,EAAQ,GAAK,EAAE,QACpBoE,GAAKpE,EAAQ,IAAM,EACnBoE,GAAKpE,EAAQ,KAAO,GAGdgL,GAAAnO,UAAA2J,sBAAP,WAEC9I,EAAAb,UAAM2J,sBAAqB3K,KAAAS,KAE3BA,MAAKqP,kBAAoB,IACzBrP,MAAKsP,SAAW,IAChBtP,MAAKuP,eAAiB,IACtBvP,MAAKwP,UAAY,IACjBxP,MAAKyP,QAAU,IACfzP,MAAK0P,WAAa,KAOnBhN,QAAAC,eAAW+L,EAAAnO,UAAA,cZomDJqC,IYpmDP,WAEC,MAAO5C,MAAKmP,aZqmDNnM,IYlmDP,SAAsBC,GAErBjD,KAAKmP,YAAclM,GZmmDbH,WAAY,KACZC,aAAc,MY9lDrBL,QAAAC,eAAW+L,EAAAnO,UAAA,gBZomDJqC,IYpmDP,WAEC,MAAO5C,MAAK6O,eZqmDN7L,IYlmDP,SAAwBC,GAEvBjD,KAAK6O,cAAgB5L,GZmmDfH,WAAY,KACZC,aAAc,MY9lDrBL,QAAAC,eAAW+L,EAAAnO,UAAA,gBZomDJqC,IYpmDP,WAEC,MAAO5C,MAAK8O,eZqmDN9L,IYlmDP,SAAwB2M,GAEvB3P,KAAK8O,cAAgBa,CACrB3P,MAAK+O,WAAcY,GAAgB,GAAM,KAAM,GAC/C3P,MAAKgP,WAAcW,GAAgB,EAAK,KAAM,GAC9C3P,MAAKiP,WAAaU,EAAe,KAAM,KZmmDjC7M,WAAY,KACZC,aAAc,MY9lDd2L,GAAAnO,UAAA2M,eAAP,SAAsBxG,EAAmBC,EAAmBO,EAAmCC,GAE9F,GAAI/H,GAAcgC,EAAAb,UAAM2M,eAAc3N,KAAAS,KAAC0G,EAAQC,EAAUO,EAAeC,EACxE,IAAIyI,EACJ,IAAIC,EACJ,IAAIvC,GAA6BpG,EAAc4I,yBAE/CD,GAAgB3I,EAAc6I,uBAC9BpJ,GAASlB,8BAAgCoK,EAAcnM,MAAM,CAE7D1D,MAAKqP,kBAAoBnI,EAAc8I,gBACvCJ,GAAkB1I,EAAc6I,uBAChC7I,GAAc6I,uBACd7I,GAAc6I,uBACd7I,GAAc6I,uBAEd3Q,IAAQ,OAASkO,EAAO,UAAYsC,EAAkB,KACrD,OAAStC,EAAO,SAAWA,EAAO,SAAWA,EAAO,OACpD,OAASA,EAAO,QAAUA,EAAO,QAAUuC,EAAgB,QAC3D,OAASvC,EAAO,QAAUA,EAAO,QAAUuC,EAAgB,QAC3D,OAAS7P,KAAKqP,kBAAoB,SAAW/B,EAAO,SACpD,OAAStN,KAAKqP,kBAAoB,aAEnC,OAAOjQ,GAMDsP,GAAAnO,UAAA6J,4BAAP,SAAmC1D,EAAuBC,EAAmBO,EAAmCC,GAE/GnH,KAAKwP,UAAYtI,EAAcM,yBAC/BxH,MAAKyP,QAAUvI,EAAcM,yBAC7BxH,MAAKsP,SAAWpI,EAAcM,yBAC9Bb,GAAShB,gCAAkC3F,KAAKwP,UAAU9L,MAAM,CAEhE,OAAOtC,GAAAb,UAAM6J,4BAA2B7K,KAAAS,KAAC0G,EAAQC,EAAUO,EAAeC,GAMpEuH,GAAAnO,UAAAiK,yBAAP,SAAgC9D,EAAuBC,EAAmB8D,EAAmCC,EAAmCxD,EAAmCC,GAElLnH,KAAKqK,eAAiB,IACtBrK,MAAKuP,eAAiB7E,CACtB,OAAOtJ,GAAAb,UAAMiK,yBAAwBjL,KAAAS,KAAC0G,EAAQC,EAAU8D,EAAaC,EAAaxD,EAAeC,GAM3FuH,GAAAnO,UAAA2K,6BAAP,SAAoCxE,EAAuBC,EAAmBM,EAAiCC,EAAmCC,GAEjJ,GAAI/H,GAAcgC,EAAAb,UAAM2K,6BAA4B3L,KAAAS,KAAC0G,EAAQC,EAAUM,EAAWC,EAAeC,EACjG,IAAImG,GAA6BpG,EAAcqD,2BAE/CnL,IAAQ,OAASkO,EAAO,SAAWtN,KAAKuP,eAAiB,SAAWvP,KAAK0P,WAAa,OACrF,OAASpC,EAAO,SAAWA,EAAO,SAAWtN,KAAKwP,UAAY,SAC9D,OAASvI,EAAY,SAAWA,EAAY,SAAWqG,EAAO,QAE/D,IAAItN,KAAK0P,YAAcvI,EAAgB8I,gBACtC/I,EAAc4D,wBAAwB7D,EAEvC,OAAO7H,GAMDsP,GAAAnO,UAAAmH,UAAP,SAAiBhB,EAAuBC,EAAmBgB,GAE1DvG,EAAAb,UAAMmH,UAASnI,KAAAS,KAAC0G,EAAQC,EAAUgB,EAElC,IAAIjE,GAAuBiD,EAAShB,+BACpC,IAAImC,GAAoBpB,EAAOmB,oBAC/BC,GAAKpE,GAAS1D,KAAK+O,SACnBjH,GAAKpE,EAAQ,GAAK1D,KAAKgP,SACvBlH,GAAKpE,EAAQ,GAAK1D,KAAKiP,SACvBnH,GAAKpE,EAAQ,GAAK1D,KAAKmP,WACvBrH,GAAKpE,EAAQ,GAAK1D,KAAK6O,cAMjBH,GAAAnO,UAAAwH,gBAAP,SAAuBrB,EAAmBC,EAAmBqB,EAA2BL,EAAaM,GAEpGtB,EAASiH,mBAAqBlH,EAAO+C,aAAazJ,KAAKkQ,WAAWC,cAAcnI,GAChFrB,GAASiH,mBAAmB1F,gBAAgBF,EAAYtB,EAExD1G,MAAKkQ,WAAWE,gBAAgBpI,GAAYqI,cAAc3J,EAAO0I,mBAAoBzI,EAASlB,8BAAgC,EAAG,MAM1HiJ,GAAAnO,UAAA2O,aAAR,SAAqBxI,EAAmBC,EAAmBM,EAAiCC,EAAmCC,GAG9H,IAAKnH,KAAKqK,eACT,MAAO,EAERrK,MAAKqK,eAAiB,KAEtB,IAAIjL,GAAc,EAElB,IAAI+H,EAAgB8I,gBACnBjQ,KAAK0P,WAAavI,EAAgB8I,oBAElC/I,GAAcoD,sBAAsBtK,KAAK0P,WAAaxI,EAAcqD,4BAA6B,EAElG,IAAI+C,GAA6BpG,EAAcqD,2BAE/CnL,IAAQuH,EAASiH,mBAAmBxG,kBAAkBV,EAAQ4G,EAAMpG,EAAeC,EAAiBnH,KAAKqP,mBAExG,OAASpI,EAAY,OAASqG,EAAO,KAAOtN,KAAKyP,QAAU,IAE5DrQ,IAAQ,OAAS6H,EAAY,OAASjH,KAAKqP,kBAAoB,OAASpI,EAAY,OAEnF,OAASA,EAAY,OAASjH,KAAKsP,SAAW,OAASrI,EAAY,OACnE,OAASA,EAAY,OAASjH,KAAKsP,SAAW,OAASrI,EAAY,OACnE,OAASA,EAAY,OAASA,EAAY,OAI1C,OAASA,EAAY,OAASA,EAAY,OAC1C,OAASA,EAAY,OAASA,EAAY,OAASjH,KAAKsP,SAAW,OACnE,OAASrI,EAAY,OAASA,EAAY,OAASjH,KAAKsP,SAAW,OACnE,OAAStP,KAAK0P,WAAa,OAASzI,EAAY,OAASA,EAAY,OAGrE,OAASA,EAAY,OAASjH,KAAKwP,UAAY,OAASxP,KAAK0P,WAAa,OAC1E,OAASzI,EAAY,OAASA,EAAY,OAASA,EAAY,MAEhE,OAAO7H,GAET,OAAAsP,IAlQsC7C,EAoQLnM,GAAAJ,QAAxBoP,IZgjDNpC,4DAA4D,8DAA8DgE,wDAAwD,SAAS9R,EAAQkB,EAAOJ,GAC7M,GAAIS,GAAYC,KAAKD,WAAa,SAAUE,EAAGC,GAC3C,IAAK,GAAIC,KAAKD,GAAG,GAAIA,EAAEE,eAAeD,GAAIF,EAAEE,GAAKD,EAAEC,EACnD,SAASE,KAAOL,KAAKM,YAAcL,EACnCI,EAAGE,UAAYL,EAAEK,SACjBN,GAAEM,UAAY,GAAIF,Gat0DtB,IAAOU,GAAkBvC,EAAc,wDb60DvC,Iav0DM+R,GAAiB,SAAAnP,GAASrB,EAA1BwQ,EAAiBnP,EAStB,SATKmP,GASOC,GAAA,GAAAA,QAAA,GAAsB,CAAtBA,EAAA,GAEXpP,EAAA7B,KAAAS,KAEAA,MAAKwQ,WAAaA,EAMZD,EAAAhQ,UAAA2J,sBAAP,WAEC9I,EAAAb,UAAM2J,sBAAqB3K,KAAAS,KAE3BA,MAAKyQ,kBAAoB,KAM1B/N,QAAAC,eAAW4N,EAAAhQ,UAAA,cbg0DJqC,Iah0DP,WAEC,MAAO5C,MAAK0Q,abi0DN1N,Ia9zDP,SAAsBC,GAErBjD,KAAK0Q,YAAczN,CACnBjD,MAAK0Q,YAAc,GAAGzN,EAAQ,Ib+zDxBH,WAAY,KACZC,aAAc,Ma1zDdwN,GAAAhQ,UAAA6J,4BAAP,SAAmC1D,EAAuBC,EAAmBO,EAAmCC,GAE/G,GAAI/H,GAAcgC,EAAAb,UAAM6J,4BAA2B7K,KAAAS,KAAC0G,EAAQC,EAAUO,EAAeC,EACrFnH,MAAKqK,eAAiB,IACtBrK,MAAKyQ,kBAAoBvJ,EAAcM,yBACvCb,GAAShB,gCAAkC3F,KAAKyQ,kBAAkB/M,MAAM,CAExE,OAAOtE,GAMDmR,GAAAhQ,UAAAiK,yBAAP,SAAgC9D,EAAuBC,EAAmB8D,EAAmCC,EAAmCxD,EAAmCC,GAElL,GAAI/H,GAAc,EAClB,IAAIV,EAGJ,IAAIsB,KAAKqK,eAAgB,CACxB3L,EAAIsB,KAAKmK,yBACH,CACNzL,EAAIwI,EAAcqD,2BAClBrD,GAAcoD,sBAAsB5L,EAAG,GAGxCU,GAAQ,OAASV,EAAI,OAAS+L,EAAc,SAAWtD,EAAgBoB,eAAiB,SACvF,OAAS7J,EAAI,OAASA,EAAI,OAASsB,KAAKyQ,kBAAoB,OAC5D,OAAS/R,EAAI,OAASA,EAAI,OAASsB,KAAKyQ,kBAAoB,OAC5D,OAAS/R,EAAI,OAASA,EAAI,OAC1B,OAASA,EAAI,QAAUA,EAAI,OAAS+L,EAAc,OAEnD,IAAIzK,KAAK6K,kBAAoB,KAC5BzL,GAAQY,KAAK6K,iBAAiBnE,EAAQC,EAAU8D,EAAavD,EAAeC,EAE7E/H,IAAQ,OAASV,EAAI,KAAOA,EAAI,OAASgM,EAAc,IAEvD,KAAK1K,KAAKqK,eAAgB,CACzBjL,GAAQ,OAASY,KAAKmK,qBAAuB,SAAWnK,KAAKmK,qBAAuB,SAAWzL,EAAI,QACnGwI,GAAc4D,wBAAwBpM,GAGvCsB,KAAKqK,eAAiB,KAEtB,OAAOjL,GAMDmR,GAAAhQ,UAAAmH,UAAP,SAAiBhB,EAAuBC,EAAmBgB,GAE1DvG,EAAAb,UAAMmH,UAASnI,KAAAS,KAAC0G,EAAQC,EAAUgB,EAElC,IAAIjE,GAAuBiD,EAAShB,+BACpC,IAAImC,GAAoBpB,EAAOmB,oBAC/BC,GAAKpE,GAAS1D,KAAK0Q,WACnB5I,GAAKpE,EAAQ,GAAK,GAAG1D,KAAK0Q,YAAc,GAE1C,OAAAH,IAtGgCxP,EAwGLrB,GAAAJ,QAAlBiR,IbgzDN1L,wDAAwD,0DAA0D8L,4DAA4D,SAASnS,EAAQkB,EAAOJ,GACzM,GAAIS,GAAYC,KAAKD,WAAa,SAAUE,EAAGC,GAC3C,IAAK,GAAIC,KAAKD,GAAG,GAAIA,EAAEE,eAAeD,GAAIF,EAAEE,GAAKD,EAAEC,EACnD,SAASE,KAAOL,KAAKM,YAAcL,EACnCI,EAAGE,UAAYL,EAAEK,SACjBN,GAAEM,UAAY,GAAIF,Gc95DtB,IAAOuQ,GAAgBpS,EAAe,sDds6DtC,Ic/5DMqS,GAAqB,SAAAzP,GAASrB,EAA9B8Q,EAAqBzP,EAW1B,SAXKyP,GAWO3O,EAAqB+L,GAAA,GAAAA,QAAA,GAA8B,CAA9BA,EAAA,MAEhC7M,EAAA7B,KAAAS,KAEAA,MAAKwJ,SAAWtH,CAChBlC,MAAKkO,gBAAkBD,CAEvB,IAAIjO,KAAKwJ,SACRxJ,KAAK+J,YAAY/J,KAAKwJ,UAMjBqH,EAAAtQ,UAAAkG,QAAP,SAAeC,EAAmBC,GAEjCA,EAAS+B,UAAYhC,EAAO+C,aAAazJ,KAAKwJ,SAE9C,IAAIxJ,KAAKkO,gBACRxH,EAAO0H,8BAEP1H,GAAOE,iBAQTlE,QAAAC,eAAWkO,EAAAtQ,UAAA,kBdu5DJqC,Icv5DP,WAEC,MAAO5C,MAAKkO,iBdw5DNlL,Icr5DP,SAA0BC,GAEzB,GAAIjD,KAAKkO,iBAAmBjL,EAC3B,MAEDjD,MAAKkO,gBAAkBjL,CAEvBjD,MAAKuJ,4Bdo5DCzG,WAAY,KACZC,aAAc,Mc/4DrBL,QAAAC,eAAWkO,EAAAtQ,UAAA,Wdq5DJqC,Icr5DP,WAEC,MAAO5C,MAAKwJ,Uds5DNxG,Icn5DP,SAAmBC,GAElB,GAAIjD,KAAKwJ,UAAYvG,EACpB,MAED,IAAIjD,KAAKwJ,SACRxJ,KAAK8J,eAAe9J,KAAKwJ,SAE1BxJ,MAAKwJ,SAAWvG,CAEhB,IAAIjD,KAAKwJ,SACRxJ,KAAK+J,YAAY/J,KAAKwJ,SAEvBxJ,MAAKuJ,4Bdg5DCzG,WAAY,KACZC,aAAc,Mc34Dd8N,GAAAtQ,UAAAyG,iBAAP,SAAwBN,EAAmBC,EAAmBM,EAAiCC,EAAmCC,GAEjI,GAAImG,GAA6BpG,EAAcqD,2BAE/C,OAAO5D,GAAS+B,UAAUtB,kBAAkBV,EAAQ4G,EAAMpG,EAAeC,EAAiBnH,KAAKkO,gBAAiB/G,EAAgBqH,mBAAqBrH,EAAgBE,WACpK,OAASJ,EAAY,KAAOA,EAAY,KAAOqG,EAAO,OAOjDuD,GAAAtQ,UAAAmH,UAAP,SAAiBhB,EAAuBC,EAAmBgB,GAE1DvG,EAAAb,UAAMmH,UAASnI,KAAAS,KAAC0G,EAAQC,EAAUgB,EAElChB,GAAS+B,UAAUd,SAASlB,GAItBmK,GAAAtQ,UAAAwH,gBAAP,SAAuBrB,EAAmBC,EAAmBqB,EAA2BL,EAAaM,GAEpGtB,EAAS+B,UAAUR,gBAAgBF,EAAYtB,GAEjD,OAAAmK,IA1GoCD,EA4GpClR,GAA+BJ,QAAtBuR,Idw4DNC,sDAAsD,wDAAwDC,8DAA8D,SAASvS,EAAQkB,EAAOJ,GACvM,GAAIS,GAAYC,KAAKD,WAAa,SAAUE,EAAGC,GAC3C,IAAK,GAAIC,KAAKD,GAAG,GAAIA,EAAEE,eAAeD,GAAIF,EAAEE,GAAKD,EAAEC,EACnD,SAASE,KAAOL,KAAKM,YAAcL,EACnCI,EAAGE,UAAYL,EAAEK,SACjBN,GAAEM,UAAY,GAAIF,GergEtB,IAAOuQ,GAAgBpS,EAAe,sDf2gEtC,IetgEMwS,GAAuB,SAAA5P,GAASrB,EAAhCiR,EAAuB5P,EAS5B,SATK4P,GASOC,GAEX7P,EAAA7B,KAAAS,KAEA,IAAIiR,EAAOzR,QAAU,GACpB,KAAM,IAAIL,OAAM,4BAEjBa,MAAKkR,QAAUD,EAMhBvO,OAAAC,eAAWqO,EAAAzQ,UAAA,efigEJqC,IejgEP,WAEC,MAAO5C,MAAKkR,SfkgENlO,Ie//DP,SAAuBC,GAEtBjD,KAAKkR,QAAUjO,GfggETH,WAAY,KACZC,aAAc,Me3/DdiO,GAAAzQ,UAAAyG,iBAAP,SAAwBN,EAAmBC,EAAmBM,EAAiCC,EAAmCC,GAEjI,GAAI/H,GAAc,EAClB,IAAI+R,GAAqCjK,EAAcM,yBACvDN,GAAcM,yBACdN,GAAcM,yBACdN,GAAcM,yBAEd,IAAI4J,GAAuClK,EAAcM,yBAEzDb,GAASjB,uBAAyByL,EAAazN,MAAM,CAErD,IAAI4J,GAA6BpG,EAAcqD,2BAE/CnL,IAAQ,OAASkO,EAAO,KAAOrG,EAAY,KAAOkK,EAAe,KAC/D,OAASlK,EAAY,KAAOqG,EAAO,KAAO8D,EAAiB,IAE7D,OAAOhS,GAMD4R,GAAAzQ,UAAAmH,UAAP,SAAiBhB,EAAmBC,EAAmBgB,GAEtD,GAAIsJ,GAAuBjR,KAAKkR,OAChC,IAAIxN,GAAuBiD,EAASjB,sBACpC,IAAIoC,GAAoBpB,EAAOmB,oBAG/BC,GAAKpE,GAASuN,EAAO,EACrBnJ,GAAKpE,EAAQ,GAAKuN,EAAO,EACzBnJ,GAAKpE,EAAQ,GAAKuN,EAAO,EACzBnJ,GAAKpE,EAAQ,GAAKuN,EAAO,EAGzBnJ,GAAKpE,EAAQ,GAAKuN,EAAO,EACzBnJ,GAAKpE,EAAQ,GAAKuN,EAAO,EACzBnJ,GAAKpE,EAAQ,GAAKuN,EAAO,EACzBnJ,GAAKpE,EAAQ,GAAKuN,EAAO,EAGzBnJ,GAAKpE,EAAQ,GAAKuN,EAAO,GACzBnJ,GAAKpE,EAAQ,GAAKuN,EAAO,GACzBnJ,GAAKpE,EAAQ,IAAMuN,EAAO,GAC1BnJ,GAAKpE,EAAQ,IAAMuN,EAAO,GAG1BnJ,GAAKpE,EAAQ,IAAMuN,EAAO,GAC1BnJ,GAAKpE,EAAQ,IAAMuN,EAAO,GAC1BnJ,GAAKpE,EAAQ,IAAMuN,EAAO,GAC1BnJ,GAAKpE,EAAQ,IAAMuN,EAAO,GAG1BnJ,GAAKpE,EAAQ,IAAMuN,EAAO,EAC1BnJ,GAAKpE,EAAQ,IAAMuN,EAAO,EAC1BnJ,GAAKpE,EAAQ,IAAMuN,EAAO,GAC1BnJ,GAAKpE,EAAQ,IAAMuN,EAAO,IAE5B,OAAAD,IA9FsCJ,EAgGtClR,GAAiCJ,QAAxB0R,Ifo/DNF,sDAAsD,wDAAwDO,iEAAiE,SAAS7S,EAAQkB,EAAOJ,GAC1M,GAAIS,GAAYC,KAAKD,WAAa,SAAUE,EAAGC,GAC3C,IAAK,GAAIC,KAAKD,GAAG,GAAIA,EAAEE,eAAeD,GAAIF,EAAEE,GAAKD,EAAEC,EACnD,SAASE,KAAOL,KAAKM,YAAcL,EACnCI,EAAGE,UAAYL,EAAEK,SACjBN,GAAEM,UAAY,GAAIF,GgB5lEtB,IAAOuQ,GAAgBpS,EAAc,sDhBmmErC,IgB7lEM8S,GAA0B,SAAAlQ,GAASrB,EAAnCuR,EAA0BlQ,EAO/B,SAPKkQ,KASJlQ,EAAA7B,KAAAS,MAMD0C,OAAAC,eAAW2O,EAAA/Q,UAAA,kBhB0lEJqC,IgB1lEP,WAEC,MAAO5C,MAAKuR,iBhB2lENvO,IgBxlEP,SAA0BC,GAEzBjD,KAAKuR,gBAAkBtO,GhBylEjBH,WAAY,KACZC,aAAc,MgBplEduO,GAAA/Q,UAAAyG,iBAAP,SAAwBN,EAAmBC,EAAmBM,EAAiCC,EAAmCC,GAEjI,GAAI/H,GAAc,EAClB,IAAI+R,GAAqCjK,EAAcM,yBACvD,IAAIgK,GAAqCtK,EAAcM,yBAEvDb,GAASjB,uBAAyByL,EAAazN,MAAM,CAIrDtE,IAAQ,OAAS6H,EAAY,KAAOA,EAAY,KAAOkK,EAAe,KAAO,OAASlK,EAAY,KAAOA,EAAY,KAAOuK,EAAe,IAE3I,OAAOpS,GAMDkS,GAAA/Q,UAAAmH,UAAP,SAAiBhB,EAAmBC,EAAmBgB,GAEtD,GAAI8J,GAAa,EAAE,GACnB,IAAI/N,GAAeiD,EAASjB,sBAC5B,IAAIoC,GAAoBpB,EAAOmB,oBAE/BC,GAAKpE,GAAS1D,KAAKuR,gBAAgBG,aACnC5J,GAAKpE,EAAQ,GAAK1D,KAAKuR,gBAAgBI,eACvC7J,GAAKpE,EAAQ,GAAK1D,KAAKuR,gBAAgBK,cACvC9J,GAAKpE,EAAQ,GAAK1D,KAAKuR,gBAAgBM,eACvC/J,GAAKpE,EAAQ,GAAK1D,KAAKuR,gBAAgBO,UAAUL,CACjD3J,GAAKpE,EAAQ,GAAK1D,KAAKuR,gBAAgBQ,YAAYN,CACnD3J,GAAKpE,EAAQ,GAAK1D,KAAKuR,gBAAgBS,WAAWP,CAClD3J,GAAKpE,EAAQ,GAAK1D,KAAKuR,gBAAgBU,YAAYR,EAGrD,OAAAH,IA9DyCV,EAgEzClR,GAAoCJ,QAA3BgS,IhBklENR,sDAAsD,wDAAwDoB,yDAAyD,SAAS1T,EAAQkB,EAAOJ,GAClM,GAAIS,GAAYC,KAAKD,WAAa,SAAUE,EAAGC,GAC3C,IAAK,GAAIC,KAAKD,GAAG,GAAIA,EAAEE,eAAeD,GAAIF,EAAEE,GAAKD,EAAEC,EACnD,SAASE,KAAOL,KAAKM,YAAcL,EACnCI,EAAGE,UAAYL,EAAEK,SACjBN,GAAEM,UAAY,GAAIF,GiB3pEtB,IAAOuQ,GAAgBpS,EAAe,sDjBiqEtC,IiB5pEM2T,GAAkB,SAAA/Q,GAASrB,EAA3BoS,EAAkB/Q,EAWvB,SAXK+Q,GAWOC,EAAoB9P,GAAA,GAAAA,QAAA,GAAgB,CAAhBA,EAAA,EAE/BlB,EAAA7B,KAAAS,KACAA,MAAKqS,QAAUD,CACfpS,MAAKoG,OAAS9D,CAEd,IAAItC,KAAKqS,QACRrS,KAAK+J,YAAY/J,KAAKqS,SAMxB3P,OAAAC,eAAWwP,EAAA5R,UAAA,QjBupEJqC,IiBvpEP,WAEC,MAAO5C,MAAKsS,OjBwpENtP,IiBrpEP,SAAgBC,GAEf,GAAIA,GAASjD,KAAKsS,MACjB,MAED,IAAItS,KAAKsS,MACRtS,KAAK8J,eAAe9J,KAAKsS,MAE1BtS,MAAKsS,MAAQrP,CAEb,IAAIjD,KAAKsS,MACRtS,KAAK+J,YAAY/J,KAAKsS,MAEvBtS,MAAKuJ,4BjBkpECzG,WAAY,KACZC,aAAc,MiB7oEdoP,GAAA5R,UAAAkG,QAAP,SAAeC,EAAmBC,GAEjCA,EAASb,aAAe,IACxBa,GAASd,UAAY,IAErBc,GAAS+B,UAAYhC,EAAO+C,aAAazJ,KAAKqS,QAE9C,IAAIrS,KAAKsS,OAAS,KAAM,CACvB3L,EAASiH,mBAAqBlH,EAAO+C,aAAazJ,KAAKsS,MACvD5L,GAAOE,kBAOTlE,QAAAC,eAAWwP,EAAA5R,UAAA,UjB+oEJqC,IiB/oEP,WAEC,MAAO5C,MAAKqS,SjBgpENrP,IiB7oEP,SAAkBC,GAEjB,GAAIjD,KAAKqS,SAAWpP,EACnB,MAED,IAAIjD,KAAKqS,QACRrS,KAAK8J,eAAe9J,KAAKqS,QAE1BrS,MAAKqS,QAAUpP,CAEf,IAAIjD,KAAKqS,QACRrS,KAAK+J,YAAY/J,KAAKqS,QAEvBrS,MAAKuJ,4BjB0oECzG,WAAY,KACZC,aAAc,MiBroEdoP,GAAA5R,UAAAmJ,QAAP,YAOAhH,QAAAC,eAAWwP,EAAA5R,UAAA,SjByoEJqC,IiBzoEP,WAEC,MAAO5C,MAAKoG,QjB0oENpD,IiBvoEP,SAAiBC,GAEhBjD,KAAKoG,OAASnD,GjBwoERH,WAAY,KACZC,aAAc,MiBnoEdoP,GAAA5R,UAAAmH,UAAP,SAAiBhB,EAAmBC,EAAmBgB,GAEtDjB,EAAOmB,qBAAqBlB,EAASjB,wBAA0B1F,KAAKoG,MAEpEO,GAAS+B,UAAUd,SAASlB,EAE5B,IAAI1G,KAAKsS,MACR3L,EAASiH,mBAAmBhG,SAASlB,GAGhCyL,GAAA5R,UAAAwH,gBAAP,SAAuBrB,EAAmBC,EAAmBqB,EAA2BL,EAAaM,GAEpGtB,EAAS+B,UAAUR,gBAAgBF,EAAYtB,EAE/C,IAAI1G,KAAKsS,MACR3L,EAASiH,mBAAmB1F,gBAAgBF,EAAYtB,GAMnDyL,GAAA5R,UAAAyG,iBAAP,SAAwBN,EAAmBC,EAAmBM,EAAiCC,EAAmCC,GAEjI,GAAIoL,GAAqCrL,EAAcM,yBACvD,IAAIpI,GAAc,EAElBuH,GAASjB,uBAAyB6M,EAAa7O,MAAM,CAErD,IAAI4J,GAA6BpG,EAAcqD,2BAC/CrD,GAAcoD,sBAAsBgD,EAAM,EAC1C,IAAIkF,GAA8BtL,EAAcqD,2BAChDrD,GAAcoD,sBAAsBkI,EAAO,EAG3CpT,IAAQ,OAASkO,EAAO,OAASnG,EAAgB8I,gBAAkB,SAAW9I,EAAgBoB,eAAiB,SAC9G,OAAS+E,EAAO,OAASA,EAAO,OAASA,EAAO,OAChD,OAASA,EAAO,SAAWnG,EAAgBoB,eAAiB,SAAW+E,EAAO,OAC9E,OAASA,EAAO,SAAWA,EAAO,SAAWnG,EAAgB8I,gBAAkB,SAC/EtJ,EAAS+B,UAAUtB,kBAAkBV,EAAQ4G,EAAMpG,EAAeC,EAAiBmG,GACnF,OAASkF,EAAQ,OAASlF,EAAO,cACjC,OAASkF,EAAQ,OACjB,OAASlF,EAAO,KAAOA,EAAO,KAAOrG,EAAY,IAElD,IAAIjH,KAAKsS,MAAO,CACflT,GAAQuH,EAASiH,mBAAmBxG,kBAAkBV,EAAQ8L,EAAOtL,EAAeC,EAAiBA,EAAgBE,WACpH,OAASiG,EAAO,KAAOkF,EAAQ,KAAOlF,EAAO,KAG/ClO,GAAQ,OAASkO,EAAO,KAAOA,EAAO,KAAOiF,EAAe,OAC1D,OAAStL,EAAY,KAAOA,EAAY,KAAOqG,EAAO,IAExDpG,GAAc4D,wBAAwBwC,EACtCpG,GAAc4D,wBAAwB0H,EAEtC,OAAOpT,GAET,OAAA+S,IApKiCvB,EAsKLlR,GAAAJ,QAAnB6S,IjBknENrB,sDAAsD,wDAAwD2B,sDAAsD,SAASjU,EAAQkB,EAAOJ,GAC/L,GAAIS,GAAYC,KAAKD,WAAa,SAAUE,EAAGC,GAC3C,IAAK,GAAIC,KAAKD,GAAG,GAAIA,EAAEE,eAAeD,GAAIF,EAAEE,GAAKD,EAAEC,EACnD,SAASE,KAAOL,KAAKM,YAAcL,EACnCI,EAAGE,UAAYL,EAAEK,SACjBN,GAAEM,UAAY,GAAIF,GkBryEtB,IAAOuQ,GAAgBpS,EAAe,sDlB2yEtC,IkBtyEMkU,GAAe,SAAAtR,GAASrB,EAAxB2S,EAAetR,EAepB,SAfKsR,GAeOC,EAAoBC,EAAoBC,GAAA,GAAAA,QAAA,GAAmC,CAAnCA,EAAA,QAEnDzR,EAAA7B,KAAAS,KAfOA,MAAA8S,aAAsB,CACtB9S,MAAA+S,aAAsB,GAe7B/S,MAAK2S,YAAcA,CACnB3S,MAAK4S,YAAcA,CACnB5S,MAAK6S,SAAWA,EAMVH,EAAAnS,UAAAkG,QAAP,SAAeC,EAAuBC,GAErCA,EAASf,gBAAkB,KAMrB8M,GAAAnS,UAAAsG,eAAP,SAAsBH,EAAmBC,GAExC,GAAImB,GAAoBpB,EAAOmB,oBAC/B,IAAInE,GAAuBiD,EAASjB,sBACpCoC,GAAKpE,EAAQ,GAAK,CAClBoE,GAAKpE,EAAQ,GAAK,CAClBoE,GAAKpE,EAAQ,GAAK,EAMnBhB,QAAAC,eAAW+P,EAAAnS,UAAA,elB6xEJqC,IkB7xEP,WAEC,MAAO5C,MAAK8S,clB8xEN9P,IkB3xEP,SAAuBC,GAEtBjD,KAAK8S,aAAe7P,GlB4xEdH,WAAY,KACZC,aAAc,MkBvxErBL,QAAAC,eAAW+P,EAAAnS,UAAA,elB6xEJqC,IkB7xEP,WAEC,MAAO5C,MAAK+S,clB8xEN/P,IkB3xEP,SAAuBC,GAEtBjD,KAAK+S,aAAe9P,GlB4xEdH,WAAY,KACZC,aAAc,MkBvxErBL,QAAAC,eAAW+P,EAAAnS,UAAA,YlB6xEJqC,IkB7xEP,WAEC,MAAO5C,MAAKgT,WlB8xENhQ,IkB3xEP,SAAoBC,GAEnBjD,KAAKgT,UAAY/P,CACjBjD,MAAKiT,OAAUhQ,GAAS,GAAM,KAAM,GACpCjD,MAAKkT,OAAUjQ,GAAS,EAAK,KAAM,GACnCjD,MAAKmT,OAASlQ,EAAQ,KAAM,KlB4xEtBH,WAAY,KACZC,aAAc,MkBvxEd2P,GAAAnS,UAAAmH,UAAP,SAAiBhB,EAAmBC,EAAmBgB,GAEtD,GAAIG,GAAoBpB,EAAOmB,oBAC/B,IAAInE,GAAuBiD,EAASjB,sBACpCoC,GAAKpE,GAAS1D,KAAKiT,KACnBnL,GAAKpE,EAAQ,GAAK1D,KAAKkT,KACvBpL,GAAKpE,EAAQ,GAAK1D,KAAKmT,KACvBrL,GAAKpE,EAAQ,GAAK1D,KAAK8S,YACvBhL,GAAKpE,EAAQ,GAAK,GAAG1D,KAAK+S,aAAe/S,KAAK8S,cAMxCJ,GAAAnS,UAAAyG,iBAAP,SAAwBN,EAAmBC,EAAmBM,EAAiCC,EAAmCC,GAEjI,GAAI0L,GAAiC3L,EAAcM,yBACnD,IAAI4L,GAAgClM,EAAcM,yBAClD,IAAI8F,GAA6BpG,EAAcqD,2BAC/CrD,GAAcoD,sBAAsBgD,EAAM,EAC1C,IAAIkF,GAA8BtL,EAAcqD,2BAChD,IAAInL,GAAc,EAClBuH,GAASjB,uBAAyBmN,EAASnP,MAAM,CAEjDtE,IAAQ,OAASoT,EAAQ,OAASrL,EAAgBkM,mBAAqB,OAASD,EAAU,OACxF,OAASZ,EAAQ,OAASA,EAAQ,OAASY,EAAU,OACrD,OAASZ,EAAQ,OAASA,EAAQ,OAClC,OAASlF,EAAO,KAAOuF,EAAW,KAAO5L,EAAY,KACrD,OAASqG,EAAO,KAAOA,EAAO,KAAOkF,EAAQ,OAC7C,OAASvL,EAAY,KAAOA,EAAY,KAAOqG,EAAO,IAExDpG,GAAc4D,wBAAwBwC,EAEtC,OAAOlO,GAET,OAAAsT,IA3H8B9B,EA6H9BlR,GAAyBJ,QAAhBoT,IlBmxEN5B,sDAAsD,wDAAwDwC,gEAAgE,SAAS9U,EAAQkB,EAAOJ,GACzM,GAAIS,GAAYC,KAAKD,WAAa,SAAUE,EAAGC,GAC3C,IAAK,GAAIC,KAAKD,GAAG,GAAIA,EAAEE,eAAeD,GAAIF,EAAEE,GAAKD,EAAEC,EACnD,SAASE,KAAOL,KAAKM,YAAcL,EACnCI,EAAGE,UAAYL,EAAEK,SACjBN,GAAEM,UAAY,GAAIF,GmBv5EtB,IAAOuQ,GAAgBpS,EAAe,sDnB85EtC,ImBx5EM+U,GAAyB,SAAAnS,GAASrB,EAAlCwT,EAAyBnS,EAc9B,SAdKmS,GAcOnB,EAAoB9P,GAAA,GAAAA,QAAA,GAAgB,CAAhBA,EAAA,EAE/BlB,EAAA7B,KAAAS,KAbOA,MAAAwT,cAAuB,CACvBxT,MAAAyT,mBAA4B,CAcnCzT,MAAKqS,QAAUD,CACfpS,MAAKoG,OAAS9D,CAEd,IAAItC,KAAKqS,QACRrS,KAAK+J,YAAY/J,KAAKqS,SAMjBkB,EAAAhT,UAAAkG,QAAP,SAAeC,EAAmBC,GAEjCA,EAASb,aAAe,IACxBa,GAASd,UAAY,IAErBc,GAAS+B,UAAYhC,EAAO+C,aAAazJ,KAAKqS,QAE9C,IAAIrS,KAAKsS,OAAS,KAAM,CACvB3L,EAASiH,mBAAqBlH,EAAO+C,aAAazJ,KAAKsS,MACvD5L,GAAOE,kBAOF2M,GAAAhT,UAAAsG,eAAP,SAAsBH,EAAmBC,GAExCD,EAAOmB,qBAAqBlB,EAASjB,uBAAyB,GAAK,EAMpEhD,QAAAC,eAAW4Q,EAAAhT,UAAA,QnB44EJqC,ImB54EP,WAEC,MAAO5C,MAAKsS,OnB64ENtP,ImB14EP,SAAgBC,GAEf,GAAIjD,KAAKsS,OAASrP,EACjB,MAED,IAAIjD,KAAKsS,MACRtS,KAAK8J,eAAe9J,KAAKsS,MAE1BtS,MAAKsS,MAAQrP,CAEb,IAAIjD,KAAKsS,MACRtS,KAAK+J,YAAY/J,KAAKsS,MAEvBtS,MAAKuJ,4BnBu4ECzG,WAAY,KACZC,aAAc,MmBl4ErBL,QAAAC,eAAW4Q,EAAAhT,UAAA,gBnBw4EJqC,ImBx4EP,WAEC,MAAO5C,MAAKwT,enBy4ENxQ,ImBt4EP,SAAwBC,GAEvBjD,KAAKwT,cAAgBvQ,GnBu4EfH,WAAY,KACZC,aAAc,MmBl4ErBL,QAAAC,eAAW4Q,EAAAhT,UAAA,UnBw4EJqC,ImBx4EP,WAEC,MAAO5C,MAAKqS,SnBy4ENrP,ImBt4EP,SAAkBC,GAEjB,GAAIjD,KAAKqS,SAAWpP,EACnB,MAED,IAAIjD,KAAKqS,QACRrS,KAAK8J,eAAe9J,KAAKqS,QAE1BrS,MAAKqS,QAAUpP,CAEf,IAAIjD,KAAKqS,QACRrS,KAAK+J,YAAY/J,KAAKqS,UnBo4EjBvP,WAAY,KACZC,aAAc,MmB/3ErBL,QAAAC,eAAW4Q,EAAAhT,UAAA,SnBq4EJqC,ImBr4EP,WAEC,MAAO5C,MAAKoG,QnBs4ENpD,ImBn4EP,SAAiBC,GAEhBjD,KAAKoG,OAASnD,GnBo4ERH,WAAY,KACZC,aAAc,MmB/3ErBL,QAAAC,eAAW4Q,EAAAhT,UAAA,qBnBq4EJqC,ImBr4EP,WAEC,MAAO5C,MAAKyT,oBnBs4ENzQ,ImBn4EP,SAA6BC,GAE5BjD,KAAKyT,mBAAqBxQ,GnBo4EpBH,WAAY,KACZC,aAAc,MmB/3EdwQ,GAAAhT,UAAAmH,UAAP,SAAiBhB,EAAmBC,EAAmBgB,GAEtD,GAAIG,GAAoBpB,EAAOmB,oBAC/B,IAAInE,GAAuBiD,EAASjB,sBACpCoC,GAAKpE,GAAS1D,KAAKoG,MACnB0B,GAAKpE,EAAQ,GAAK1D,KAAKyT,kBACvB3L,GAAKpE,EAAQ,GAAK1D,KAAKwT,aAEvB7M,GAAS+B,UAAUd,SAASlB,EAE5B,IAAI1G,KAAKsS,MACR3L,EAASiH,mBAAmBhG,SAASlB,GAGhC6M,GAAAhT,UAAAwH,gBAAP,SAAuBrB,EAAmBC,EAAmBqB,EAA2BL,EAAaM,GAEpGtB,EAAS+B,UAAUR,gBAAgBF,EAAYtB,EAE/C,IAAI1G,KAAKsS,MACR3L,EAASiH,mBAAmB1F,gBAAgBF,EAAYtB,GAMnD6M,GAAAhT,UAAAyG,iBAAP,SAAwBN,EAAmBC,EAAmBM,EAAiCC,EAAmCC,GAEjI,GAAIoL,GAAqCrL,EAAcM,yBACvD,IAAIpI,GAAc,EAClB,IAAIsU,GAAmCvM,EAAgB8I,eACvD,IAAI0D,GAAkCxM,EAAgBoB,cAEtD5B,GAASjB,uBAAyB6M,EAAa7O,MAAM,CAErD,IAAI4J,GAA6BpG,EAAcqD,2BAC/CrD,GAAcoD,sBAAsBgD,EAAM,EAC1C,IAAIkF,GAA8BtL,EAAcqD,2BAChDrD,GAAcoD,sBAAsBkI,EAAO,EAG3CpT,IAAQ,OAASkO,EAAO,OAASoG,EAAa,SAAWC,EAAY,SACnE,OAASrG,EAAO,OAASA,EAAO,OAASA,EAAO,OAChD,OAASA,EAAO,SAAWqG,EAAY,SAAWrG,EAAO,OACzD,OAASA,EAAO,SAAWA,EAAO,SAAWoG,EAAa,SAC3D/M,EAAS+B,UAAUtB,kBAAkBV,EAAQ4G,EAAMpG,EAAeC,EAAiBmG,GAClF,OAASkF,EAAQ,OAASlF,EAAO,cACjC,OAASkF,EAAQ,OACjB,OAASlF,EAAO,KAAOA,EAAO,KAAOrG,EAAY,IAGnD7H,IAAQ,OAASsU,EAAa,OAASA,EAAa,SAAWC,EAAY,SACzE,OAASD,EAAa,OAASnB,EAAe,OAASmB,EAAa,OACpE,OAASA,EAAa,OAASA,EAAa,OAASnB,EAAe,OACpE,OAASoB,EAAY,OAASpB,EAAe,OAASmB,EAAa,OACnE,OAASC,EAAY,OAASpB,EAAe,OAASoB,EAAY,OAClE,OAASD,EAAa,OAASA,EAAa,OAASC,EAAY,OAGjE,OAASD,EAAa,OAASnB,EAAe,OAASmB,EAAa,MAEtE,IAAI1T,KAAKsS,MAAO,CACflT,GAAQuH,EAASiH,mBAAmBxG,kBAAkBV,EAAQ8L,EAAOtL,EAAeC,EAAiBA,EAAgBE,WACpH,OAASqM,EAAa,OAASlB,EAAQ,OAASkB,EAAa,OAI/DtU,GAAQ,OAASkO,EAAO,KAAOA,EAAO,KAAOoG,EAAa,OACxD,OAASzM,EAAY,KAAOA,EAAY,KAAOqG,EAAO,IAExDpG,GAAc4D,wBAAwBwC,EACtCpG,GAAc4D,wBAAwB0H,EAEtC,OAAOpT,GAET,OAAAmU,IAnNwC3C,EAqNxClR,GAAmCJ,QAA1BiU,InBq2ENzC,sDAAsD,wDAAwD8C,2DAA2D,SAASpV,EAAQkB,EAAOJ,GACpM,GAAIS,GAAYC,KAAKD,WAAa,SAAUE,EAAGC,GAC3C,IAAK,GAAIC,KAAKD,GAAG,GAAIA,EAAEE,eAAeD,GAAIF,EAAEE,GAAKD,EAAEC,EACnD,SAASE,KAAOL,KAAKM,YAAcL,EACnCI,EAAGE,UAAYL,EAAEK,SACjBN,GAAEM,UAAY,GAAIF,GoBrkFtB,IAAOuQ,GAAgBpS,EAAe,sDpB6kFtC,IoBtkFMqV,GAAoB,SAAAzS,GAASrB,EAA7B8T,EAAoBzS,EAwBzB,SAxBKyS,GAwBO9F,EAAsBC,EAA+BC,GAA/B,GAAAD,QAAA,GAA6B,CAA7BA,EAAA,WAA+B,GAAAC,QAAA,GAA8B,CAA9BA,EAAA,MAEhE7M,EAAA7B,KAAAS,KAEA,IAAIgO,GAAa6F,EAAqBvF,KAAON,GAAa6F,EAAqBtF,SAC9E,KAAM,IAAIpP,OAAM,qBAEjBa,MAAKmO,UAAYJ,CACjB/N,MAAKqO,WAAaL,CAClBhO,MAAKkO,gBAAkBD,CAEvB,IAAIjO,KAAKmO,UACRnO,KAAK+J,YAAY/J,KAAKmO,WAMjB0F,EAAAtT,UAAAkG,QAAP,SAAeC,EAAmBC,GAEjCA,EAAS+B,UAAYhC,EAAO+C,aAAazJ,KAAKmO,UAE9C,IAAInO,KAAKkO,gBACRxH,EAAO0H,8BAEP1H,GAAOE,iBASTlE,QAAAC,eAAWkR,EAAAtT,UAAA,apBkjFJqC,IoBljFP,WAEC,MAAO5C,MAAKqO,YpBmjFNrL,IoBhjFP,SAAqBC,GAEpB,GAAIjD,KAAKqO,YAAcpL,EACtB,MAED,IAAIA,GAAS4Q,EAAqBvF,KAAOrL,GAAS4Q,EAAqBtF,SACtE,KAAM,IAAIpP,OAAM,qBAEjBa,MAAKqO,WAAapL,CAElBjD,MAAKuJ,4BpB8iFCzG,WAAY,KACZC,aAAc,MoBziFrBL,QAAAC,eAAWkR,EAAAtT,UAAA,YpB+iFJqC,IoB/iFP,WAEC,MAAO5C,MAAKmO,WpBgjFNnL,IoB7iFP,SAAoBC,GAEnB,GAAIjD,KAAKmO,WAAalL,EACrB,MAED,IAAIjD,KAAKmO,UACRnO,KAAK8J,eAAe9J,KAAKmO,UAE1BnO,MAAKmO,UAAYlL,CAEjB,IAAIjD,KAAKmO,UACRnO,KAAK+J,YAAY/J,KAAKmO,UAEvBnO,MAAKuJ,4BpB0iFCzG,WAAY,KACZC,aAAc,MoBriFrBL,QAAAC,eAAWkR,EAAAtT,UAAA,kBpB2iFJqC,IoB3iFP,WAEC,MAAO5C,MAAKkO,iBpB4iFNlL,IoBziFP,SAA0BC,GAEzB,GAAIjD,KAAKkO,iBAAmBjL,EAC3B,MAEDjD,MAAKkO,gBAAkBjL,CAEvBjD,MAAKuJ,4BpBwiFCzG,WAAY,KACZC,aAAc,MoBniFd8Q,GAAAtT,UAAAyG,iBAAP,SAAwBN,EAAmBC,EAAmBM,EAAiCC,EAAmCC,GAEjI,GAAI/H,EACJ,IAAIkO,GAA6BpG,EAAcqD,2BAE/CnL,GAAOuH,EAASiH,mBAAmBxG,kBAAkBV,EAAQ4G,EAAMpG,EAAeC,EAAiBnH,KAAKkO,gBAAiB/G,EAAgBqH,mBAAqBrH,EAAgBE,UAE9K,QAAQrH,KAAKqO,YACZ,IAAKwF,GAAqBtF,SACzBnP,GAAQ,OAAS6H,EAAY,KAAOA,EAAY,KAAOqG,EAAO,IAC9D,MACD,KAAKuG,GAAqBvF,IACzBlP,GAAQ,OAAS6H,EAAY,KAAOA,EAAY,KAAOqG,EAAO,IAC9D,OAGF,MAAOlO,GAMDyU,GAAAtT,UAAAmH,UAAP,SAAiBhB,EAAmBC,EAAmBgB,GAEtDhB,EAAS+B,UAAUd,SAASlB,GAItBmN,GAAAtT,UAAAwH,gBAAP,SAAuBrB,EAAmBC,EAAmBqB,EAA2BL,EAAaM,GAEpGtB,EAAS+B,UAAUR,gBAAgBF,EAAYtB,GAlJlCmN,GAAAtF,SAAkB,UAKlBsF,GAAAvF,IAAa,KA+I5B,OAAAuF,IAzJmCjD,EA2JLlR,GAAAJ,QAArBuU,IpByiFN/C,sDAAsD,wDAAwDA,uDAAuD,SAAStS,EAAQkB,EAAOJ,GAChM,GAAIS,GAAYC,KAAKD,WAAa,SAAUE,EAAGC,GAC3C,IAAK,GAAIC,KAAKD,GAAG,GAAIA,EAAEE,eAAeD,GAAIF,EAAEE,GAAKD,EAAEC,EACnD,SAASE,KAAOL,KAAKM,YAAcL,EACnCI,EAAGE,UAAYL,EAAEK,SACjBN,GAAEM,UAAY,GAAIF,GqB3tFtB,IAAOyT,GAAmBtV,EAAa,6CAQvC,IAAO0H,GAAiB1H,EAAa,uDrB2tFrC,IqBrtFMoS,GAAgB,SAAAxP,GAASrB,EAAzB6Q,EAAgBxP,EAIrB,SAJKwP,KAMJxP,EAAA7B,KAAAS,MAMD0C,OAAAC,eAAWiO,EAAArQ,UAAA,arBktFJqC,IqBltFP,WAEC,MAAOgO,GAAiB/N,WrBmtFlBC,WAAY,KACZC,aAAc,MqB1sFd6N,GAAArQ,UAAAyG,iBAAP,SAAwBN,EAAmBC,EAAmBM,EAAiCC,EAAmCC,GAEjI,KAAM,IAAI2M,EACV,OAAO,GAzBMlD,GAAA/N,UAAmB,sBA2BlC,OAAA+N,IA7B+B1K,EA+B/BxG,GAA0BJ,QAAjBsR,IrBqtFNmD,6CAA6CvP,UAAU2D,uDAAuD,yDAAyD6L,mEAAmE,SAASxV,EAAQkB,EAAOJ,GACrQ,GAAIS,GAAYC,KAAKD,WAAa,SAAUE,EAAGC,GAC3C,IAAK,GAAIC,KAAKD,GAAG,GAAIA,EAAEE,eAAeD,GAAIF,EAAEE,GAAKD,EAAEC,EACnD,SAASE,KAAOL,KAAKM,YAAcL,EACnCI,EAAGE,UAAYL,EAAEK,SACjBN,GAAEM,UAAY,GAAIF,GsB5vFtB,IAAOuQ,GAAgBpS,EAAe,sDtBkwFtC,IsB7vFMyV,GAA4B,SAAA7S,GAASrB,EAArCkU,EAA4B7S,EAoBjC,SApBK6S,GAoBO7B,EAAoB8B,EAA6BC,EAAwBC,EAAwBC,GAA7E,GAAAH,QAAA,GAA2B,CAA3BA,EAAA,GAA6B,GAAAC,QAAA,GAAsB,CAAtBA,EAAA,EAAwB,GAAAC,QAAA,GAAsB,CAAtBA,EAAA,EAAwB,GAAAC,QAAA,GAAsB,CAAtBA,EAAA,EAE5GjT,EAAA7B,KAAAS,KAlBOA,MAAAsU,aAAsB,CACtBtU,MAAAuU,aAAsB,CACtBvU,MAAAwU,aAAsB,CAGtBxU,MAAAoG,OAAgB,CAcvBpG,MAAKqS,QAAUD,CACfpS,MAAKsU,aAAeH,CACpBnU,MAAKuU,aAAeH,CACpBpU,MAAKwU,aAAeH,CACpBrU,MAAKyU,iBAAmBzU,KAAKsU,cAAgBtU,KAAKwU,cAAgBxU,KAAKsU,cAAgBtU,KAAKuU,aAC5FvU,MAAK0U,iBAAmBR,CAExB,IAAIlU,KAAKqS,QACRrS,KAAK+J,YAAY/J,KAAKqS,SAMjB4B,EAAA1T,UAAAsG,eAAP,SAAsBH,EAAmBC,GAExC,GAAIjD,GAAuBiD,EAASjB,sBACpC,IAAIoC,GAAoBpB,EAAOmB,oBAC/BC,GAAKpE,EAAQ,GAAK,CAClBoE,GAAKpE,EAAQ,GAAK,CAClBoE,GAAKpE,EAAQ,GAAK,EAMZuQ,GAAA1T,UAAAkG,QAAP,SAAeC,EAAmBC,GAEjCA,EAASb,aAAe,IACxBa,GAASd,UAAY,IAErBc,GAAS+B,UAAYhC,EAAO+C,aAAazJ,KAAKqS,SAM/C3P,QAAAC,eAAWsR,EAAA1T,UAAA,UtBqvFJqC,IsBrvFP,WAEC,MAAO5C,MAAKqS,StBsvFNrP,IsBnvFP,SAAkBC,GAEjB,GAAIjD,KAAKqS,SAAWpP,EACnB,MAED,IAAIjD,KAAKqS,QACRrS,KAAK8J,eAAe9J,KAAKqS,QAE1BrS,MAAKqS,QAAUpP,CAEf,IAAIjD,KAAKqS,QACRrS,KAAK+J,YAAY/J,KAAKqS,UtBivFjBvP,WAAY,KACZC,aAAc,MsB5uFrBL,QAAAC,eAAWsR,EAAA1T,UAAA,mBtBkvFJqC,IsBlvFP,WAEC,MAAO5C,MAAK0U,kBtBmvFN1R,IsBhvFP,SAA2BC,GAE1BjD,KAAK0U,iBAAmBzR,GtBivFlBH,WAAY,KACZC,aAAc,MsB5uFrBL,QAAAC,eAAWsR,EAAA1T,UAAA,etBkvFJqC,IsBlvFP,WAEC,MAAO5C,MAAKsU,ctBmvFNtR,IsBhvFP,SAAuBC,GAEtBjD,KAAKsU,aAAerR,CAEpB,IAAI0R,KAA0B3U,KAAKsU,cAAgBtU,KAAKwU,cAAgBxU,KAAKsU,cAAgBtU,KAAKuU,aAClG,IAAIvU,KAAKyU,gBAAkBE,EAAe,CACzC3U,KAAKuJ,0BACLvJ,MAAKyU,eAAiBE,ItBivFjB7R,WAAY,KACZC,aAAc,MsB3uFrBL,QAAAC,eAAWsR,EAAA1T,UAAA,etBivFJqC,IsBjvFP,WAEC,MAAO5C,MAAKuU,ctBkvFNvR,IsB/uFP,SAAuBC,GAEtBjD,KAAKuU,aAAetR,CAEpB,IAAI0R,KAA0B3U,KAAKsU,cAAgBtU,KAAKwU,cAAgBxU,KAAKsU,cAAgBtU,KAAKuU,aAClG,IAAIvU,KAAKyU,gBAAkBE,EAAe,CACzC3U,KAAKuJ,0BACLvJ,MAAKyU,eAAiBE,ItBgvFjB7R,WAAY,KACZC,aAAc,MsB1uFrBL,QAAAC,eAAWsR,EAAA1T,UAAA,etBgvFJqC,IsBhvFP,WAEC,MAAO5C,MAAKwU,ctBivFNxR,IsB9uFP,SAAuBC,GAEtBjD,KAAKwU,aAAevR,CAEpB,IAAI0R,KAA0B3U,KAAKsU,cAAgBtU,KAAKwU,cAAgBxU,KAAKsU,cAAgBtU,KAAKuU,aAClG,IAAIvU,KAAKyU,gBAAkBE,EAAe,CACzC3U,KAAKuJ,0BACLvJ,MAAKyU,eAAiBE,ItB+uFjB7R,WAAY,KACZC,aAAc,MsBxuFrBL,QAAAC,eAAWsR,EAAA1T,UAAA,StB+uFJqC,IsB/uFP,WAEC,MAAO5C,MAAKoG,QtBgvFNpD,IsB7uFP,SAAiBC,GAEhBjD,KAAKoG,OAASnD,GtB8uFRH,WAAY,KACZC,aAAc,MsBzuFdkR,GAAA1T,UAAAmH,UAAP,SAAiBhB,EAAmBC,EAAmBgB,GAEtD,GAAIjE,GAAuBiD,EAASjB,sBACpC,IAAIoC,GAAoBpB,EAAOmB,oBAE/BC,GAAKpE,GAAS1D,KAAKsU,aAAetU,KAAK0U,gBAEvC,IAAI1U,KAAKyU,eAAgB,CACxB3M,EAAKpE,EAAQ,GAAK1D,KAAKuU,aAAevU,KAAK0U,gBAC3C5M,GAAKpE,EAAQ,GAAK1D,KAAKwU,aAAexU,KAAK0U,iBAE5C5M,EAAKpE,EAAQ,GAAK1D,KAAKoG,MAEvBO,GAAS+B,UAAUd,SAASlB,GAGtBuN,GAAA1T,UAAAwH,gBAAP,SAAuBrB,EAAmBC,EAAmBqB,EAA2BL,EAAaM,GAEpGtB,EAAS+B,UAAUR,gBAAgBF,EAAYtB,GAMzCuN,GAAA1T,UAAAyG,iBAAP,SAAwBN,EAAmBC,EAAmBM,EAAiCC,EAAmCC,GtByuF3H,GsBtuFFW,GAA6BZ,EAAcM,yBAC/C,IAAIoN,GAA8B1N,EAAcM,yBAChD,IAAIpI,GAAc,EAClB,IAAIyV,EACJ,IAAIC,EACJ,IAAIxH,EAEJ3G,GAASjB,uBAAyBoC,EAAKpE,MAAM,CAE7CmR,GAAgB3N,EAAcqD,2BAC9BrD,GAAcoD,sBAAsBuK,EAAe,EACnDC,GAAkB5N,EAAcqD,2BAChCrD,GAAcoD,sBAAsBwK,EAAiB,EACrDxH,GAAOpG,EAAcqD,2BACrBrD,GAAcoD,sBAAsBgD,EAAM,EAE1C,IAAIoG,GAAmCvM,EAAgB8I,eACvD,IAAI0D,GAAkCxM,EAAgBoB,cAEtDnJ,IAAQ,OAASsU,EAAa,SAAWA,EAAa,QAEtDtU,IAAQ,OAASkO,EAAO,OAASoG,EAAa,SAAWC,EAAY,SACpE,OAASrG,EAAO,OAASA,EAAO,OAASA,EAAO,OAChD,OAASA,EAAO,OAASsH,EAAQ,OAAStH,EAAO,OACjD,OAASA,EAAO,OAASxF,EAAO,OAASwF,EAAO,OAChD,OAASA,EAAO,OAASxF,EAAO,OAASwF,EAAO,OAChD,OAASA,EAAO,OAASsH,EAAQ,OAAStH,EAAO,OACjD,OAASA,EAAO,OAASA,EAAO,OAEhC,OAASA,EAAO,OAASxF,EAAO,OAASwF,EAAO,OAChD,OAASA,EAAO,OAASA,EAAO,OAASA,EAAO,OAChD,OAASA,EAAO,SAAWA,EAAO,OAASqG,EAAY,SAEvD,OAASkB,EAAgB,KAAO/M,EAAO,OAAS4L,EAAa,KAC7D,OAASmB,EAAgB,SAAWA,EAAgB,SAAWvH,EAAO,SACtE,OAASuH,EAAgB,SAAWA,EAAgB,SACrDlO,EAAS+B,UAAUtB,kBAAkBV,EAAQoO,EAAiB5N,EAAeC,EAAiB0N,GAC7F,OAASC,EAAkB,OAASA,EAAkB,eACtD,OAASA,EAAkB,MAE5B,IAAI9U,KAAKyU,eAAgB,CAExBrV,GAAQ,OAASkO,EAAO,OAASoG,EAAa,SAAWC,EAAY,SACpE,OAASrG,EAAO,OAASA,EAAO,OAASA,EAAO,OAChD,OAASA,EAAO,OAASsH,EAAQ,OAAStH,EAAO,OACjD,OAASA,EAAO,OAASxF,EAAO,OAASwF,EAAO,OAChD,OAASA,EAAO,OAASxF,EAAO,OAASwF,EAAO,OAChD,OAASA,EAAO,OAASsH,EAAQ,OAAStH,EAAO,OACjD,OAASA,EAAO,OAASA,EAAO,OAEhC,OAASA,EAAO,OAASxF,EAAO,OAASwF,EAAO,OAChD,OAASA,EAAO,OAASA,EAAO,OAASA,EAAO,OAChD,OAASA,EAAO,SAAWA,EAAO,OAASqG,EAAY,SAEvD,OAASkB,EAAgB,KAAO/M,EAAO,OAAS4L,EAAa,KAC7D,OAASmB,EAAgB,SAAWA,EAAgB,SAAWvH,EAAO,SACtE,OAASuH,EAAgB,SAAWA,EAAgB,SACrDlO,EAAS+B,UAAUtB,kBAAkBV,EAAQ4G,EAAMpG,EAAeC,EAAiB0N,GAClF,OAASC,EAAkB,OAASxH,EAAO,MAG5ClO,IAAQ,OAASkO,EAAO,OAASoG,EAAa,SAAWC,EAAY,SACpE,OAASrG,EAAO,OAASA,EAAO,OAASA,EAAO,OAChD,OAASA,EAAO,OAASsH,EAAQ,OAAStH,EAAO,OACjD,OAASA,EAAO,OAASxF,EAAO,OAASwF,EAAO,OAChD,OAASA,EAAO,OAASxF,EAAO,OAASwF,EAAO,OAChD,OAASA,EAAO,OAASsH,EAAQ,OAAStH,EAAO,OACjD,OAASA,EAAO,OAASA,EAAO,OAEhC,OAASA,EAAO,OAASxF,EAAO,OAASwF,EAAO,OAChD,OAASA,EAAO,OAASA,EAAO,OAASA,EAAO,OAChD,OAASA,EAAO,SAAWA,EAAO,OAASqG,EAAY,SAEvD,OAASkB,EAAgB,KAAO/M,EAAO,OAAS4L,EAAa,KAC7D,OAASmB,EAAgB,SAAWA,EAAgB,SAAWvH,EAAO,SACtE,OAASuH,EAAgB,SAAWA,EAAgB,SACrDlO,EAAS+B,UAAUtB,kBAAkBV,EAAQ4G,EAAMpG,EAAeC,EAAiB0N,GAClF,OAASC,EAAkB,OAASxH,EAAO,OAG7ClO,GAAQ,OAAS0V,EAAkB,SAAWA,EAAkB,SAAW7N,EAAY,SACtF,OAAS6N,EAAkB,SAAWA,EAAkB,SAAWhN,EAAO,OAC1E,OAASb,EAAY,SAAWA,EAAY,SAAW6N,EAAkB,QAE1E5N,GAAc4D,wBAAwBwC,EACtCpG,GAAc4D,wBAAwB+J,EACtC3N,GAAc4D,wBAAwBgK,EAGtC1V,IAAQ,OAASsU,EAAa,SAAWA,EAAa,QAEtD,OAAOtU,GAET,OAAA6U,IA9R2CrD,EAgS3ClR,GAAsCJ,QAA7B2U,ItB0qFNnD,sDAAsD,wDAAwDiE,2DAA2D,SAASvW,EAAQkB,EAAOJ,GACpM,GAAIS,GAAYC,KAAKD,WAAa,SAAUE,EAAGC,GAC3C,IAAK,GAAIC,KAAKD,GAAG,GAAIA,EAAEE,eAAeD,GAAIF,EAAEE,GAAKD,EAAEC,EACnD,SAASE,KAAOL,KAAKM,YAAcL,EACnCI,EAAGE,UAAYL,EAAEK,SACjBN,GAAEM,UAAY,GAAIF,GuBx9FtB,IAAOuQ,GAAgBpS,EAAe,sDvB89FtC,IuBz9FMwW,GAAoB,SAAA5T,GAASrB,EAA7BiV,EAAoB5T,EAsBzB,SAtBK4T,GAsBO5S,EAAkC6S,EAAsBC,EAAkBC,GAA1E,GAAA/S,QAAA,GAAgC,CAAhCA,EAAA,SAAkC,GAAA6S,QAAA,GAAoB,CAApBA,EAAA,GAAsB,GAAAC,QAAA,GAAgB,CAAhBA,EAAA,EAAkB,GAAAC,QAAA,GAAoB,CAApBA,EAAA,MAErF/T,EAAA7B,KAAAS,KAEAA,MAAKqO,WAAa8G,CAClBnV,MAAKoV,UAAYH,CACjBjV,MAAKqV,OAASH,CAEdlV,MAAKoC,MAAQA,EAMP4S,EAAAzU,UAAAsG,eAAP,SAAsBH,EAAmBC,GAExCD,EAAOmB,qBAAqBlB,EAASjB,uBAAyB,GAAK,EAM7DsP,GAAAzU,UAAAkG,QAAP,SAAeC,EAAmBC,GAEjCA,EAASb,aAAe,IACxBa,GAASd,UAAY,KAWtBnD,QAAAC,eAAWqS,EAAAzU,UAAA,avBy8FJqC,IuBz8FP,WAEC,MAAO5C,MAAKqO,YvB08FNrL,IuBv8FP,SAAqBC,GAEpB,GAAIjD,KAAKqO,YAAcpL,EACtB,MAEDjD,MAAKqO,WAAapL,CAElBjD,MAAKuJ,4BvBs8FCzG,WAAY,KACZC,aAAc,MuBj8FrBL,QAAAC,eAAWqS,EAAAzU,UAAA,SvBu8FJqC,IuBv8FP,WAEC,MAAO5C,MAAKmG,QvBw8FNnD,IuBr8FP,SAAiBC,GAEhBjD,KAAKmG,OAASlD,CACdjD,MAAKqG,SAAYpD,GAAS,GAAM,KAAM,GACtCjD,MAAKsG,SAAYrD,GAAS,EAAK,KAAM,GACrCjD,MAAKuG,SAAWtD,EAAQ,KAAM,KvBs8FxBH,WAAY,KACZC,aAAc,MuBj8FrBL,QAAAC,eAAWqS,EAAAzU,UAAA,YvBu8FJqC,IuBv8FP,WAEC,MAAO5C,MAAKoV,WvBw8FNpS,IuBr8FP,SAAoBC,GAEnBjD,KAAKoV,UAAYnS,GvBs8FXH,WAAY,KACZC,aAAc,MuBj8FrBL,QAAAC,eAAWqS,EAAAzU,UAAA,SvBu8FJqC,IuBv8FP,WAEC,MAAO5C,MAAKqV,QvBw8FNrS,IuBr8FP,SAAiBC,GAEhBjD,KAAKqV,OAASpS,GvBs8FRH,WAAY,KACZC,aAAc,MuBj8FdiS,GAAAzU,UAAAmH,UAAP,SAAiBhB,EAAmBC,EAAmBgB,GAEtD,GAAIjE,GAAuBiD,EAASjB,sBACpC,IAAIoC,GAAoBpB,EAAOmB,oBAC/BC,GAAKpE,GAAS1D,KAAKqG,OACnByB,GAAKpE,EAAQ,GAAK1D,KAAKsG,OACvBwB,GAAKpE,EAAQ,GAAK1D,KAAKuG,OACvBuB,GAAKpE,EAAQ,GAAK1D,KAAKoV,SACvBtN,GAAKpE,EAAQ,GAAK1D,KAAKqV,OAMjBL,GAAAzU,UAAAyG,iBAAP,SAAwBN,EAAmBC,EAAmBM,EAAiCC,EAAmCC,GAEjI,GAAIoL,GAAqCrL,EAAcM,yBACvD,IAAI8N,GAAsCpO,EAAcM,yBACxD,IAAI8F,GAA6BpG,EAAcqD,2BAC/C,IAAInL,GAAc,EAElBuH,GAASjB,uBAAyB6M,EAAa7O,MAAM,CAErDtE,IAAQ,OAASkO,EAAO,OAASnG,EAAgB8I,gBAAkB,SAAW9I,EAAgBoB,eAAiB,SAC9G,OAAS+E,EAAO,OAASA,EAAO,OAChC,OAASA,EAAO,OAASiF,EAAe,OAASjF,EAAO,OACxD,OAASA,EAAO,OAASA,EAAO,OAASgI,EAAgB,OACzD,OAAShI,EAAO,OAASA,EAAO,OAASgI,EAAgB,OACzD,OAAShI,EAAO,OAASiF,EAAe,OAASjF,EAAO,OACxD,OAASrG,EAAY,SAAWA,EAAY,SAAWqG,EAAO,OAC9D,OAASA,EAAO,OAASiF,EAAe,OAASjF,EAAO,MAEzD,IAAItN,KAAKqO,YAAc2G,EAAqB1G,IAAK,CAChDlP,GAAQ,OAASkO,EAAO,SAAWA,EAAO,OAASiF,EAAe,SACjE,OAAStL,EAAY,SAAWA,EAAY,SAAWqG,EAAO,aACzD,IAAItN,KAAKqO,YAAc2G,EAAqBzG,SAAU,CAC5DnP,GAAQ,OAASkO,EAAO,SAAWA,EAAO,OAASiF,EAAe,SACjE,OAAStL,EAAY,SAAWA,EAAY,SAAWqG,EAAO,aACzD,CACNlO,GAAQ,OAASkO,EAAO,SAAWiF,EAAe,SAAWtL,EAAY,SACxE,OAASqG,EAAO,SAAWA,EAAO,SAAWA,EAAO,OACpD,OAASrG,EAAY,SAAWA,EAAY,SAAWqG,EAAO,SAGhE,MAAOlO,GAhKM4V,GAAA1G,IAAa,KACb0G,GAAAzG,SAAkB,UAClByG,GAAAO,IAAa,KAgK5B,OAAAP,IApKmCpE,EAsKLlR,GAAAJ,QAArB0V,IvB27FNlE,sDAAsD,wDAAwDnF,yDAAyD,SAASnN,EAAQkB,EAAOJ,GAClM,GAAIS,GAAYC,KAAKD,WAAa,SAAUE,EAAGC,GAC3C,IAAK,GAAIC,KAAKD,GAAG,GAAIA,EAAEE,eAAeD,GAAIF,EAAEE,GAAKD,EAAEC,EACnD,SAASE,KAAOL,KAAKM,YAAcL,EACnCI,EAAGE,UAAYL,EAAEK,SACjBN,GAAEM,UAAY,GAAIF,GwB5mGtB,IAAO6F,GAAiB1H,EAAa,uDxBmnGrC,IwB7mGMmK,GAAkB,SAAAvH,GAASrB,EAA3B4I,EAAkBvH,EAUvB,SAVKuH,KAYJvH,EAAA7B,KAAAS,MASM2I,EAAApI,UAAA6J,4BAAP,SAAmC1D,EAAuBC,EAAmBO,EAAmCC,GAE/G,MAAO,GAWDwB,GAAApI,UAAAiK,yBAAP,SAAgC9D,EAAuBC,EAAmB8D,EAAmCC,EAAmCxD,EAAmCC,GAElL,MAAO,GAWDwB,GAAApI,UAAAwK,yBAAP,SAAgCrE,EAAuBC,EAAmBqE,EAAkCC,EAAuB/D,EAAmCC,GAErK,MAAO,GAWDwB,GAAApI,UAAA2K,6BAAP,SAAoCxE,EAAuBC,EAAmBM,EAAiCC,EAAmCC,GAEjJ,MAAO,GAET,OAAAwB,IAhEiCzC,EAkEjCxG,GAA4BJ,QAAnBqJ,IxBimGNR,uDAAuD,yDAAyDrD,wDAAwD,SAAStG,EAAQkB,EAAOJ,GACnM,GAAIS,GAAYC,KAAKD,WAAa,SAAUE,EAAGC,GAC3C,IAAK,GAAIC,KAAKD,GAAG,GAAIA,EAAEE,eAAeD,GAAIF,EAAEE,GAAKD,EAAEC,EACnD,SAASE,KAAOL,KAAKM,YAAcL,EACnCI,EAAGE,UAAYL,EAAEK,SACjBN,GAAEM,UAAY,GAAIF,GyBzqGtB,IAAO6F,GAAiB1H,EAAc,uDzB+qGtC,IyB1qGMwC,GAAiB,SAAAI,GAASrB,EAA1BiB,EAAiBI,EAOtB,SAPKJ,GAOO+C,GAAA,GAAAA,QAAA,GAA4B,CAA5BA,EAAA,KAEX3C,EAAA7B,KAAAS,KAEAA,MAAKwV,WAAazR,CAElB,IAAI/D,KAAKwV,WACRxV,KAAK+J,YAAY/J,KAAKwV,YAGjBxU,EAAAT,UAAA8I,QAAP,SAAe3C,GAEd,GAAI1G,KAAKwV,YAAc9O,EAAO+O,mBAC7B,MAAO,KAER,OAAO,OAMDzU,GAAAT,UAAAkG,QAAP,SAAeC,EAAmBC,GAEjC,GAAI3G,KAAKwV,WAAY,CACpB7O,EAAS+B,UAAYhC,EAAO+C,aAAazJ,KAAKwV,WAC9C9O,GAAOE,kBAOF5F,GAAAT,UAAAmV,uBAAP,WAEC,MAAO,MAMD1U,GAAAT,UAAA4C,SAAP,SAAgBI,GAEf,GAAI1E,GAAQ0E,CACZ,IAAIoS,GAA4CpS,CAEhD,IAAIoS,EAAI5R,WAAa,KACpB/D,KAAK+D,UAAY4R,EAAI5R,UAMvBrB,QAAAC,eAAW3B,EAAAT,UAAA,azB4pGJqC,IyB5pGP,WAEC,MAAO5C,MAAKwV,YzB6pGNxS,IyB1pGP,SAAqBC,GAEpB,GAAIjD,KAAKwV,YAAcvS,EACtB,MAED,IAAIjD,KAAKwV,WACRxV,KAAK8J,eAAe9J,KAAKwV,WAE1BxV,MAAKwV,WAAavS,CAElB,IAAIjD,KAAKwV,WACRxV,KAAK+J,YAAY/J,KAAKwV,WAEvBxV;KAAKuJ,4BzBupGCzG,WAAY,KACZC,aAAc,MyBlpGd/B,GAAAT,UAAAmJ,QAAP,WAEC,GAAI1J,KAAKwV,WACRxV,KAAKwV,WAAa,KAMbxU,GAAAT,UAAAmH,UAAP,SAAiBhB,EAAmBC,EAAmBgB,GAEtD,GAAI3H,KAAKwV,WACR7O,EAAS+B,UAAUd,SAASlB,GAGvB1F,GAAAT,UAAAwH,gBAAP,SAAuBrB,EAAmBC,EAAmBqB,EAA2BL,EAAaM,GAEpG,GAAIjI,KAAKwV,WACR7O,EAAS+B,UAAUR,gBAAgBF,EAAYtB,GAM1C1F,GAAAT,UAAAyG,iBAAP,SAAwBN,EAAmBC,EAAmBM,EAAiCC,EAAmCC,GAEjI,GAAI/H,GAAc,EAElB,IAAIY,KAAKwV,WACRpW,GAAQuH,EAAS+B,UAAUtB,kBAAkBV,EAAQO,EAAWC,EAAeC,EAAiBA,EAAgBE,UAGjHjI,IAAQ,OAAS6H,EAAY,SAAWA,EAAY,SAAWE,EAAgBwD,QAAU,SACxF,OAAS1D,EAAY,SAAWA,EAAY,IAE7C,OAAO7H,GAET,OAAA4B,IAxHgCkF,EA0HhCxG,GAA2BJ,QAAlB0B,IzB6oGNmH,uDAAuD,yDAAyDyN,4DAA4D,SAASpX,EAAQkB,EAAOJ,GACvM,GAAIS,GAAYC,KAAKD,WAAa,SAAUE,EAAGC,GAC3C,IAAK,GAAIC,KAAKD,GAAG,GAAIA,EAAEE,eAAeD,GAAIF,EAAEE,GAAKD,EAAEC,EACnD,SAASE,KAAOL,KAAKM,YAAcL,EACnCI,EAAGE,UAAYL,EAAEK,SACjBN,GAAEM,UAAY,GAAIF,G0BpxGtB,IAAOW,GAAiBxC,EAAc,uD1B0xGtC,I0BpxGMqX,GAAqB,SAAAzU,GAASrB,EAA9B8V,EAAqBzU,EAa1B,SAbKyU,GAaOC,EAAuBC,EAAmBC,EAAoBC,GAEzE7U,EAAA7B,KAAAS,KAEAA,MAAK+D,UAAY+R,CACjB9V,MAAKkW,cAAgBH,EAAWC,CAChChW,MAAKmW,cAAgBF,EAAWD,EAM1BH,EAAAtV,UAAAsG,eAAP,SAAsBH,EAAmBC,GAExC,GAAIjD,GAAuBiD,EAASjB,sBACpC,IAAIoC,GAAoBpB,EAAOmB,oBAC/BC,GAAKpE,GAAS,EAAqB1D,KAAK+D,UAAWqS,QAAQC,KAC3DvO,GAAKpE,EAAQ,GAAK,EAAqB1D,KAAK+D,UAAWqS,QAAQE,MAC/DxO,GAAKpE,EAAQ,GAAK,CAClBoE,GAAKpE,EAAQ,GAAK,CAClBoE,GAAKpE,EAAQ,GAAK1D,KAAKkW,aACvBpO,GAAKpE,EAAQ,GAAK1D,KAAKmW,cAMxBzT,QAAAC,eAAWkT,EAAAtV,UAAA,gB1B6wGJqC,I0B7wGP,WAEC,MAAO,Q1B8wGDE,WAAY,KACZC,aAAc,M0BzwGd8S,GAAAtV,UAAA4C,SAAP,SAAgBI,GAEfnC,EAAAb,UAAM4C,SAAQ5D,KAAAS,KAACuD,EAEfvD,MAAKkW,cAAyC3S,EAAQ2S,aACtDlW,MAAKmW,cAAyC5S,EAAQ4S,cAMhDN,GAAAtV,UAAAyG,iBAAP,SAAwBN,EAAmBC,EAAmBM,EAAiCC,EAAmCC,GAEjI,GAAI/H,GAAc,EAClB,IAAIkO,GAA6BpG,EAAcqD,2BAC/CrD,GAAcoD,sBAAsBgD,EAAM,EAE1C,IAAIiJ,GAAgCrP,EAAcM,yBAClD,IAAIgP,GAAiCtP,EAAcM,yBAEnDb,GAASjB,uBAAyB6Q,EAAQ7S,MAAM,CAEhDtE,IAAOuH,EAAS+B,UAAUtB,kBAAkBV,EAAQO,EAAWC,EAAeC,EAAiBA,EAAgBE,WAE9G,OAASiG,EAAO,KAAOnG,EAAgBE,UAAY,KAAOkP,EAAU,UAErE5P,EAAS+B,UAAUtB,kBAAkBV,EAAQ4G,EAAMpG,EAAeC,EAAiBmG,GAElF,OAASrG,EAAY,OAASA,EAAY,OAASqG,EAAO,OAC1D,OAASA,EAAO,KAAOnG,EAAgBE,UAAY,KAAOkP,EAAU,UAErE5P,EAAS+B,UAAUtB,kBAAkBV,EAAQ4G,EAAMpG,EAAeC,EAAiBmG,GAElF,OAASrG,EAAY,OAASA,EAAY,OAASqG,EAAO,OAC1D,OAASrG,EAAY,OAASsP,EAAU,OACxC,OAAStP,EAAY,QAAUA,EAAY,QAAUuP,EAAW,QAChE,OAASvP,EAAY,SAAWA,EAAY,QAE7CC,GAAc4D,wBAAwBwC,EAEtC,OAAOlO,GAET,OAAAyW,IA1FoC7U,EA4FpCtB,GAA+BJ,QAAtBuW,I1ByvGN/Q,uDAAuD,yDAAyD2R,8DAA8D,SAASjY,EAAQkB,EAAOJ,GACzM,GAAIS,GAAYC,KAAKD,WAAa,SAAUE,EAAGC,GAC3C,IAAK,GAAIC,KAAKD,GAAG,GAAIA,EAAEE,eAAeD,GAAIF,EAAEE,GAAKD,EAAEC,EACnD,SAASE,KAAOL,KAAKM,YAAcL,EACnCI,EAAGE,UAAYL,EAAEK,SACjBN,GAAEM,UAAY,GAAIF,G2B71GtB,IAAOW,GAAiBxC,EAAc,uD3Bm2GtC,I2B91GMkY,GAAuB,SAAAtV,GAASrB,EAAhC2W,EAAuBtV,EAa5B,SAbKsV,GAaO3S,EAA8B4S,GAA9B,GAAA5S,QAAA,GAA4B,CAA5BA,EAAA,KAA8B,GAAA4S,QAAA,GAAqC,CAArCA,EAAA,KAEzCvV,EAAA7B,KAAAS,KAAM+D,EAZC/D,MAAA4W,eAAwB,CACxB5W,MAAA6W,eAAwB,CACxB7W,MAAA8W,eAAwB,CACxB9W,MAAA+W,eAAwB,CAW/B/W,MAAKgX,oBAAsBL,CAE3B,IAAI3W,KAAKgX,oBACRhX,KAAK+J,YAAY/J,KAAKgX,qBAMjBN,EAAAnW,UAAAsG,eAAP,SAAsBH,EAAmBC,GAExC,GAAIjD,GAAeiD,EAASjB,sBAC5B,IAAIoC,GAAoBpB,EAAOmB,oBAC/BC,GAAKpE,GAAS,EACdoE,GAAKpE,EAAQ,GAAK,CAClBoE,GAAKpE,EAAQ,GAAK,CAClBoE,GAAKpE,EAAQ,GAAK,EAMZgT,GAAAnW,UAAAkG,QAAP,SAAeC,EAAmBC,GAEjCvF,EAAAb,UAAMkG,QAAOlH,KAAAS,KAAC0G,EAAQC,EAEtB,IAAI3G,KAAKgX,oBAAqB,CAC7BrQ,EAASiH,mBAAqBlH,EAAO+C,aAAazJ,KAAKgX,oBACvDtQ,GAAOE,kBAOTlE,QAAAC,eAAW+T,EAAAnW,UAAA,iB3Bs1GJqC,I2Bt1GP,WAEC,MAAO5C,MAAK4W,gB3Bu1GN5T,I2Bp1GP,SAAyBC,GAExBjD,KAAK4W,eAAiB3T,G3Bq1GhBH,WAAY,KACZC,aAAc,M2Bh1GrBL,QAAAC,eAAW+T,EAAAnW,UAAA,iB3Bs1GJqC,I2Bt1GP,WAEC,MAAO5C,MAAK6W,gB3Bu1GN7T,I2Bp1GP,SAAyBC,GAExBjD,KAAK6W,eAAiB5T,G3Bq1GhBH,WAAY,KACZC,aAAc,M2Bh1GrBL,QAAAC,eAAW+T,EAAAnW,UAAA,iB3Bs1GJqC,I2Bt1GP,WAEC,MAAO5C,MAAK8W,gB3Bu1GN9T,I2Bp1GP,SAAyBC,GAExBjD,KAAK8W,eAAiB7T,G3Bq1GhBH,WAAY,KACZC,aAAc,M2Bh1GrBL,QAAAC,eAAW+T,EAAAnW,UAAA,iB3Bs1GJqC,I2Bt1GP,WAEC,MAAO5C,MAAK+W,gB3Bu1GN/T,I2Bp1GP,SAAyBC,GAExBjD,KAAK+W,eAAiB9T,G3Bq1GhBH,WAAY,KACZC,aAAc,M2Bh1GrBL,QAAAC,eAAW+T,EAAAnW,UAAA,sB3Bs1GJqC,I2Bt1GP,WAEC,MAAO5C,MAAKgX,qB3Bu1GNhU,I2Bp1GP,SAA8BC,GAE7B,GAAIjD,KAAKgX,qBAAuB/T,EAC/B,MAED,IAAIjD,KAAKgX,oBACRhX,KAAK8J,eAAe9J,KAAKgX,oBAE1BhX,MAAKgX,oBAAsB/T,CAE3B,IAAIjD,KAAKgX,oBACRhX,KAAK+J,YAAY/J,KAAKgX,oBAEvBhX,MAAKuJ,4B3Bi1GCzG,WAAY,KACZC,aAAc,M2B50Gd2T,GAAAnW,UAAAmJ,QAAP,WAECtI,EAAAb,UAAMmJ,QAAOnK,KAAAS,KAEbA,MAAKgX,oBAAsB,KAMrBN,GAAAnW,UAAAmH,UAAP,SAAiBhB,EAAmBC,EAAmBgB,GAEtDvG,EAAAb,UAAMmH,UAASnI,KAAAS,KAAC0G,EAAQC,EAAUgB,EAElC,IAAIG,GAAoBpB,EAAOmB,oBAC/B,IAAInE,GAAeiD,EAASjB,sBAE5BoC,GAAKpE,EAAQ,GAAK1D,KAAK4W,cACvB9O,GAAKpE,EAAQ,GAAK1D,KAAK6W,cACvB/O,GAAKpE,EAAQ,GAAK1D,KAAK8W,cACvBhP,GAAKpE,EAAQ,GAAK1D,KAAK+W,cAEvB,IAAI/W,KAAKgX,oBACRrQ,EAASiH,mBAAmBhG,SAASlB,GAMhCgQ,GAAAnW,UAAAwH,gBAAP,SAAuBrB,EAAmBC,EAAmBqB,EAA2BL,EAAaM,GAEpG7G,EAAAb,UAAMwH,gBAAexI,KAAAS,KAAC0G,EAAQC,EAAUqB,EAAYL,EAAOM,EAE3D,IAAIjI,KAAKgX,oBACRrQ,EAASiH,mBAAmB1F,gBAAgBF,EAAYtB,GAMnDgQ,GAAAnW,UAAAyG,iBAAP,SAAwBN,EAAmBC,EAAmBM,EAAiCC,EAAmCC,GAEjI,GAAI/H,GAAc,EAClB,IAAIkO,GAA6BpG,EAAcqD,2BAC/CrD,GAAcoD,sBAAsBgD,EAAM,EAE1C,IAAIiJ,GAAgCrP,EAAcM,yBAClD,IAAIgP,GAAiCtP,EAAcM,yBACnDb,GAASjB,uBAAyB6Q,EAAQ7S,MAAM,CAEhDtE,IAAQ,OAASkO,EAAO,KAAOnG,EAAgBE,UAAY,KAAOmP,EAAW,SAE7E,IAAIxW,KAAK+D,UACR3E,GAAQuH,EAAS+B,UAAUtB,kBAAkBV,EAAQO,EAAWC,EAAeC,EAAiBmG,EAEjGlO,IAAQ,OAASkO,EAAO,KAAOnG,EAAgBE,UAAY,KAAOmP,EAAW,SAE7E,IAAIxW,KAAKgX,oBACR5X,GAAQuH,EAASiH,mBAAmBxG,kBAAkBV,EAAQ4G,EAAMpG,EAAeC,EAAiBmG,EAErGlO,IAAQ,OAAS6H,EAAY,KAAOA,EAAY,KAAOqG,EAAO,OAC7D,OAASrG,EAAY,KAAOA,EAAY,KAAOsP,EAAU,QACzD,OAAStP,EAAY,SAAWA,EAAY,SAAWE,EAAgBwD,QAAU,UACjF,OAAS1D,EAAY,SAAWA,EAAY,eAE7C,OAAO7H,GAET,OAAAsX,IAnMsC1V,EAqMLtB,GAAAJ,QAAxBoX,I3B6zGN5R,uDAAuD,yDAAyDqD,wDAAwD,SAAS3J,EAAQkB,EAAOJ,GACnM,GAAIS,GAAYC,KAAKD,WAAa,SAAUE,EAAGC,GAC3C,IAAK,GAAIC,KAAKD,GAAG,GAAIA,EAAEE,eAAeD,GAAIF,EAAEE,GAAKD,EAAEC,EACnD,SAASE,KAAOL,KAAKM,YAAcL,EACnCI,EAAGE,UAAYL,EAAEK,SACjBN,GAAEM,UAAY,GAAIF,G4BxhHtB,IAAO4W,GAASzY,EAAe,oCAS/B,IAAO+N,GAAkB/N,EAAa,kD5BuhHtC,I4B1gHM0H,GAAiB,SAAA9E,GAASrB,EAA1BmG,EAAiB9E,EAoBtB,SApBK8E,KAsBJ9E,EAAA7B,KAAAS,KApBMA,MAAAkX,UAA+B,GAAIxV,MAEnC1B,MAAAmX,QAA8B,GAAIzV,MAClC1B,MAAAoX,QAAwB,GAAI1V,OAOnCgB,OAAAC,eAAWuD,EAAA3F,UAAA,a5B6gHJqC,I4B7gHP,WAEC,MAAOsD,GAAkBrD,W5B8gHnBC,WAAY,KACZC,aAAc,M4BpgHdmD,GAAA3F,UAAA8I,QAAP,SAAe3C,GAEd,MAAO,MAUDR,GAAA3F,UAAAkG,QAAP,SAAeC,EAAmBC,IAY3BT,GAAA3F,UAAAsG,eAAP,SAAsBH,EAAmBC,IASlCT,GAAA3F,UAAA8W,kBAAP,WAEC,MAAO,MAMDnR,GAAA3F,UAAAmJ,QAAP,YAMOxD,GAAA3F,UAAAgC,UAAP,SAAiByK,G5By/GV,G4Bt/GFtJ,GAAe1D,KAAKmX,QAAQrT,QAAQkJ,EAExC,IAAItJ,IAAU,EAAG,CAChB1D,KAAKoX,QAAQ1T,SACP,CACN1D,KAAKmX,QAAQ3T,KAAKwJ,EAClBhN,MAAKoX,QAAQ5T,KAAK,E5Bw/GT,I4Br/GL8T,GAAatX,KAAKkX,UAAU1X,MAChC,KAAK,GAAIP,GAAW,EAAGA,EAAGqY,EAAKrY,IAC9Be,KAAKkX,UAAUjY,GAAGsD,UAAUyK,IAIxB9G,GAAA3F,UAAA6C,aAAP,SAAoB4J,GAEnB,GAAItJ,GAAe1D,KAAKmX,QAAQrT,QAAQkJ,EAExC,IAAIhN,KAAKoX,QAAQ1T,IAAU,EAAG,CAC7B1D,KAAKoX,QAAQ1T,SACP,CACN1D,KAAKmX,QAAQvT,OAAOF,EAAO,EAC3B1D,MAAKoX,QAAQxT,OAAOF,EAAO,E5Bq/GlB,I4Bl/GL4T,GAAatX,KAAKkX,UAAU1X,MAChC,KAAK,GAAIP,GAAW,EAAGA,EAAGqY,EAAKrY,IAC9Be,KAAKkX,UAAUjY,GAAGmE,aAAa4J,IAQ3B9G,GAAA3F,UAAAwJ,YAAP,SAAmB7H,GAElBlC,KAAKkX,UAAU1T,KAAKtB,EAEpB,IAAIoV,GAAatX,KAAKmX,QAAQ3X,MAC9B,KAAK,GAAIP,GAAW,EAAGA,EAAIqY,EAAKrY,IAC/BiD,EAAQK,UAAUvC,KAAKmX,QAAQlY,IAM1BiH,GAAA3F,UAAAuJ,eAAP,SAAsB5H,GAErBlC,KAAKkX,UAAUtT,OAAO5D,KAAKkX,UAAUpT,QAAQ5B,GAAU,EAEvD,IAAIoV,GAAatX,KAAKmX,QAAQ3X,MAC9B,KAAK,GAAIP,GAAW,EAAGA,EAAIqY,EAAKrY,IAC/BiD,EAAQkB,aAAapD,KAAKmX,QAAQlY,IAQ7BiH,GAAA3F,UAAAgF,OAAP,WAECvF,KAAKkK,wBAQChE,GAAA3F,UAAA2J,sBAAP,YAWOhE,GAAA3F,UAAA2M,eAAP,SAAsBxG,EAAmBC,EAAmBO,EAAmCC,GAE9F,MAAO,GAMDjB,GAAA3F,UAAAyG,iBAAP,SAAwBN,EAAmBC,EAAmBM,EAAiCC,EAAmCC,GAEjI,MAAO,MAWDjB,GAAA3F,UAAAmH,UAAP,SAAiBhB,EAAmBC,EAAmBgB,IAehDzB,GAAA3F,UAAAwH,gBAAP,SAAuBrB,EAAmBC,EAAmBqB,EAA2BL,EAAaM,IAY9F/B,GAAA3F,UAAA0M,YAAP,SAAmBvG,EAAmBC,EAAmBgB,IAUlDzB,GAAA3F,UAAAgJ,yBAAP,WAECvJ,KAAKuX,cAAc,GAAIhL,GAAmBA,EAAmBO,qBAMvD5G,GAAA3F,UAAA4C,SAAP,SAAgBI,IAzNF2C,GAAArD,UAAmB,uBA4NlC,OAAAqD,IAnOgC+Q,EAqOLvX,GAAAJ,QAAlB4G,I5By9GNsR,oCAAoChT,UAAU2I,kDAAkD3I,YAAYiT,0DAA0D,SAASjZ,EAAQkB,EAAOJ,GACjM,GAAIS,GAAYC,KAAKD,WAAa,SAAUE,EAAGC,GAC3C,IAAK,GAAIC,KAAKD,GAAG,GAAIA,EAAEE,eAAeD,GAAIF,EAAEE,GAAKD,EAAEC,EACnD,SAASE,KAAOL,KAAKM,YAAcL,EACnCI,EAAGE,UAAYL,EAAEK,SACjBN,GAAEM,UAAY,GAAIF,G6BztHtB,IAAOqX,GAAKlZ,EAAiB,+BAG7B,IAAOmZ,GAAgBnZ,EAAe,+CAOtC,IAAO+N,GAAkB/N,EAAc,kDAOvC,IAAO4G,GAAQ5G,EAAiB,2CAChC,IAAOoZ,GAAmBpZ,EAAc,yD7BotHxC,I6B3sHMqZ,GAAmB,SAAAzW,GAASrB,EAA5B8X,EAAmBzW,EAYxB,SAZKyW,GAYOC,GAZb,GAAA7L,GAAAjM,IAcEoB,GAAA7B,KAAAS,KAAM8X,EAAiBC,aAEvB/X,MAAKgY,YAAcF,CACnB,MAAM9X,KAAKiY,yBAA0BN,IACpC,KAAM,IAAIxY,OAAM,+DAEjBa,MAAKkY,qBAA6ClY,KAAKiY,eAAeE,YAEtE,KAAKnY,KAAKkY,qBACT,KAAM,IAAI/Y,OAAM,yGAEjBa,MAAKkY,qBAAqBrL,iBAAiB6K,EAAMU,OAAQ,SAAC1L,GAAgB,MAAAT,GAAKoM,gBAAgB3L,IAC/F1M,MAAKgY,YAAYnL,iBAAiBN,EAAmBO,mBAAoB,SAACJ,GAA6B,MAAAT,GAAKU,oBAAoBD,KAUjIhK,OAAAC,eAAWkV,EAAAtX,UAAA,c7BksHJqC,I6BlsHP,WAEC,MAAO5C,MAAKgY,a7BmsHNhV,I6BhsHP,SAAsBC,GAAtB,GAAAgJ,GAAAjM,IAEC,IAAIA,KAAKgY,aAAe/U,EACvB,MAEDjD,MAAKgY,YAAYjL,oBAAoBR,EAAmBO,mBAAoB,SAACJ,GAA6B,MAAAT,GAAKU,oBAAoBD,IAEnI1M,MAAKgY,YAAc/U,CAEnBjD,MAAKgY,YAAYnL,iBAAiBN,EAAmBO,mBAAoB,SAACJ,GAA6B,MAAAT,GAAKU,oBAAoBD,IAEhI1M,MAAKuJ,4B7B8rHCzG,WAAY,KACZC,aAAc,M6BzrHd8U,GAAAtX,UAAAkG,QAAP,SAAeC,EAAuBC,GAErC,GAAI2R,GAAkB,GAAIlT,GAASpF,KAAKgY,YACxChY,MAAKgY,YAAYvR,QAAQC,EAAQ4R,EAEjC3R,GAASX,qBAAuB,IAChCW,GAASf,gBAAkB,IAE3Be,GAAS+B,UAAYhC,EAAO+C,aAAazJ,KAAKiY,eAAeE,aAAaI,UAMpEV,GAAAtX,UAAAsG,eAAP,SAAsBH,EAAmBC,GAExC,GAAI6R,GAA4B9R,EAAOmB,oBACvC,IAAI4Q,GAA0B/R,EAAO0I,kBACrC,IAAI1L,GAAeiD,EAASjB,sBAC5B8S,GAAa9U,GAAS,CACtB8U,GAAa9U,EAAQ,GAAK,EAAE,GAC5B8U,GAAa9U,EAAQ,GAAK,EAAE,KAC5B8U,GAAa9U,EAAQ,GAAK,EAAE,QAE5B8U,GAAa9U,EAAQ,GAAK,EAC1B8U,GAAa9U,EAAQ,IAAM,EAE3BA,GAAQiD,EAASnB,oBACjBiT,GAAW/U,GAAS,EACpB+U,GAAW/U,EAAQ,IAAM,EACzB+U,GAAW/U,EAAQ,GAAK,EAMlBmU,GAAAtX,UAAA2J,sBAAP,WAEC9I,EAAAb,UAAM2J,sBAAqB3K,KAAAS,KAC3BA,MAAK0Y,oBAAsB,IAC3B1Y,MAAK2Y,uBAAyB,KAMxBd,GAAAtX,UAAA2M,eAAP,SAAsBxG,EAAmBC,EAAmBO,EAAmCC,GAE9F,GAAI/H,GAAc,EAClB,IAAImX,GAAgCrP,EAAc6I,uBAElD/P,MAAK4Y,oBAAoB1R,EACzBP,GAASnB,qBAAuB+Q,EAAQ7S,MAAM,CAE9C,IAAI4J,GAA6BpG,EAAc4I,yBAE/C,KAAK,GAAI7Q,GAAW,EAAGA,EAAIe,KAAKkY,qBAAqBW,cAAe5Z,EAAG,CACtEG,GAAQ,OAASkO,EAAO,KAAOnG,EAAgB2R,qBAAuB,KAAO9Y,KAAK0Y,oBAAoBzZ,GAAK,KAC1G,OAASe,KAAK2Y,uBAAuB1Z,GAAK,KAAOqO,EAAO,KAAOiJ,EAAU,UAG3E,MAAOnX,GAMAyY,GAAAtX,UAAAqY,oBAAR,SAA4B1R,GAE3BlH,KAAK0Y,oBAAsB,GAAIhX,OAA6B1B,KAAKkY,qBAAqBW,YACtF7Y,MAAK2Y,uBAAyB,GAAIjX,OAA6B1B,KAAKkY,qBAAqBW,YAEzF,KAAK,GAAI5Z,GAAW,EAAGA,EAAIe,KAAKkY,qBAAqBW,cAAe5Z,EAAG,CACtEe,KAAK2Y,uBAAuB1Z,GAAKiI,EAAc8I,gBAC/ChQ,MAAK0Y,oBAAoBzZ,GAAKiI,EAAc6I,uBAC5C7I,GAAc6I,uBACd7I,GAAc6I,uBACd7I,GAAc6I,yBAOT8H,GAAAtX,UAAAyG,iBAAP,SAAwBN,EAAmBC,EAAmBM,EAAiCC,EAAmCC,GAEjI,GAAI0R,GAAqB7Y,KAAKkY,qBAAqBW,WACnD,IAAItL,GAA+BrG,EAAcM,yBACjD,IAAI+O,GAAgCrP,EAAcM,yBAClD,IAAIuR,GAAyC7R,EAAcM,yBAC3D,IAAIwR,GAA+BtX,MAAeqX,EAAmB,KAAMA,EAAmB,KAAMA,EAAmB,KAAMA,EAAmB,KAChJ,IAAI3Z,EAEJuH,GAASjB,uBAAyB6H,EAAO7J,MAAM,CAE/C,IAAIuV,GAA+B/R,EAAcqD,2BACjDrD,GAAcoD,sBAAsB2O,EAAQ,EAC5C,IAAIC,GAAgChS,EAAcqD,2BAClDrD,GAAcoD,sBAAsB4O,EAAS,EAG7C9Z,GAAO,OAAS8Z,EAAU,KAAOlZ,KAAK2Y,uBAAuBE,EAAc,GAAK,IAEhF,KAAK,GAAI5Z,GAAW4Z,EAAc,EAAG5Z,GAAK,IAAKA,EAAG,CACjD,GAAIka,GAAqCnZ,KAAK2Y,uBAAuB1Z,EAGrEG,IAAQ,OAAS6Z,EAAS,OAAS9R,EAAgBkM,mBAAqB,OAAS2F,EAAe/Z,GAAK,IAErG,IAAIqO,GAA6BpG,EAAcqD,2BAG/CnL,IAAQ,OAASkO,EAAO,KAAO6L,EAAe,KAAOD,EAAU,KAC9D,OAAS5L,EAAO,KAAOA,EAAO,KAAO2L,EAAS,OAC9C,OAASC,EAAU,KAAOA,EAAU,KAAO5L,EAAO,KAGpDpG,EAAc4D,wBAAwBmO,EAEtC7Z,IAAQ,OAAS8Z,EAAU,KAAOA,EAAU,KAAOA,EAAU,OAC5D,OAASA,EAAU,QAAUA,EAAU,QAAU3C,EAAU,QAC3D,OAAS2C,EAAU,QAAUA,EAAU,QAAU3C,EAAU,OAE5DnX,IAAQY,KAAKgY,YAAYoB,yBAAyB1S,EAAQC,EAAU4G,EAAQ2L,EAASjS,EAAWC,EAAeC,GAC9G,OAASF,EAAY,OAASA,EAAY,OAASsP,EAAU,MAE9DrP,GAAc4D,wBAAwBoO,EAEtC,OAAO9Z,GAMDyY,GAAAtX,UAAAmH,UAAP,SAAiBhB,EAAmBC,EAAmBgB,GAEtDhB,EAAS+B,UAAUd,SAASlB,EAE5B,IAAI+R,GAA0B/R,EAAO0I,kBACrC,IAAIiK,GAAqB1S,EAASnB,oBAElCkB,GAAO0I,mBAAmBzI,EAASnB,qBAAuB,IAAM,GAAGxF,KAAKkY,qBAAqBoB,MAAMtZ,KAAKuZ,UAExG,IAAIV,GAAqB7Y,KAAKkY,qBAAqBW,WACnDQ,IAAe,CACf,KAAK,GAAIG,GAAW,EAAGA,EAAIX,IAAeW,EAAG,CAC5CxZ,KAAKkY,qBAAqBuB,oBAAoBD,GAAGnJ,cAAcoI,EAAYY,EAAa,KACxFA,IAAe,GAGhB,GAAIb,GAA4B9R,EAAOmB,oBACvC,IAAI6R,GAAuB/S,EAASjB,sBACpC8S,GAAakB,EAAgB,GAAK,EAAI1Z,KAAK2Z,OAE3C,IAAIC,GAAmC5Z,KAAKkY,qBAAqB2B,oBAEjEH,IAAiB,CACjB,KAAK,GAAIza,GAAW,EAAGA,EAAI4Z,IAAe5Z,EACzCuZ,EAAakB,EAAgBza,GAAK2a,EAAmB3a,EAEtDe,MAAKgY,YAAY8B,oBAAoBpT,EAAQC,EAAUgB,GAMjDkQ,GAAAtX,UAAAwH,gBAAP,SAAuBrB,EAAmBC,EAAmBqB,EAA2BL,EAAaM,IAO7F4P,GAAAtX,UAAA8X,gBAAR,SAAwB3L,GAEvB1M,KAAKuJ,2BAMEsO,GAAAtX,UAAAoM,oBAAR,SAA4BD,GAE3B1M,KAAKuJ,2BAEP,OAAAsO,IAnPkCD,EAqPlClY,GAA6BJ,QAApBuY,I7B2oHNkC,+BAA+BvV,UAAUwV,+CAA+CxV,UAAUW,2CAA2C,2CAA2C8U,yDAAyD,yDAAyD9M,kDAAkD3I,YAAY0V,2DAA2D,SAAS1b,EAAQkB,EAAOJ,GAC9b,GAAIS,GAAYC,KAAKD,WAAa,SAAUE,EAAGC,GAC3C,IAAK,GAAIC,KAAKD,GAAG,GAAIA,EAAEE,eAAeD,GAAIF,EAAEE,GAAKD,EAAEC,EACnD,SAASE,KAAOL,KAAKM,YAAcL,EACnCI,EAAGE,UAAYL,EAAEK,SACjBN,GAAEM,UAAY,GAAIF,G8Bh6HtB,IAAO8Z,GAAa3b,EAAe,qCAInC,IAAOkC,GAAelC,EAAe,8CAYrC,IAAO4b,GAAgB5b,EAAe,sD9Bw5HtC,I8Bn5HM6b,GAAoB,SAAAjZ,GAASrB,EAA7Bsa,EAAoBjZ,EAczB,SAdKiZ,GAcOtC,EAA+BuC,EAA+BC,GAA/B,GAAAD,QAAA,GAA6B,CAA7BA,EAAA,EAA+B,GAAAC,QAAA,GAAgB,CAAhBA,EAAA,EAEzEnZ,EAAA7B,KAAAS,KAAM+X,EAEN/X,MAAKwa,cAAgBxa,KAAKiY,eAAeE,aAAaxJ,YAEtD3O,MAAKsa,WAAaA,CAClBta,MAAKua,MAAQA,IAEXF,EAAqBI,YAEvB,KAAKJ,EAAqBK,cACzB1a,KAAK2a,mBAOPjY,OAAAC,eAAW0X,EAAA9Z,UAAA,c9By4HJqC,I8Bz4HP,WAEC,MAAO5C,MAAK4a,a9B04HN5X,I8Bv4HP,SAAsBC,GAErB,GAAIA,EAAQ,EACXA,EAAQ,MACJ,IAAIA,EAAQ,GAChBA,EAAQ,EAET,IAAIjD,KAAK4a,aAAe3X,EACvB,MAEDjD,MAAK4a,YAAc3X,CAEnBjD,MAAKuJ,4B9Bq4HCzG,WAAY,KACZC,aAAc,M8Bh4HdsX,GAAA9Z,UAAAkG,QAAP,SAAeC,EAAuBC,GAErCvF,EAAAb,UAAMkG,QAAOlH,KAAAS,KAAC0G,EAAQC,EAEtBA,GAASf,gBAAkB,IAE3Be,GAASiH,mBAAqBlH,EAAO+C,aAAa4Q,EAAqBK,eAMjEL,GAAA9Z,UAAAsG,eAAP,SAAsBH,EAAmBC,GAExCvF,EAAAb,UAAMsG,eAActH,KAAAS,KAAC0G,EAAQC,EAE7B,IAAI6R,GAA4B9R,EAAOmB,oBACvC,IAAInE,GAAuBiD,EAASjB,sBACpC8S,GAAa9U,EAAQ,GAAK,EAAE1D,KAAK4a,YAMlClY,QAAAC,eAAW0X,EAAA9Z,UAAA,S9B+3HJqC,I8B/3HP,WAEC,MAAO5C,MAAK6a,OAAO,G9Bg4Hb7X,I8B73HP,SAAiBC,GAEhBjD,KAAK6a,OAAS5X,EAAM,G9B83HdH,WAAY,KACZC,aAAc,M8Bz3HbsX,GAAA9Z,UAAAoa,iBAAR,WAECN,EAAqBS,oBAAsB,GAAIX,GAAc,GAAI,GAAI,MACrE,IAAIY,GAA6B,GAAIrZ,MACrC,IAAI4V,GAAsB,IAC1B,IAAI0D,GAAc,GAAGhb,KAAKwa,cAAcxa,KAAK6a,OAC7C,IAAIjc,GAAUqc,CAEd,KAAK,GAAIhc,GAAoB,EAAGA,EAAIqY,IAAOrY,EAAG,CAC7CL,EAAI,GAAGsc,KAAKC,SAAW,GACvBF,GAAI,GAAGC,KAAKC,SAAW,GACvB,IAAIvc,EAAI,EACPA,GAAKoc,MACLpc,IAAKoc,CACN,IAAIC,EAAI,EACPA,GAAKD,MACLC,IAAKD,CACN,IAAIpc,EAAI,EACPA,EAAI,MAAQ,IAAIA,GAAK,EACrBA,GAAK,CACN,IAAIqc,EAAI,EACPA,EAAI,MAAQ,IAAIA,GAAK,EACrBA,GAAK,CACNF,GAAI9b,GAAMic,KAAKE,OAAOxc,EAAE,GAAK,IAAI,MAAS,GAAOsc,KAAKE,OAAOH,EAAE,GAAK,IAAI,MAAS,EAGlFZ,EAAqBS,oBAAoBO,SAAShB,EAAqBS,oBAAoBQ,KAAMP,EACjGV,GAAqBK,cAAgB,GAAIha,GAAgB2Z,EAAqBS,qBAMxET,GAAA9Z,UAAAmJ,QAAP,WAEC,KAAM2Q,EAAqBI,cAAgB,EAAG,CAC7CJ,EAAqBK,cAAchR,SACnC2Q,GAAqBS,oBAAoBpR,SACzC2Q,GAAqBK,cAAgB,MAOhCL,GAAA9Z,UAAAmH,UAAP,SAAiBhB,EAAmBC,EAAmBgB,GAEtDvG,EAAAb,UAAMmH,UAASnI,KAAAS,KAAC0G,EAAQC,EAAUgB,EAElC,IAAIG,GAAoBpB,EAAOmB,oBAC/B,IAAInE,GAAwBiD,EAASjB,sBACrCoC,GAAKpE,EAAQ,IAAMiE,EAAM0O,MAAQ,GAAG,EACpCvO,GAAKpE,EAAQ,KAAOiE,EAAM2O,OAAS,GAAG,EACtCxO,GAAKpE,EAAQ,IAAM,EAAE1D,KAAK6a,OAAO7a,KAAKwa,aAEtC7T,GAASiH,mBAAmBhG,SAASlB,GAO/B2T,GAAA9Z,UAAAwH,gBAAP,SAAuBrB,EAAmBC,EAAmBqB,EAA2BL,EAAaM,GAEpG7G,EAAAb,UAAMwH,gBAAexI,KAAAS,KAAC0G,EAAQC,EAAUqB,EAAYL,EAAOM,EAE3DtB,GAASiH,mBAAmB1F,gBAAgBF,EAAYtB,GAMlD2T,GAAA9Z,UAAAgb,wBAAP,SAA+B7U,EAAmBC,EAAmBM,EAAiCqB,EAA8BnB,GAEnI,GAAIoG,GAA+BjF,EAASd,yBAC5C,IAAI+O,GAAgCjO,EAASd,yBAC7C,IAAIgU,GAAsClT,EAASd,yBAEnDb,GAASjB,uBAAyB6H,EAAO7J,MAAM,CAE/C,OAAO1D,MAAKyb,cAAc/U,EAAQC,EAAU6U,EAAejO,EAAQtG,EAAWqB,EAAUnB,GAUjFkT,GAAA9Z,UAAAkb,cAAR,SAAsB/U,EAAmBC,EAAmB6U,EAAqCjO,EAA8BtG,EAAiCqB,EAA8BnB,GAE7L,GAAI/H,GAAc,EAClB,IAAIkb,GAA4Bta,KAAK4a,WACrC,IAAIc,GAA8BpT,EAASiC,2BAC3CjC,GAASgC,sBAAsBoR,EAAO,EACtC,IAAIpO,GAA6BhF,EAASiC,2BAC1CjC,GAASgC,sBAAsBgD,EAAM,EAErC,IAAIqO,GAAsCxU,EAAgBkM,kBAE1DjU,IAAQ,OAASsc,EAAQ,KAAOC,EAAgB,KAAOA,EAAgB,OACtE,OAASD,EAAQ,QAAUA,EAAQ,QAAUF,EAAgB,OAE9D,OAAOlB,EAAa,EAAG,CACtB,GAAIA,GAActa,KAAK4a,YAAa,CACnCxb,GAAQuH,EAASiH,mBAAmBxG,kBAAkBV,EAAQgV,EAAOpT,EAAUnB,EAAiBuU,OAC1F,CACNtc,GAAQ,OAASkO,EAAO,KAAOoO,EAAQ,WACtC/U,EAASiH,mBAAmBxG,kBAAkBV,EAAQgV,EAAOpT,EAAUnB,EAAiBmG,GAI1FlO,GAAQ,OAASsc,EAAQ,QAAUA,EAAQ,gBAC1C,OAASA,EAAQ,QAAUA,EAAQ,QAAUF,EAAgB,MAE9D,IAAIlB,GAActa,KAAK4a,YAAa,CAEnCxb,GAAQ,OAASsc,EAAQ,QAAUA,EAAQ,QAAU1b,KAAK4b,mBAAqB,QAC9EjV,EAAS+B,UAAUtB,kBAAkBV,EAAQ4G,EAAMhF,EAAUnB,EAAiBuU,GAC9E,OAASpO,EAAO,OAASA,EAAO,KAAOC,EAAS,KAChD,OAAStG,EAAY,OAASjH,KAAK4b,mBAAqB,OAAStO,EAAO,WACnE,CACNlO,GAAQY,KAAK6b,UAAUnV,EAAQC,EAAU+U,EAAOnO,EAAQtG,EAAWqB,EAAUnB,GAG9E,GAAImT,EAAa,EAChBlb,GAAQ,OAASsc,EAAQ,QAAUA,EAAQ,QAAUA,EAAQ,QAAU1b,KAAK6b,UAAUnV,EAAQC,EAAU+U,EAAOnO,EAAQtG,EAAWqB,EAAUnB,EAE7I,IAAImT,EAAa,EAChBlb,GAAQ,OAASsc,EAAQ,QAAU1b,KAAK4b,mBAAqB,QAAUF,EAAQ,QAAU1b,KAAK6b,UAAUnV,EAAQC,EAAU+U,EAAOnO,EAAQtG,EAAWqB,EAAUnB,EAE/J,IAAImT,EAAa,EAChBlb,GAAQ,OAASsc,EAAQ,QAAUA,EAAQ,QAAUA,EAAQ,QAAU1b,KAAK6b,UAAUnV,EAAQC,EAAU+U,EAAOnO,EAAQtG,EAAWqB,EAAUnB,EAE7I,IAAImT,EAAa,EAAG,CACnBlb,GAAQ,OAASsc,EAAQ,OAASA,EAAQ,MAC1Ctc,IAAQ,OAASsc,EAAQ,QAAUA,EAAQ,QAAU1b,KAAK4b,mBAAqB,QAAU5b,KAAK6b,UAAUnV,EAAQC,EAAU+U,EAAOnO,EAAQtG,EAAWqB,EAAUnB,GAG/J,GAAImT,EAAa,EAChBlb,GAAQ,OAASsc,EAAQ,QAAUA,EAAQ,QAAUA,EAAQ,QAAU1b,KAAK6b,UAAUnV,EAAQC,EAAU+U,EAAOnO,EAAQtG,EAAWqB,EAAUnB,EAE7I,IAAImT,EAAa,EAChBlb,GAAQ,OAASsc,EAAQ,QAAU1b,KAAK4b,mBAAqB,QAAUF,EAAQ,QAAU1b,KAAK6b,UAAUnV,EAAQC,EAAU+U,EAAOnO,EAAQtG,EAAWqB,EAAUnB,EAE/J,IAAImT,EAAa,EAChBlb,GAAQ,OAASsc,EAAQ,QAAUA,EAAQ,QAAUA,EAAQ,QAAU1b,KAAK6b,UAAUnV,EAAQC,EAAU+U,EAAOnO,EAAQtG,EAAWqB,EAAUnB,EAE7ImT,IAAc,EAGfhS,EAASwC,wBAAwBwC,EACjChF,GAASwC,wBAAwB4Q,EACjCtc,IAAQ,OAAS6H,EAAY,OAASA,EAAY,OAASuU,EAAgB,MAC3E,OAAOpc,GAYAib,GAAA9Z,UAAAsb,UAAR,SAAkBnV,EAAmBC,EAAmB+U,EAA6BnO,EAA8BtG,EAAiCqB,EAA8BnB,GAEjL,GAAImG,GAA6BhF,EAASiC,2BAE1C,OAAO5D,GAAS+B,UAAUtB,kBAAkBV,EAAQ4G,EAAMhF,EAAUnB,EAAiBuU,GACpF,OAASpO,EAAO,OAASA,EAAO,KAAOC,EAAS,KAChD,OAASD,EAAO,OAAStN,KAAK4b,mBAAqB,OAAStO,EAAO,OACnE,OAASrG,EAAY,OAASA,EAAY,OAASqG,EAAO,OAMrD+M,GAAA9Z,UAAAuZ,oBAAP,SAA2BpT,EAAmBC,EAAmBgB,GAEhE,GAAIG,GAAoBpB,EAAOmB,oBAC/B,IAAInE,GAAwBiD,EAAShB,+BACrCmC,GAAKpE,GAAS,EAAE1D,KAAK4a,WACrB9S,GAAKpE,EAAQ,IAAMiE,EAAM0O,MAAQ,GAAG,EACpCvO,GAAKpE,EAAQ,IAAMiE,EAAM2O,OAAS,GAAG,EACrCxO,GAAKpE,EAAQ,GAAK,EAAE1D,KAAK6a,OAAO7a,KAAKwa,aAErC7T,GAASiH,mBAAmBhG,SAASlB,GAM/B2T,GAAA9Z,UAAA6Y,yBAAP,SAAgC1S,EAAmBC,EAAmBmV,EAAsCC,EAAuCC,EAAsC9U,EAAmCC,GAE3NnH,KAAK4b,mBAAqBG,CAE1B,IAAIxF,GAAgCrP,EAAcM,yBAClDb,GAAShB,gCAAkC4Q,EAAQ7S,MAAM,CAEzD,OAAO1D,MAAKyb,cAAc/U,EAAQC,EAAU4P,EAASuF,EAAgBE,EAAgB9U,EAAeC,GAEtG,OAAAkT,IAzSmCD,EA2SnC1a,GAA8BJ,QAArB+a,I9Bk1HN4B,qCAAqCzX,UAAUE,8CAA8CF,UAAU0X,sDAAsD,wDAAwDC,2DAA2D,SAAS3d,EAAQkB,EAAOJ,GAC3S,GAAIS,GAAYC,KAAKD,WAAa,SAAUE,EAAGC,GAC3C,IAAK,GAAIC,KAAKD,GAAG,GAAIA,EAAEE,eAAeD,GAAIF,EAAEE,GAAKD,EAAEC,EACnD,SAASE,KAAOL,KAAKM,YAAcL,EACnCI,EAAGE,UAAYL,EAAEK,SACjBN,GAAEM,UAAY,GAAIF,G+B5oItB,IAAO+Z,GAAgB5b,EAAe,sD/BmpItC,I+B7oIM4d,GAAoB,SAAAhb,GAASrB,EAA7Bqc,EAAoBhb,EAOzB,SAPKgb,GAOOrE,GAEX3W,EAAA7B,KAAAS,KAAM+X,GAMAqE,EAAA7b,UAAAsG,eAAP,SAAsBH,EAAuBC,GAE5CvF,EAAAb,UAAMsG,eAActH,KAAAS,KAAC0G,EAAQC,EAE7B,IAAI6R,GAA4B9R,EAAOmB,oBACvC,IAAInE,GAAuBiD,EAASjB,sBACpC8S,GAAa9U,EAAQ,GAAK,EAC1B,IAAI2Y,GAAsBrc,KAAK+X,aAAaI,aAAaxJ,YACzD6J,GAAa9U,EAAQ,GAAK2Y,CAC1B7D,GAAa9U,EAAQ,IAAM,EAAE2Y,EAMvBD,GAAA7b,UAAAgb,wBAAP,SAA+B7U,EAAmBC,EAAmBM,EAAiCqB,EAA8BnB,GAEnI,GAAI/H,GAAc,EAClB,IAAImO,GAA+BjF,EAASd,yBAC5Cc,GAASd,yBACT,IAAIgU,GAAsClT,EAASd,yBAEnDb,GAASjB,uBAAyB6H,EAAO7J,MAAM,CAE/C,IAAI4Y,GAAiChU,EAASiC,2BAC9CjC,GAASgC,sBAAsBgS,EAAU,EACzC,IAAIZ,GAA8BpT,EAASiC,2BAC3CjC,GAASgC,sBAAsBoR,EAAO,EAEtCtc,IAAQ,OAASsc,EAAQ,KAAO1b,KAAK4b,mBAAqB,KAEzDjV,EAAS+B,UAAUtB,kBAAkBV,EAAQ4V,EAAUhU,EAAUnB,EAAiBnH,KAAK4b,oBACvF,OAASU,EAAW,OAASA,EAAW,KAAO/O,EAAS,KACxD,OAASmO,EAAQ,OAAS1b,KAAK4b,mBAAqB,OAASU,EAAW,OAExE,OAASZ,EAAQ,OAAS1b,KAAK4b,mBAAqB,OAASJ,EAAgB,OAC7E7U,EAAS+B,UAAUtB,kBAAkBV,EAAQ4V,EAAUhU,EAAUnB,EAAiBuU,GAClF,OAASY,EAAW,OAASA,EAAW,KAAO/O,EAAS,KACxD,OAASmO,EAAQ,OAAS1b,KAAK4b,mBAAqB,OAASU,EAAW,OAExE,OAASA,EAAW,OAAStc,KAAK4b,mBAAqB,OAASJ,EAAgB,OAChF,OAASc,EAAW,OAASA,EAAW,OACxC,OAASZ,EAAQ,OAASA,EAAQ,OAASA,EAAQ,OACnD,OAASA,EAAQ,OAASA,EAAQ,OAASY,EAAW,OACtD,OAASrV,EAAY,OAASyU,EAAQ,OAASA,EAAQ,OAEvD,OAASA,EAAQ,OAAS1b,KAAK4b,mBAAqB,OACpD,OAASF,EAAQ,OAAS1b,KAAK4b,mBAAqB,OAASJ,EAAgB,OAC7E7U,EAAS+B,UAAUtB,kBAAkBV,EAAQ4V,EAAUhU,EAAUnB,EAAiBuU,GAClF,OAASY,EAAW,OAASA,EAAW,KAAO/O,EAAS,KACxD,OAASmO,EAAQ,OAAS1b,KAAK4b,mBAAqB,OAASU,EAAW,OAExE,OAASZ,EAAQ,OAAS1b,KAAK4b,mBAAqB,OAASJ,EAAgB,OAC7E7U,EAAS+B,UAAUtB,kBAAkBV,EAAQ4V,EAAUhU,EAAUnB,EAAiBuU,GAClF,OAASY,EAAW,OAASA,EAAW,KAAO/O,EAAS,KACxD,OAASmO,EAAQ,OAAS1b,KAAK4b,mBAAqB,OAASU,EAAW,OAGxE,OAASA,EAAW,OAAStc,KAAK4b,mBAAqB,OAASJ,EAAgB,OAChF,OAASc,EAAW,OAASA,EAAW,OAAS,OAASZ,EAAQ,OAASA,EAAQ,OAASA,EAAQ,OACpG,OAASA,EAAQ,OAASA,EAAQ,OAASY,EAAW,OACtD,OAASZ,EAAQ,OAASA,EAAQ,OAASA,EAAQ,OAEnD,OAASY,EAAW,OAAStc,KAAK4b,mBAAqB,OAASJ,EAAgB,OAChF,OAASc,EAAW,OAASA,EAAW,OACxC,OAASZ,EAAQ,OAASA,EAAQ,OAASzU,EAAY,OACvD,OAASyU,EAAQ,OAASA,EAAQ,OAASY,EAAW,OACtD,OAASrV,EAAY,OAASA,EAAY,OAASyU,EAAQ,MAE5DpT,GAASwC,wBAAwBwR,EACjChU,GAASwC,wBAAwB4Q,EAEjC,OAAOtc,GAMDgd,GAAA7b,UAAAuZ,oBAAP,SAA2BpT,EAAmBC,EAAmBgB,GAEhE,GAAI0U,GAAsBrc,KAAK+X,aAAaI,aAAaxJ,YACzD,IAAIjL,GAAuBiD,EAAShB,+BACpC,IAAImC,GAAoBpB,EAAOmB,oBAC/BC,GAAKpE,GAAS2Y,CACdvU,GAAKpE,EAAQ,GAAK,EAAE2Y,EAMdD,GAAA7b,UAAA6Y,yBAAP,SAAgC1S,EAAmBC,EAAmBmV,EAAsCC,EAAuCC,EAAsC9U,EAAmCC,GAE3N,GAAI/H,EACJ,IAAImX,GAAgCrP,EAAcM,yBAClDb,GAAShB,gCAAkC4Q,EAAQ7S,MAAM,CAEzD,IAAI4J,GAA6BpG,EAAcqD,2BAC/CrD,GAAcoD,sBAAsBgD,EAAM,EAC1C,IAAIiP,GAAkCrV,EAAcqD,2BACpDrD,GAAcoD,sBAAsBiS,EAAW,EAE/Cnd,GAAOuH,EAAS+B,UAAUtB,kBAAkBV,EAAQ4G,EAAMpG,EAAeC,EAAiB4U,GACzF,OAASzO,EAAO,OAASA,EAAO,KAAOwO,EAAiB,KACxD,OAASS,EAAY,OAASR,EAAkB,OAASzO,EAAO,OAEhE,OAASyO,EAAkB,OAASA,EAAkB,OAASxF,EAAU,OACzE5P,EAAS+B,UAAUtB,kBAAkBV,EAAQ4G,EAAMpG,EAAeC,EAAiB4U,GACnF,OAASzO,EAAO,OAASA,EAAO,KAAOwO,EAAiB,KACxD,OAASS,EAAY,OAASR,EAAkB,OAASzO,EAAO,OAEhE,OAASyO,EAAkB,OAASA,EAAkB,OAASxF,EAAU,OACzE5P,EAAS+B,UAAUtB,kBAAkBV,EAAQ4G,EAAMpG,EAAeC,EAAiB4U,GACnF,OAASzO,EAAO,OAASA,EAAO,KAAOwO,EAAiB,KACxD,OAASS,EAAY,OAASR,EAAkB,OAASzO,EAAO,OAEhE,OAASyO,EAAkB,OAASA,EAAkB,OAASxF,EAAU,OACzE5P,EAAS+B,UAAUtB,kBAAkBV,EAAQ4G,EAAMpG,EAAeC,EAAiB4U,GACnF,OAASzO,EAAO,OAASA,EAAO,KAAOwO,EAAiB,KACxD,OAASS,EAAY,OAASR,EAAkB,OAASzO,EAAO,OAEhE,OAASA,EAAO,QAAUyO,EAAkB,QAAUxF,EAAU,OAChE,OAASjJ,EAAO,QAAUA,EAAO,QAGjC,OAASyO,EAAkB,KAAOQ,EAAY,UAAYA,EAAY,UACtE,OAASR,EAAkB,KAAOA,EAAkB,KAAOzO,EAAO,OAElE,OAASiP,EAAY,QAAUA,EAAY,QAAUR,EAAkB,QAEvE,OAASQ,EAAY,OAASA,EAAY,OAASA,EAAY,OAC/D,OAASA,EAAY,OAASA,EAAY,OAASjP,EAAO,OAC1D,OAAS0O,EAAiB,OAASO,EAAY,OAASA,EAAY,MAErErV,GAAc4D,wBAAwBwC,EACtCpG,GAAc4D,wBAAwByR,EACtC,OAAOnd,GAET,OAAAgd,IAxJmChC,EA0JL1a,GAAAJ,QAArB8c,I/ByjINF,sDAAsD,wDAAwDM,uDAAuD,SAAShe,EAAQkB,EAAOJ,GAChM,GAAIS,GAAYC,KAAKD,WAAa,SAAUE,EAAGC,GAC3C,IAAK,GAAIC,KAAKD,GAAG,GAAIA,EAAEE,eAAeD,GAAIF,EAAEE,GAAKD,EAAEC,EACnD,SAASE,KAAOL,KAAKM,YAAcL,EACnCI,EAAGE,UAAYL,EAAEK,SACjBN,GAAEM,UAAY,GAAIF,GgC/tItB,IAAO+Z,GAAgB5b,EAAe,sDhCquItC,IgChuIMie,GAAgB,SAAArb,GAASrB,EAAzB0c,EAAgBrb,EAKrB,SALKqb,GAKO1E,GAEX3W,EAAA7B,KAAAS,KAAM+X,GAMA0E,EAAAlc,UAAAgb,wBAAP,SAA+B7U,EAAmBC,EAAmBM,EAAiCqB,EAA8BnB,GAEnI,GAAI/H,GAAc,EAClB,IAAImO,GAA+BjF,EAASd,yBAC5Cc,GAASd,yBAET,IAAI8U,GAAiChU,EAASiC,2BAE9C5D,GAASjB,uBAAyB6H,EAAO7J,MAAM,CAE/CtE,IAAQuH,EAAS+B,UAAUtB,kBAAkBV,EAAQ4V,EAAUhU,EAAUnB,EAAiBnH,KAAK4b,oBAC9F,OAASU,EAAW,OAASA,EAAW,KAAO/O,EAAS,KACxD,OAAStG,EAAY,OAASjH,KAAK4b,mBAAqB,OAASU,EAAW,MAE7E,OAAOld,GAMDqd,GAAAlc,UAAAmc,uBAAP,SAA8BhW,EAAmBC,EAAmBM,EAAiCqB,EAA8BnB,GAElI,GAAI/H,GAAc,EAClB,IAAImO,GAA+BjF,EAASd,yBAC5C,IAAImV,GAA+BrU,EAASd,yBAC5C,IAAIoV,GAA+BtU,EAASd,yBAC5C,IAAIqV,GAAuCvU,EAASiC,2BACpDjC,GAASgC,sBAAsBuS,EAAgB,EAC/C,IAAIC,GAAiCxU,EAASiC,2BAC9CjC,GAASgC,sBAAsBwS,EAAU,EAEzCnW,GAASjB,uBAAyB6H,EAAO7J,MAAM,CAE/CtE,IAAQ,OAAS0d,EAAW,KAAO3V,EAAgB4V,sBAAwB,KAAOH,EAAS,KAC1F,OAASE,EAAW,OAASA,EAAW,SAAWA,EAAW,SAC9D,OAASA,EAAW,OAASA,EAAW,OAASF,EAAS,OAC1D,OAASE,EAAW,SAAWA,EAAW,SAE1CnW,EAAS+B,UAAUtB,kBAAkBV,EAAQmW,EAAgBvU,EAAUnB,EAAiB2V,GACxF,OAASD,EAAiB,OAASA,EAAiB,KAAOtP,EAAS,KACpE,OAAStG,EAAY,OAAS6V,EAAW,OAASH,EAAS,OAE3D,OAAS1V,EAAY,OAASA,EAAY,OAAS4V,EAAiB,MAErEvU,GAASwC,wBAAwBgS,EACjCxU,GAASwC,wBAAwB+R,EAEjC,OAAOzd,GAMDqd,GAAAlc,UAAA6Y,yBAAP,SAAgC1S,EAAmBC,EAAmBmV,EAAsCC,EAAuCC,EAAsC9U,EAAmCC,GAE3N,GAAImG,GAA6BpG,EAAcqD,2BAE/C,OAAO5D,GAAS+B,UAAUtB,kBAAkBV,EAAQ4G,EAAMpG,EAAeC,EAAiB4U,GACzF,OAASzO,EAAO,OAASA,EAAO,KAAOwO,EAAiB,KACxD,OAASE,EAAiB,OAASD,EAAkB,OAASzO,EAAO,OAMhEmP,GAAAlc,UAAAuZ,oBAAP,SAA2BpT,EAAmBC,EAAmBgB,IAGlE,OAAA8U,IAjF+BrC,EAmF/B1a,GAA0BJ,QAAjBmd,IhCmsINP,sDAAsD,wDAAwDjC,0DAA0D,SAASzb,EAAQkB,EAAOJ,GACnM,GAAIS,GAAYC,KAAKD,WAAa,SAAUE,EAAGC,GAC3C,IAAK,GAAIC,KAAKD,GAAG,GAAIA,EAAEE,eAAeD,GAAIF,EAAEE,GAAKD,EAAEC,EACnD,SAASE,KAAOL,KAAKM,YAAcL,EACnCI,EAAGE,UAAYL,EAAEK,SACjBN,GAAEM,UAAY,GAAIF,GiCryItB,IAAO6F,GAAiB1H,EAAc,uDjC2yItC,IiCtyIMoZ,GAAmB,SAAAxW,GAASrB,EAA5B6X,EAAmBxW,EAcxB,SAdKwW,GAcOG,GAEX3W,EAAA7B,KAAAS,KATMA,MAAAuZ,UAAmB,GACnBvZ,MAAA2Z,QAAiB,CASvB3Z,MAAKiY,eAAiBF,CACtBA,GAAaiF,aAAe,IAC5Bhd,MAAKid,eAAiBlF,EAAaI,YAEnCnY,MAAK+J,YAAYgO,EAAaI,aAAaI,UAM5C7V,OAAAC,eAAWiV,EAAArX,UAAA,ajC8xIJqC,IiC9xIP,WAEC,MAAOgV,GAAoB/U,WjC+xIrBC,WAAY,KACZC,aAAc,MiC1xIrBL,QAAAC,eAAWiV,EAAArX,UAAA,SjCgyIJqC,IiChyIP,WAEC,MAAO5C,MAAK2Z,SjCiyIN3W,IiC9xIP,SAAiBC,GAEhBjD,KAAK2Z,QAAU1W,GjC+xITH,WAAY,KACZC,aAAc,MiC1xIrBL,QAAAC,eAAWiV,EAAArX,UAAA,gBjCgyIJqC,IiChyIP,WAEC,MAAO5C,MAAKiY,gBjCiyINnV,WAAY,KACZC,aAAc,MiC3xIrBL,QAAAC,eAAWiV,EAAArX,UAAA,WjCkyIJqC,IiClyIP,WAEC,MAAO5C,MAAKuZ,WjCmyINvW,IiChyIP,SAAmBC,GAElBjD,KAAKuZ,UAAYtW,GjCiyIXH,WAAY,KACZC,aAAc,MiCh2IP6U,GAAA/U,UAAmB,yBAgElC,OAAA+U,IAlEkC1R,EAoElCxG,GAA6BJ,QAApBsY,IjCqyINzP,uDAAuD,yDAAyD+T,uDAAuD,SAAS1d,EAAQkB,EAAOJ,GAClM,GAAIS,GAAYC,KAAKD,WAAa,SAAUE,EAAGC,GAC3C,IAAK,GAAIC,KAAKD,GAAG,GAAIA,EAAEE,eAAeD,GAAIF,EAAEE,GAAKD,EAAEC,EACnD,SAASE,KAAOL,KAAKM,YAAcL,EACnCI,EAAGE,UAAYL,EAAEK,SACjBN,GAAEM,UAAY,GAAIF,GkCv3ItB,IAAOyT,GAAmBtV,EAAc,6CAKxC,IAAO0e,GAAU1e,EAAgB,yCAcjC,IAAOoZ,GAAmBpZ,EAAc,yDlC42IxC,IkCv2IM4b,GAAgB,SAAAhZ,GAASrB,EAAzBqa,EAAgBhZ,EASrB,SATKgZ,GASOrC,GAEX/X,KAAKmd,WAAcpF,YAAwBmF,EAE3C9b,GAAA7B,KAAAS,KAAM+X,GAMAqC,EAAA7Z,UAAAkG,QAAP,SAAeC,EAAuBC,GAErCA,EAASd,UAAY,IACrBc,GAASX,qBAAuB,IAChCW,GAASV,uBAAyBjG,KAAKmd,UACvCxW,GAASb,aAAeY,EAAO4C,UAAY,CAE3C3C,GAAS+B,UAAYhC,EAAO+C,aAAazJ,KAAKiY,eAAeE,aAAaI,UAMpE6B,GAAA7Z,UAAAsG,eAAP,SAAsBH,EAAmBC,GAExC,GAAI6R,GAA4B9R,EAAOmB,oBACvC,IAAI4Q,GAA0B/R,EAAO0I,kBACrC,IAAI1L,GAAuBiD,EAASjB,sBACpC8S,GAAa9U,GAAS,CACtB8U,GAAa9U,EAAQ,GAAK,EAAE,GAC5B8U,GAAa9U,EAAQ,GAAK,EAAE,KAC5B8U,GAAa9U,EAAQ,GAAK,EAAE,QAE5B8U,GAAa9U,EAAQ,GAAK,CAC1B8U,GAAa9U,EAAQ,GAAK,CAE1B,IAAI1D,KAAKmd,WAAY,CACpB3E,EAAa9U,EAAQ,GAAK,CAC1B8U,GAAa9U,EAAQ,GAAK,CAC1B8U,GAAa9U,EAAQ,IAAM,CAC3B8U,GAAa9U,EAAQ,IAAM,EAG5BA,EAAQiD,EAASnB,oBACjB,IAAI9B,IAAU,EAAG,CAChB+U,EAAW/U,GAAS,EACpB+U,GAAW/U,EAAQ,GAAK,EACxB+U,GAAW/U,EAAQ,GAAK,CACxB+U,GAAW/U,EAAQ,GAAK,GAO1BhB,QAAAC,eAAWyX,EAAA7Z,UAAA,sBlC01IJqC,IkC11IP,WAEC,MAAO5C,MAAK4b,oBlC21IN5Y,IkCx1IP,SAA8BC,GAE7BjD,KAAK4b,mBAAqB3Y,GlCy1IpBH,WAAY,KACZC,aAAc,MkCp1IdqX,GAAA7Z,UAAA2J,sBAAP,WAEC9I,EAAAb,UAAM2J,sBAAqB3K,KAAAS,KAE3BA,MAAK4b,mBAAqB,KAMpBxB,GAAA7Z,UAAA2M,eAAP,SAAsBxG,EAAmBC,EAAmB2B,EAA8BnB,GAEzF,MAAOnH,MAAKmd,WAAYnd,KAAKod,qBAAqBzW,EAAU2B,EAAUnB,GAAiBnH,KAAKqd,qBAAqB1W,EAAU2B,EAAUnB,GAS/HiT,GAAA7Z,UAAA6c,qBAAP,SAA4BzW,EAAmB2B,EAA8BnB,GAE5ER,EAASnB,sBAAwB,CACjC,OAAO,GASD4U,GAAA7Z,UAAA8c,qBAAP,SAA4B1W,EAAmB2B,EAA8BnB,GAE5E,GAAI/H,GAAc,EAClB,IAAIkO,GAA6BhF,EAASwH,yBAC1C,IAAIyG,GAAgCjO,EAASyH,uBAC7C,IAAIuN,GAAqChV,EAASyH,uBAClDzH,GAASyH,uBACTzH,GAASyH,uBACTzH,GAASyH,uBACT/P,MAAK4b,mBAAqBtT,EAAS0H,gBACnCrJ,GAASnB,qBAAuB+Q,EAAQ7S,MAAM,CAI9CtE,IAAQ,OAASkO,EAAO,KAAOnG,EAAgB2R,qBAAuB,KAAOwE,EAAe,KAC3F,OAAShQ,EAAO,KAAOA,EAAO,KAAOA,EAAO,OAC5C,OAASA,EAAO,QAAUA,EAAO,QAAUiJ,EAAU,QACrD,OAASvW,KAAK4b,mBAAqB,KAAOtO,EAAO,KAAOiJ,EAAU,SAGnE,OAAOnX,GAMDgb,GAAA7Z,UAAAyG,iBAAP,SAAwBN,EAAmBC,EAAmBM,EAAiCC,EAAmCC,GAEjI,GAAI/H,GAAcY,KAAKmd,WAAYnd,KAAK0c,uBAAuBhW,EAAQC,EAAUM,EAAWC,EAAeC,GAAmBnH,KAAKub,wBAAwB7U,EAAQC,EAAUM,EAAWC,EAAeC,EACvM/H,IAAQ,OAAS6H,EAAY,OAASA,EAAY,UAAYN,EAASjB,uBAAuB,EAAI,GAAK,OACtG,OAASuB,EAAY,OAASA,EAAY,MAC3C,OAAO7H,GAUDgb,GAAA7Z,UAAAgb,wBAAP,SAA+B7U,EAAmBC,EAAmBM,EAAiCqB,EAA8BnB,GAEnI,KAAM,IAAI2M,EACV,OAAO,GAUDsG,GAAA7Z,UAAAmc,uBAAP,SAA8BhW,EAAmBC,EAAmBM,EAAiCqB,EAA8BnB,GAElI,KAAM,IAAI2M,EACV,OAAO,GAMDsG,GAAA7Z,UAAAwH,gBAAP,SAAuBrB,EAAmBC,EAAmBqB,EAA2BL,EAAaM,GAEpG,IAAKjI,KAAKmd,WACkBnd,KAAKid,eAAgBM,iBAAiBlN,cAAc3J,EAAO0I,mBAAoBzI,EAASnB,qBAAuB,EAAG,KAE9ImB,GAAS+B,UAAUR,gBAAgBF,EAAYtB,GAazC0T,GAAA7Z,UAAA6Y,yBAAP,SAAgC1S,EAAmBC,EAAmBmV,EAAsCC,EAAuCC,EAAsC9U,EAAmCC,GAE3N,KAAM,IAAIhI,OAAM,2DAMVib,GAAA7Z,UAAAmH,UAAP,SAAiBhB,EAAmBC,EAAmBgB,GAEtD,GAAI6Q,GAA4B9R,EAAOmB,oBACvC,IAAInE,GAAuBiD,EAASjB,sBAEpC,IAAI1F,KAAKmd,WACR3E,EAAa9U,EAAQ,IAAMwX,KAAKsC,IAAI,GAAiBxd,KAAKiY,eAAgBwF,QAAQzd,KAAKuZ,WAAY,OAEnG7S,GAAO0I,mBAAmBzI,EAASnB,qBAAuB,IAAM,GAA8BxF,KAAKid,eAAgB3D,MAAMtZ,KAAKuZ,UAE/Hf,GAAa9U,EAAQ,GAAK,EAAI1D,KAAK2Z,OAEnC,IAAI3Z,KAAKmd,WAAY,CACpB,GAAIO,GAAe1d,KAAKiY,eAAe0F,aACvCnF,GAAa9U,EAAQ,GAAKga,EAAIE,CAC9BpF,GAAa9U,EAAQ,GAAKga,EAAIG,CAC9BrF,GAAa9U,EAAQ,IAAMga,EAAII,ClC4zItB,IkC1zIL5e,GAAyBc,KAAKiY,eAAgBwF,OAClDjF,GAAa9U,EAAQ,IAAM,GAAG,EAAExE,EAAEA,GAGnCyH,EAAS+B,UAAUd,SAASlB,GAMtB0T,GAAA7Z,UAAAuZ,oBAAP,SAA2BpT,EAAmBC,EAAmBgB,GAEhE,KAAM,IAAIxI,OAAM,2DAElB,OAAAib,IAvO+BxC,EAyOLlY,GAAAJ,QAAjB8a,IlCyzINrG,6CAA6CvP,UAAUuZ,yCAAyCvZ,UAAUyV,yDAAyD,2DAA2D+D,uDAAuD,SAASxf,EAAQkB,EAAOJ,GAChT,GAAIS,GAAYC,KAAKD,WAAa,SAAUE,EAAGC,GAC3C,IAAK,GAAIC,KAAKD,GAAG,GAAIA,EAAEE,eAAeD,GAAIF,EAAEE,GAAKD,EAAEC,EACnD,SAASE,KAAOL,KAAKM,YAAcL,EACnCI,EAAGE,UAAYL,EAAEK,SACjBN,GAAEM,UAAY,GAAIF,GmC1jJtB,IAAOkM,GAAkB/N,EAAc,kDAQvC,IAAO4b,GAAgB5b,EAAe,sDnC6jJtC,ImCpjJMyf,GAAgB,SAAA7c,GAASrB,EAAzBke,EAAgB7c,EAcrB,SAdK6c,GAcOjS,EAA6BkS,GAd1C,GAAAjS,GAAAjM,IAc0C,IAAAke,QAAA,GAAqB,CAArBA,EAAA,GAExC9c,EAAA7B,KAAAS,KAAMgM,EAAW+L,aAEjB/X,MAAKyM,6BAA+B,SAACC,GAA6B,MAAAT,GAAKU,oBAAoBD,GAE3F1M,MAAKgY,YAAchM,CACnBhM,MAAKme,WAAaD,CAClBle,MAAKoe,kBAAkDpe,KAAKiY,eAAeE,YAC3E,KAAKnY,KAAKoe,kBACT,KAAM,IAAIjf,OAAM,8GACjBa,MAAKgY,YAAYnL,iBAAiBN,EAAmBO,mBAAoB9M,KAAKyM,8BAM/E/J,OAAAC,eAAWsb,EAAA1d,UAAA,cnC4iJJqC,ImC5iJP,WAEC,MAAO5C,MAAKgY,anC6iJNhV,ImC1iJP,SAAsBC,GAErB,GAAIjD,KAAKgY,aAAe/U,EACvB,MAEDjD,MAAKgY,YAAYjL,oBAAoBR,EAAmBO,mBAAoB9M,KAAKyM,6BAEjFzM,MAAKgY,YAAc/U,CAEnBjD,MAAKgY,YAAYnL,iBAAiBN,EAAmBO,mBAAoB9M,KAAKyM,6BAE9EzM,MAAKuJ,4BnCuiJCzG,WAAY,KACZC,aAAc,MmCliJdkb,GAAA1d,UAAAsG,eAAP,SAAsBH,EAAmBC,GAExCvF,EAAAb,UAAMsG,eAActH,KAAAS,KAAC0G,EAAQC,EAC7B3G,MAAKgY,YAAYnR,eAAeH,EAAQC,EAExC,IAAI6R,GAA4B9R,EAAOmB,oBACvC,IAAInE,GAAuBiD,EAAShB,+BACpC6S,GAAa9U,EAAQ,GAAK,CAC1B8U,GAAa9U,EAAQ,GAAK,EAMpBua,GAAA1d,UAAAkG,QAAP,SAAeC,EAAuBC,GAErC3G,KAAKgY,YAAYvR,QAAQC,EAAQC,EAEjCA,GAASf,gBAAkB,KAMrBqY,GAAA1d,UAAAmJ,QAAP,WAEC1J,KAAKgY,YAAYjL,oBAAoBR,EAAmBO,mBAAoB9M,KAAKyM,8BAMlF/J,QAAAC,eAAWsb,EAAA1d,UAAA,SnCgiJJqC,ImChiJP,WAEC,MAAO5C,MAAKgY,YAAY1V,OnCiiJlBU,ImC9hJP,SAAiBC,GAEhBjD,KAAKgY,YAAY1V,MAAQW,GnC+hJnBH,WAAY,KACZC,aAAc,MmC1hJrBL,QAAAC,eAAWsb,EAAA1d,UAAA,WnCgiJJqC,ImChiJP,WAEC,MAAO5C,MAAKgY,YAAYqG,SnCiiJlBrb,ImC9hJP,SAAmBC,GAElBjD,KAAKgY,YAAYqG,QAAUpb,GnC+hJrBH,WAAY,KACZC,aAAc,MmC1hJrBL,QAAAC,eAAWsb,EAAA1d,UAAA,anCgiJJqC,ImChiJP,WAEC,MAAO5C,MAAKme,YnCiiJNnb,ImC9hJP,SAAqBC,GAEpBjD,KAAKme,WAAalb,GnC+hJZH,WAAY,KACZC,aAAc,MmC1hJdkb,GAAA1d,UAAAyG,iBAAP,SAAwBN,EAAmBC,EAAmBM,EAAiCC,EAAmCC,GAEjI,GAAI/H,GAAcY,KAAKgY,YAAYhR,iBAAiBN,EAAQC,EAAUM,EAAWC,EAAeC,EAEhG,IAAIoP,GAAgCrP,EAAcM,yBAClD,IAAI8F,GAA6BpG,EAAcoX,2BAC/C3X,GAAShB,gCAAkC4Q,EAAQ7S,MAAM,CAEzDtE,IAAQ,OAASkO,EAAO,KAAOnG,EAAgBkM,mBAAqB,OACnE,OAAS/F,EAAO,KAAOA,EAAO,KAAOiJ,EAAU,OAC/C,OAASjJ,EAAO,KAAOA,EAAO,KAAOiJ,EAAU,OAC/C,OAASjJ,EAAO,KAAOA,EAAO,KAC9B,OAASA,EAAO,KAAOiJ,EAAU,MAAQjJ,EAAO,KAChD,OAASrG,EAAY,OAASsP,EAAU,MAAQtP,EAAY,OAC5D,OAASA,EAAY,OAASA,EAAY,OAASqG,EAAO,KAC1D,OAASrG,EAAY,OAASsP,EAAU,MAAQtP,EAAY,MAE7D,OAAO7H,GAMD6e,GAAA1d,UAAAmH,UAAP,SAAiBhB,EAAmBC,EAAmBgB,GAEtD3H,KAAKgY,YAAYtQ,UAAUhB,EAAQC,EAAUgB,GAMvCsW,GAAA1d,UAAA0M,YAAP,SAAmBvG,EAAmBC,EAAmBgB,GAExD3H,KAAKgY,YAAY/K,YAAYvG,EAAQC,EAAUgB,GAMzCsW,GAAA1d,UAAAwH,gBAAP,SAAuBrB,EAAmBC,EAAmBqB,EAA2BL,EAAaM,GnCihJ9F,GmC9gJFsW,GAActW,EAAOuW,WAAWD,IACpC,IAAIte,GAAWgI,EAAOuW,WAAWC,IAAMF,CACvC,IAAI3L,GAAqB5S,KAAKoe,kBAAkBM,aAChD,IAAI/L,GAAqBC,GAAa,EAAI5S,KAAKme,WAE/CvL,GAAc2L,EAAO3L,EAAY3S,CACjC0S,GAAc4L,EAAO5L,EAAY1S,CAEjC,IAAIuY,GAA4B9R,EAAOmB,oBACvC,IAAInE,GAAuBiD,EAAShB,+BACpC6S,GAAa9U,GAASiP,CACtB6F,GAAa9U,EAAQ,GAAK,GAAGkP,EAAcD,EAE3C3S,MAAKgY,YAAYjQ,gBAAgBrB,EAAQC,EAAUqB,EAAYL,EAAOM,GAMhEgW,GAAA1d,UAAA2M,eAAP,SAAsBxG,EAAmBC,EAAmBO,EAAmCC,GAE9F,MAAOnH,MAAKgY,YAAY9K,eAAexG,EAAQC,EAAUO,EAAeC,GAMlE8W,GAAA1d,UAAAgF,OAAP,WAECvF,KAAKgY,YAAYzS,SAMX0Y,GAAA1d,UAAA2J,sBAAP,WAEC9I,EAAAb,UAAM2J,sBAAqB3K,KAAAS,KAC3BA;KAAKgY,YAAY9N,wBAMV+T,GAAA1d,UAAAoM,oBAAR,SAA4BD,GAE3B1M,KAAKuJ,2BAEP,OAAA0U,IAtN+B7D,EAwNL1a,GAAAJ,QAAjB2e,InCqgJN/B,sDAAsD,sDAAsD/O,kDAAkD3I,YAAYma,uDAAuD,SAASngB,EAAQkB,EAAOJ,GAC5P,GAAIS,GAAYC,KAAKD,WAAa,SAAUE,EAAGC,GAC3C,IAAK,GAAIC,KAAKD,GAAG,GAAIA,EAAEE,eAAeD,GAAIF,EAAEE,GAAKD,EAAEC,EACnD,SAASE,KAAOL,KAAKM,YAAcL,EACnCI,EAAGE,UAAYL,EAAEK,SACjBN,GAAEM,UAAY,GAAIF,GoCzvJtB,IAAOue,GAAapgB,EAAe,qCAYnC,IAAO4b,GAAgB5b,EAAe,sDpCovJtC,IoC/uJMqgB,GAAgB,SAAAzd,GAASrB,EAAzB8e,EAAgBzd,EAYrB,SAZKyd,GAYO9G,EAA+BuC,EAA+BC,GAA/B,GAAAD,QAAA,GAA6B,CAA7BA,EAAA,EAA+B,GAAAC,QAAA,GAAgB,CAAhBA,EAAA,EAEzEnZ,EAAA7B,KAAAS,KAAM+X,EAZC/X,MAAA6a,OAAgB,CAcvB7a,MAAKsa,WAAaA,CAClBta,MAAKua,MAAQA,EAOd7X,OAAAC,eAAWkc,EAAAte,UAAA,cpC4uJJqC,IoC5uJP,WAEC,MAAO5C,MAAK4a,apC6uJN5X,IoC1uJP,SAAsBC,GAErBjD,KAAK4a,YAAc3X,CAEnB,IAAIjD,KAAK4a,YAAc,EACtB5a,KAAK4a,YAAc,MACf,IAAI5a,KAAK4a,YAAc,GAC3B5a,KAAK4a,YAAc,EAEpB5a,MAAK8e,SAAWF,EAAcG,gBAAgB/e,KAAK4a,YAEnD5a,MAAKuJ,4BpCwuJCzG,WAAY,KACZC,aAAc,MoCnuJrBL,QAAAC,eAAWkc,EAAAte,UAAA,SpCyuJJqC,IoCzuJP,WAEC,MAAO5C,MAAK6a,QpC0uJN7X,IoCvuJP,SAAiBC,GAEhBjD,KAAK6a,OAAS5X,GpCwuJRH,WAAY,KACZC,aAAc,MoCnuJd8b,GAAAte,UAAAsG,eAAP,SAAsBH,EAAmBC,GAExCvF,EAAAb,UAAMsG,eAActH,KAAAS,KAAC0G,EAAQC,EAE7BD,GAAOmB,qBAAqBlB,EAASjB,uBAAyB,GAAK,EAAE1F,KAAK4a,WAC1ElU,GAAOmB,qBAAqBlB,EAASjB,uBAAyB,GAAK,EAM7DmZ,GAAAte,UAAAmH,UAAP,SAAiBhB,EAAmBC,EAAmBgB,GAEtDvG,EAAAb,UAAMmH,UAASnI,KAAAS,KAAC0G,EAAQC,EAAUgB,EAElC,IAAIqX,GAAkB,GAAGhf,KAAK6a,OAAO7a,KAAKiY,eAAeE,aAAaxJ,YACtE,IAAI7G,GAAoBpB,EAAOmB,oBAC/B,IAAInE,GAAwBiD,EAASjB,uBAAyB,EAC9D,IAAI4R,GAAsBtX,KAAK4a,aAAe,CAE9C,KAAK,GAAI3b,GAAmB,EAAGA,EAAIqY,IAAOrY,EACzC6I,EAAKpE,EAAQzE,GAAKe,KAAK8e,SAAS7f,GAAG+f,EAM9BH,GAAAte,UAAAgb,wBAAP,SAA+B7U,EAAmBC,EAAmBM,EAAiCqB,EAA8BnB,GpCmuJ7H,GoChuJFoG,GAA+BjF,EAASd,yBAC5Cc,GAASd,yBACT,IAAI+O,GAAgCjO,EAASd,yBAE7Cb,GAASjB,uBAAyB6H,EAAO7J,MAAM,CAE/C,OAAO1D,MAAKyb,cAAc/U,EAAQC,EAAU4G,EAAQtG,EAAWqB,EAAUnB,EAAiBoP,GAYnFsI,GAAAte,UAAAsb,UAAR,SAAkBnV,EAAmBC,EAAmBmV,EAAsCE,EAAsC9U,EAAmCC,EAAoCuU,GAE1M,GAAIpO,GAA6BpG,EAAcqD,2BAC/C,OAAO5D,GAAS+B,UAAUtB,kBAAkBV,EAAQ4G,EAAMpG,EAAeC,EAAiBuU,GACzF,OAASpO,EAAO,OAASA,EAAO,KAAOwO,EAAiB,KACxD,OAASJ,EAAQ,OAAS1b,KAAK4b,mBAAqB,OAAStO,EAAO,OACpE,OAAS0O,EAAiB,OAASA,EAAiB,OAASN,EAAQ,OAMhEmD,GAAAte,UAAAuZ,oBAAP,SAA2BpT,EAAmBC,EAAmBgB,GAEhEvG,EAAAb,UAAMmH,UAASnI,KAAAS,KAAC0G,EAAQC,EAAUgB,EAElC,IAAIqX,GAAkBhf,KAAK6a,OAAO7a,KAAKiY,eAAeE,aAAaxJ,YACnE,IAAI7G,GAAoBpB,EAAOmB,oBAC/B,IAAInE,GAAwBiD,EAAShB,+BACrC,IAAI2R,GAAsBtX,KAAK4a,aAAe,CAC9C9S,GAAKpE,GAAS,EAAE1D,KAAK4a,WACrB9S,GAAKpE,EAAQ,GAAK,CAClBA,IAAS,CAET,KAAK,GAAIzE,GAAmB,EAAGA,EAAIqY,IAAOrY,EACzC6I,EAAKpE,EAAQzE,GAAKe,KAAK8e,SAAS7f,GAAG+f,CAEpC,IAAI1H,EAAI,GAAK,EAAG,CACfxP,EAAKpE,EAAQ4T,GAAO,CACpBxP,GAAKpE,EAAQ4T,EAAM,GAAK,GAOnBuH,GAAAte,UAAA6Y,yBAAP,SAAgC1S,EAAmBC,EAAmBmV,EAAsCC,EAAuCC,EAAsC9U,EAAmCC,GAE3NnH,KAAK4b,mBAAqBG,CAE1B,IAAIxF,GAAgCrP,EAAcM,yBAClDb,GAAShB,gCAAkC4Q,EAAQ7S,MAAM,CAEzD,OAAO1D,MAAKyb,cAAc/U,EAAQC,EAAUmV,EAAgBE,EAAgB9U,EAAeC,EAAiBoP,GAWrGsI,GAAAte,UAAAkb,cAAR,SAAsB/U,EAAmBC,EAAmBmV,EAAsCE,EAAsC9U,EAAmCC,EAAoCoP,GAE9M,GAAInX,EACJ,IAAIsc,GAA8BxU,EAAcqD,2BAChDrD,GAAcoD,sBAAsBoR,EAAO,EAE3C,IAAIuD,GAAwB,GAAIvd,OAAc6U,EAAU,MACxD,IAAI2I,GAAyBlf,KAAK4a,aAAe,CAEjD,KAAK,GAAI3b,GAAmB,EAAGA,EAAIigB,IAAWjgB,EAAG,CAChD,GAAIkgB,GAA4BjY,EAAcM,yBAC9CyX,GAAQzb,KAAK2b,EAAM,MACnBF,GAAQzb,KAAK2b,EAAM,OAGpB,IAAKlgB,EAAI,EAAGA,EAAIe,KAAK4a,cAAe3b,EAAG,CACtC,GAAIA,GAAK,EAAG,CACX,GAAIqO,GAA6BpG,EAAcqD,2BAE/CnL,GAAO,OAASsc,EAAQ,KAAO1b,KAAK4b,mBAAqB,KAAOrF,EAAU,UACzE5P,EAAS+B,UAAUtB,kBAAkBV,EAAQ4G,EAAMpG,EAAeC,EAAiBuU,GACnF,OAASpO,EAAO,OAASA,EAAO,KAAOwO,EAAiB,KACxD,OAASE,EAAiB,OAAShc,KAAK4b,mBAAqB,OAAStO,EAAO,WACxE,CACNlO,GAAQ,OAASsc,EAAQ,QAAU1b,KAAK4b,mBAAqB,QAAUqD,EAAQhgB,GAAK,KACnFe,KAAK6b,UAAUnV,EAAQC,EAAUmV,EAAgBE,EAAgB9U,EAAeC,EAAiBuU,IAIpGxU,EAAc4D,wBAAwB4Q,EAEtCtc,IAAQ,OAAS4c,EAAiB,OAASA,EAAiB,OAASzF,EAAU,MAE/E,OAAOnX,GAET,OAAAyf,IApM+BzE,EAsML1a,GAAAJ,QAAjBuf,IpCssJNO,qCAAqC5a,UAAU0X,sDAAsD,wDAAwDmD,gEAAgE,SAAS7gB,EAAQkB,EAAOJ,GACxP,GAAIS,GAAYC,KAAKD,WAAa,SAAUE,EAAGC,GAC3C,IAAK,GAAIC,KAAKD,GAAG,GAAIA,EAAEE,eAAeD,GAAIF,EAAEE,GAAKD,EAAEC,EACnD,SAASE,KAAOL,KAAKM,YAAcL,EACnCI,EAAGE,UAAYL,EAAEK,SACjBN,GAAEM,UAAY,GAAIF,GqC55JtB,IAAOY,GAAmBzC,EAAc,yDrCo6JxC,IqC75JM8gB,GAAyB,SAAAle,GAASrB,EAAlCuf,EAAyBle,EAK9B,SALKke,KAOJle,EAAA7B,KAAAS,MAMMsf,EAAA/e,UAAAkG,QAAP,SAAeC,EAAuBC,GAErCA,EAASZ,cAAgB,IACzBY,GAASd,UAAY,KAMfyZ,GAAA/e,UAAAiK,yBAAP,SAAgC9D,EAAuBC,EAAmB8D,EAAmCC,EAAmCxD,EAAmCC,GAElL,GAAI/H,GAAc,EAClB,IAAIV,EAEJ,IAAIsB,KAAKqK,eACR3L,EAAIsB,KAAKmK,yBACL,CACJzL,EAAIwI,EAAcqD,2BAClBrD,GAAcoD,sBAAsB5L,EAAG,GAKxCU,GAAQ,OAASV,EAAI,SAAWyI,EAAgBoY,eAAiB,SAChE,OAAS7gB,EAAI,OAASA,EAAI,SAAW+L,EAAc,SACnD,OAAS/L,EAAI,OAASA,EAAI,SAAWyI,EAAgB8I,gBAAkB,QAGxE7Q,IAAQ,OAASV,EAAI,OAASA,EAAI,OACjC,OAASA,EAAI,OAASA,EAAI,OAE1B,OAASA,EAAI,OAASA,EAAI,OAASA,EAAI,OAEvC,OAASA,EAAI,OAASA,EAAI,OAC1B,OAASA,EAAI,OAASA,EAAI,OAE1B,OAASA,EAAI,OAASA,EAAI,OAASA,EAAI,OAEvC,OAASA,EAAI,OAASA,EAAI,OAASA,EAAI,MAExC,IAAIsB,KAAKkC,QAAS,CAEjB9C,GAAQ,OAASY,KAAKwf,kBAAoB,OAASxf,KAAKwf,kBAAoB,OAASxf,KAAKyf,uBAAyB,OAClH,OAAS/gB,EAAI,OAASA,EAAI,OAASsB,KAAKwf,kBAAoB,WAE7DpgB,IAAQ,OAASV,EAAI,OAASA,EAAI,OAASsB,KAAKyf,uBAAyB,MAG1ErgB,IAAQ,OAASV,EAAI,OAASA,EAAI,OAAS+L,EAAc,MAEzD,IAAIzK,KAAK6K,kBAAoB,KAC5BzL,GAAQY,KAAK6K,iBAAiBnE,EAAQC,EAAUjI,EAAGwI,EAAeC,EAEnE/H,IAAQ,OAASV,EAAI,SAAWgM,EAAc,SAAWhM,EAAI,MAE7D,KAAKsB,KAAKqK,eAAgB,CACzBjL,GAAQ,OAASY,KAAKmK,qBAAuB,SAAWnK,KAAKmK,qBAAuB,SAAWzL,EAAI,QACnGwI,GAAc4D,wBAAwBpM,GAGvCsB,KAAKqK,eAAiB,KAEtB,OAAOjL,GAET,OAAAkgB,IA7EwCre,EA+ELvB,GAAAJ,QAA1BggB,IrCm4JNva,yDAAyD,2DAA2DA,0DAA0D,SAASvG,EAAQkB,EAAOJ,GACzM,GAAIS,GAAYC,KAAKD,WAAa,SAAUE,EAAGC,GAC3C,IAAK,GAAIC,KAAKD,GAAG,GAAIA,EAAEE,eAAeD,GAAIF,EAAEE,GAAKD,EAAEC,EACnD,SAASE,KAAOL,KAAKM,YAAcL,EACnCI,EAAGE,UAAYL,EAAEK,SACjBN,GAAEM,UAAY,GAAIF,GsCx9JtB,IAAOsI,GAAkBnK,EAAc,wDtC+9JvC,IsCx9JMyC,GAAmB,SAAAG,GAASrB,EAA5BkB,EAAmBG,EAmBxB,SAnBKH,KAqBJG,EAAA7B,KAAAS,KAbOA,MAAA0f,OAAgB,EAChB1f,MAAA2f,UAAmB,CACnB3f,MAAA4f,eAAwB,QACzB5f,MAAA6f,YAAqB,CACrB7f,MAAA8f,YAAqB,CACrB9f,MAAA+f,YAAqB,EAWrB9e,EAAAV,UAAA8I,QAAP,SAAe3C,GAEd,IAAKA,EAAO4C,UACX,MAAO,MAER,OAAO,MAMDrI,GAAAV,UAAAkG,QAAP,SAAeC,EAAuBC,GAErCA,EAASb,aAAeY,EAAO4C,UAAY,CAC3C3C,GAASd,UAAYa,EAAO4C,UAAY,CAExC,IAAItJ,KAAKwJ,SAAU,CAClB7C,EAAS+B,UAAYhC,EAAO+C,aAAazJ,KAAKwJ,SAC9C9C,GAAOE,qBACD,IAAID,EAAS+B,UAAW,CAC9B/B,EAAS+B,UAAUgB,SACnB/C,GAAS+B,UAAY,MAOvBhG,QAAAC,eAAW1B,EAAAV,UAAA,StC08JJqC,IsC18JP,WAEC,MAAO5C,MAAK0f,QtC28JN1c,IsCx8JP,SAAiBC,GAEhBjD,KAAK0f,OAASzc,GtCy8JRH,WAAY,KACZC,aAAc,MsCp8JrBL,QAAAC,eAAW1B,EAAAV,UAAA,YtC08JJqC,IsC18JP,WAEC,MAAO5C,MAAK2f,WtC28JN3c,IsCx8JP,SAAoBC,GAEnB,GAAIA,GAASjD,KAAK2f,UACjB,MAED3f,MAAK2f,UAAY1c,CACjBjD,MAAKggB,kBtCw8JCld,WAAY,KACZC,aAAc,MsCn8JrBL,QAAAC,eAAW1B,EAAAV,UAAA,iBtCy8JJqC,IsCz8JP,WAEC,MAAO5C,MAAK4f,gBtC08JN5c,IsCv8JP,SAAyBC,GAExB,GAAIjD,KAAK4f,gBAAkB3c,EAC1B,MAGD,IAAIjD,KAAK4f,gBAAkB,GAAK3c,GAAS,EACxCjD,KAAKuJ,0BAENvJ,MAAK4f,eAAiB3c,CACtBjD,MAAKggB,kBtCs8JCld,WAAY,KACZC,aAAc,MsC/7JrBL,QAAAC,eAAW1B,EAAAV,UAAA,WtCu8JJqC,IsCv8JP,WAEC,MAAO5C,MAAKwJ,UtCw8JNxG,IsCr8JP,SAAmBC,GAElB,GAAIjD,KAAKwJ,UAAYvG,EACpB,MAED,IAAIjD,KAAKwJ,SACRxJ,KAAK8J,eAAe9J,KAAKwJ,SAE1BxJ,MAAKwJ,SAAWvG,CAEhB,IAAIjD,KAAKwJ,SACRxJ,KAAK+J,YAAY/J,KAAKwJ,SAEvBxJ,MAAKuJ,4BtCk8JCzG,WAAY,KACZC,aAAc,MsC77Jd9B,GAAAV,UAAA4C,SAAP,SAAgBI,GAGf,GAAIwD,GAAQxD,CACZ,IAAI0c,GAAgD1c,CAEpD,IAAI2c,GAA2BD,CAC/BjgB,MAAKkC,QAAUge,EAAKhe,OACpBlC,MAAKkE,SAAWgc,EAAKhc,QACrBlE,MAAKqE,cAAgB6b,EAAK7b,aAC1BrE,MAAKgE,MAAQkc,EAAKlc,MAMZ/C,GAAAV,UAAA2J,sBAAP,WAEC9I,EAAAb,UAAM2J,sBAAqB3K,KAAAS,KAC3BA,MAAKmK,qBAAuB,IAC5BnK,MAAKwf,kBAAoB,IACzBxf,MAAKyf,uBAAyB,KAMxBxe,GAAAV,UAAA6J,4BAAP,SAAmC1D,EAAuBC,EAAmBO,EAAmCC,GAE/G,GAAI/H,GAAc,EAElBY,MAAKqK,eAAiB,IAEtBrK,MAAKyf,uBAAyBvY,EAAcM,yBAC5Cb,GAASjB,uBAAyB1F,KAAKyf,uBAAuB/b,MAAM,CAEpE,IAAI1D,KAAKwJ,SAAU,CAElBxJ,KAAKwf,kBAAoBtY,EAAcqD,2BACvCrD,GAAcoD,sBAAsBtK,KAAKwf,kBAAmB,EAE5DpgB,IAAQuH,EAAS+B,UAAUtB,kBAAkBV,EAAQ1G,KAAKwf,kBAAmBtY,EAAeC,EAAiBA,EAAgBE,WAG9HrH,KAAKmK,qBAAuBjD,EAAcqD,2BAC1CrD,GAAcoD,sBAAsBtK,KAAKmK,qBAAsB,EAE/D,OAAO/K,GAMD6B,GAAAV,UAAAiK,yBAAP,SAAgC9D,EAAuBC,EAAmB8D,EAAmCC,EAAmCxD,EAAmCC,GAElL,GAAI/H,GAAc,EAClB,IAAIV,EAEJ,IAAIsB,KAAKqK,eAAgB,CACxB3L,EAAIsB,KAAKmK,yBACH,CACNzL,EAAIwI,EAAcqD,2BAClBrD,GAAcoD,sBAAsB5L,EAAG,GAGxC,GAAIgV,GAAmCvM,EAAgB8I,eACvD,IAAI0D,GAAkCxM,EAAgBoB,cAGtDnJ,IAAQ,OAASV,EAAI,KAAO+L,EAAc,KAAOiJ,EAAa,KAC5D,OAAShV,EAAI,SAAWA,EAAI,KAC5B,OAASA,EAAI,OAASiV,EAAY,KAAOjV,EAAI,KAC7C,OAASA,EAAI,OAASA,EAAI,MAE5B,IAAIsB,KAAKwJ,SAAU,CAElBpK,GAAQ,OAASY,KAAKwf,kBAAoB,OAASxf,KAAKwf,kBAAoB,OAASxf,KAAKyf,uBAAyB,OACjH,OAAS/gB,EAAI,OAASA,EAAI,OAASsB,KAAKwf,kBAAoB,WACxD,CACNpgB,GAAQ,OAASV,EAAI,OAASA,EAAI,OAASsB,KAAKyf,uBAAyB,OAI1E,GAAI/Y,EAAOkE,iBACVxL,GAAQ,OAASV,EAAI,OAASA,EAAI,OAAS+L,EAAc,MAE1D,IAAIzK,KAAK6K,kBAAoB,KAC5BzL,GAAQY,KAAK6K,iBAAiBnE,EAAQC,EAAUjI,EAAGwI,EAAeC,EAEnE/H,IAAQ,OAASV,EAAI,SAAWgM,EAAc,KAAOhM,EAAI,MAEzD,KAAKsB,KAAKqK,eAAgB,CACzBjL,GAAQ,OAASY,KAAKmK,qBAAuB,SAAWnK,KAAKmK,qBAAuB,KAAOzL,EAAI,IAC/FwI,GAAc4D,wBAAwBpM,GAGvCsB,KAAKqK,eAAiB,KAEtB,OAAOjL,GAMD6B,GAAAV,UAAAwK,yBAAP,SAAgCrE,EAAuBC,EAAmBqE,EAAkCC,EAAuB/D,EAAmCC,GAErK,GAAI/H,GAAc,EAClB,IAAIV,EAGJ,IAAIsB,KAAKqK,eAAgB,CACxB3L,EAAIsB,KAAKmK,yBACH,CACNzL,EAAIwI,EAAcqD,2BAClBrD,GAAcoD,sBAAsB5L,EAAG,GAGxC,GAAIiV,GAAkCxM,EAAgBoB,cACtD,IAAImL,GAAmCvM,EAAgB8I,eAEvD7Q,IAAQ,OAASV,EAAI,OAASiV,EAAY,KAAOD,EAAa,KAC5D,OAAShV,EAAI,OAASA,EAAI,OAASA,EAAI,OACvC,OAASA,EAAI,KAAOA,EAAI,OAASiV,EAAY,KAC7C,OAASjV,EAAI,KAAOA,EAAI,KAAOgV,EAAa,KAC5C,OAAShV,EAAI,KAAOA,EAAI,KAAOsM,EAAa,WAAatE,EAAOyZ,kBAAmB,SAAS,WAAa,gBACzG,OAASzhB,EAAI,SAAWA,EAAI,KAAOuM,EAAiB,IAEtD,IAAIjL,KAAK6K,kBAAoB,KAC5BzL,GAAQY,KAAK6K,iBAAiBnE,EAAQC,EAAUjI,EAAGwI,EAAeC,EAEnE,KAAKnH,KAAKqK,eAAgB,CACzBjL,GAAQ,OAASY,KAAKmK,qBAAuB,SAAWnK,KAAKmK,qBAAuB,KAAOzL,EAAI,IAC/FwI,GAAc4D,wBAAwBpM,GAGvCsB,KAAKqK,eAAiB,KAEtB,OAAOjL,GAMD6B,GAAAV,UAAA2K,6BAAP,SAAoCxE,EAAuBC,EAAmBM,EAAiCC,EAAmCC,GAEjJ,GAAI/H,GAAc,EAElB,IAAI+H,EAAgBiE,aACnBhM,GAAQ,OAASY,KAAKmK,qBAAuB,SAAWnK,KAAKmK,qBAAuB,KAAOhD,EAAgBiE,aAAe,MAE3H,IAAIpL,KAAKwJ,SAAU,CAElBpK,GAAQ,OAASY,KAAKmK,qBAAuB,SAAWnK,KAAKmK,qBAAuB,KAAOnK,KAAKwf,kBAAoB,MACpHtY,GAAc4D,wBAAwB9K,KAAKwf,mBAI5CpgB,GAAQ,OAASY,KAAKmK,qBAAuB,SAAWnK,KAAKmK,qBAAuB,KAAOnK,KAAKyf,uBAAyB,KACxH,OAASxY,EAAY,SAAWA,EAAY,KAAOjH,KAAKmK,qBAAuB,IAChFjD,GAAc4D,wBAAwB9K,KAAKmK,qBAE3C,OAAO/K,GAMD6B,GAAAV,UAAAmH,UAAP,SAAiBhB,EAAuBC,EAAmBgB,GAE1D,GAAI3H,KAAKwJ,SACR7C,EAAS+B,UAAUd,SAASlB,EAE7B,IAAIhD,GAAeiD,EAASjB,sBAC5B,IAAIoC,GAAoBpB,EAAOmB,oBAC/BC,GAAKpE,GAAS1D,KAAK6f,WACnB/X,GAAKpE,EAAQ,GAAK1D,KAAK8f,WACvBhY,GAAKpE,EAAQ,GAAK1D,KAAK+f,WACvBjY,GAAKpE,EAAQ,GAAK1D,KAAK0f,OAGjBze,GAAAV,UAAAwH,gBAAP,SAAuBrB,EAAuBC,EAAmBqB,EAA2BL,EAAaM,GAExG,GAAIjI,KAAKwJ,SACR7C,EAAS+B,UAAUR,gBAAgBF,EAAYtB,GAMzCzF,GAAAV,UAAAyf,eAAR,WAEChgB,KAAK6f,aAAiB7f,KAAK4f,gBAAkB,GAAM,KAAM,IAAK5f,KAAK2f,SACnE3f,MAAK8f,aAAiB9f,KAAK4f,gBAAkB,EAAK,KAAM,IAAK5f,KAAK2f,SAClE3f,MAAK+f,aAAgB/f,KAAK4f,eAAiB,KAAM,IAAK5f,KAAK2f,UAE7D,OAAA1e,IApUkC0H,EAsULjJ,GAAAJ,QAApB2B,ItC64JN0K,wDAAwD,0DAA0DyU,wDAAwD,SAAS5hB,EAAQkB,EAAOJ,GACrM,GAAIS,GAAYC,KAAKD,WAAa,SAAUE,EAAGC,GAC3C,IAAK,GAAIC,KAAKD,GAAG,GAAIA,EAAEE,eAAeD,GAAIF,EAAEE,GAAKD,EAAEC,EACnD,SAASE,KAAOL,KAAKM,YAAcL,EACnCI,EAAGE,UAAYL,EAAEK,SACjBN,GAAEM,UAAY,GAAIF,GuCjuKtB,IAAOggB,GAAuB7hB,EAAa,6DvCuuK3C,IuCluKM8hB,GAAiB,SAAAlf,GAASrB,EAA1BugB,EAAiBlf,EAWtB,SAXKkf,GAWOC,EAA4BvU,GAXzC,GAAAC,GAAAjM,IAWa,IAAAugB,QAAA,GAA0B,CAA1BA,EAAA,GAA4B,GAAAvU,QAAA,GAAqC,CAArCA,EAAA,KAEvC5K,EAAA7B,KAAAS,KAAM,KAAMgM,EAVLhM,MAAAkM,YAAqB,EACrBlM,MAAAwgB,gBAAyB,EAWhCxgB,MAAKgM,WAAWnB,iBAAmB,SAACnE,EAAmBC,EAAmBM,EAAiCC,EAAmCC,GAAuC,MAAA8E,GAAKwU,cAAc/Z,EAAQC,EAAUM,EAAWC,EAAeC,GAEpPnH,MAAKwgB,gBAAkBD,EAMxB7d,OAAAC,eAAW2d,EAAA/f,UAAA,cvCguKJqC,IuChuKP,WAEC,MAAO5C,MAAKkM,avCiuKNlJ,IuC9tKP,SAAsBC,GAErBjD,KAAKkM,YAAcjJ,GvC+tKbH,WAAY,KACZC,aAAc,MuC1tKrBL,QAAAC,eAAW2d,EAAA/f,UAAA,kBvCguKJqC,IuChuKP,WAEC,MAAO5C,MAAKwgB,iBvCiuKNxd,IuC9tKP,SAA0BC,GAEzBjD,KAAKwgB,gBAAkBvd,GvC+tKjBH,WAAY,KACZC,aAAc,MuC1tKdud,GAAA/f,UAAAmH,UAAP,SAAiBhB,EAAuBC,EAAmBgB,GAE1DvG,EAAAb,UAAMmH,UAASnI,KAAAS,KAAC0G,EAAQC,EAAUgB,EAElC,IAAIjE,GAAuBiD,EAAShB,+BACpC,IAAImC,GAAoBpB,EAAOmB,oBAC/BC,GAAKpE,GAAS1D,KAAKkM,WACnBpE,GAAKpE,EAAQ,GAAK1D,KAAKwgB,gBAMjBF,GAAA/f,UAAA2J,sBAAP,WAEC9I,EAAAb,UAAM2J,sBAAqB3K,KAAAS,KAC3BA,MAAKqM,SAAW,KAWTiU,GAAA/f,UAAAkgB,cAAR,SAAsB/Z,EAAmBC,EAAmBM,EAAiCC,EAAmCC,GAE/H,MAAO,OAASF,EAAY,OAASA,EAAY,OAASjH,KAAKqM,SAAW,OACzE,OAASpF,EAAY,OAASA,EAAY,OAASjH,KAAKqM,SAAW,OACnE,OAASpF,EAAY,OAASA,EAAY,OAC1C,OAASA,EAAY,OAASA,EAAY,OAASjH,KAAKqM,SAAW,OACnE,OAASpF,EAAY,OAASA,EAAY,OAASA,EAAY,OAM1DqZ,GAAA/f,UAAA6J,4BAAP,SAAmC1D,EAAuBC,EAAmBO,EAAmCC,GAE/GnH,KAAKqM,SAAWnF,EAAcM,yBAC9Bb,GAAShB,gCAAkC3F,KAAKqM,SAAS3I,MAAM,CAE/D,OAAOtC,GAAAb,UAAM6J,4BAA2B7K,KAAAS,KAAC0G,EAAQC,EAAUO,EAAeC,GAE5E,OAAAmZ,IA/FgCD,EAiGhC3gB,GAA2BJ,QAAlBghB,IvCotKNI,6DAA6D,+DAA+DA,8DAA8D,SAASliB,EAAQkB,EAAOJ,GACrN,GAAIS,GAAYC,KAAKD,WAAa,SAAUE,EAAGC,GAC3C,IAAK,GAAIC,KAAKD,GAAG,GAAIA,EAAEE,eAAeD,GAAIF,EAAEE,GAAKD,EAAEC,EACnD,SAASE,KAAOL,KAAKM,YAAcL,EACnCI,EAAGE,UAAYL,EAAEK,SACjBN,GAAEM,UAAY,GAAIF,GwCl0KtB,IAAOkM,GAAkB/N,EAAc,kDAQvC,IAAOyC,GAAmBzC,EAAc,yDxCk0KxC,IwC5zKM6hB,GAAuB,SAAAjf,GAASrB,EAAhCsgB,EAAuBjf,EAY5B,SAZKif,GAYO7T,EAAyKR,GAZtL,GAAAC,GAAAjM,IAYsL,IAAAgM,QAAA,GAAqC,CAArCA,EAAA,KAEpL5K,EAAA7B,KAAAS,KAEAA,MAAKyM,6BAA+B,SAACC,GAA6B,MAAAT,GAAKU,oBAAoBD,GAE3F1M,MAAKgY,YAAchM,GAAc,GAAI/K,EACrCjB,MAAKgY,YAAYnN,iBAAmB2B,CACpCxM,MAAKgY,YAAYnL,iBAAiBN,EAAmBO,mBAAoB9M,KAAKyM,8BAMxE4T,EAAA9f,UAAAkG,QAAP,SAAeC,EAAuBC,GAErC3G,KAAKgY,YAAYvR,QAAQC,EAAQC,GAM3B0Z,GAAA9f,UAAAsG,eAAP,SAAsBH,EAAmBC,GAExC3G,KAAKgY,YAAYnR,eAAeH,EAAQC,GAIlC0Z,GAAA9f,UAAAgC,UAAP,SAAiByK,GAEhB5L,EAAAb,UAAMgC,UAAShD,KAAAS,KAACgN,EAEhBhN,MAAKgY,YAAYzV,UAAUyK,GAGrBqT,GAAA9f,UAAA6C,aAAP,SAAoB4J,GAEnB5L,EAAAb,UAAM6C,aAAY7D,KAAAS,KAACgN,EAEnBhN,MAAKgY,YAAY5U,aAAa4J,GAM/BtK,QAAAC,eAAW0d,EAAA9f,UAAA,cxC4yKJqC,IwC5yKP,WAEC,MAAO5C,MAAKgY,axC6yKNhV,IwC1yKP,SAAsBC,GAErB,GAAIjD,KAAKgY,aAAe/U,EACvB,MAEDjD,MAAKgY,YAAYjL,oBAAoBR,EAAmBO,mBAAoB9M,KAAKyM,6BAEjFzM,MAAKgY,YAAc/U,CAEnBjD,MAAKgY,YAAYnL,iBAAiBN,EAAmBO,mBAAoB9M,KAAKyM,6BAE9EzM,MAAKuJ,4BxCuyKCzG,WAAY,KACZC,aAAc,MwClyKrBL,QAAAC,eAAW0d,EAAA9f,UAAA,SxCwyKJqC,IwCxyKP,WAEC,MAAO5C,MAAKgY,YAAYhU,OxCyyKlBhB,IwCtyKP,SAAiBC,GAEhBjD,KAAKgY,YAAYhU,MAAQf,GxCuyKnBH,WAAY,KACZC,aAAc,MwClyKrBL,QAAAC,eAAW0d,EAAA9f,UAAA,YxCwyKJqC,IwCxyKP,WAEC,MAAO5C,MAAKgY,YAAY9T,UxCyyKlBlB,IwCtyKP,SAAoBC,GAEnBjD,KAAKgY,YAAY9T,SAAWjB,GxCuyKtBH,WAAY,KACZC,aAAc,MwClyKdsd,GAAA9f,UAAAmJ,QAAP,WAEC1J,KAAKgY,YAAYjL,oBAAoBR,EAAmBO,mBAAoB9M,KAAKyM,6BACjFzM,MAAKgY,YAAYtO,UAMlBhH,QAAAC,eAAW0d,EAAA9f,UAAA,WxCsyKJqC,IwCtyKP,WAEC,MAAO5C,MAAKgY,YAAY9V,SxCuyKlBc,IwCpyKP,SAAmBC,GAElBjD,KAAKgY,YAAY9V,QAAUe,GxCqyKrBH,WAAY,KACZC,aAAc,MwChyKdsd,GAAA9f,UAAAmH,UAAP,SAAiBhB,EAAuBC,EAAmBgB,GAE1D3H,KAAKgY,YAAYtQ,UAAUhB,EAAQC,EAAUgB,GAMvC0Y,GAAA9f,UAAAwH,gBAAP,SAAuBrB,EAAuBC,EAAmBqB,EAA2BL,EAAaM,GAExGjI,KAAKgY,YAAYjQ,gBAAgBrB,EAAQC,EAAUqB,EAAYL,EAAOM,GAMhEoY,GAAA9f,UAAA0M,YAAP,SAAmBvG,EAAmBC,EAAmBgB,GAExD3H,KAAKgY,YAAY/K,YAAYvG,EAAQC,EAAUgB,GAMzC0Y,GAAA9f,UAAA2M,eAAP,SAAsBxG,EAAmBC,EAAmBO,EAAmCC,GAE9F,MAAOnH,MAAKgY,YAAY9K,eAAexG,EAAQC,EAAUO,EAAeC,GAMlEkZ,GAAA9f,UAAA6J,4BAAP,SAAmC1D,EAAuBC,EAAmBO,EAAmCC,GAE/G,MAAOnH,MAAKgY,YAAY5N,4BAA4B1D,EAAQC,EAAUO,EAAeC,GAM/EkZ,GAAA9f,UAAAiK,yBAAP,SAAgC9D,EAAuBC,EAAmB8D,EAAmCC,EAAmCxD,EAAmCC,GAElL,MAAOnH,MAAKgY,YAAYxN,yBAAyB9D,EAAQC,EAAU8D,EAAaC,EAAaxD,EAAeC,GAOtGkZ,GAAA9f,UAAAwK,yBAAP,SAAgCrE,EAAuBC,EAAmBqE,EAAkCC,EAAuB/D,EAAmCC,GAErK,MAAOnH,MAAKgY,YAAYjN,yBAAyBrE,EAAQC,EAAUqE,EAAYC,EAAgB/D,EAAeC,GAMxGkZ,GAAA9f,UAAA2K,6BAAP,SAAoCxE,EAAuBC,EAAmBM,EAAiCC,EAAmCC,GAEjJ,MAAOnH,MAAKgY,YAAY9M,6BAA6BxE,EAAQC,EAAUM,EAAWC,EAAeC,GAM3FkZ,GAAA9f,UAAAgF,OAAP,WAECvF,KAAKgY,YAAYzS,SAMX8a,GAAA9f,UAAA2J,sBAAP,WAEC9I,EAAAb,UAAM2J,sBAAqB3K,KAAAS,KAC3BA,MAAKgY,YAAY9N,wBAMVmW,GAAA9f,UAAAoM,oBAAR,SAA4BD,GAE3B1M,KAAKuJ,2BAEP,OAAA8W,IArNsCpf,EAuNLvB,GAAAJ,QAAxB+gB,IxCkxKNtb,yDAAyD,yDAAyDoI,kDAAkD3I,YAAYmc,4DAA4D,SAASniB,EAAQkB,EAAOJ,GACvQ,GAAIS,GAAYC,KAAKD,WAAa,SAAUE,EAAGC,GAC3C,IAAK,GAAIC,KAAKD,GAAG,GAAIA,EAAEE,eAAeD,GAAIF,EAAEE,GAAKD,EAAEC,EACnD,SAASE,KAAOL,KAAKM,YAAcL,EACnCI,EAAGE,UAAYL,EAAEK,SACjBN,GAAEM,UAAY,GAAIF,GyCv/KtB,IAAOggB,GAAuB7hB,EAAa,6DzC6/K3C,IyCx/KMoiB,GAAqB,SAAAxf,GAASrB,EAA9B6gB,EAAqBxf,EAY1B,SAZKwf,GAYOC,EAA+B7U,GAZ5C,GAAAC,GAAAjM,IAYa,IAAA6gB,QAAA,GAA6B,CAA7BA,EAAA,KAA+B,GAAA7U,QAAA,GAAqC,CAArCA,EAAA,KAG1C5K,EAAA7B,KAAAS,KAAM,KAAMgM,EAXLhM,MAAAwT,cAAuB,CACvBxT,MAAAyT,mBAA4B,IAYnCzT,MAAKgM,WAAWnB,iBAAmB,SAACnE,EAAmBC,EAAmBM,EAAiCC,EAAmCC,GAAuC,MAAA8E,GAAK6U,iBAAiBpa,EAAQC,EAAUM,EAAWC,EAAeC,GAEvPnH,MAAK+gB,gBAAkBF,EAMjBD,EAAArgB,UAAAsG,eAAP,SAAsBH,EAAmBC,GAGxC,GAAIjD,GAAeiD,EAAShB,+BAC5Be,GAAOmB,qBAAqBnE,EAAQ,GAAK,CACzCgD,GAAOmB,qBAAqBnE,EAAQ,GAAK,EAM1ChB,QAAAC,eAAWie,EAAArgB,UAAA,kBzCk/KJqC,IyCl/KP,WAEC,OAAQ5C,KAAK+gB,gBzCm/KP/d,IyCh/KP,SAA0BC,GAEzB,GAAIjD,KAAK+gB,gBAAkB9d,EAC1B,MAEDjD,MAAK+gB,gBAAkB9d,CAEvBjD,MAAKuJ,4BzC++KCzG,WAAY,KACZC,aAAc,MyC1+KrBL,QAAAC,eAAWie,EAAArgB,UAAA,gBzCg/KJqC,IyCh/KP,WAEC,MAAO5C,MAAKwT,ezCi/KNxQ,IyC9+KP,SAAwBC,GAEvBjD,KAAKwT,cAAgBvQ,GzC++KfH,WAAY,KACZC,aAAc,MyC1+Kd6d,GAAArgB,UAAA2J,sBAAP,WAEC9I,EAAAb,UAAM2J,sBAAqB3K,KAAAS,KAC3BA,MAAKqM,SAAW,KAMjB3J,QAAAC,eAAWie,EAAArgB,UAAA,qBzC8+KJqC,IyC9+KP,WAEC,MAAO5C,MAAKyT,oBzC++KNzQ,IyC5+KP,SAA6BC,GAE5BjD,KAAKyT,mBAAqBxQ,GzC6+KpBH,WAAY,KACZC,aAAc,MyCx+Kd6d,GAAArgB,UAAAmH,UAAP,SAAiBhB,EAAuBC,EAAmBgB,GAE1DvG,EAAAb,UAAMmH,UAASnI,KAAAS,KAAC0G,EAAQC,EAAUgB,EAElC,IAAI6Q,GAA4B9R,EAAOmB,oBAEvC,IAAInE,GAAeiD,EAAShB,+BAC5B6S,GAAa9U,GAAS1D,KAAKyT,kBAC3B+E,GAAa9U,EAAQ,GAAK1D,KAAKwT,cAMzBoN,GAAArgB,UAAA6J,4BAAP,SAAmC1D,EAAuBC,EAAmBO,EAAmCC,GAE/GnH,KAAKqM,SAAWnF,EAAcM,yBAE9Bb,GAAShB,gCAAkC3F,KAAKqM,SAAS3I,MAAM,CAE/D,OAAOtC,GAAAb,UAAM6J,4BAA2B7K,KAAAS,KAAC0G,EAAQC,EAAUO,EAAeC,GAYnEyZ,GAAArgB,UAAAugB,iBAAR,SAAyBpa,EAAmBC,EAAmBM,EAAiCC,EAAmCC,GAElI,GAAI/H,EAEJA,GAAO,OAAS6H,EAAY,OAASE,EAAgB8I,gBAAkB,UAAYjQ,KAAK+gB,eAAgB9Z,EAAYE,EAAgBoB,gBAAkB,SACrJ,OAAStB,EAAY,OAASjH,KAAKqM,SAAW,OAASpF,EAAY,OACnE,OAASA,EAAY,OAASA,EAAY,OAASjH,KAAKqM,SAAW,OACnE,OAASpF,EAAY,OAASjH,KAAKqM,SAAW,OAASpF,EAAY,OACnE,OAASA,EAAY,OAASjH,KAAKqM,SAAW,OAASpF,EAAY,OACnE,OAASA,EAAY,OAASA,EAAY,OAASA,EAAY,OAC/D,OAASA,EAAY,OAASA,EAAY,OAASA,EAAY,MAEhE,OAAO7H,GAGT,OAAAwhB,IAxIoCP,EA0IL3gB,GAAAJ,QAAtBshB,IzC69KNF,6DAA6D,+DAA+DM,0DAA0D,SAASxiB,EAAQkB,EAAOJ,GACjN,GAAIS,GAAYC,KAAKD,WAAa,SAAUE,EAAGC,GAC3C,IAAK,GAAIC,KAAKD,GAAG,GAAIA,EAAEE,eAAeD,GAAIF,EAAEE,GAAKD,EAAEC,EACnD,SAASE,KAAOL,KAAKM,YAAcL,EACnCI,EAAGE,UAAYL,EAAEK,SACjBN,GAAEM,UAAY,GAAIF,G0CvnLtB,IAAOY,GAAmBzC,EAAc,yD1C6nLxC,I0CxnLMyiB,GAAmB,SAAA7f,GAASrB,EAA5BkhB,EAAmB7f,EAKxB,SALK6f,KAOJ7f,EAAA7B,KAAAS,MAMMihB,EAAA1gB,UAAAiK,yBAAP,SAAgC9D,EAAuBC,EAAmB8D,EAAmCC,EAAmCxD,EAAmCC,GAElL,GAAI/H,GAAc,EAClB,IAAIV,EAEJ,IAAIsB,KAAKqK,eAAgB,CACxB3L,EAAIsB,KAAKmK,yBACH,CACNzL,EAAIwI,EAAcqD,2BAClBrD,GAAcoD,sBAAsB5L,EAAG,GAGxC,GAAIgV,GAAkCvM,EAAgB8I,eACtD,IAAI0D,GAAiCxM,EAAgBoB,cAGrDnJ,IAAQ,OAASV,EAAI,OAAS+L,EAAc,KAAOkJ,EAAY,KAG9D,OAASjV,EAAI,OAASA,EAAI,OAASA,EAAI,OACvC,OAASA,EAAI,SAAWiV,EAAY,KAAOjV,EAAI,OAC/C,OAASA,EAAI,SAAWA,EAAI,KAAO+L,EAAc,KAGjD,OAAS/L,EAAI,OAASA,EAAI,OAAQyI,EAAgBwD,QAAU,OAC5D,OAASjM,EAAI,OAASA,EAAI,OAC1B,OAASA,EAAI,SAAWA,EAAI,KAAOA,EAAI,OAGvC,OAASA,EAAI,OAASA,EAAI,KAAOgV,EAAa,KAC9C,OAAShV,EAAI,OAASA,EAAI,MAE3B,IAAIsB,KAAKkC,QAAS,CAEjB9C,GAAQ,OAASY,KAAKwf,kBAAoB,OAASxf,KAAKwf,kBAAoB,OAASxf,KAAKyf,uBAAyB,OAClH,OAAS/gB,EAAI,OAASA,EAAI,OAASsB,KAAKwf,kBAAoB,WAE7DpgB,IAAQ,OAASV,EAAI,OAASA,EAAI,OAASsB,KAAKyf,uBAAyB,MAG1E,IAAI/Y,EAAOkE,iBACVxL,GAAQ,OAASV,EAAI,OAASA,EAAI,OAAS+L,EAAc,MAE1D,IAAIzK,KAAK6K,kBAAoB,KAC5BzL,GAAQY,KAAK6K,iBAAiBnE,EAAQC,EAAUjI,EAAGwI,EAAeC,EAEnE/H,IAAQ,OAASV,EAAI,SAAWgM,EAAc,SAAWhM,EAAI,MAE7D,KAAKsB,KAAKqK,eAAgB,CACzBjL,GAAQ,OAASY,KAAKmK,qBAAuB,SAAWnK,KAAKmK,qBAAuB,SAAWzL,EAAI,QACnGwI,GAAc4D,wBAAwBpM,GAGvCsB,KAAKqK,eAAiB,KAEtB,OAAOjL,GAET,OAAA6hB,IAtEkChgB,EAwELvB,GAAAJ,QAApB2hB,I1CgmLNlc,yDAAyD,2DAA2DC,0DAA0D,SAASxG,EAAQkB,EAAOJ,GACzM,GAAIS,GAAYC,KAAKD,WAAa,SAAUE,EAAGC,GAC3C,IAAK,GAAIC,KAAKD,GAAG,GAAIA,EAAEE,eAAeD,GAAIF,EAAEE,GAAKD,EAAEC,EACnD,SAASE,KAAOL,KAAKM,YAAcL,EACnCI,EAAGE,UAAYL,EAAEK,SACjBN,GAAEM,UAAY,GAAIF,G2CxrLtB,IAAO6gB,GAAS1iB,EAAgB,iCAUhC,IAAO2iB,GAAiB3iB,EAAc,8DAGtC,IAAOoC,GAAoBpC,EAAc,+CAOzC,IAAO4iB,GAAU5iB,EAAgB,0CAIjC,IAAOmB,GAAkBnB,EAAc,gDACvC,IAAO6iB,GAAc7iB,EAAe,0DACpC,IAAO8iB,GAAU9iB,EAAgB,sD3C2qLjC,I2C7pLM0C,GAAoB,SAAAE,GAASrB,EAA7BmB,EAAoBE,EA4BzB,SA5BKF,GA4BOqgB,EAAiBC,EAAyBC,EAAkC9Z,GAEvFvG,EAAA7B,KAAAS,KAAMuhB,EAAMC,EAAUC,EAAiB9Z,EAEvC3H,MAAK0hB,UAAYF,EAtBlB9e,OAAAC,eAAYzB,EAAAX,UAAA,a3CkqLLqC,I2ClqLP,WAEC,MAAO5C,MAAK0hB,UAAUC,YAAa3hB,KAAK0hB,UAAUC,YAAYC,eAAiB5hB,KAAK0hB,UAAUC,YAAYE,qBAAuB7hB,KAAK0hB,UAAUC,YAAYG,eAAiB9hB,KAAK0hB,UAAUC,YAAYI,4BAA8B/hB,KAAK0hB,UAAUC,YAAYK,sBAAwB,G3CmqLnRlf,WAAY,KACZC,aAAc,M2C9pLrBL,QAAAC,eAAYzB,EAAAX,UAAA,iB3CoqLLqC,I2CpqLP,WAEC,MAAO5C,MAAK0hB,UAAUC,YAAa3hB,KAAK0hB,UAAUC,YAAYC,eAAiB5hB,KAAK0hB,UAAUC,YAAYE,qBAAuB7hB,KAAK0hB,UAAUC,YAAYG,eAAiB,G3CqqLvKhf,WAAY,KACZC,aAAc,M2CppLd7B,GAAAX,UAAA0hB,eAAP,WAEC7gB,EAAAb,UAAM0hB,eAAc1iB,KAAAS,KAEpBA,MAAKkiB,YAELliB,MAAKmiB,yBAELniB,MAAKoiB,eAEL,IAAIpiB,KAAK0hB,UAAUW,MAAQ1iB,EAAmBE,WAAY,CACzD,GAAIG,KAAKsiB,iBACRtiB,KAAKuiB,UAAUviB,KAAKsiB,iBAErB,IAAItiB,KAAKwiB,sBACR,IAAK,GAAIvjB,GAAW,EAAGA,EAAIe,KAAKwiB,sBAAsBhjB,SAAUP,EAC/De,KAAKuiB,UAAUviB,KAAKwiB,sBAAsBvjB,IAG7C,GAAIe,KAAKyiB,MACRziB,KAAKuiB,UAAUviB,KAAKyiB,OAMdvhB,GAAAX,UAAA2hB,WAAR,WAIC,GAAIliB,KAAKsJ,WAAa,GAAKtJ,KAAK0hB,UAAUgB,iBAAmB,GAAK1iB,KAAK0hB,UAAUW,MAAQ1iB,EAAmBC,YAC3GI,KAAK2iB,qBACD,IAAI3iB,KAAKyiB,MACbziB,KAAK4iB,kBAGN,IAAI5iB,KAAK0hB,UAAUmB,cAAgB7iB,KAAK0hB,UAAUW,MAAQ1iB,EAAmBE,WAC5EG,KAAK8iB,0BACD,IAAI9iB,KAAKsiB,iBACbtiB,KAAK+iB,uBAGN,IAAI/iB,KAAKgjB,cAAgB,GAAKhjB,KAAK0hB,UAAUW,MAAQ1iB,EAAmBE,WACvEG,KAAKijB,+BACD,IAAIjjB,KAAKwiB,sBACbxiB,KAAKkjB,6BAMChiB,GAAAX,UAAA4hB,wBAAR,WAEC,GAAIgB,GAA2BC,QAAQpjB,KAAKsiB,kBAAoBtiB,KAAKyiB,MAGrE,IAAIziB,KAAKsiB,iBAAkB,CAC1BtiB,KAAKsiB,iBAAiBa,iBAAmBA,CACzCnjB,MAAKsiB,iBAAiB5b,OAAO2c,aAAanC,EAAUoC,OACpDtjB,MAAKsiB,iBAAiB5b,OAAO6c,iBAAmBvjB,KAAK0hB,UAAU6B,iBAGhE,GAAIvjB,KAAKwiB,sBAAuB,CAC/B,GAAIgB,GAA4B,CAIhC,KAAKxjB,KAAKsiB,iBAAkB,CAC3BtiB,KAAKwiB,sBAAsB,GAAGW,iBAAmBA,CACjDnjB,MAAKwiB,sBAAsB,GAAG9b,OAAO2c,aAAanC,EAAUoC,OAC5DtjB,MAAKwiB,sBAAsB,GAAG9b,OAAO6c,iBAAmBvjB,KAAK0hB,UAAU6B,gBACvEC,GAAqB,EAItB,IAAK,GAAIvkB,GAAWukB,EAAoBvkB,EAAIe,KAAKwiB,sBAAsBhjB,SAAUP,EAAG,CACnFe,KAAKwiB,sBAAsBvjB,GAAGkkB,iBAAmBA,CACjDnjB,MAAKwiB,sBAAsBvjB,GAAGyH,OAAO2c,aAAanC,EAAU5S,IAC5DtO,MAAKwiB,sBAAsBvjB,GAAGyH,OAAO6c,iBAAmB3iB,EAAqBoB,YAI/E,GAAIhC,KAAKsiB,kBAAoBtiB,KAAKwiB,sBAAuB,CAExDxiB,KAAKyjB,mBAAqB,KAG1B,IAAIzjB,KAAKyiB,MAAO,CACfziB,KAAKyiB,MAAMJ,KAAOhB,EAAeqC,OACjC1jB,MAAKyiB,MAAMU,iBAAmBA,CAC9BnjB,MAAKyiB,MAAM/b,OAAO6c,iBAAmB3iB,EAAqBoB,UAC1DhC,MAAKyiB,MAAM/b,OAAO2c,aAAanC,EAAUyC,YAGpC,IAAI3jB,KAAKyiB,MAAO,CACtBziB,KAAKyjB,mBAAsBzjB,KAAK0hB,UAAU1T,WAAakT,EAAUoC,QAAUtjB,KAAK0hB,UAAUkC,eAAkB5jB,KAAK0hB,UAAUmC,gBAAkB7jB,KAAK0hB,UAAUmC,eAAehS,gBAAkB,CAE7L7R,MAAKyiB,MAAMJ,KAAOhB,EAAeyC,YACjC9jB,MAAKyiB,MAAMsB,cAAgB/jB,KAAKyjB,kBAChCzjB,MAAKyiB,MAAMU,iBAAmB,KAC9BnjB,MAAKyiB,MAAMoB,eAAiB7jB,KAAK0hB,UAAUmC,cAC3C7jB,MAAKyiB,MAAM/b,OAAO2c,aAAcrjB,KAAK0hB,UAAU1T,WAAakT,EAAUoC,QAAUtjB,KAAKyjB,mBAAqBvC,EAAUyC,MAAQ3jB,KAAK0hB,UAAU1T,UAC3IhO,MAAKyiB,MAAM/b,OAAO6c,iBAAmBvjB,KAAK0hB,UAAU6B,kBAI9CriB,GAAAX,UAAAuiB,oBAAR,WAGC,GAAI9iB,KAAKsiB,kBAAoB,KAC5BtiB,KAAKsiB,iBAAmB,GAAIhB,GAAWD,EAAe2C,SAAUhkB,KAAMA,KAAK0hB,UAAW1hB,KAAKikB,iBAAkBjkB,KAAKkkB,OAEnHlkB,MAAKsiB,iBAAiBX,YAAc,GAAIR,IAAmBnhB,KAAK0hB,UAAUmB,aAAa9K,cACvF/X,MAAKsiB,iBAAiBO,aAAe7iB,KAAK0hB,UAAUmB,YACpD7iB,MAAKsiB,iBAAiB6B,cAAgBnkB,KAAK0hB,UAAUyC,aACrDnkB,MAAKsiB,iBAAiB8B,cAAgBpkB,KAAK0hB,UAAU0C,aACrDpkB,MAAKsiB,iBAAiB+B,aAAerkB,KAAK0hB,UAAU2C,YACpDrkB,MAAKsiB,iBAAiBgC,eAAiBtkB,KAAK0hB,UAAU4C,eAG/CpjB,GAAAX,UAAAwiB,sBAAR,WAEC/iB,KAAKsiB,iBAAiB5Y,SACtB1J,MAAKukB,aAAavkB,KAAKsiB,iBACvBtiB,MAAKsiB,iBAAmB,KAGjBphB,GAAAX,UAAA0iB,yBAAR,WAECjjB,KAAKkjB,4BACL,IAAIsB,EACJ,IAAIC,GAAsBzkB,KAAK0hB,UAAUC,YAAYE,oBACrD,IAAIC,GAAwB9hB,KAAK0hB,UAAUC,YAAYG,cACvD,IAAIF,GAAwB5hB,KAAK0hB,UAAUC,YAAYC,cACvD,IAAI8C,GAAwB,CAC5B,IAAIC,GAA0B,CAC9B,IAAIC,GAAqB,CAEzB,KAAK5kB,KAAKsiB,iBAAkB,CAC3BmC,GAAgBzkB,KAAK0hB,UAAUC,YAAYI,2BAC3CD,IAAkB9hB,KAAK0hB,UAAUC,YAAYK,sBAG9ChiB,KAAKwiB,sBAAwB,GAAI9gB,MAEjC,OAAOgjB,EAAiBD,GAAgBE,EAAmB7C,GAAkB8C,EAAchD,EAAgB,CAC1G4C,EAAO,GAAIlD,GAAWD,EAAe2C,SAAUhkB,KAAMA,KAAK0hB,UAAW1hB,KAAKikB,iBAAkBjkB,KAAKkkB,OACjGM,GAAKK,eAAiB7kB,KAAK0hB,UAAUmB,cAAgB,IACrD2B,GAAKM,wBAA0BJ,CAC/BF,GAAKO,kBAAoBJ,CACzBH,GAAKQ,kBAAoBJ,CACzBJ,GAAK7C,YAAc3hB,KAAK0hB,UAAUC,WAClC6C,GAAKL,cAAgBnkB,KAAK0hB,UAAUyC,aACpCK,GAAKJ,cAAgBpkB,KAAK0hB,UAAU0C,aACpCI,GAAKH,aAAerkB,KAAK0hB,UAAU2C,YACnCG,GAAKF,eAAiBtkB,KAAK0hB,UAAU4C,cACrCtkB,MAAKwiB,sBAAsBhf,KAAKghB,EAEhCE,IAAkBF,EAAK3C,oBACvB8C,IAAoBH,EAAK1C,cACzB8C,IAAeJ,EAAK5C,gBAId1gB,GAAAX,UAAA2iB,2BAAR,WAEC,IAAKljB,KAAKwiB,sBACT,MAED,KAAK,GAAIvjB,GAAW,EAAGA,EAAIe,KAAKwiB,sBAAsBhjB,SAAUP,EAC/De,KAAKukB,aAAavkB,KAAKwiB,sBAAsBvjB,GAE9Ce,MAAKwiB,sBAAwB,KAGtBthB,GAAAX,UAAAqiB,iBAAR,WAEC,GAAI5iB,KAAKyiB,MAAM2B,eAAiBpkB,KAAK0hB,UAAU0C,cAC9CpkB,KAAKyiB,MAAM2B,cAAc1a,SAE1B,IAAI1J,KAAKyiB,MAAM0B,eAAiBnkB,KAAK0hB,UAAUyC,cAC9CnkB,KAAKyiB,MAAM0B,cAAcza,SAE1B,IAAI1J,KAAKyiB,MAAM6B,gBAAkBtkB,KAAK0hB,UAAU4C,eAC/CtkB,KAAKyiB,MAAM6B,eAAe5a,SAE3B,IAAI1J,KAAKyiB,MAAM4B,cAAgBrkB,KAAK0hB,UAAU2C,aAC7CrkB,KAAKyiB,MAAM4B,aAAa3a,SAEzB1J,MAAKukB,aAAavkB,KAAKyiB,MACvBziB,MAAKyiB,MAAQ,KAGNvhB,GAAAX,UAAAoiB,eAAR,WAEC,GAAI3iB,KAAKyiB,OAAS,KACjBziB,KAAKyiB,MAAQ,GAAInB,GAAWD,EAAeyC,aAAc9jB,KAAMA,KAAK0hB,UAAW1hB,KAAKikB,iBAAkBjkB,KAAKkkB,OAE5G,IAAIlkB,KAAK0hB,UAAUW,MAAQ1iB,EAAmBC,YAAa,CAC1DI,KAAKyiB,MAAM2B,cAAgBpkB,KAAK0hB,UAAU0C,aAC1CpkB,MAAKyiB,MAAM0B,cAAgBnkB,KAAK0hB,UAAUyC,aAC1CnkB,MAAKyiB,MAAM6B,eAAiBtkB,KAAK0hB,UAAU4C,cAC3CtkB,MAAKyiB,MAAM4B,aAAerkB,KAAK0hB,UAAU2C,YACzCrkB,MAAKyiB,MAAMI,aAAe7iB,KAAK0hB,UAAUmB,iBACnC,IAAI7iB,KAAK0hB,UAAUW,MAAQ1iB,EAAmBE,WAAY,CAChE,GAAIG,KAAKsJ,WAAa,EAAG,CACxBtJ,KAAKyiB,MAAM2B,cAAgBpkB,KAAK0hB,UAAU0C,kBACpC,CACNpkB,KAAKyiB,MAAM2B,cAAgB,KAG5BpkB,KAAKyiB,MAAMsB,cAAgB,KAC3B/jB,MAAKyiB,MAAM4B,aAAerkB,KAAK0hB,UAAU2C,a3CgnLpC,G2C5mLFplB,GAAW,CACf,IAAIgmB,EACJ,IAAI3N,GAAa4D,KAAKgK,IAAIllB,KAAK0hB,UAAUgB,iBAAkB1iB,KAAKyiB,MAAMC,iBAEtE,OAAOzjB,EAAIqY,EAAK,CACf2N,EAAejlB,KAAK0hB,UAAUje,kBAAkBxE,EAChD,IAAIgmB,GAAgBjlB,KAAKyiB,MAAMhf,kBAAkBxE,GAAI,CACpDe,KAAKyiB,MAAM0C,qBAAqBlmB,EAEhC,IAAIgmB,GAAgB,KAAM,CACzB,GAAIhmB,EAAIe,KAAKyiB,MAAMC,iBAClB1iB,KAAKyiB,MAAM9e,kBAAkBshB,EAAchmB,OAE3Ce,MAAKyiB,MAAMnf,gBAAgB2hB,IAI9BhmB,KAOKiC,GAAAX,UAAAmJ,QAAP,WAECtI,EAAAb,UAAMmJ,QAAOnK,KAAAS,MAIf,OAAAkB,IA5RmCkgB,EA8RL1hB,GAAAJ,QAArB4B,I3CwmLNkkB,iCAAiC5gB,UAAU6gB,8DAA8D7gB,UAAU/E,gDAAgD,gDAAgD6lB,sDAAsD,sDAAsDC,0DAA0D,0DAA0DC,0CAA0ChhB,UAAUU,+CAA+CV,YAAY+gB,2DAA2D,SAAS/mB,EAAQkB,EAAOJ,G4C96LxnB,GAAMmmB,GAAQ,WAAd,QAAMA,MAKSA,EAAA/B,QAAiB,CAKjB+B,GAAAzB,SAAkB,CAKlByB,GAAA3B,aAAsB,CACrC,OAAA2B,KAEA/lB,GAAkBJ,QAATmmB,O5Cg7LHH,uDAAuD,SAAS9mB,EAAQkB,EAAOJ,GACrF,GAAIS,GAAYC,KAAKD,WAAa,SAAUE,EAAGC,GAC3C,IAAK,GAAIC,KAAKD,GAAG,GAAIA,EAAEE,eAAeD,GAAIF,EAAEE,GAAKD,EAAEC,EACnD,SAASE,KAAOL,KAAKM,YAAcL,EACnCI,EAAGE,UAAYL,EAAEK,SACjBN,GAAEM,UAAY,GAAIF,G6Cj8LtB,IAAOqX,GAAKlZ,EAAiB,+BAM7B,IAAOknB,GAAYlnB,EAAgB,4CAKnC,IAAOmnB,GAAcnnB,EAAe,+CACpC,IAAO+N,GAAkB/N,EAAc,kDACvC,IAAOonB,GAAUpnB,EAAgB,2CAKjC,IAAOqnB,GAAQrnB,EAAiB,+CAIhC,IAAO4G,GAAQ5G,EAAiB,2CAGhC,IAAO8S,GAA0B9S,EAAY,gEAM7C,IAAO6iB,GAAc7iB,EAAe,0D7Ci7LpC,I6C16LM8iB,GAAU,SAAAlgB,GAASrB,EAAnBuhB,EAAUlgB,EAoIf,SApIKkgB,GAoIOe,EAAayD,EAA6BC,EAA0BtE,EAAkC9Z,GApInH,GAAAsE,GAAAjM,IAsIEoB,GAAA7B,KAAAS,KAAM8lB,EAAQC,EAAatE,EAAiB9Z,EApIrC3H,MAAAgmB,WAAoB,CAEpBhmB,MAAAiC,MAAe,CAIfjC,MAAAimB,gBAA0B,IAQ3BjmB,MAAAkmB,YAA8B,GAAIxkB,MAElC1B,MAAAmmB,uBAAgC,CAKhCnmB,MAAA6hB,qBAA8B,CAE9B7hB,MAAA8hB,eAAwB,CAExB9hB,MAAA4hB,eAAwB,CAExB5hB,MAAA+kB,kBAA2B,CAE3B/kB,MAAA8kB,wBAAgC,CAEhC9kB,MAAAglB,kBAA2B,CAuGjChlB,MAAKiC,MAAQogB,CAEbriB,MAAK0hB,UAAYqE,CAEjB/lB,MAAKomB,wBAA0B,SAAC1Z,GAAgB,MAAAT,GAAKoa,eAAe3Z,GAEpE1M,MAAKsmB,6BAA+B,SAAC5Z,GAA6B,MAAAT,GAAKsa,oBAAoB7Z,GAE3F1M,MAAK2hB,YAAcoE,EAAYpE,WAE/B,IAAI3hB,KAAKwmB,SAAW,KACnBxmB,KAAKymB,gBA7GP/jB,OAAAC,eAAW2e,EAAA/gB,UAAA,Q7Cq6LJqC,I6Cr6LP,WAEC,MAAO5C,MAAKiC,O7Cs6LNe,I6Cn6LP,SAAgBC,GAEf,GAAIjD,KAAKiC,OAASgB,EACjB,MAEDjD,MAAKiC,MAAQgB,CAEbjD,MAAK0mB,iB7Ck6LC5jB,WAAY,KACZC,aAAc,M6C75LrBL,QAAAC,eAAW2e,EAAA/gB,UAAA,kB7Cm6LJqC,I6Cn6LP,WAEC,MAAO5C,MAAKimB,iB7Co6LNjjB,I6Cj6LP,SAA0BC,GAEzB,GAAIjD,KAAKimB,iBAAmBhjB,EAC3B,MAEDjD,MAAKimB,gBAAkBhjB,CAEvBjD,MAAK0mB,iB7Cg6LC5jB,WAAY,KACZC,aAAc,M6C15LrBL,QAAAC,eAAW2e,EAAA/gB,UAAA,e7Ci6LJqC,I6Cj6LP,WAEC,MAAO5C,MAAK2mB,c7Ck6LN3jB,I6C/5LP,SAAuBC,GAKtB,GAAIjD,KAAK2mB,aACR3mB,KAAK2mB,aAAa5Z,oBAAoB2K,EAAMU,OAAQpY,KAAKomB,wBAE1DpmB,MAAK2mB,aAAe1jB,CAEpB,IAAIjD,KAAK2mB,aACR3mB,KAAK2mB,aAAa9Z,iBAAiB6K,EAAMU,OAAQpY,KAAKomB,wBAEvDpmB,MAAK0mB,iB7C45LC5jB,WAAY,KACZC,aAAc,M6Ct5LrBL,QAAAC,eAAW2e,EAAA/gB,UAAA,sB7C65LJqC,I6C75LP,WAEC,MAAO5C,MAAK0hB,UAAUkF,oB7C85LhB9jB,WAAY,KACZC,aAAc,M6Ct5LrBL,QAAAC,eAAW2e,EAAA/gB,UAAA,uB7C+5LJqC,I6C/5LP,WAEC,MAAO5C,MAAK0hB,UAAUmF,qB7Cg6LhB/jB,WAAY,KACZC,aAAc,M6Cx5LrBL,QAAAC,eAAW2e,EAAA/gB,UAAA,wB7Ci6LJqC,I6Cj6LP,WAEC,MAAO5C,MAAK0hB,UAAUoF,sB7Ck6LhBhkB,WAAY,KACZC,aAAc,M6Cz4Lbue,GAAA/gB,UAAAkmB,cAAR,WAEC,IAAKzmB,KAAK6hB,sBAAwB7hB,KAAK8hB,gBAAkB9hB,KAAK4hB,mBAAqB5hB,KAAKwmB,kBAAmBb,IAAiB,CAC3H,GAAI3lB,KAAKwmB,SAAW,KACnBxmB,KAAKwmB,QAAQ9c,SAEd1J,MAAKwmB,QAAU,GAAIb,GAAe3lB,KAAKikB,iBAAkBjkB,KAAMA,KAAKkkB,YAC9D,MAAMlkB,KAAKwmB,kBAAmBZ,IAAa,CACjD,GAAI5lB,KAAKwmB,SAAW,KACnBxmB,KAAKwmB,QAAQ9c,SAEd1J,MAAKwmB,QAAU,GAAIZ,GAAW5lB,KAAKikB,iBAAkBjkB,KAAMA,KAAKkkB,SAO3D5C,GAAA/gB,UAAAwmB,mBAAP,SAA0BrgB,GAEzBtF,EAAAb,UAAMwmB,mBAAkBxnB,KAAAS,KAAC0G,E7Cy4LnB,I6Ct4LF4Q,GAAatX,KAAKkmB,YAAY1mB,MAClC,KAAK,GAAIP,GAAW,EAAGA,EAAIqY,IAAOrY,EACjCe,KAAKkmB,YAAYjnB,GAAGsE,OAAOsD,eAAeH,EAAQ1G,KAAKkmB,YAAYjnB,IAMrEyD,QAAAC,eAAW2e,EAAA/gB,UAAA,kB7Cs4LJqC,I6Ct4LP,WAEC,MAAO5C,MAAKgnB,qBAAsBhnB,KAAKgnB,qBAAqBnD,eAAiB,M7Cu4LvE7gB,I6Cp4LP,SAA0BC,GAEzB,GAAIA,EAAO,CACV,GAAIjD,KAAKgnB,sBAAwB,KAChChnB,KAAKgnB,qBAAuB,GAAI1V,EAEjCtR,MAAKgnB,qBAAqBnD,eAAiB5gB,MAErC,KAAKA,EAAO,CAClB,GAAIjD,KAAKgnB,qBACRhnB,KAAKgnB,qBAAuB,O7Cq4LxBlkB,WAAY,KACZC,aAAc,M6C/3LrBL,QAAAC,eAAW2e,EAAA/gB,UAAA,wB7Cq4LJqC,I6Cr4LP,WAEC,MAAO5C,MAAKinB,yBAAuDjnB,KAAKinB,yBAAyB1jB,OAAS,M7Cs4LpGP,I6Cn4LP,SAAgCC,GAE/B,GAAIjD,KAAKinB,0BAA4BjnB,KAAKinB,yBAAyB1jB,QAAUN,EAC5E,MAED;GAAIjD,KAAKinB,yBAA0B,CAClCjnB,KAAKknB,kBAAkBlnB,KAAKinB,yBAC5BjnB,MAAKinB,yBAA2B,KAGjC,GAAIhkB,EAAO,CACVjD,KAAKinB,yBAA2B,GAAI7hB,GAASnC,EAC7CjD,MAAKmnB,eAAennB,KAAKinB,4B7Cm4LpBnkB,WAAY,KACZC,aAAc,M6Ch4Lbue,GAAA/gB,UAAA2mB,kBAAR,SAA0BvgB,EAAmBygB,GAAA,GAAAA,QAAA,GAAiC,CAAjCA,EAAA,MAE5C,GAAI1jB,GAAe1D,KAAKkmB,YAAYpiB,QAAQ6C,EAE5C,KAAKygB,EACJpnB,KAAKmmB,wBAENxf,GAASpD,OAAOwJ,oBAAoBR,EAAmBO,mBAAoB9M,KAAKsmB,6BAChFtmB,MAAKkmB,YAAYtiB,OAAOF,EAAO,EAE/B1D,MAAKqnB,iBAGE/F,GAAA/gB,UAAA4mB,eAAR,SAAuBxgB,EAAmBygB,EAAmC1jB,GAAnC,GAAA0jB,QAAA,GAAiC,CAAjCA,EAAA,MAAmC,GAAA1jB,QAAA,GAAiB,CAAjBA,GAAgB,EAE5FiD,EAASpD,OAAOsJ,iBAAiBN,EAAmBO,mBAAoB9M,KAAKsmB,6BAE7E,IAAIc,EAAmB,CACtB,GAAI1jB,IAAU,EACb1D,KAAKkmB,YAAYtiB,OAAOF,EAAQ1D,KAAKkmB,YAAY1mB,OAASQ,KAAKmmB,uBAAwB,EAAGxf,OAE1F3G,MAAKkmB,YAAY1iB,KAAKmD,EACvB3G,MAAKmmB,6BACC,CACNnmB,KAAKkmB,YAAYtiB,OAAO5D,KAAKkmB,YAAY1mB,OAASQ,KAAKmmB,uBAAwB,EAAGxf,GAGnF3G,KAAKqnB,iBAQC/F,GAAA/gB,UAAA+C,gBAAP,SAAuBC,GAEtBvD,KAAKmnB,eAAe,GAAI/hB,GAAS7B,GAAS,MAM3Cb,QAAAC,eAAW2e,EAAA/gB,UAAA,oB7C43LJqC,I6C53LP,WAEC,MAAO5C,MAAKmmB,wB7C63LNrjB,WAAY,KACZC,aAAc,M6Cr3Ldue,GAAA/gB,UAAA+mB,gBAAP,SAAuB/jB,GAEtB,MAAOvD,MAAKunB,uBAAuBhkB,IAAW,KAQxC+d,GAAA/gB,UAAAkD,kBAAP,SAAyBC,GAExB,GAAIA,EAAQ,GAAKA,EAAQ1D,KAAKmmB,uBAAyB,EACtD,MAAO,KAER,OAA0BnmB,MAAKkmB,YAAYxiB,EAAQ1D,KAAKkmB,YAAY1mB,OAASQ,KAAKmmB,wBAAwB5iB,OAQpG+d,GAAA/gB,UAAAoD,kBAAP,SAAyBJ,EAAyBG,GAEjD1D,KAAKmnB,eAAe,GAAI/hB,GAAS7B,GAAS,KAAMG,GAO1C4d,GAAA/gB,UAAAsD,mBAAP,SAA0BN,GAEzB,GAAIoD,GAAoB3G,KAAKunB,uBAAuBhkB,EAEpD,IAAIoD,GAAY,KACf3G,KAAKknB,kBAAkBvgB,EAAU,MAO5B2a,GAAA/gB,UAAA4kB,qBAAP,SAA4BzhB,GAE3B,GAAIA,EAAQ,GAAKA,EAAQ1D,KAAKmmB,uBAAyB,EACtD,MAED,IAAIxf,GAAoB3G,KAAKkmB,YAAYxiB,EAAQ1D,KAAKkmB,YAAY1mB,OAASQ,KAAKmmB,uBAEhF,IAAIxf,GAAY,KACf3G,KAAKknB,kBAAkBvgB,EAAU,MAI3B2a,GAAA/gB,UAAAgnB,uBAAR,SAA+BhkB,GAE9B,GAAI+T,GAAatX,KAAKkmB,YAAY1mB,MAClC,KAAK,GAAIP,GAAW,EAAGA,EAAIqY,IAAOrY,EACjC,GAAIe,KAAKkmB,YAAYjnB,GAAGsE,QAAUA,EACjC,MAAOvD,MAAKkmB,YAAYjnB,EAE1B,OAAO,MAMRyD,QAAAC,eAAW2e,EAAA/gB,UAAA,gB7C22LJqC,I6C32LP,WAEC,MAAO5C,MAAKwnB,iBAAsCxnB,KAAKwnB,iBAAiBjkB,OAAS,M7C42L3EP,I6Cz2LP,SAAwBC,GAEvB,GAAIjD,KAAKwnB,kBAAoBxnB,KAAKwnB,iBAAiBjkB,QAAUN,EAC5D,MAED,IAAIjD,KAAKwnB,iBAAkB,CAC1BxnB,KAAKknB,kBAAkBlnB,KAAKwnB,iBAC5BxnB,MAAKwnB,iBAAmB,KAGzB,GAAIvkB,EAAO,CACVjD,KAAKwnB,iBAAmB,GAAIpiB,GAASnC,EACrCjD,MAAKmnB,eAAennB,KAAKwnB,oB7Cy2LpB1kB,WAAY,KACZC,aAAc,M6Cn2LrBL,QAAAC,eAAW2e,EAAA/gB,UAAA,iB7Cy2LJqC,I6Cz2LP,WAEC,MAAO5C,MAAKynB,kBAAwCznB,KAAKynB,kBAAkBlkB,OAAS,M7C02L9EP,I6Cv2LP,SAAyBC,GAExB,GAAIjD,KAAKynB,mBAAqBznB,KAAKynB,kBAAkBlkB,QAAUN,EAC9D,MAED,IAAIjD,KAAKynB,kBAAmB,CAC3BznB,KAAKknB,kBAAkBlnB,KAAKynB,kBAC5BznB,MAAKynB,kBAAoB,KAG1B,GAAIxkB,EAAO,CACVjD,KAAKynB,kBAAoB,GAAIriB,GAASnC,EACtCjD,MAAKmnB,eAAennB,KAAKynB,qB7Cu2LpB3kB,WAAY,KACZC,aAAc,M6Cj2LrBL,QAAAC,eAAW2e,EAAA/gB,UAAA,gB7Cu2LJqC,I6Cv2LP,WAEC,MAAO5C,MAAK0nB,iBAAwC1nB,KAAK0nB,iBAAiBnkB,OAAS,M7Cw2L7EP,I6Cr2LP,SAAwBC,GAEvB,GAAIjD,KAAK0nB,kBAAoB1nB,KAAK0nB,iBAAiBnkB,QAAUN,EAC5D,MAED,IAAIjD,KAAK0nB,iBAAkB,CAC1B1nB,KAAKknB,kBAAkBlnB,KAAK0nB,iBAC5B1nB,MAAK0nB,iBAAmB,KAGzB,GAAIzkB,EAAO,CACVjD,KAAK0nB,iBAAmB,GAAItiB,GAASnC,EACrCjD,MAAKmnB,eAAennB,KAAK0nB,oB7Cq2LpB5kB,WAAY,KACZC,aAAc,M6C/1LrBL,QAAAC,eAAW2e,EAAA/gB,UAAA,iB7Cq2LJqC,I6Cr2LP,WAEC,MAAO5C,MAAK2nB,kBAAwC3nB,KAAK2nB,kBAAkBpkB,OAAS,M7Cs2L9EP,I6Cn2LP,SAAyBC,GAExB,GAAIjD,KAAK2nB,mBAAqB3nB,KAAK2nB,kBAAkBpkB,QAAUN,EAC9D,MAED,IAAIjD,KAAK2nB,kBAAmB,CAC3B3nB,KAAKknB,kBAAkBlnB,KAAK2nB,kBAC5B3nB,MAAK2nB,kBAAoB,KAG1B,GAAI1kB,EAAO,CACVjD,KAAK2nB,kBAAoB,GAAIviB,GAASnC,EACtCjD,MAAKmnB,eAAennB,KAAK2nB,qB7Cm2LpB7kB,WAAY,KACZC,aAAc,M6C71LrBL,QAAAC,eAAW2e,EAAA/gB,UAAA,kB7Cm2LJqC,I6Cn2LP,WAEC,MAAO5C,MAAK4nB,mBAA0C5nB,KAAK4nB,mBAAmBrkB,OAAS,M7Co2LjFP,I6Cj2LP,SAA0BC,GAEzB,GAAIjD,KAAK4nB,oBAAsB5nB,KAAK4nB,mBAAmBrkB,QAAUN,EAChE,MAED,IAAIjD,KAAK4nB,mBAAoB,CAC5B5nB,KAAKknB,kBAAkBlnB,KAAK4nB,mBAC5B5nB,MAAK4nB,mBAAqB,KAG3B,GAAI3kB,EAAO,CACVjD,KAAK4nB,mBAAqB,GAAIxiB,GAASnC,EACvCjD,MAAKmnB,eAAennB,KAAK4nB,sB7Ci2LpB9kB,WAAY,KACZC,aAAc,M6C31Ldue,GAAA/gB,UAAAmJ,QAAP,WAEC,GAAI1J,KAAK2mB,aACR3mB,KAAK2mB,aAAa5Z,oBAAoB2K,EAAMU,OAAQpY,KAAKomB,wBAE1D,OAAOpmB,KAAKkmB,YAAY1mB,OACvBQ,KAAKknB,kBAAkBlnB,KAAKkmB,YAAY,GAEzC9kB,GAAAb,UAAMmJ,QAAOnK,KAAAS,KAEbA,MAAKkmB,YAAc,KAMZ5E,GAAA/gB,UAAAgmB,oBAAR,SAA4B7Z,GAE3B1M,KAAKqnB,iBAQC/F,GAAA/gB,UAAAsnB,WAAP,SAAkB5f,GAEjB7G,EAAAb,UAAMsnB,WAAUtoB,KAAAS,KAACiI,EAEjB,IAAItB,EACJ,IAAI2Q,GAAatX,KAAKkmB,YAAY1mB,MAClC,KAAK,GAAIP,GAAW,EAAGA,EAAIqY,IAAOrY,EAAG,CACpC0H,EAAW3G,KAAKkmB,YAAYjnB,EAC5B,IAAI0H,EAAStB,UACZsB,EAASpD,OAAOmE,UAAU1H,KAAKwmB,QAAS7f,EAAU3G,KAAKkkB,SAWnD5C,GAAA/gB,UAAAunB,SAAP,SAAgB9f,EAA2BC,EAAe8f,GAEzD3mB,EAAAb,UAAMunB,SAAQvoB,KAAAS,KAACgI,EAAYC,EAAQ8f,EAEnC,IAAIphB,EACJ,IAAI2Q,GAAatX,KAAKkmB,YAAY1mB,MAClC,KAAK,GAAIP,GAAW,EAAGA,EAAIqY,IAAOrY,EAAG,CACpC0H,EAAW3G,KAAKkmB,YAAYjnB,EAC5B,IAAI0H,EAAStB,UACZsB,EAASpD,OAAOwE,gBAAgB/H,KAAKwmB,QAAS7f,EAAUqB,EAAYhI,KAAKkkB,OAAQjc,IAO7EqZ,GAAA/gB,UAAAynB,aAAP,WAEC5mB,EAAAb,UAAMynB,aAAYzoB,KAAAS,KAElB,IAAI2G,EACJ,IAAI2Q,GAAatX,KAAKkmB,YAAY1mB,MAClC,KAAK,GAAIP,GAAW,EAAGA,EAAIqY,IAAOrY,EAAG,CACpC0H,EAAW3G,KAAKkmB,YAAYjnB,EAC5B,IAAI0H,EAAStB,UACZsB,EAASpD,OAAO0J,YAAYjN,KAAKwmB,QAAS7f,EAAU3G,KAAKkkB,SAIrD5C,GAAA/gB,UAAA0nB,sBAAP,SAA6BvhB,GAE5BtF,EAAAb,UAAM0nB,sBAAqB1oB,KAAAS,KAAC0G,EAG5BA,GAAOwhB,sBAAwB9E,QAAQpjB,KAAKiC,OAASof,EAAeyC,aAEpE,IAAIpd,EAAOyhB,uBAAyBzhB,EAAO0hB,aAC1C1hB,EAAOiD,eAAiB,IAEzB,IAAI1K,EACJ,IAAIqY,GAAatX,KAAKkmB,YAAY1mB,MAClC,KAAKP,EAAI,EAAGA,EAAIqY,IAAOrY,EACtBe,KAAKqoB,0BAA0B3hB,EAAQ1G,KAAKkmB,YAAYjnB,GAEzD,IAAIqpB,GAA2B,IAE/B,IAAI3hB,EACJ,KAAK1H,EAAI,EAAGA,EAAIqY,IAAOrY,EAAG,CACzB0H,EAAW3G,KAAKkmB,YAAYjnB,EAC5B,KAAK0H,EAAStB,UAAYsB,EAASpD,OAAO8F,QAAQ3C,MAAaC,EAASpD,OAAO8T,oBAC9EiR,EAAmB,MAGrB5hB,EAAO6hB,eAAiBvoB,KAAKwnB,kBAAoBxnB,KAAKwnB,iBAAiBniB,SACvEqB,GAAO8hB,sBAAwB9hB,EAAO6hB,gBAAuCvoB,KAAKwnB,iBAAiBjkB,OAAQmS,wBAC3GhP,GAAO4hB,iBAAmB5hB,EAAO8hB,wBAA0B9hB,EAAO+hB,YAAcH,CAEhF,KAAK5hB,EAAO4hB,iBAAkB,CAC7B,GAAI5hB,EAAOgiB,oBAAsB,EAAG,CACnChiB,EAAOiiB,4BACD,IAAI3oB,KAAK8hB,eAAiB,GAAKpb,EAAOkiB,WAAY,CACxDliB,EAAOiiB,uBACP,IAAIvF,QAAQpjB,KAAKiC,MAAQof,EAAeqC,SACvChd,EAAOmiB,sBAAwB,OAW3BvH,GAAA/gB,UAAA8nB,0BAAR,SAAkC3hB,EAAmBC,GAEpDA,EAASrB,OAETqB,GAASpD,OAAOkD,QAAQC,EAAQC,EAEhC,IAAIA,EAASf,gBACZc,EAAOoiB,wBAER,IAAIniB,EAASX,sBAAwBW,EAASV,uBAAwB,CAErES,EAAOiiB,uBAEP,IAAIhiB,EAASV,uBACZS,EAAOmiB,sBAAwB,KAIjC,GAAIliB,EAASb,aACZY,EAAO+O,oBAER,IAAI9O,EAASZ,cACZW,EAAOqiB,qBAER,IAAIpiB,EAASd,UACZa,EAAOgiB,sBAGFpH,GAAA/gB,UAAAyoB,2BAAP,SAAkCtiB,EAAmBQ,EAAmCC,GAEvF,GAAI/H,GAAc,EAElB,IAAIY,KAAKynB,mBAAqBznB,KAAKynB,kBAAkBpiB,UACpDjG,GAAQY,KAAKynB,kBAAkBlkB,OAAO2J,eAAexG,EAAQ1G,KAAKynB,kBAAmBvgB,EAAeC,EAErG,IAAInH,KAAK2nB,mBAAqB3nB,KAAK2nB,kBAAkBtiB,UACpDjG,GAAQY,KAAK2nB,kBAAkBpkB,OAAO2J,eAAexG,EAAQ1G,KAAK2nB,kBAAmBzgB,EAAeC,EAErG,IAAInH,KAAK4nB,oBAAsB5nB,KAAK4nB,mBAAmBviB,UACtDjG,GAAQY,KAAK4nB,mBAAmBrkB,OAAO2J,eAAexG,EAAQ1G,KAAK4nB,mBAAoB1gB,EAAeC,EAEvG,OAAO/H,GAGDkiB,GAAA/gB,UAAA0oB,6BAAP,SAAoCviB,EAAmBQ,EAAmCC,GAEzF,GAAI/H,GAAc,EAElB,IAAIY,KAAKynB,mBAAqBznB,KAAKynB,kBAAkBpiB,UAAW,CAC/DjG,GAAQY,KAAKynB,kBAAkBlkB,OAAOyD,iBAAiBN,EAAQ1G,KAAKynB,kBAAmBtgB,EAAgB+hB,aAAchiB,EAAeC,EAEpI,IAAInH,KAAKynB,kBAAkB3hB,aAC1BoB,EAAc4D,wBAAwB3D,EAAgBoB,eAEvD,IAAIvI,KAAKynB,kBAAkB5hB,UAC1BqB,EAAc4D,wBAAwB3D,EAAgB8I,iBAGxD,GAAIjQ,KAAK2nB,mBAAqB3nB,KAAK2nB,kBAAkBtiB,UACpDjG,GAA8BY,KAAK2nB,kBAAkBpkB,OAAQ6G,4BAA6C1D,EAAQ1G,KAAK2nB,kBAAmBzgB,EAAeC,EAE1J,IAAInH,KAAK4nB,oBAAsB5nB,KAAK4nB,mBAAmBviB,UACtDjG,GAA8BY,KAAK4nB,mBAAmBrkB,OAAQ6G,4BAA6C1D,EAAQ1G,KAAK4nB,mBAAoB1gB,EAAeC,EAE5J,OAAO/H,GAGDkiB,GAAA/gB,UAAA4oB,iCAAP,SAAwCziB,EAAuB+D,EAAmC2e,EAAuCliB,EAAmCC,GAE3K,MAA6BnH,MAAK2nB,kBAAkBpkB,OAAQiH,yBAAyB9D,EAAQ1G,KAAK2nB,kBAAmBld,EAAa2e,EAAiBliB,EAAeC,GAG5Jma,GAAA/gB,UAAA8oB,kCAAP,SAAyC3iB,EAAuB+D,EAAmC6e,EAAwCpiB,EAAmCC,GAE7K,MAA6BnH,MAAK4nB,mBAAmBrkB,OAAQiH,yBAAyB9D,EAAQ1G,KAAK4nB,mBAAoBnd,EAAa6e,EAAkBpiB,EAAeC,GAG/Jma,GAAA/gB,UAAAgpB,iCAAP,SAAwC7iB,EAAuB8iB,EAA8BC,EAAkBviB,EAAmCC,GAEjJ,MAA6BnH,MAAK2nB,kBAAkBpkB,OAAQwH,yBAAyBrE,EAAQ1G,KAAK2nB,kBAAmB6B,EAAQC,EAAWviB,EAAeC,GAGjJma,GAAA/gB,UAAAmpB,kCAAP,SAAyChjB,EAAuB8iB,EAA8BC,EAAkBviB,EAAmCC,GAElJ,MAA6BnH,MAAK4nB,mBAAmBrkB,OAAQwH,yBAAyBrE,EAAQ1G,KAAK4nB,mBAAoB4B,EAAQC,EAAWviB,EAAeC,GAGnJma,GAAA/gB,UAAAopB,4BAAP,SAAmCjjB,EAAuBQ,EAAmCC,GAE5F,GAAI/H,GAAc,EAElB,IAAIY,KAAK0nB,iBACRtoB,GAAQY,KAAK0nB,iBAAiBnkB,OAAO2J,eAAexG,EAAQ1G,KAAK0nB,iBAAkBxgB,EAAeC,EAEnG,OAAO/H,GAGDkiB,GAAA/gB,UAAAqpB,8BAAP,SAAqCljB,EAAuBQ,EAAmCC,GAE9F,GAAI/H,GAAc,EAElB,IAAIsH,EAAOyhB,uBAAyBzhB,EAAO0hB,aAAc,CACxDhpB,GAAQ,OAAS+H,EAAgB+hB,aAAe,OAAS/hB,EAAgB+hB,aAAe,OAAS/hB,EAAgBwD,QAAU,OAC3H,OAASxD,EAAgB+hB,aAAe,SAAW/hB,EAAgB+hB,aAAe,KAAO/hB,EAAgB+hB,aAAe,OACxH,OAAS/hB,EAAgB+hB,aAAe,OAAS/hB,EAAgB+hB,aAAe,OAAS/hB,EAAgBwD,QAAU,OACnH,OAASxD,EAAgB+hB,aAAe,SAAW/hB,EAAgB+hB,aAAe,KAGnF,GAAIlpB,KAAK0nB,iBACRtoB,GAAQY,KAAK0nB,iBAAiBnkB,OAAOyD,iBAAiBN,EAAQ1G,KAAK0nB,iBAAkBvgB,EAAgBiE,aAAclE,EAAeC,EAEnI,IAAInH,KAAK2nB,mBAAqB3nB,KAAK2nB,kBAAkBtiB,UAAW,CAC/DjG,GAA8BY,KAAK2nB,kBAAkBpkB,OAAQ2H,6BAA6BxE,EAAQ1G,KAAK2nB,kBAAmBxgB,EAAgB+hB,aAAchiB,EAAeC,EAGvK,IAAInH,KAAK2nB,kBAAkB7hB,aAC1BoB,EAAc4D,wBAAwB3D,EAAgBoB,eAEvD,IAAIvI,KAAK2nB,kBAAkB9hB,UAC1BqB,EAAc4D,wBAAwB3D,EAAgB8I,iBAGxD,GAAIjQ,KAAK4nB,oBAAsB5nB,KAAK4nB,mBAAmBviB,UAAW,CACjEjG,GAA8BY,KAAK4nB,mBAAmBrkB,OAAQ2H,6BAA6BxE,EAAQ1G,KAAK4nB,mBAAoBzgB,EAAgB+hB,aAAchiB,EAAeC,EACzK,IAAInH,KAAK4nB,mBAAmB9hB,aAC3BoB,EAAc4D,wBAAwB3D,EAAgBoB,eACvD,IAAIvI,KAAK4nB,mBAAmB/hB,UAC3BqB,EAAc4D,wBAAwB3D,EAAgB8I,iBAGxD,GAAIjQ,KAAK0nB,iBACRxgB,EAAc4D,wBAAwB3D,EAAgBiE,aAEvD,OAAOhM,GAIDkiB,GAAA/gB,UAAAspB,sBAAP,SAA6BnjB,EAAmBQ,EAAmCC,GAElF,MAAOnH,MAAKwnB,iBAAiBjkB,OAAO2J,eAAexG,EAAQ1G,KAAKwnB,iBAAkBtgB,EAAeC,GAG3Fma,GAAA/gB,UAAAupB,wBAAP,SAA+BpjB,EAAmBQ,EAAmCC,GAEpF,GAAI/H,GAAcY,KAAKwnB,iBAAiBjkB,OAAOyD,iBAAiBN,EAAQ1G,KAAKwnB,iBAAkBrgB,EAAgBoB,eAAgBrB,EAAeC,EAE9I,IAAInH,KAAKwnB,iBAAiB3hB,UACzBqB,EAAc4D,wBAAwB3D,EAAgB8I,gBAEvD,IAAIjQ,KAAKwnB,iBAAiBvhB,wBAA0BjG,KAAKwnB,iBAAiBxhB,qBACzEkB,EAAc6iB,sBAAsB5iB,EAAgB2R,qBAErD,OAAO1Z,GAMDkiB,GAAA/gB,UAAAypB,gBAAP,SAAuBtjB,EAAmB4B,EAA8B2hB,GAEvE,GAAI7qB,GAAc,EAClB,IAAIuH,EACJ,IAAI2Q,GAAatX,KAAKkmB,YAAY1mB,MAClC,KAAK,GAAIP,GAAWqY,EAAMtX,KAAKmmB,uBAAwBlnB,EAAIqY,EAAKrY,IAAK,CACpE0H,EAAW3G,KAAKkmB,YAAYjnB,EAC5B,IAAI0H,EAAStB,UAAW,CACvBjG,GAAQuH,EAASpD,OAAO2J,eAAexG,EAAQC,EAAU2B,EAAU2hB,EAEnE,IAAItjB,EAASX,sBAAwBW,EAASV,uBAC7CqC,EAASyhB,sBAAsBE,EAAUnR,uBAI5C,GAAI9Y,KAAKinB,0BAA4BjnB,KAAKinB,yBAAyB5hB,UAClEjG,GAAQY,KAAKinB,yBAAyB1jB,OAAO2J,eAAexG,EAAQ1G,KAAKinB,yBAA0B3e,EAAU2hB,EAE9G,OAAO7qB,GAMDkiB,GAAA/gB,UAAA6G,kBAAP,SAAyBV,EAAmB4B,EAA8B2hB,GAEzE,GAAI7qB,GAAc,EAClB,IAAI8qB,EAEJ,IAAIlqB,KAAK+jB,eAAiB/jB,KAAKmmB,uBAAyB,EAAG,CAC1D+D,EAAW5hB,EAASgW,2BACpBhW,GAASgC,sBAAsB4f,EAAU,EACzC9qB,IAAQ,OAAS8qB,EAAW,KAAOD,EAAUf,aAAe,OAG7D,GAAIviB,EACJ,IAAI2Q,GAAatX,KAAKkmB,YAAY1mB,MAClC,KAAK,GAAIP,GAAWqY,EAAMtX,KAAKmmB,uBAAwBlnB,EAAIqY,EAAKrY,IAAK,CACpE0H,EAAW3G,KAAKkmB,YAAYjnB,EAC5B,IAAI0H,EAAStB,UAAW,CACvBjG,GAAQuH,EAASpD,OAAOyD,iBAAiBN,EAAQC,EAAUsjB,EAAUf,aAAc5gB,EAAU2hB,EAE7F,IAAItjB,EAASb,aACZwC,EAASwC,wBAAwBmf,EAAU1hB,eAE5C,IAAI5B,EAASd,UACZyC,EAASwC,wBAAwBmf,EAAUha,kBAK9C,GAAIjQ,KAAK+jB,eAAiB/jB,KAAKmmB,uBAAyB,EAAG,CAC1D/mB,GAAQ,OAAS6qB,EAAUf,aAAe,OAASgB,EAAW,IAC9D5hB,GAASwC,wBAAwBof,GAGlC,GAAIlqB,KAAKinB,0BAA4BjnB,KAAKinB,yBAAyB5hB,UAClEjG,GAAQY,KAAKinB,yBAAyB1jB,OAAOyD,iBAAiBN,EAAQ1G,KAAKinB,yBAA0BgD,EAAUf,aAAc5gB,EAAU2hB,EAExI,OAAO7qB,GAKDkiB,GAAA/gB,UAAA4pB,cAAP,SAAqBzjB,GAEpB,MAAO0c,SAAQpjB,KAAK0nB,mBAAqB1nB,KAAK2mB,aAAayD,yBAAyB5qB,OAAS,GAAKQ,KAAK2mB,aAAa0D,mBAAmB7qB,OAAS,IAM1I8hB,GAAA/gB,UAAA+pB,eAAP,SAAsB5jB,GAErB,MAAO0c,SAAQpjB,KAAK4nB,oBAMdtG,GAAA/gB,UAAAgqB,cAAP,SAAqB7jB,GAEpB,MAAO0c,SAAQpjB,KAAK2nB,mBAIbrG,GAAA/gB,UAAA8lB,eAAR,SAAuB3Z,GAEtB1M,KAAK0mB,gBAGEpF,GAAA/gB,UAAAmmB,cAAR,WAEC,GAAI8D,GAAiCxqB,KAAK6hB,oBAC1C,IAAI4I,GAA2BzqB,KAAK8hB,cACpC,IAAI4I,GAA2B1qB,KAAK4hB,cAEpC,IAAI5hB,KAAK2mB,cAAiB3mB,KAAKiC,MAAQof,EAAe2C,SAAW,CAChEhkB,KAAK6hB,qBAAuB7hB,KAAK2qB,8BAA8B3qB,KAAK2mB,aAAa9E,qBACjF7hB,MAAK8hB,eAAiB9hB,KAAK4qB,wBAAwB5qB,KAAK2mB,aAAa7E,eACrE9hB,MAAK4hB,eAAiB5hB,KAAK6qB,mBAAmB7qB,KAAK2mB,aAAa/E,eAEhE,IAAI5hB,KAAKimB,gBAAiB,CACzBjmB,KAAK6hB,sBAAwB7hB,KAAK2mB,aAAa5E,2BAC/C/hB,MAAK8hB,gBAAkB9hB,KAAK2mB,aAAa3E,2BAGpC,CACNhiB,KAAK6hB,qBAAuB,CAC5B7hB,MAAK8hB,eAAiB,CACtB9hB,MAAK4hB,eAAiB,EAGvB,GAAI4I,GAA2BxqB,KAAK6hB,sBAAwB4I,GAAqBzqB,KAAK8hB,gBAAkB4I,GAAqB1qB,KAAK4hB,eAAgB,CACjJ5hB,KAAKymB,eAELzmB,MAAKqnB,kBASC/F,GAAA/gB,UAAAoqB,8BAAR,SAAsC9I,GAErC,MAAO3G,MAAK4P,IAAIjJ,EAAuB7hB,KAAK8kB,wBAAyB9kB,KAAKgmB,YAQnE1E,GAAA/gB,UAAAqqB,wBAAR,SAAgC9I,GAE/B,GAAIiJ,GAAiB/qB,KAAKgmB,WAAahmB,KAAK6hB,oBAC5C,OAAO3G,MAAK4P,IAAIhJ,EAAiB9hB,KAAK+kB,kBAAmBgG,GAQlDzJ,GAAA/gB,UAAAsqB,mBAAR,SAA2BjJ,GAE1B,GAAIoJ,GAAqB,CAEzB,KAAKhrB,KAAK8mB,qBAAuBpB,EAAauF,SAAW,IACtDD,CAEH,KAAKhrB,KAAK6mB,oBAAsBnB,EAAauF,SAAW,IACrDD,CAGH,OAAO9P,MAAK4P,IAAIlJ,EAAiB5hB,KAAKglB,kBAAoB,EAAEgG,EAAe,GAE7E,OAAA1J,IAx4ByBuE,EA04BzBnmB,GAAoBJ,QAAXgiB,I7CyuLNvH,+BAA+BvV,UAAU0mB,4CAA4C1mB,UAAUW,2CAA2C,2CAA2CkM,gEAAgE,gEAAgEkU,0DAA0D,0DAA0DpY,kDAAkD3I,UAAU2mB,+CAA+C3mB,UAAU4mB,+CAA+C5mB,UAAU6mB,2CAA2C7mB,YAAY8mB,kEAAkE,SAAS9sB,EAAQkB,EAAOJ,GAC3uB,GAAIS,GAAYC,KAAKD,WAAa,SAAUE,EAAGC,GAC3C,IAAK,GAAIC,KAAKD,GAAG,GAAIA,EAAEE,eAAeD,GAAIF,EAAEE,GAAKD,EAAEC,EACnD,SAASE,KAAOL,KAAKM,YAAcL,EACnCI,EAAGE,UAAYL,EAAEK,SACjBN,GAAEM,UAAY,GAAIF,G8CpqNtB,IAAOG,GAAOhC,EAAiB,+BAC/B,IAAO+sB,GAAQ/sB,EAAiB,gCAOhC,IAAOkC,GAAelC,EAAe,8CAGrC,IAAOgtB,GAAiBhtB,EAAc,4CACtC,IAAOitB,GAAoBjtB,EAAc,+CAQzC,IAAOqnB,GAAQrnB,EAAiB,+CAKhC,IAAOktB,GAAiBltB,EAAc,8C9CwpNtC,I8ClpNMmtB,GAAqB,SAAAvqB,GAASrB,EAA9B4rB,EAAqBvqB,EAuC1B,SAvCKuqB,GAuCO7F,EAAmBC,EAA0BtE,EAAkC9Z,GAE1FvG,EAAA7B,KAAAS,KAAM8lB,EAAQC,EAAatE,EAAiB9Z,EApCrC3H,MAAA4rB,aAA+B,GAC/B5rB,MAAA6rB,YAA2B,GAAIC,eAAc,GAAI,EAAG,EAAG,GAEvD9rB,MAAA+rB,2BAAqC,IAyC5C/rB,MAAKgsB,mBAAqBN,EAAkBO,UApC7CvpB,OAAAC,eAAWgpB,EAAAprB,UAAA,e9C2pNJqC,I8C3pNP,WAEC,MAAO5C,MAAK4rB,c9C4pNN5oB,I8CzpNP,SAAuBC,GAEtBjD,KAAK4rB,aAAe3oB,G9C0pNdH,WAAY,KACZC,aAAc,M8CrpNrBL,QAAAC,eAAWgpB,EAAAprB,UAAA,c9C2pNJqC,I8C3pNP,WAEC,MAAO5C,MAAK6rB,YAAY,I9C4pNlB7oB,I8CzpNP,SAAsBC,GAErBjD,KAAK6rB,YAAY,GAAK5oB,G9C0pNhBH,WAAY,KACZC,aAAc,M8CroNd4oB,GAAAprB,UAAAmJ,QAAP,WAEC,GAAI1J,KAAKkX,UAAW,CACnB,IAAK,GAAIgV,KAAOlsB,MAAKkX,UAAW,CAC/B,GAAIhV,GAAsBlC,KAAKkX,UAAUgV,EACzChqB,GAAQwH,UAET1J,KAAKkX,UAAY,MAOXyU,GAAAprB,UAAA4rB,yBAAR,WAEC,GAAInsB,KAAKkX,UAAW,CACnB,IAAK,GAAIgV,KAAOlsB,MAAKkX,UAAW,CAC/B,GAAIhV,GAAsBlC,KAAKkX,UAAUgV,EACzChqB,GAAQwH,WAIV1J,KAAKkX,UAAY,GAAIxU,OACrB1C,MAAKosB,aAAe,GAAI1pB,OACxB1C,MAAK+rB,2BAA6B,MAM5BJ,GAAAprB,UAAAypB,gBAAP,WAEC,GAAI5qB,EAEJA,GAAO,yBACL,sBACA,oBAEFA,IAAQ,sBACN,eAGFA,IAAQ,sBAER,OAAOA,GAMDusB,GAAAprB,UAAA6G,kBAAP,SAAyBV,EAAmBQ,EAAmCC,GAE9E,GAAI/H,GAAc,EAGlBA,IAAQ,uBACN,iBACA,2BACA,sBACA,eAEF,OAAOA,GASDusB,GAAAprB,UAAA4P,cAAP,SAAqBnI,GAEpB,MAAOhI,MAAKkX,UAAUlP,EAAWqkB,gBAAgBC,IAQ3CX,GAAAprB,UAAA6P,gBAAP,SAAuBpI,GAEtB,MAAOhI,MAAKosB,aAAapkB,EAAWqkB,gBAAgBC,IAM9CX,GAAAprB,UAAAunB,SAAP,SAAgB9f,EAA2BC,EAAe8f,GAEzD,GAAI9W,EACJ,IAAIsb,GAAqBvsB,KAAKkkB,OAAOqI,OACrC,IAAIjV,EACJ,IAAIkV,EACJ,IAAIC,GAA0BzsB,KAAK0sB,aAAa/K,YAAYgL,eAC5D,IAAIC,GAAa5kB,EAAWqkB,gBAAgBC,EAE5C,KAAKtsB,KAAKkX,UAAU0V,GACnB5sB,KAAKkX,UAAU0V,GAAO,GAAIlsB,GAAgB,GAAIF,GAAQR,KAAK4rB,aAAc5rB,KAAK4rB,cAE/E,KAAK5rB,KAAKosB,aAAaQ,GACtB5sB,KAAKosB,aAAaQ,GAAO,GAAIrB,EAE9BjU,GAAMmV,EAAOjtB,MAGbgtB,GAAQC,EAAO,EAEfxb,GAASub,EAAMK,2BAA2B7kB,EAAW8kB,aAAc7kB,EAAQjI,KAAKosB,aAAaQ,GAE7F5sB,MAAKkkB,OAAO6I,gBAAgB/sB,KAAKkX,UAAU0V,GAAM,KACjDL,GAAQS,MAAM,EAAK,EAAK,EACxBT,GAAQU,8BAA8BxB,EAAqByB,OAAQ,EAAGjc,EAAQ,KAC9Esb,GAAQY,6BAA6B1B,EAAqB2B,SAAU,EAAGptB,KAAKqtB,KAAM,EAElF,IAAIC,GAAkCtlB,EAAWslB,aACjD,IAAIC,GAAoDD,EAAcE,WAEtEF,GAAcG,uBAAuB,EAAGF,EAAQG,UAAW1tB,KAAKkkB,OAChEoJ,GAAcG,uBAAuB,EAAGF,EAAQI,QAAS3tB,KAAKkkB,OAC9DoJ,GAAcM,iBAAiB5tB,KAAKkkB,QAAQ2J,KAAKrC,EAAkBsC,UAAW,EAAGR,EAAcE,YAAYO,aAMrGpC,GAAAprB,UAAAsnB,WAAP,SAAkB5f,GAEjB,GAAIjI,KAAK+rB,2BACR/rB,KAAKmsB,0BAGN/qB,GAAAb,UAAMsnB,WAAUtoB,KAAAS,KAACiI,EAEjBjI,MAAKkkB,OAAOqI,QAAQY,6BAA6B1B,EAAqByB,OAAQ,EAAGltB,KAAK6rB,YAAa,GAErG,OAAAF,IAhMoC9F,EAkMpCnmB,GAA+BJ,QAAtBqsB,I9CumNNpnB,+BAA+BC,UAAUwpB,gCAAgCxpB,UAAUE,8CAA8CF,UAAU2mB,+CAA+C3mB,UAAUypB,8CAA8CzpB,UAAU0pB,4CAA4C1pB,UAAU2pB,+CAA+C3pB",
  "file": "awayjs-methodmaterials.min.js",
  "sourcesContent": [
    "(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})",
    "class MethodMaterialMode\n{\n\t/**\n\t *\n\t */\n\tpublic static SINGLE_PASS:string = \"singlePass\";\n\n\t/**\n\t *\n\t */\n\tpublic static MULTI_PASS:string = \"multiPass\";\n}\n\nexport = MethodMaterialMode;",
    null,
    "import BlendMode\t\t\t\t\t= require(\"awayjs-core/lib/data/BlendMode\");\nimport Image2D\t\t\t\t\t\t= require(\"awayjs-core/lib/data/Image2D\");\n\nimport IRenderOwner\t\t\t\t\t= require(\"awayjs-display/lib/base/IRenderOwner\");\nimport Camera\t\t\t\t\t\t= require(\"awayjs-display/lib/entities/Camera\");\nimport StaticLightPicker\t\t\t= require(\"awayjs-display/lib/materials/lightpickers/StaticLightPicker\");\nimport MaterialBase\t\t\t\t\t= require(\"awayjs-display/lib/materials/MaterialBase\");\nimport IRender\t\t\t\t\t\t= require(\"awayjs-display/lib/pool/IRender\");\nimport Single2DTexture\t\t\t\t= require(\"awayjs-display/lib/textures/Single2DTexture\");\nimport TextureBase\t\t\t\t\t= require(\"awayjs-display/lib/textures/TextureBase\");\n\nimport ContextGLCompareMode\t\t\t= require(\"awayjs-stagegl/lib/base/ContextGLCompareMode\");\n\nimport RenderPool\t\t\t\t\t= require(\"awayjs-renderergl/lib/render/RenderPool\");\n\nimport MethodMaterialMode\t\t\t= require(\"awayjs-methodmaterials/lib/MethodMaterialMode\");\nimport AmbientBasicMethod\t\t\t= require(\"awayjs-methodmaterials/lib/methods/AmbientBasicMethod\");\nimport DiffuseBasicMethod\t\t\t= require(\"awayjs-methodmaterials/lib/methods/DiffuseBasicMethod\");\nimport EffectMethodBase\t\t\t\t= require(\"awayjs-methodmaterials/lib/methods/EffectMethodBase\");\nimport NormalBasicMethod\t\t\t= require(\"awayjs-methodmaterials/lib/methods/NormalBasicMethod\");\nimport ShadowMapMethodBase\t\t\t= require(\"awayjs-methodmaterials/lib/methods/ShadowMapMethodBase\");\nimport SpecularBasicMethod\t\t\t= require(\"awayjs-methodmaterials/lib/methods/SpecularBasicMethod\");\nimport MethodMaterialRender\t\t\t= require(\"awayjs-methodmaterials/lib/render/MethodMaterialRender\");\n\n/**\n * MethodMaterial forms an abstract base class for the default shaded materials provided by Stage,\n * using material methods to define their appearance.\n */\nclass MethodMaterial extends MaterialBase\n{\n\tpublic static assetType:string = \"[materials MethodMaterial]\";\n\n\tprivate _effectMethods:Array<EffectMethodBase> = new Array<EffectMethodBase>();\n\tprivate _mode:string;\n\n\tprivate _ambientMethod:AmbientBasicMethod = new AmbientBasicMethod();\n\tprivate _shadowMethod:ShadowMapMethodBase;\n\tprivate _diffuseMethod:DiffuseBasicMethod = new DiffuseBasicMethod();\n\tprivate _normalMethod:NormalBasicMethod = new NormalBasicMethod();\n\tprivate _specularMethod:SpecularBasicMethod = new SpecularBasicMethod();\n\n\n\tprivate _depthCompareMode:string = ContextGLCompareMode.LESS_EQUAL;\n\n\tprivate static register = MethodMaterial.addRenderable();\n\n\tprivate static addRenderable()\n\t{\n\t\tRenderPool.registerClass(MethodMaterialRender, MethodMaterial);\n\t}\n\n\t/**\n\t *\n\t */\n\tpublic get assetType():string\n\t{\n\t\treturn MethodMaterial.assetType;\n\t}\n\n\t/**\n\t * Creates a new MethodMaterial object.\n\t *\n\t * @param texture The texture used for the material's albedo color.\n\t * @param smooth Indicates whether the texture should be filtered when sampled. Defaults to true.\n\t * @param repeat Indicates whether the texture should be tiled when sampled. Defaults to false.\n\t * @param mipmap Indicates whether or not any used textures should use mipmapping. Defaults to false.\n\t */\n\tconstructor(texture?:Image2D, smooth?:boolean, repeat?:boolean, mipmap?:boolean);\n\tconstructor(texture?:TextureBase, smooth?:boolean, repeat?:boolean, mipmap?:boolean);\n\tconstructor(color?:number, alpha?:number);\n\tconstructor(textureColor:any = null, smoothAlpha:any = null, repeat:boolean = false, mipmap:boolean = true)\n\t{\n\t\tsuper();\n\n\t\tthis._mode = MethodMaterialMode.SINGLE_PASS;\n\n\t\tif (textureColor instanceof Image2D)\n\t\t\ttextureColor = new Single2DTexture(textureColor);\n\n\t\tif (textureColor instanceof TextureBase) {\n\t\t\tthis.texture = <TextureBase> textureColor;\n\n\t\t\tthis.smooth = (smoothAlpha == null)? true : false;\n\t\t\tthis.repeat = repeat;\n\t\t\tthis.mipmap = mipmap;\n\t\t} else {\n\t\t\tthis.color = (textureColor == null)? 0xFFFFFF : Number(textureColor);\n\t\t\tthis.alpha = (smoothAlpha == null)? 1 : Number(smoothAlpha);\n\t\t}\n\n\t\t//add default methods owners\n\t\tthis._ambientMethod.iAddOwner(this);\n\t\tthis._diffuseMethod.iAddOwner(this);\n\t\tthis._normalMethod.iAddOwner(this);\n\t\tthis._specularMethod.iAddOwner(this);\n\t}\n\n\n\tpublic get mode():string\n\t{\n\t\treturn this._mode;\n\t}\n\n\tpublic set mode(value:string)\n\t{\n\t\tif (this._mode == value)\n\t\t\treturn;\n\n\t\tthis._mode = value;\n\n\t\tthis._pInvalidateRender();\n\t}\n\n\t/**\n\t * The depth compare mode used to render the renderables using this material.\n\t *\n\t * @see away.stagegl.ContextGLCompareMode\n\t */\n\n\tpublic get depthCompareMode():string\n\t{\n\t\treturn this._depthCompareMode;\n\t}\n\n\tpublic set depthCompareMode(value:string)\n\t{\n\t\tif (this._depthCompareMode == value)\n\t\t\treturn;\n\n\t\tthis._depthCompareMode = value;\n\n\t\tthis._pInvalidateRender();\n\t}\n\n\t/**\n\t * The texture object to use for the ambient colour.\n\t */\n\tpublic get diffuseTexture():TextureBase\n\t{\n\t\treturn this._diffuseMethod.texture;\n\t}\n\n\tpublic set diffuseTexture(value:TextureBase)\n\t{\n\t\tthis._diffuseMethod.texture = value;\n\t}\n\n\t/**\n\t * The method that provides the ambient lighting contribution. Defaults to AmbientBasicMethod.\n\t */\n\tpublic get ambientMethod():AmbientBasicMethod\n\t{\n\t\treturn this._ambientMethod;\n\t}\n\n\tpublic set ambientMethod(value:AmbientBasicMethod)\n\t{\n\t\tif (this._ambientMethod == value)\n\t\t\treturn;\n\n\t\tif (value && this._ambientMethod)\n\t\t\tvalue.copyFrom(this._ambientMethod);\n\n\t\tif (this._ambientMethod)\n\t\t\tthis._ambientMethod.iRemoveOwner(this);\n\n\t\tthis._ambientMethod = value;\n\n\t\tif (this._ambientMethod)\n\t\t\tthis._ambientMethod.iAddOwner(this);\n\n\t\tthis._pInvalidateRender();\n\t}\n\n\t/**\n\t * The method used to render shadows cast on this surface, or null if no shadows are to be rendered. Defaults to null.\n\t */\n\tpublic get shadowMethod():ShadowMapMethodBase\n\t{\n\t\treturn this._shadowMethod;\n\t}\n\n\tpublic set shadowMethod(value:ShadowMapMethodBase)\n\t{\n\t\tif (this._shadowMethod == value)\n\t\t\treturn;\n\n\t\tif (value && this._shadowMethod)\n\t\t\tvalue.copyFrom(this._shadowMethod);\n\n\t\tif (this._shadowMethod)\n\t\t\tthis._shadowMethod.iRemoveOwner(this);\n\n\t\tthis._shadowMethod = value;\n\n\t\tif (this._shadowMethod)\n\t\t\tthis._shadowMethod.iAddOwner(this);\n\n\t\tthis._pInvalidateRender();\n\t}\n\n\t/**\n\t * The method that provides the diffuse lighting contribution. Defaults to DiffuseBasicMethod.\n\t */\n\tpublic get diffuseMethod():DiffuseBasicMethod\n\t{\n\t\treturn this._diffuseMethod;\n\t}\n\n\tpublic set diffuseMethod(value:DiffuseBasicMethod)\n\t{\n\t\tif (this._diffuseMethod == value)\n\t\t\treturn;\n\n\t\tif (value && this._diffuseMethod)\n\t\t\tvalue.copyFrom(this._diffuseMethod);\n\n\t\tif (this._diffuseMethod)\n\t\t\tthis._diffuseMethod.iRemoveOwner(this);\n\n\t\tthis._diffuseMethod = value;\n\n\t\tif (this._diffuseMethod)\n\t\t\tthis._diffuseMethod.iAddOwner(this);\n\n\t\tthis._pInvalidateRender();\n\t}\n\n\t/**\n\t * The method that provides the specular lighting contribution. Defaults to SpecularBasicMethod.\n\t */\n\tpublic get specularMethod():SpecularBasicMethod\n\t{\n\t\treturn this._specularMethod;\n\t}\n\n\tpublic set specularMethod(value:SpecularBasicMethod)\n\t{\n\t\tif (this._specularMethod == value)\n\t\t\treturn;\n\n\t\tif (value && this._specularMethod)\n\t\t\tvalue.copyFrom(this._specularMethod);\n\n\t\tif (this._specularMethod)\n\t\t\tthis._specularMethod.iRemoveOwner(this);\n\n\t\tthis._specularMethod = value;\n\n\t\tif (this._specularMethod)\n\t\t\tthis._specularMethod.iAddOwner(this);\n\n\t\tthis._pInvalidateRender();\n\t}\n\n\t/**\n\t * The method used to generate the per-pixel normals. Defaults to NormalBasicMethod.\n\t */\n\tpublic get normalMethod():NormalBasicMethod\n\t{\n\t\treturn this._normalMethod;\n\t}\n\n\tpublic set normalMethod(value:NormalBasicMethod)\n\t{\n\t\tif (this._normalMethod == value)\n\t\t\treturn;\n\n\t\tif (value && this._normalMethod)\n\t\t\tvalue.copyFrom(this._normalMethod);\n\n\t\tif (this._normalMethod)\n\t\t\tthis._normalMethod.iRemoveOwner(this);\n\n\t\tthis._normalMethod = value;\n\n\t\tif (this._normalMethod)\n\t\t\tthis._normalMethod.iAddOwner(this);\n\n\t\tthis._pInvalidateRender();\n\t}\n\n\tpublic get numEffectMethods():number\n\t{\n\t\treturn this._effectMethods.length;\n\t}\n\n\t/**\n\t * Appends an \"effect\" shading method to the shader. Effect methods are those that do not influence the lighting\n\t * but modulate the shaded colour, used for fog, outlines, etc. The method will be applied to the result of the\n\t * methods added prior.\n\t */\n\tpublic addEffectMethod(method:EffectMethodBase)\n\t{\n\t\tmethod.iAddOwner(this);\n\n\t\tthis._effectMethods.push(method);\n\n\t\tthis._pInvalidateRender();\n\t}\n\n\t/**\n\t * Returns the method added at the given index.\n\t * @param index The index of the method to retrieve.\n\t * @return The method at the given index.\n\t */\n\tpublic getEffectMethodAt(index:number):EffectMethodBase\n\t{\n\t\treturn this._effectMethods[index];\n\t}\n\n\t/**\n\t * Adds an effect method at the specified index amongst the methods already added to the material. Effect\n\t * methods are those that do not influence the lighting but modulate the shaded colour, used for fog, outlines,\n\t * etc. The method will be applied to the result of the methods with a lower index.\n\t */\n\tpublic addEffectMethodAt(method:EffectMethodBase, index:number)\n\t{\n\t\tmethod.iAddOwner(this);\n\n\t\tthis._effectMethods.splice(index, 0, method);\n\n\t\tthis._pInvalidateRender();\n\t}\n\n\t/**\n\t * Removes an effect method from the material.\n\t * @param method The method to be removed.\n\t */\n\tpublic removeEffectMethod(method:EffectMethodBase)\n\t{\n\t\tmethod.iRemoveOwner(this);\n\n\t\tthis._effectMethods.splice(this._effectMethods.indexOf(method), 1);\n\n\t\tthis._pInvalidateRender();\n\t}\n\n\t/**\n\t * The normal map to modulate the direction of the surface for each texel. The default normal method expects\n\t * tangent-space normal maps, but others could expect object-space maps.\n\t */\n\tpublic get normalMap():TextureBase\n\t{\n\t\treturn this._normalMethod.normalMap;\n\t}\n\n\tpublic set normalMap(value:TextureBase)\n\t{\n\t\tthis._normalMethod.normalMap = value;\n\t}\n\n\t/**\n\t * A specular map that defines the strength of specular reflections for each texel in the red channel,\n\t * and the gloss factor in the green channel. You can use Specular2DTexture if you want to easily set\n\t * specular and gloss maps from grayscale images, but correctly authored images are preferred.\n\t */\n\tpublic get specularMap():TextureBase\n\t{\n\t\treturn this._specularMethod.texture;\n\t}\n\n\tpublic set specularMap(value:TextureBase)\n\t{\n\t\tthis._specularMethod.texture = value;\n\t}\n\n\t/**\n\t * The glossiness of the material (sharpness of the specular highlight).\n\t */\n\tpublic get gloss():number\n\t{\n\t\treturn this._specularMethod.gloss;\n\t}\n\n\tpublic set gloss(value:number)\n\t{\n\t\tthis._specularMethod.gloss = value;\n\t}\n\n\t/**\n\t * The strength of the ambient reflection.\n\t */\n\tpublic get ambient():number\n\t{\n\t\treturn this._ambientMethod.ambient;\n\t}\n\n\tpublic set ambient(value:number)\n\t{\n\t\tthis._ambientMethod.ambient = value;\n\t}\n\n\t/**\n\t * The overall strength of the specular reflection.\n\t */\n\tpublic get specular():number\n\t{\n\t\treturn this._specularMethod.specular;\n\t}\n\n\tpublic set specular(value:number)\n\t{\n\t\tthis._specularMethod.specular = value;\n\t}\n\n\t/**\n\t * The colour of the ambient reflection.\n\t */\n\tpublic get ambientColor():number\n\t{\n\t\treturn this._diffuseMethod.ambientColor;\n\t}\n\n\tpublic set ambientColor(value:number)\n\t{\n\t\tthis._diffuseMethod.ambientColor = value;\n\t}\n\n\t/**\n\t * The colour of the diffuse reflection.\n\t */\n\tpublic get diffuseColor():number\n\t{\n\t\treturn this._diffuseMethod.diffuseColor;\n\t}\n\n\tpublic set diffuseColor(value:number)\n\t{\n\t\tthis._diffuseMethod.diffuseColor = value;\n\t}\n\n\t/**\n\t * The colour of the specular reflection.\n\t */\n\tpublic get specularColor():number\n\t{\n\t\treturn this._specularMethod.specularColor;\n\t}\n\n\tpublic set specularColor(value:number)\n\t{\n\t\tthis._specularMethod.specularColor = value;\n\t}\n}\n\nexport = MethodMaterial;",
    "import TextureVOBase\t\t\t\t= require(\"awayjs-renderergl/lib/vos/TextureVOBase\");\n\nimport ShadingMethodBase\t\t\t= require(\"awayjs-methodmaterials/lib/methods/ShadingMethodBase\");\n\n/**\n * MethodVO contains data for a given shader object for the use within a single material.\n * This allows shader methods to be shared across materials while their non-public state differs.\n */\nclass MethodVO\n{\n\tpublic useMethod:boolean = true;\n\n\tpublic method:ShadingMethodBase;\n\n\t// public register indices\n\tpublic textureVO:TextureVOBase;\n\tpublic secondaryTextureVO:TextureVOBase; // sometimes needed for composites\n\tpublic vertexConstantsIndex:number;\n\tpublic secondaryVertexConstantsIndex:number; // sometimes needed for composites\n\tpublic fragmentConstantsIndex:number;\n\tpublic secondaryFragmentConstantsIndex:number; // sometimes needed for composites\n\n\t// internal stuff for the material to know before assembling code\n\tpublic needsProjection:boolean;\n\tpublic needsView:boolean;\n\tpublic needsNormals:boolean;\n\tpublic needsTangents:boolean;\n\tpublic needsGlobalVertexPos:boolean;\n\tpublic needsGlobalFragmentPos:boolean;\n\t/**\n\t * Creates a new MethodVO object.\n\t */\n\tconstructor(method:ShadingMethodBase)\n\t{\n\t\tthis.method = method;\n\t}\n\n\t/**\n\t * Resets the values of the value object to their \"unused\" state.\n\t */\n\tpublic reset()\n\t{\n\t\tthis.method.iReset();\n\n\t\tthis.vertexConstantsIndex = -1;\n\t\tthis.secondaryVertexConstantsIndex = -1;\n\t\tthis.fragmentConstantsIndex = -1;\n\t\tthis.secondaryFragmentConstantsIndex = -1;\n\n\t\tthis.needsProjection = false;\n\t\tthis.needsView = false;\n\t\tthis.needsNormals = false;\n\t\tthis.needsTangents = false;\n\t\tthis.needsGlobalVertexPos = false;\n\t\tthis.needsGlobalFragmentPos = false;\n\t}\n}\n\nexport = MethodVO;\n",
    "import Camera\t\t\t\t\t\t\t= require(\"awayjs-display/lib/entities/Camera\");\n\nimport Stage\t\t\t\t\t\t\t= require(\"awayjs-stagegl/lib/base/Stage\");\n\nimport RenderableBase\t\t\t\t\t= require(\"awayjs-renderergl/lib/renderables/RenderableBase\");\nimport ShaderBase\t\t\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderBase\");\nimport ShaderRegisterCache\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterCache\");\nimport ShaderRegisterData\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterData\");\nimport ShaderRegisterElement\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterElement\");\n\nimport MethodVO\t\t\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/data/MethodVO\");\nimport ShadingMethodBase\t\t\t\t= require(\"awayjs-methodmaterials/lib/methods/ShadingMethodBase\");\n\n/**\n * AmbientBasicMethod provides the default shading method for uniform ambient lighting.\n */\nclass AmbientBasicMethod extends ShadingMethodBase\n{\n\tprivate _color:number = 0xffffff;\n\tprivate _alpha:number = 1;\n\n\tprivate _colorR:number = 1;\n\tprivate _colorG:number = 1;\n\tprivate _colorB:number = 1;\n\n\tprivate _ambient:number = 1;\n\n\t/**\n\t * Creates a new AmbientBasicMethod object.\n\t */\n\tconstructor()\n\t{\n\t\tsuper();\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitVO(shader:ShaderBase, methodVO:MethodVO)\n\t{\n\t\tif (shader.texture)\n\t\t\tshader.uvDependencies++;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitConstants(shader:ShaderBase, methodVO:MethodVO)\n\t{\n\t\tif (!shader.texture) {\n\t\t\tthis._color = shader.color;\n\t\t\tthis.updateColor();\n\t\t}\n\t}\n\n\t/**\n\t * The strength of the ambient reflection of the surface.\n\t */\n\tpublic get ambient():number\n\t{\n\t\treturn this._ambient;\n\t}\n\n\tpublic set ambient(value:number)\n\t{\n\t\tif (this._ambient == value)\n\t\t\treturn;\n\n\t\tthis._ambient = value;\n\n\t\tthis.updateColor();\n\t}\n\n\t/**\n\t * The alpha component of the surface.\n\t */\n\tpublic get alpha():number\n\t{\n\t\treturn this._alpha;\n\t}\n\n\tpublic set alpha(value:number)\n\t{\n\t\tif (this._alpha == value)\n\t\t\treturn;\n\n\t\tthis._alpha = value;\n\n\t\tthis.updateColor();\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic copyFrom(method:ShadingMethodBase)\n\t{\n\t\tvar m:any = method;\n\t\tvar b:AmbientBasicMethod = <AmbientBasicMethod> m;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentCode(shader:ShaderBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = \"\";\n\n\t\tif (shader.texture) {\n\t\t\tcode += shader.texture._iGetFragmentCode(shader, targetReg, registerCache, sharedRegisters, sharedRegisters.uvVarying);\n\n\t\t\tif (shader.alphaThreshold > 0) {\n\t\t\t\tvar cutOffReg:ShaderRegisterElement = registerCache.getFreeFragmentConstant();\n\t\t\t\tmethodVO.fragmentConstantsIndex = cutOffReg.index*4;\n\n\t\t\t\tcode += \"sub \" + targetReg + \".w, \" + targetReg + \".w, \" + cutOffReg + \".x\\n\" +\n\t\t\t\t\t\"kil \" + targetReg + \".w\\n\" +\n\t\t\t\t\t\"add \" + targetReg + \".w, \" + targetReg + \".w, \" + cutOffReg + \".x\\n\";\n\t\t\t}\n\n\t\t} else {\n\t\t\tvar ambientInputRegister:ShaderRegisterElement = registerCache.getFreeFragmentConstant();\n\t\t\tmethodVO.fragmentConstantsIndex = ambientInputRegister.index*4;\n\n\t\t\tcode += \"mov \" + targetReg + \", \" + ambientInputRegister + \"\\n\";\n\t\t}\n\n\t\treturn code;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iActivate(shader:ShaderBase, methodVO:MethodVO, stage:Stage)\n\t{\n\t\tif (shader.texture) {\n\t\t\tshader.texture.activate(shader);\n\n\t\t\tif (shader.alphaThreshold > 0)\n\t\t\t\tshader.fragmentConstantData[methodVO.fragmentConstantsIndex] = shader.alphaThreshold;\n\t\t} else {\n\t\t\tvar index:number = methodVO.fragmentConstantsIndex;\n\t\t\tvar data:Float32Array = shader.fragmentConstantData;\n\t\t\tdata[index] = this._colorR;\n\t\t\tdata[index + 1] = this._colorG;\n\t\t\tdata[index + 2] = this._colorB;\n\t\t\tdata[index + 3] = this._alpha;\n\t\t}\n\t}\n\n\tpublic iSetRenderState(shader:ShaderBase, methodVO:MethodVO, renderable:RenderableBase, stage:Stage, camera:Camera)\n\t{\n\t\tif (shader.texture)\n\t\t\tshader.texture._setRenderState(renderable, shader);\n\t}\n\n\t/**\n\t * Updates the ambient color data used by the render state.\n\t */\n\tprivate updateColor()\n\t{\n\t\tthis._colorR = ((this._color >> 16) & 0xff)/0xff*this._ambient;\n\t\tthis._colorG = ((this._color >> 8) & 0xff)/0xff*this._ambient;\n\t\tthis._colorB = (this._color & 0xff)/0xff*this._ambient;\n\t}\n}\n\nexport = AmbientBasicMethod;",
    "import ShaderBase\t\t\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderBase\");\nimport ShaderRegisterCache\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterCache\");\nimport ShaderRegisterData\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterData\");\nimport ShaderRegisterElement\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterElement\");\n\nimport MethodVO\t\t\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/data/MethodVO\");\nimport AmbientBasicMethod\t\t\t\t= require(\"awayjs-methodmaterials/lib/methods/AmbientBasicMethod\");\n\n/**\n * AmbientEnvMapMethod provides a diffuse shading method that uses a diffuse irradiance environment map to\n * approximate global lighting rather than lights.\n */\nclass AmbientEnvMapMethod extends AmbientBasicMethod\n{\n\t/**\n\t * Creates a new <code>AmbientEnvMapMethod</code> object.\n\t *\n\t * @param envMap The cube environment map to use for the ambient lighting.\n\t */\n\tconstructor()\n\t{\n\t\tsuper();\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitVO(shader:ShaderBase, methodVO:MethodVO)\n\t{\n\t\tmethodVO.needsNormals = true;\n\t}\n\t\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentCode(shader:ShaderBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, regCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\treturn shader.texture._iGetFragmentCode(shader, targetReg, regCache, sharedRegisters, sharedRegisters.normalFragment);\n\t}\n}\n\nexport = AmbientEnvMapMethod;",
    "import Camera\t\t\t\t\t\t\t= require(\"awayjs-display/lib/entities/Camera\");\n\nimport Stage\t\t\t\t\t\t\t= require(\"awayjs-stagegl/lib/base/Stage\");\n\nimport RenderableBase\t\t\t\t\t= require(\"awayjs-renderergl/lib/renderables/RenderableBase\");\nimport ShaderBase\t\t\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderBase\");\nimport ShaderRegisterCache\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterCache\");\nimport ShaderRegisterData\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterData\");\nimport ShaderRegisterElement\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterElement\");\n\nimport MethodVO\t\t\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/data/MethodVO\");\nimport ShadingMethodBase\t\t\t\t= require(\"awayjs-methodmaterials/lib/methods/ShadingMethodBase\");\n\n/**\n * AmbientBasicMethod provides the default shading method for uniform ambient lighting.\n */\nclass CurveBasicMethod extends ShadingMethodBase\n{\n\tprivate _color:number = 0xffffff;\n\tprivate _alpha:number = 1;\n\n\tprivate _colorR:number = 1;\n\tprivate _colorG:number = 1;\n\tprivate _colorB:number = 1;\n\n\tprivate _ambient:number = 1;\n\n\t/**\n\t * Creates a new AmbientBasicMethod object.\n\t */\n\tconstructor()\n\t{\n\t\tsuper();\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitVO(shader:ShaderBase, methodVO:MethodVO)\n\t{\n\t\tif (shader.texture)\n\t\t\tshader.uvDependencies++;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitConstants(shader:ShaderBase, methodVO:MethodVO)\n\t{\n\t\tif (!shader.texture) {\n\t\t\tthis._color = shader.color;\n\t\t\tthis.updateColor();\n\t\t}\n\t}\n\n\t/**\n\t * The strength of the ambient reflection of the surface.\n\t */\n\tpublic get ambient():number\n\t{\n\t\treturn this._ambient;\n\t}\n\n\tpublic set ambient(value:number)\n\t{\n\t\tif (this._ambient == value)\n\t\t\treturn;\n\n\t\tthis._ambient = value;\n\n\t\tthis.updateColor();\n\t}\n\n\t/**\n\t * The alpha component of the surface.\n\t */\n\tpublic get alpha():number\n\t{\n\t\treturn this._alpha;\n\t}\n\n\tpublic set alpha(value:number)\n\t{\n\t\tif (this._alpha == value)\n\t\t\treturn;\n\n\t\tthis._alpha = value;\n\n\t\tthis.updateColor();\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic copyFrom(method:ShadingMethodBase)\n\t{\n\t\tvar m:any = method;\n\t\tvar b:CurveBasicMethod = <CurveBasicMethod> m;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n    /*\n    public iGeVertexCode(shader:ShaderBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string {\n        var code:string = \"\";\n        code = \"mov \" + sharedRegisters.uvVarying + \" \" + registerCache.uv +  \" \\n\";\n    }*/\n    public iGetFragmentCode(shader:ShaderBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = \"\";\n\t\tvar ambientInputRegister:ShaderRegisterElement;\n\n\t\tif (shader.texture) {\n\t\t\tcode += shader.texture._iGetFragmentCode(shader, targetReg, registerCache, sharedRegisters, sharedRegisters.uvVarying);\n\n\t\t\tif (shader.alphaThreshold > 0) {\n\t\t\t\tvar cutOffReg:ShaderRegisterElement = registerCache.getFreeFragmentConstant();\n\t\t\t\tmethodVO.fragmentConstantsIndex = cutOffReg.index*4;\n\n\t\t\t\tcode += \"sub \" + targetReg + \".w, \" + targetReg + \".w, \" + cutOffReg + \".x\\n\" +\n\t\t\t\t\t\"kil \" + targetReg + \".w\\n\" +\n\t\t\t\t\t\"add \" + targetReg + \".w, \" + targetReg + \".w, \" + cutOffReg + \".x\\n\";\n\t\t\t}\n\n\t\t} else {\n\t\t\tambientInputRegister = registerCache.getFreeFragmentConstant();\n\t\t\tmethodVO.fragmentConstantsIndex = ambientInputRegister.index*4;\n\n\t\t\tcode += \"mov \" + targetReg + \", \" + ambientInputRegister + \"\\n\";\n\t\t}\n        code = \"mov \" + targetReg + \", \" + sharedRegisters.uvVarying + \"\\n\";\n\t\treturn code;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iActivate(shader:ShaderBase, methodVO:MethodVO, stage:Stage)\n\t{\n\t\tif (shader.texture) {\n\t\t\tshader.texture.activate(shader);\n\n\t\t\tif (shader.alphaThreshold > 0)\n\t\t\t\tshader.fragmentConstantData[methodVO.fragmentConstantsIndex] = shader.alphaThreshold;\n\t\t} else {\n\t\t\tvar index:number = methodVO.fragmentConstantsIndex;\n\t\t\tvar data:Float32Array = shader.fragmentConstantData;\n\t\t\tdata[index] = this._colorR;\n\t\t\tdata[index + 1] = this._colorG;\n\t\t\tdata[index + 2] = this._colorB;\n\t\t\tdata[index + 3] = this._alpha;\n\t\t}\n\t}\n\n\tpublic iSetRenderState(shader:ShaderBase, methodVO:MethodVO, renderable:RenderableBase, stage:Stage, camera:Camera)\n\t{\n\t\tif (shader.texture)\n\t\t\tmethodVO.textureVO._setRenderState(renderable, shader);\n\t}\n\n\t/**\n\t * Updates the ambient color data used by the render state.\n\t */\n\tprivate updateColor()\n\t{\n\t\tthis._colorR = ((this._color >> 16) & 0xff)/0xff*this._ambient;\n\t\tthis._colorG = ((this._color >> 8) & 0xff)/0xff*this._ambient;\n\t\tthis._colorB = (this._color & 0xff)/0xff*this._ambient;\n\t}\n}\nexport = CurveBasicMethod;",
    "import Camera\t\t\t\t\t\t\t= require(\"awayjs-display/lib/entities/Camera\");\nimport TextureBase\t\t\t\t\t\t= require(\"awayjs-display/lib/textures/TextureBase\");\n\nimport Stage\t\t\t\t\t\t\t= require(\"awayjs-stagegl/lib/base/Stage\");\n\nimport RenderableBase\t\t\t\t\t= require(\"awayjs-renderergl/lib/renderables/RenderableBase\");\nimport LightingShader\t\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/LightingShader\");\nimport ShaderRegisterCache\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterCache\");\nimport ShaderRegisterData\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterData\");\nimport ShaderRegisterElement\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterElement\");\n\nimport MethodVO\t\t\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/data/MethodVO\");\nimport ShadingMethodBase\t\t\t\t= require(\"awayjs-methodmaterials/lib/methods/ShadingMethodBase\");\nimport LightingMethodBase\t\t\t\t= require(\"awayjs-methodmaterials/lib/methods/LightingMethodBase\");\n\n/**\n * DiffuseBasicMethod provides the default shading method for Lambert (dot3) diffuse lighting.\n */\nclass DiffuseBasicMethod extends LightingMethodBase\n{\n\tprivate _multiply:boolean = true;\n\n\tpublic _pTotalLightColorReg:ShaderRegisterElement;\n\n\tpublic _texture:TextureBase;\n\tprivate _diffuseColor:number = 0xffffff;\n\tprivate _ambientColor:number = 0xffffff;\n\tprivate _diffuseR:number = 1;\n\tprivate _diffuseG:number = 1;\n\tprivate _diffuseB:number = 1;\n\tprivate _ambientR:number = 1;\n\tprivate _ambientG:number = 1;\n\tprivate _ambientB:number = 1;\n\n\tpublic _pIsFirstLight:boolean;\n\n\t/**\n\t * Creates a new DiffuseBasicMethod object.\n\t */\n\tconstructor()\n\t{\n\t\tsuper();\n\t}\n\n\tpublic iIsUsed(shader:LightingShader):boolean\n\t{\n\t\tif (!shader.numLights)\n\t\t\treturn false;\n\n\t\treturn true;\n\t}\n\n\t/**\n\t * Set internally if diffuse color component multiplies or replaces the ambient color\n\t */\n\tpublic get multiply():boolean\n\t{\n\t\treturn this._multiply;\n\t}\n\n\tpublic set multiply(value:boolean)\n\t{\n\t\tif (this._multiply == value)\n\t\t\treturn;\n\n\t\tthis._multiply = value;\n\n\t\tthis.iInvalidateShaderProgram();\n\t}\n\n\tpublic iInitVO(shader:LightingShader, methodVO:MethodVO)\n\t{\n\t\tif (this._texture) {\n\t\t\tmethodVO.textureVO = shader.getTextureVO(this._texture);\n\t\t\tshader.uvDependencies++;\n\t\t} else if (methodVO.textureVO) {\n\t\t\tmethodVO.textureVO.dispose();\n\t\t\tmethodVO.textureVO = null;\n\t\t}\n\n\t\tif (shader.numLights > 0) {\n\t\t\tshader.usesCommonData = true;\n\t\t\tmethodVO.needsNormals = true;\n\t\t}\n\t}\n\n\t/**\n\t * The color of the diffuse reflection when not using a texture.\n\t */\n\tpublic get diffuseColor():number\n\t{\n\t\treturn this._diffuseColor;\n\t}\n\n\tpublic set diffuseColor(value:number)\n\t{\n\t\tif (this._diffuseColor == value)\n\t\t\treturn;\n\n\t\tthis._diffuseColor = value;\n\n\t\tthis.updateDiffuse();\n\t}\n\n\t/**\n\t * The color of the ambient reflection\n\t */\n\tpublic get ambientColor():number\n\t{\n\t\treturn this._ambientColor;\n\t}\n\n\tpublic set ambientColor(value:number)\n\t{\n\t\tif (this._ambientColor == value)\n\t\t\treturn;\n\n\t\tthis._ambientColor = value;\n\n\t\tthis.updateAmbient();\n\t}\n\n\n\t/**\n\t * The bitmapData to use to define the diffuse reflection color per texel.\n\t */\n\tpublic get texture():TextureBase\n\t{\n\t\treturn this._texture;\n\t}\n\n\tpublic set texture(value:TextureBase)\n\t{\n\t\tif (this._texture == value)\n\t\t\treturn;\n\n\t\tif (this._texture)\n\t\t\tthis.iRemoveTexture(this._texture);\n\n\t\tthis._texture = value;\n\n\t\tif (this._texture)\n\t\t\tthis.iAddTexture(this._texture);\n\n\t\tthis.iInvalidateShaderProgram();\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic dispose()\n\t{\n\t\tthis._texture = null;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic copyFrom(method:ShadingMethodBase)\n\t{\n\t\tvar diff:DiffuseBasicMethod = <DiffuseBasicMethod> method;\n\n\t\tthis.texture = diff.texture;\n\t\tthis.multiply = diff.multiply;\n\t\tthis.diffuseColor = diff.diffuseColor;\n\t\tthis.ambientColor = diff.ambientColor;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iCleanCompilationData()\n\t{\n\t\tsuper.iCleanCompilationData();\n\n\t\tthis._pTotalLightColorReg = null;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentPreLightingCode(shader:LightingShader, methodVO:MethodVO, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = \"\";\n\n\t\tthis._pIsFirstLight = true;\n\n\t\tregisterCache.addFragmentTempUsages(this._pTotalLightColorReg = registerCache.getFreeFragmentVectorTemp(), 1);\n\n\t\treturn code;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentCodePerLight(shader:LightingShader, methodVO:MethodVO, lightDirReg:ShaderRegisterElement, lightColReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = \"\";\n\t\tvar t:ShaderRegisterElement;\n\n\t\t// write in temporary if not first light, so we can add to total diffuse colour\n\t\tif (this._pIsFirstLight) {\n\t\t\tt = this._pTotalLightColorReg;\n\t\t} else {\n\t\t\tt = registerCache.getFreeFragmentVectorTemp();\n\t\t\tregisterCache.addFragmentTempUsages(t, 1);\n\t\t}\n\n\t\tcode += \"dp3 \" + t + \".x, \" + lightDirReg + \", \" + sharedRegisters.normalFragment + \"\\n\" +\n\t\t\t\t\"max \" + t + \".w, \" + t + \".x, \" + sharedRegisters.commons + \".y\\n\";\n\n\t\tif (shader.usesLightFallOff)\n\t\t\tcode += \"mul \" + t + \".w, \" + t + \".w, \" + lightDirReg + \".w\\n\";\n\n\t\tif (this._iModulateMethod != null)\n\t\t\tcode += this._iModulateMethod(shader, methodVO, t, registerCache, sharedRegisters);\n\n\t\tcode += \"mul \" + t + \", \" + t + \".w, \" + lightColReg + \"\\n\";\n\n\t\tif (!this._pIsFirstLight) {\n\t\t\tcode += \"add \" + this._pTotalLightColorReg + \".xyz, \" + this._pTotalLightColorReg + \", \" + t + \"\\n\";\n\t\t\tregisterCache.removeFragmentTempUsage(t);\n\t\t}\n\n\t\tthis._pIsFirstLight = false;\n\n\t\treturn code;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentCodePerProbe(shader:LightingShader, methodVO:MethodVO, cubeMapReg:ShaderRegisterElement, weightRegister:string, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = \"\";\n\t\tvar t:ShaderRegisterElement;\n\n\t\t// write in temporary if not first light, so we can add to total diffuse colour\n\t\tif (this._pIsFirstLight) {\n\t\t\tt = this._pTotalLightColorReg;\n\t\t} else {\n\t\t\tt = registerCache.getFreeFragmentVectorTemp();\n\t\t\tregisterCache.addFragmentTempUsages(t, 1);\n\t\t}\n\n\t\tcode += \"tex \" + t + \", \" + sharedRegisters.normalFragment + \", \" + cubeMapReg + \" <cube,linear,miplinear>\\n\" +\n\t\t\t\t\"mul \" + t + \".xyz, \" + t + \".xyz, \" + weightRegister + \"\\n\";\n\n\t\tif (this._iModulateMethod != null)\n\t\t\tcode += this._iModulateMethod(shader, methodVO, t, registerCache, sharedRegisters);\n\n\t\tif (!this._pIsFirstLight) {\n\t\t\tcode += \"add \" + this._pTotalLightColorReg + \".xyz, \" + this._pTotalLightColorReg + \", \" + t + \"\\n\";\n\t\t\tregisterCache.removeFragmentTempUsage(t);\n\t\t}\n\n\t\tthis._pIsFirstLight = false;\n\n\t\treturn code;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentPostLightingCode(shader:LightingShader, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = \"\";\n\n\t\tvar albedo:ShaderRegisterElement;\n\t\tvar cutOffReg:ShaderRegisterElement;\n\n\t\t// incorporate input from ambient\n\t\tif (sharedRegisters.shadowTarget)\n\t\t\tcode += this.pApplyShadow(shader, methodVO, registerCache, sharedRegisters);\n\n\t\tregisterCache.addFragmentTempUsages(albedo = registerCache.getFreeFragmentVectorTemp(), 1);\n\n\t\tvar ambientColorRegister:ShaderRegisterElement = registerCache.getFreeFragmentConstant();\n\t\tmethodVO.fragmentConstantsIndex = ambientColorRegister.index*4;\n\n\t\tif (this._texture) {\n\t\t\tcode += methodVO.textureVO._iGetFragmentCode(shader, albedo, registerCache, sharedRegisters, sharedRegisters.uvVarying);\n\t\t} else {\n\t\t\tvar diffuseInputRegister:ShaderRegisterElement = registerCache.getFreeFragmentConstant();\n\n\t\t\tcode += \"mov \" + albedo + \", \" + diffuseInputRegister + \"\\n\";\n\t\t}\n\n\t\tcode += \"sat \" + this._pTotalLightColorReg + \", \" + this._pTotalLightColorReg + \"\\n\" +\n\t\t\t\"mul \" + albedo + \".xyz, \" + albedo + \", \" + this._pTotalLightColorReg + \"\\n\";\n\n\t\tif (this._multiply) {\n\t\t\tcode += \"add \" + albedo + \".xyz, \" + albedo + \", \" + ambientColorRegister + \"\\n\" +\n\t\t\t\t\"mul \" + targetReg + \".xyz, \" + targetReg + \", \" + albedo + \"\\n\";\n\t\t} else {\n\t\t\tcode += \"mul \" + targetReg + \".xyz, \" + targetReg + \", \" + ambientColorRegister + \"\\n\" +\n\t\t\t\t\"mul \" + this._pTotalLightColorReg + \".xyz, \" + targetReg + \", \" + this._pTotalLightColorReg + \"\\n\" +\n\t\t\t\t\"sub \" + targetReg + \".xyz, \" + targetReg + \", \" + this._pTotalLightColorReg + \"\\n\" +\n\t\t\t\t\"add \" + targetReg + \".xyz, \" + targetReg + \", \" + albedo + \"\\n\";\n\t\t}\n\n\t\tregisterCache.removeFragmentTempUsage(this._pTotalLightColorReg);\n\t\tregisterCache.removeFragmentTempUsage(albedo);\n\n\t\treturn code;\n\t}\n\n\t/**\n\t * Generate the code that applies the calculated shadow to the diffuse light\n\t * @param methodVO The MethodVO object for which the compilation is currently happening.\n\t * @param regCache The register cache the compiler is currently using for the register management.\n\t */\n\tpublic pApplyShadow(shader:LightingShader, methodVO:MethodVO, regCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\treturn \"mul \" + this._pTotalLightColorReg + \".xyz, \" + this._pTotalLightColorReg + \", \" + sharedRegisters.shadowTarget + \".w\\n\";\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iActivate(shader:LightingShader, methodVO:MethodVO, stage:Stage)\n\t{\n\t\tif (this._texture) {\n\t\t\tmethodVO.textureVO.activate(shader);\n\t\t} else {\n\t\t\tvar index:number = methodVO.fragmentConstantsIndex;\n\t\t\tvar data:Float32Array = shader.fragmentConstantData;\n\t\t\tdata[index + 4] = this._diffuseR;\n\t\t\tdata[index + 5] = this._diffuseG;\n\t\t\tdata[index + 6] = this._diffuseB;\n\t\t\tdata[index + 7] = 1;\n\t\t}\n\t}\n\n\t/**\n\t * Updates the diffuse color data used by the render state.\n\t */\n\tprivate updateDiffuse()\n\t{\n\t\tthis._diffuseR = ((this._diffuseColor >> 16) & 0xff)/0xff;\n\t\tthis._diffuseG = ((this._diffuseColor >> 8) & 0xff)/0xff;\n\t\tthis._diffuseB = (this._diffuseColor & 0xff)/0xff;\n\t}\n\n\t/**\n\t * Updates the ambient color data used by the render state.\n\t */\n\tprivate updateAmbient()\n\t{\n\t\tthis._ambientR = ((this._ambientColor >> 16) & 0xff)/0xff;\n\t\tthis._ambientG = ((this._ambientColor >> 8) & 0xff)/0xff;\n\t\tthis._ambientB = (this._ambientColor & 0xff)/0xff;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iSetRenderState(shader:LightingShader, methodVO:MethodVO, renderable:RenderableBase, stage:Stage, camera:Camera)\n\t{\n\t\tif (this._texture)\n\t\t\tmethodVO.textureVO._setRenderState(renderable, shader);\n\n\t\t//TODO move this to Activate (ambientR/G/B currently calc'd in render state)\n\t\tif (shader.numLights > 0) {\n\t\t\tvar index:number = methodVO.fragmentConstantsIndex;\n\t\t\tvar data:Float32Array = shader.fragmentConstantData;\n\t\t\tdata[index] = shader.ambientR*this._ambientR;\n\t\t\tdata[index + 1] = shader.ambientG*this._ambientG;\n\t\t\tdata[index + 2] = shader.ambientB*this._ambientB;\n\t\t\tdata[index + 3] = 1;\n\t\t}\n\t}\n}\n\nexport = DiffuseBasicMethod;",
    "import Stage\t\t\t\t\t\t\t= require(\"awayjs-stagegl/lib/base/Stage\");\n\nimport LightingShader\t\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/LightingShader\");\nimport ShaderBase\t\t\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderBase\");\nimport ShaderRegisterCache\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterCache\");\nimport ShaderRegisterData\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterData\");\nimport ShaderRegisterElement\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterElement\");\n\nimport MethodVO\t\t\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/data/MethodVO\");\nimport DiffuseBasicMethod\t\t\t\t= require(\"awayjs-methodmaterials/lib/methods/DiffuseBasicMethod\");\nimport DiffuseCompositeMethod\t\t\t= require(\"awayjs-methodmaterials/lib/methods/DiffuseCompositeMethod\");\n\n/**\n * DiffuseCelMethod provides a shading method to add diffuse cel (cartoon) shading.\n */\nclass DiffuseCelMethod extends DiffuseCompositeMethod\n{\n\tprivate _levels:number /*uint*/;\n\tprivate _dataReg:ShaderRegisterElement;\n\tprivate _smoothness:number = .1;\n\n\t/**\n\t * Creates a new DiffuseCelMethod object.\n\t * @param levels The amount of shadow gradations.\n\t * @param baseMethod An optional diffuse method on which the cartoon shading is based. If omitted, DiffuseBasicMethod is used.\n\t */\n\tconstructor(levels:number /*uint*/ = 3, baseMethod:DiffuseBasicMethod = null)\n\t{\n\t\tsuper(null, baseMethod);\n\n\t\tthis.baseMethod._iModulateMethod = (shader:ShaderBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData) => this.clampDiffuse(shader, methodVO, targetReg, registerCache, sharedRegisters);\n\n\t\tthis._levels = levels;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitConstants(shader:LightingShader, methodVO:MethodVO)\n\t{\n\t\tvar data:Float32Array = shader.fragmentConstantData;\n\t\tvar index:number /*int*/ = methodVO.secondaryFragmentConstantsIndex;\n\t\tsuper.iInitConstants(shader, methodVO);\n\t\tdata[index + 1] = 1;\n\t\tdata[index + 2] = 0;\n\t}\n\n\t/**\n\t * The amount of shadow gradations.\n\t */\n\tpublic get levels():number /*uint*/\n\t{\n\t\treturn this._levels;\n\t}\n\n\tpublic set levels(value:number /*uint*/)\n\t{\n\t\tthis._levels = value;\n\t}\n\n\t/**\n\t * The smoothness of the edge between 2 shading levels.\n\t */\n\tpublic get smoothness():number\n\t{\n\t\treturn this._smoothness;\n\t}\n\n\tpublic set smoothness(value:number)\n\t{\n\t\tthis._smoothness = value;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iCleanCompilationData()\n\t{\n\t\tsuper.iCleanCompilationData();\n\t\tthis._dataReg = null;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentPreLightingCode(shader:LightingShader, methodVO:MethodVO, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tthis._dataReg = registerCache.getFreeFragmentConstant();\n\t\tmethodVO.secondaryFragmentConstantsIndex = this._dataReg.index*4;\n\n\t\treturn super.iGetFragmentPreLightingCode(shader, methodVO, registerCache, sharedRegisters);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iActivate(shader:LightingShader, methodVO:MethodVO, stage:Stage)\n\t{\n\t\tsuper.iActivate(shader, methodVO, stage);\n\t\tvar data:Float32Array = shader.fragmentConstantData;\n\t\tvar index:number /*int*/ = methodVO.secondaryFragmentConstantsIndex;\n\t\tdata[index] = this._levels;\n\t\tdata[index + 3] = this._smoothness;\n\t}\n\n\t/**\n\t * Snaps the diffuse shading of the wrapped method to one of the levels.\n\t * @param vo The MethodVO used to compile the current shader.\n\t * @param t The register containing the diffuse strength in the \"w\" component.\n\t * @param regCache The register cache used for the shader compilation.\n\t * @param sharedRegisters The shared register data for this shader.\n\t * @return The AGAL fragment code for the method.\n\t */\n\tprivate clampDiffuse(shader:ShaderBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\treturn \"mul \" + targetReg + \".w, \" + targetReg + \".w, \" + this._dataReg + \".x\\n\" +\n\t\t\t\"frc \" + targetReg + \".z, \" + targetReg + \".w\\n\" +\n\t\t\t\"sub \" + targetReg + \".y, \" + targetReg + \".w, \" + targetReg + \".z\\n\" +\n\t\t\t\"mov \" + targetReg + \".x, \" + this._dataReg + \".x\\n\" +\n\t\t\t\"sub \" + targetReg + \".x, \" + targetReg + \".x, \" + this._dataReg + \".y\\n\" +\n\t\t\t\"rcp \" + targetReg + \".x,\" + targetReg + \".x\\n\" +\n\t\t\t\"mul \" + targetReg + \".w, \" + targetReg + \".y, \" + targetReg + \".x\\n\" +\n\n\t\t\t// previous clamped strength\n\t\t\t\"sub \" + targetReg + \".y, \" + targetReg + \".w, \" + targetReg + \".x\\n\" +\n\n\t\t\t// fract/epsilon (so 0 - epsilon will become 0 - 1)\n\t\t\t\"div \" + targetReg + \".z, \" + targetReg + \".z, \" + this._dataReg + \".w\\n\" +\n\t\t\t\"sat \" + targetReg + \".z, \" + targetReg + \".z\\n\" +\n\n\t\t\t\"mul \" + targetReg + \".w, \" + targetReg + \".w, \" + targetReg + \".z\\n\" +\n\t\t\t// 1-z\n\t\t\t\"sub \" + targetReg + \".z, \" + this._dataReg + \".y, \" + targetReg + \".z\\n\" +\n\t\t\t\"mul \" + targetReg + \".y, \" + targetReg + \".y, \" + targetReg + \".z\\n\" +\n\t\t\t\"add \" + targetReg + \".w, \" + targetReg + \".w, \" + targetReg + \".y\\n\" +\n\t\t\t\"sat \" + targetReg + \".w, \" + targetReg + \".w\\n\";\n\t}\n}\n\nexport = DiffuseCelMethod;",
    "import Camera\t\t\t\t\t\t\t= require(\"awayjs-display/lib/entities/Camera\");\nimport TextureBase\t\t\t\t\t\t= require(\"awayjs-display/lib/textures/TextureBase\");\nimport IRenderOwner\t\t\t\t\t\t= require(\"awayjs-display/lib/base/IRenderOwner\");\n\nimport Stage\t\t\t\t\t\t\t= require(\"awayjs-stagegl/lib/base/Stage\");\n\nimport LightingShader\t\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/LightingShader\");\nimport ShaderBase\t\t\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderBase\");\nimport ShaderRegisterCache\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterCache\");\nimport ShaderRegisterData\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterData\");\nimport ShaderRegisterElement\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterElement\");\nimport ShadingMethodEvent\t\t\t\t= require(\"awayjs-renderergl/lib/events/ShadingMethodEvent\");\nimport RenderableBase\t\t\t\t\t= require(\"awayjs-renderergl/lib/renderables/RenderableBase\");\n\nimport MethodVO\t\t\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/data/MethodVO\");\nimport DiffuseBasicMethod\t\t\t\t= require(\"awayjs-methodmaterials/lib/methods/DiffuseBasicMethod\");\n\n/**\n * DiffuseCompositeMethod provides a base class for diffuse methods that wrap a diffuse method to alter the\n * calculated diffuse reflection strength.\n */\nclass DiffuseCompositeMethod extends DiffuseBasicMethod\n{\n\tpublic pBaseMethod:DiffuseBasicMethod;\n\n\tprivate _onShaderInvalidatedDelegate:Function;\n\n\t/**\n\t * Creates a new <code>DiffuseCompositeMethod</code> object.\n\t *\n\t * @param modulateMethod The method which will add the code to alter the base method's strength. It needs to have the signature clampDiffuse(t:ShaderRegisterElement, regCache:ShaderRegisterCache):string, in which t.w will contain the diffuse strength.\n\t * @param baseMethod The base diffuse method on which this method's shading is based.\n\t */\n\tconstructor(modulateMethod:(shader:ShaderBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData) => string, baseMethod:DiffuseBasicMethod = null)\n\t{\n\t\tsuper();\n\n\t\tthis._onShaderInvalidatedDelegate = (event:ShadingMethodEvent) => this.onShaderInvalidated(event);\n\n\t\tthis.pBaseMethod = baseMethod || new DiffuseBasicMethod();\n\t\tthis.pBaseMethod._iModulateMethod = modulateMethod;\n\t\tthis.pBaseMethod.addEventListener(ShadingMethodEvent.SHADER_INVALIDATED, this._onShaderInvalidatedDelegate);\n\t}\n\n\t/**\n\t * The base diffuse method on which this method's shading is based.\n\t */\n\tpublic get baseMethod():DiffuseBasicMethod\n\t{\n\t\treturn this.pBaseMethod;\n\t}\n\n\tpublic set baseMethod(value:DiffuseBasicMethod)\n\t{\n\t\tif (this.pBaseMethod == value)\n\t\t\treturn;\n\n\t\tthis.pBaseMethod.removeEventListener(ShadingMethodEvent.SHADER_INVALIDATED, this._onShaderInvalidatedDelegate);\n\t\tthis.pBaseMethod = value;\n\t\tthis.pBaseMethod.addEventListener(ShadingMethodEvent.SHADER_INVALIDATED, this._onShaderInvalidatedDelegate);\n\t\tthis.iInvalidateShaderProgram();\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitVO(shader:LightingShader, methodVO:MethodVO)\n\t{\n\t\tthis.pBaseMethod.iInitVO(shader, methodVO);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitConstants(shader:LightingShader, methodVO:MethodVO)\n\t{\n\t\tthis.pBaseMethod.iInitConstants(shader, methodVO);\n\t}\n\n\tpublic iAddOwner(owner:IRenderOwner)\n\t{\n\t\tsuper.iAddOwner(owner);\n\n\t\tthis.pBaseMethod.iAddOwner(owner);\n\t}\n\n\tpublic iRemoveOwner(owner:IRenderOwner)\n\t{\n\t\tsuper.iRemoveOwner(owner);\n\n\t\tthis.pBaseMethod.iRemoveOwner(owner);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic dispose()\n\t{\n\t\tthis.pBaseMethod.removeEventListener(ShadingMethodEvent.SHADER_INVALIDATED, this._onShaderInvalidatedDelegate);\n\t\tthis.pBaseMethod.dispose();\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic get texture():TextureBase\n\t{\n\t\treturn this.pBaseMethod.texture;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic set texture(value:TextureBase)\n\t{\n\t\tthis.pBaseMethod.texture = value;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic get diffuseColor():number\n\t{\n\t\treturn this.pBaseMethod.diffuseColor;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic set diffuseColor(value:number)\n\t{\n\t\tthis.pBaseMethod.diffuseColor = value;\n\t}\n\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic get ambientColor():number\n\t{\n\t\treturn this.pBaseMethod.ambientColor;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic set ambientColor(value:number)\n\t{\n\t\tthis.pBaseMethod.ambientColor = value;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentPreLightingCode(shader:LightingShader, methodVO:MethodVO, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\treturn this.pBaseMethod.iGetFragmentPreLightingCode(shader, methodVO, registerCache, sharedRegisters);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentCodePerLight(shader:LightingShader, methodVO:MethodVO, lightDirReg:ShaderRegisterElement, lightColReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = this.pBaseMethod.iGetFragmentCodePerLight(shader, methodVO, lightDirReg, lightColReg, registerCache, sharedRegisters);\n\t\tthis._pTotalLightColorReg = this.pBaseMethod._pTotalLightColorReg;\n\t\treturn code;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentCodePerProbe(shader:LightingShader, methodVO:MethodVO, cubeMapReg:ShaderRegisterElement, weightRegister:string, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = this.pBaseMethod.iGetFragmentCodePerProbe(shader, methodVO, cubeMapReg, weightRegister, registerCache, sharedRegisters);\n\t\tthis._pTotalLightColorReg = this.pBaseMethod._pTotalLightColorReg;\n\t\treturn code;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iActivate(shader:LightingShader, methodVO:MethodVO, stage:Stage)\n\t{\n\t\tthis.pBaseMethod.iActivate(shader, methodVO, stage);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iSetRenderState(shader:LightingShader, methodVO:MethodVO, renderable:RenderableBase, stage:Stage, camera:Camera)\n\t{\n\t\tthis.pBaseMethod.iSetRenderState(shader, methodVO, renderable, stage, camera);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iDeactivate(shader:LightingShader, methodVO:MethodVO, stage:Stage)\n\t{\n\t\tthis.pBaseMethod.iDeactivate(shader, methodVO, stage);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetVertexCode(shader:ShaderBase, methodVO:MethodVO, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\treturn this.pBaseMethod.iGetVertexCode(shader, methodVO, registerCache, sharedRegisters);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentPostLightingCode(shader:LightingShader, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\treturn this.pBaseMethod.iGetFragmentPostLightingCode(shader, methodVO, targetReg, registerCache, sharedRegisters);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iReset()\n\t{\n\t\tthis.pBaseMethod.iReset();\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iCleanCompilationData()\n\t{\n\t\tsuper.iCleanCompilationData();\n\t\tthis.pBaseMethod.iCleanCompilationData();\n\t}\n\n\t/**\n\t * Called when the base method's shader code is invalidated.\n\t */\n\tprivate onShaderInvalidated(event:ShadingMethodEvent)\n\t{\n\t\tthis.iInvalidateShaderProgram();\n\t}\n}\n\nexport = DiffuseCompositeMethod;",
    "import RenderableBase\t\t\t\t\t= require(\"awayjs-renderergl/lib/renderables/RenderableBase\");\nimport LightingShader\t\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/LightingShader\");\nimport ShaderBase\t\t\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderBase\");\nimport ShaderRegisterCache\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterCache\");\nimport ShaderRegisterData\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterData\");\nimport ShaderRegisterElement\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterElement\");\n\nimport MethodVO\t\t\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/data/MethodVO\");\nimport DiffuseBasicMethod\t\t\t\t= require(\"awayjs-methodmaterials/lib/methods/DiffuseBasicMethod\");\n\n/**\n * DiffuseDepthMethod provides a debug method to visualise depth maps\n */\nclass DiffuseDepthMethod extends DiffuseBasicMethod\n{\n\t/**\n\t * Creates a new DiffuseBasicMethod object.\n\t */\n\tconstructor()\n\t{\n\t\tsuper();\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitConstants(shader:ShaderBase, methodVO:MethodVO)\n\t{\n\t\tvar data:Float32Array = shader.fragmentConstantData;\n\t\tvar index:number /*int*/ = methodVO.fragmentConstantsIndex;\n\t\tdata[index] = 1.0;\n\t\tdata[index + 1] = 1/255.0;\n\t\tdata[index + 2] = 1/65025.0;\n\t\tdata[index + 3] = 1/16581375.0;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentPostLightingCode(shader:LightingShader, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = \"\";\n\t\tvar temp:ShaderRegisterElement;\n\t\tvar decReg:ShaderRegisterElement;\n\n\t\tif (!this._texture)\n\t\t\tthrow new Error(\"DiffuseDepthMethod requires texture!\");\n\n\t\t// incorporate input from ambient\n\t\tif (shader.numLights > 0) {\n\t\t\tif (sharedRegisters.shadowTarget)\n\t\t\t\tcode += \"mul \" + this._pTotalLightColorReg + \".xyz, \" + this._pTotalLightColorReg + \".xyz, \" + sharedRegisters.shadowTarget + \".w\\n\";\n\t\t\tcode += \"add \" + targetReg + \".xyz, \" + this._pTotalLightColorReg + \".xyz, \" + targetReg + \".xyz\\n\" +\n\t\t\t\t\"sat \" + targetReg + \".xyz, \" + targetReg + \".xyz\\n\";\n\t\t\tregisterCache.removeFragmentTempUsage(this._pTotalLightColorReg);\n\t\t\tregisterCache.addFragmentTempUsages(temp = registerCache.getFreeFragmentVectorTemp(), 1);\n\t\t} else {\n\t\t\ttemp = targetReg;\n\t\t}\n\n\t\tdecReg = registerCache.getFreeFragmentConstant();\n\t\tmethodVO.fragmentConstantsIndex = decReg.index*4;\n\n\t\tcode += methodVO.textureVO._iGetFragmentCode(shader, temp, registerCache, sharedRegisters, sharedRegisters.uvVarying) +\n\t\t\t\"dp4 \" + temp + \".x, \" + temp + \", \" + decReg + \"\\n\" +\n\t\t\t\"mov \" + temp + \".yz, \" + temp + \".xx\t\t\t\\n\" +\n\t\t\t\"mov \" + temp + \".w, \" + decReg + \".x\\n\" +\n\t\t\t\"sub \" + temp + \".xyz, \" + decReg + \".xxx, \" + temp + \".xyz\\n\";\n\n\t\tif (shader.numLights == 0)\n\t\t\treturn code;\n\n\t\tcode += \"mul \" + targetReg + \".xyz, \" + temp + \".xyz, \" + targetReg + \".xyz\\n\" +\n\t\t\t\"mov \" + targetReg + \".w, \" + temp + \".w\\n\";\n\n\t\tif (shader.numLights > 0)\n\t\t\tregisterCache.removeFragmentTempUsage(temp);\n\n\t\treturn code;\n\t}\n}\n\nexport = DiffuseDepthMethod;",
    "import Camera\t\t\t\t\t\t\t= require(\"awayjs-display/lib/entities/Camera\");\nimport TextureBase\t\t\t\t\t\t= require(\"awayjs-display/lib/textures/TextureBase\");\n\nimport Stage\t\t\t\t\t\t\t= require(\"awayjs-stagegl/lib/base/Stage\");\n\nimport RenderableBase\t\t\t\t\t= require(\"awayjs-renderergl/lib/renderables/RenderableBase\");\nimport LightingShader\t\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/LightingShader\");\nimport ShaderRegisterCache\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterCache\");\nimport ShaderRegisterData\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterData\");\nimport ShaderRegisterElement\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterElement\");\n\nimport MethodVO\t\t\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/data/MethodVO\");\nimport DiffuseBasicMethod\t\t\t\t= require(\"awayjs-methodmaterials/lib/methods/DiffuseBasicMethod\");\n\n/**\n * DiffuseGradientMethod is an alternative to DiffuseBasicMethod in which the shading can be modulated with a gradient\n * to introduce color-tinted shading as opposed to the single-channel diffuse strength. This can be used as a crude\n * approximation to subsurface scattering (for instance, the mid-range shading for skin can be tinted red to similate\n * scattered light within the skin attributing to the final colour)\n */\nclass DiffuseGradientMethod extends DiffuseBasicMethod\n{\n\tprivate _gradient:TextureBase;\n\n\t/**\n\t * Creates a new DiffuseGradientMethod object.\n\t * @param gradient A texture that contains the light colour based on the angle. This can be used to change\n\t * the light colour due to subsurface scattering when the surface faces away from the light.\n\t */\n\tconstructor(gradient:TextureBase)\n\t{\n\t\tsuper();\n\n\t\tthis._gradient = gradient;\n\n\t\tif (this._gradient)\n\t\t\tthis.iAddTexture(this._gradient);\n\t}\n\n\tpublic iInitVO(shader:LightingShader, methodVO:MethodVO)\n\t{\n\t\tsuper.iInitVO(shader, methodVO);\n\n\t\tmethodVO.secondaryTextureVO = shader.getTextureVO(this._gradient);\n\t}\n\n\t/**\n\t * A texture that contains the light colour based on the angle. This can be used to change the light colour\n\t * due to subsurface scattering when the surface faces away from the light.\n\t */\n\tpublic get gradient():TextureBase\n\t{\n\t\treturn this._gradient;\n\t}\n\n\tpublic set gradient(value:TextureBase)\n\t{\n\t\tif (this._gradient == value)\n\t\t\treturn;\n\n\t\tif (this._gradient)\n\t\t\tthis.iRemoveTexture(this._gradient);\n\n\t\tthis._gradient = value;\n\n\t\tif (this._gradient)\n\t\t\tthis.iAddTexture(this._gradient);\n\n\t\tthis.iInvalidateShaderProgram();\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iCleanCompilationData()\n\t{\n\t\tsuper.iCleanCompilationData();\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentPreLightingCode(shader:LightingShader, methodVO:MethodVO, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = super.iGetFragmentPreLightingCode(shader, methodVO, registerCache, sharedRegisters);\n\t\tthis._pIsFirstLight = true;\n\n\t\treturn code;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentCodePerLight(shader:LightingShader, methodVO:MethodVO, lightDirReg:ShaderRegisterElement, lightColReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = \"\";\n\t\tvar t:ShaderRegisterElement;\n\n\t\t// write in temporary if not first light, so we can add to total diffuse colour\n\t\tif (this._pIsFirstLight)\n\t\t\tt = this._pTotalLightColorReg;\n\t\telse {\n\t\t\tt = registerCache.getFreeFragmentVectorTemp();\n\t\t\tregisterCache.addFragmentTempUsages(t, 1);\n\t\t}\n\n\t\tcode += \"dp3 \" + t + \".w, \" + lightDirReg + \".xyz, \" + sharedRegisters.normalFragment + \".xyz\\n\" +\n\t\t\t\"mul \" + t + \".w, \" + t + \".w, \" + sharedRegisters.commons + \".x\\n\" +\n\t\t\t\"add \" + t + \".w, \" + t + \".w, \" + sharedRegisters.commons + \".x\\n\" +\n\t\t\t\"mul \" + t + \".xyz, \" + t + \".w, \" + lightDirReg + \".w\\n\";\n\n\t\tif (this._iModulateMethod != null)\n\t\t\tcode += this._iModulateMethod(shader, methodVO, t, registerCache, sharedRegisters);\n\n\t\tcode += methodVO.secondaryTextureVO._iGetFragmentCode(shader, t, registerCache, sharedRegisters, t) +\n\t\t\t//\t\t\t\t\t\"mul \" + t + \".xyz, \" + t + \".xyz, \" + t + \".w\\n\" +\n\t\t\t\"mul \" + t + \".xyz, \" + t + \".xyz, \" + lightColReg + \".xyz\\n\";\n\n\t\tif (!this._pIsFirstLight) {\n\t\t\tcode += \"add \" + this._pTotalLightColorReg + \".xyz, \" + this._pTotalLightColorReg + \".xyz, \" + t + \".xyz\\n\";\n\t\t\tregisterCache.removeFragmentTempUsage(t);\n\t\t}\n\n\t\tthis._pIsFirstLight = false;\n\n\t\treturn code;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic pApplyShadow(shader:LightingShader, methodVO:MethodVO, regCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar t:ShaderRegisterElement = regCache.getFreeFragmentVectorTemp();\n\n\t\treturn \"mov \" + t + \", \" + sharedRegisters.shadowTarget + \".wwww\\n\" +\n\t\t\tmethodVO.secondaryTextureVO._iGetFragmentCode(shader, t, regCache, sharedRegisters, sharedRegisters.uvVarying) +\n\t\t\t\"mul \" + this._pTotalLightColorReg + \".xyz, \" + this._pTotalLightColorReg + \", \" + t + \"\\n\";\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iActivate(shader:LightingShader, methodVO:MethodVO, stage:Stage)\n\t{\n\t\tsuper.iActivate(shader, methodVO, stage);\n\n\t\tmethodVO.secondaryTextureVO.activate(shader);\n\t}\n\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iSetRenderState(shader:LightingShader, methodVO:MethodVO, renderable:RenderableBase, stage:Stage, camera:Camera)\n\t{\n\t\tsuper.iSetRenderState(shader, methodVO, renderable, stage, camera);\n\n\t\tif (shader.numLights > 0)\n\t\t\tmethodVO.secondaryTextureVO._setRenderState(renderable, shader);\n\t}\n}\n\nexport = DiffuseGradientMethod;",
    "import Camera\t\t\t\t\t\t\t= require(\"awayjs-display/lib/entities/Camera\");\nimport TextureBase\t\t\t\t\t\t= require(\"awayjs-display/lib/textures/TextureBase\");\n\nimport Stage\t\t\t\t\t\t\t= require(\"awayjs-stagegl/lib/base/Stage\");\n\nimport RenderableBase\t\t\t\t\t= require(\"awayjs-renderergl/lib/renderables/RenderableBase\");\nimport LightingShader\t\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/LightingShader\");\nimport ShaderRegisterCache\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterCache\");\nimport ShaderRegisterData\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterData\");\nimport ShaderRegisterElement\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterElement\");\n\nimport MethodVO\t\t\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/data/MethodVO\");\nimport DiffuseBasicMethod\t\t\t\t= require(\"awayjs-methodmaterials/lib/methods/DiffuseBasicMethod\");\nimport DiffuseCompositeMethod\t\t\t= require(\"awayjs-methodmaterials/lib/methods/DiffuseCompositeMethod\");\n\n/**\n * DiffuseLightMapMethod provides a diffuse shading method that uses a light map to modulate the calculated diffuse\n * lighting. It is different from EffectLightMapMethod in that the latter modulates the entire calculated pixel color, rather\n * than only the diffuse lighting value.\n */\nclass DiffuseLightMapMethod extends DiffuseCompositeMethod\n{\n\t/**\n\t * Indicates the light map should be multiplied with the calculated shading result.\n\t * This can be used to add pre-calculated shadows or occlusion.\n\t */\n\tpublic static MULTIPLY:string = \"multiply\";\n\n\t/**\n\t * Indicates the light map should be added into the calculated shading result.\n\t * This can be used to add pre-calculated lighting or global illumination.\n\t */\n\tpublic static ADD:string = \"add\";\n\n\tprivate _lightMap:TextureBase;\n\tprivate _blendMode:string;\n\tprivate _useSecondaryUV:boolean;\n\n\t/**\n\t * Creates a new DiffuseLightMapMethod method.\n\t *\n\t * @param lightMap The texture containing the light map.\n\t * @param blendMode The blend mode with which the light map should be applied to the lighting result.\n\t * @param useSecondaryUV Indicates whether the secondary UV set should be used to map the light map.\n\t * @param baseMethod The diffuse method used to calculate the regular diffuse-based lighting.\n\t */\n\tconstructor(lightMap:TextureBase, blendMode:string = \"multiply\", useSecondaryUV:boolean = false, baseMethod:DiffuseBasicMethod = null)\n\t{\n\t\tsuper(null, baseMethod);\n\n\t\tthis._useSecondaryUV = useSecondaryUV;\n\t\tthis._lightMap = lightMap;\n\t\tthis.blendMode = blendMode;\n\n\t\tif (this._lightMap)\n\t\t\tthis.iAddTexture(this._lightMap);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitVO(shader:LightingShader, methodVO:MethodVO)\n\t{\n\t\tmethodVO.secondaryTextureVO = shader.getTextureVO(this._lightMap);\n\n\t\tif (this._useSecondaryUV)\n\t\t\tshader.secondaryUVDependencies++;\n\t\telse\n\t\t\tshader.uvDependencies++;\n\t}\n\n\t/**\n\t * The blend mode with which the light map should be applied to the lighting result.\n\t *\n\t * @see DiffuseLightMapMethod.ADD\n\t * @see DiffuseLightMapMethod.MULTIPLY\n\t */\n\tpublic get blendMode():string\n\t{\n\t\treturn this._blendMode;\n\t}\n\n\tpublic set blendMode(value:string)\n\t{\n\t\tif (value != DiffuseLightMapMethod.ADD && value != DiffuseLightMapMethod.MULTIPLY)\n\t\t\tthrow new Error(\"Unknown blendmode!\");\n\n\t\tif (this._blendMode == value)\n\t\t\treturn;\n\n\t\tthis._blendMode = value;\n\n\t\tthis.iInvalidateShaderProgram();\n\t}\n\n\t/**\n\t * The texture containing the light map data.\n\t */\n\tpublic get lightMap():TextureBase\n\t{\n\t\treturn this._lightMap;\n\t}\n\n\tpublic set lightMap(value:TextureBase)\n\t{\n\t\tif (this._lightMap == value)\n\t\t\treturn;\n\n\t\tif (this._lightMap)\n\t\t\tthis.iRemoveTexture(this._lightMap);\n\n\t\tthis._lightMap = value;\n\n\t\tif (this._lightMap)\n\t\t\tthis.iAddTexture(this._lightMap);\n\n\t\tthis.iInvalidateShaderProgram();\n\t}\n\n\t/**\n\t * Indicates whether the secondary UV set should be used to map the light map.\n\t */\n\tpublic get useSecondaryUV():boolean\n\t{\n\t\treturn this._useSecondaryUV;\n\t}\n\n\tpublic set useSecondaryUV(value:boolean)\n\t{\n\t\tif (this._useSecondaryUV == value)\n\t\t\treturn;\n\n\t\tthis._useSecondaryUV = value;\n\n\t\tthis.iInvalidateShaderProgram();\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentPostLightingCode(shader:LightingShader, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string;\n\t\tvar temp:ShaderRegisterElement = registerCache.getFreeFragmentVectorTemp();\n\n\t\tcode = methodVO.secondaryTextureVO._iGetFragmentCode(shader, temp, registerCache, sharedRegisters, this._useSecondaryUV? sharedRegisters.secondaryUVVarying : sharedRegisters.uvVarying);\n\n\t\tswitch (this._blendMode) {\n\t\t\tcase DiffuseLightMapMethod.MULTIPLY:\n\t\t\t\tcode += \"mul \" + this._pTotalLightColorReg + \", \" + this._pTotalLightColorReg + \", \" + temp + \"\\n\";\n\t\t\t\tbreak;\n\t\t\tcase DiffuseLightMapMethod.ADD:\n\t\t\t\tcode += \"add \" + this._pTotalLightColorReg + \", \" + this._pTotalLightColorReg + \", \" + temp + \"\\n\";\n\t\t\t\tbreak;\n\t\t}\n\n\t\tcode += super.iGetFragmentPostLightingCode(shader, methodVO, targetReg, registerCache, sharedRegisters);\n\n\t\treturn code;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iActivate(shader:LightingShader, methodVO:MethodVO, stage:Stage)\n\t{\n\t\tsuper.iActivate(shader, methodVO, stage);\n\n\t\tmethodVO.secondaryTextureVO.activate(shader);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iSetRenderState(shader:LightingShader, methodVO:MethodVO, renderable:RenderableBase, stage:Stage, camera:Camera)\n\t{\n\t\tsuper.iSetRenderState(shader, methodVO, renderable, stage, camera);\n\n\t\tmethodVO.secondaryTextureVO._setRenderState(renderable, shader);\n\t}\n}\n\nexport = DiffuseLightMapMethod;",
    "import Camera\t\t\t\t\t\t\t= require(\"awayjs-display/lib/entities/Camera\");\n\nimport Stage\t\t\t\t\t\t\t= require(\"awayjs-stagegl/lib/base/Stage\");\n\nimport RenderableBase\t\t\t\t\t= require(\"awayjs-renderergl/lib/renderables/RenderableBase\");\nimport LightingShader\t\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/LightingShader\");\nimport ShaderBase\t\t\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderBase\");\nimport ShaderRegisterCache\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterCache\");\nimport ShaderRegisterData\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterData\");\nimport ShaderRegisterElement\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterElement\");\n\nimport MethodVO\t\t\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/data/MethodVO\");\nimport DiffuseBasicMethod\t\t\t\t= require(\"awayjs-methodmaterials/lib/methods/DiffuseBasicMethod\");\nimport DiffuseCompositeMethod\t\t\t= require(\"awayjs-methodmaterials/lib/methods/DiffuseCompositeMethod\");\nimport SingleObjectDepthPass\t\t\t= require(\"awayjs-methodmaterials/lib/render/passes/SingleObjectDepthPass\");\n\n/**\n * DiffuseSubSurfaceMethod provides a depth map-based diffuse shading method that mimics the scattering of\n * light inside translucent surfaces. It allows light to shine through an object and to soften the diffuse shading.\n * It can be used for candle wax, ice, skin, ...\n */\nclass DiffuseSubSurfaceMethod extends DiffuseCompositeMethod\n{\n\tprivate _depthPass:SingleObjectDepthPass;\n\tprivate _lightProjVarying:ShaderRegisterElement;\n\tprivate _propReg:ShaderRegisterElement;\n\tprivate _scattering:number;\n\tprivate _translucency:number = 1;\n\tprivate _lightColorReg:ShaderRegisterElement;\n\tprivate _scatterColor:number /*uint*/ = 0xffffff;\n\tprivate _colorReg:ShaderRegisterElement;\n\tprivate _decReg:ShaderRegisterElement;\n\tprivate _scatterR:number = 1.0;\n\tprivate _scatterG:number = 1.0;\n\tprivate _scatterB:number = 1.0;\n\tprivate _targetReg:ShaderRegisterElement;\n\t\n\t/**\n\t * Creates a new <code>DiffuseSubSurfaceMethod</code> object.\n\t *\n\t * @param depthMapSize The size of the depth map used.\n\t * @param depthMapOffset The amount by which the rendered object will be inflated, to prevent depth map rounding errors.\n\t * @param baseMethod The diffuse method used to calculate the regular diffuse-based lighting.\n\t */\n\tconstructor(depthMapSize:number /*int*/ = 512, depthMapOffset:number = 15, baseMethod:DiffuseBasicMethod = null)\n\t{\n\t\tsuper(null, baseMethod);\n\n\t\tthis.pBaseMethod._iModulateMethod = (shader:ShaderBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData) => this.scatterLight(shader, methodVO, targetReg, registerCache, sharedRegisters);\n\n\t\t//this._passes = new Array<MaterialPassGLBase>();\n\t\t//this._depthPass = new SingleObjectDepthPass();\n\t\t//this._depthPass.textureSize = depthMapSize;\n\t\t//this._depthPass.polyOffset = depthMapOffset;\n\t\t//this._passes.push(this._depthPass);\n\t\tthis._scattering = 0.2;\n\t\tthis._translucency = 1;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitConstants(shader:LightingShader, methodVO:MethodVO)\n\t{\n\t\tsuper.iInitConstants(shader, methodVO);\n\n\t\tvar data:Float32Array = shader.vertexConstantData;\n\t\tvar index:number /*int*/ = methodVO.secondaryVertexConstantsIndex;\n\t\tdata[index] = .5;\n\t\tdata[index + 1] = -.5;\n\t\tdata[index + 2] = 0;\n\t\tdata[index + 3] = 1;\n\t\t\n\t\tdata = shader.fragmentConstantData;\n\t\tindex = methodVO.secondaryFragmentConstantsIndex;\n\t\tdata[index + 3] = 1.0;\n\t\tdata[index + 4] = 1.0;\n\t\tdata[index + 5] = 1/255;\n\t\tdata[index + 6] = 1/65025;\n\t\tdata[index + 7] = 1/16581375;\n\t\tdata[index + 10] = .5;\n\t\tdata[index + 11] = -.1;\n\t}\n\t\n\tpublic iCleanCompilationData()\n\t{\n\t\tsuper.iCleanCompilationData();\n\n\t\tthis._lightProjVarying = null;\n\t\tthis._propReg = null;\n\t\tthis._lightColorReg = null;\n\t\tthis._colorReg = null;\n\t\tthis._decReg = null;\n\t\tthis._targetReg = null;\n\t}\n\t\n\t/**\n\t * The amount by which the light scatters. It can be used to set the translucent surface's thickness. Use low\n\t * values for skin.\n\t */\n\tpublic get scattering():number\n\t{\n\t\treturn this._scattering;\n\t}\n\t\n\tpublic set scattering(value:number)\n\t{\n\t\tthis._scattering = value;\n\t}\n\t\n\t/**\n\t * The translucency of the object.\n\t */\n\tpublic get translucency():number\n\t{\n\t\treturn this._translucency;\n\t}\n\t\n\tpublic set translucency(value:number)\n\t{\n\t\tthis._translucency = value;\n\t}\n\t\n\t/**\n\t * The colour of the \"insides\" of the object, ie: the colour the light becomes after leaving the object.\n\t */\n\tpublic get scatterColor():number /*uint*/\n\t{\n\t\treturn this._scatterColor;\n\t}\n\t\n\tpublic set scatterColor(scatterColor:number /*uint*/)\n\t{\n\t\tthis._scatterColor = scatterColor;\n\t\tthis._scatterR = ((scatterColor >> 16) & 0xff)/0xff;\n\t\tthis._scatterG = ((scatterColor >> 8) & 0xff)/0xff;\n\t\tthis._scatterB = (scatterColor & 0xff)/0xff;\n\t}\n\t\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetVertexCode(shader:ShaderBase, methodVO:MethodVO, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = super.iGetVertexCode(shader, methodVO, registerCache, sharedRegisters);\n\t\tvar lightProjection:ShaderRegisterElement;\n\t\tvar toTexRegister:ShaderRegisterElement;\n\t\tvar temp:ShaderRegisterElement = registerCache.getFreeVertexVectorTemp();\n\t\t\n\t\ttoTexRegister = registerCache.getFreeVertexConstant();\n\t\tmethodVO.secondaryVertexConstantsIndex = toTexRegister.index*4;\n\n\t\tthis._lightProjVarying = registerCache.getFreeVarying();\n\t\tlightProjection = registerCache.getFreeVertexConstant();\n\t\tregisterCache.getFreeVertexConstant();\n\t\tregisterCache.getFreeVertexConstant();\n\t\tregisterCache.getFreeVertexConstant();\n\t\t\n\t\tcode += \"m44 \" + temp + \", vt0, \" + lightProjection + \"\\n\" +\n\t\t\t\"div \" + temp + \".xyz, \" + temp + \".xyz, \" + temp + \".w\\n\" +\n\t\t\t\"mul \" + temp + \".xy, \" + temp + \".xy, \" + toTexRegister + \".xy\\n\" +\n\t\t\t\"add \" + temp + \".xy, \" + temp + \".xy, \" + toTexRegister + \".xx\\n\" +\n\t\t\t\"mov \" + this._lightProjVarying + \".xyz, \" + temp + \".xyz\\n\" +\n\t\t\t\"mov \" + this._lightProjVarying + \".w, va0.w\\n\";\n\t\t\n\t\treturn code;\n\t}\n\t\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentPreLightingCode(shader:LightingShader, methodVO:MethodVO, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tthis._colorReg = registerCache.getFreeFragmentConstant();\n\t\tthis._decReg = registerCache.getFreeFragmentConstant();\n\t\tthis._propReg = registerCache.getFreeFragmentConstant();\n\t\tmethodVO.secondaryFragmentConstantsIndex = this._colorReg.index*4;\n\t\t\n\t\treturn super.iGetFragmentPreLightingCode(shader, methodVO, registerCache, sharedRegisters);\n\t}\n\t\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentCodePerLight(shader:LightingShader, methodVO:MethodVO, lightDirReg:ShaderRegisterElement, lightColReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tthis._pIsFirstLight = true;\n\t\tthis._lightColorReg = lightColReg;\n\t\treturn super.iGetFragmentCodePerLight(shader, methodVO, lightDirReg, lightColReg, registerCache, sharedRegisters);\n\t}\n\t\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentPostLightingCode(shader:LightingShader, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = super.iGetFragmentPostLightingCode(shader, methodVO, targetReg, registerCache, sharedRegisters);\n\t\tvar temp:ShaderRegisterElement = registerCache.getFreeFragmentVectorTemp();\n\t\t\n\t\tcode += \"mul \" + temp + \".xyz, \" + this._lightColorReg + \".xyz, \" + this._targetReg + \".w\\n\" +\n\t\t\t\"mul \" + temp + \".xyz, \" + temp + \".xyz, \" + this._colorReg + \".xyz\\n\" +\n\t\t\t\"add \" + targetReg + \".xyz, \" + targetReg + \".xyz, \" + temp + \".xyz\\n\";\n\t\t\n\t\tif (this._targetReg != sharedRegisters.viewDirFragment)\n\t\t\tregisterCache.removeFragmentTempUsage(targetReg);\n\t\t\n\t\treturn code;\n\t}\n\t\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iActivate(shader:LightingShader, methodVO:MethodVO, stage:Stage)\n\t{\n\t\tsuper.iActivate(shader, methodVO, stage);\n\n\t\tvar index:number /*int*/ = methodVO.secondaryFragmentConstantsIndex;\n\t\tvar data:Float32Array = shader.fragmentConstantData;\n\t\tdata[index] = this._scatterR;\n\t\tdata[index + 1] = this._scatterG;\n\t\tdata[index + 2] = this._scatterB;\n\t\tdata[index + 8] = this._scattering;\n\t\tdata[index + 9] = this._translucency;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iSetRenderState(shader:ShaderBase, methodVO:MethodVO, renderable:RenderableBase, stage:Stage, camera:Camera)\n\t{\n\t\tmethodVO.secondaryTextureVO = shader.getTextureVO(this._depthPass._iGetDepthMap(renderable));\n\t\tmethodVO.secondaryTextureVO._setRenderState(renderable, shader);\n\n\t\tthis._depthPass._iGetProjection(renderable).copyRawDataTo(shader.vertexConstantData, methodVO.secondaryVertexConstantsIndex + 4, true);\n\t}\n\t\n\t/**\n\t * Generates the code for this method\n\t */\n\tprivate scatterLight(shader:ShaderBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\t// only scatter first light\n\t\tif (!this._pIsFirstLight)\n\t\t\treturn \"\";\n\n\t\tthis._pIsFirstLight = false;\n\n\t\tvar code:string = \"\";\n\n\t\tif (sharedRegisters.viewDirFragment)\n\t\t\tthis._targetReg = sharedRegisters.viewDirFragment;\n\t\telse\n\t\t\tregisterCache.addFragmentTempUsages(this._targetReg = registerCache.getFreeFragmentVectorTemp(), 1);\n\n\t\tvar temp:ShaderRegisterElement = registerCache.getFreeFragmentVectorTemp();\n\n\t\tcode += methodVO.secondaryTextureVO._iGetFragmentCode(shader, temp, registerCache, sharedRegisters, this._lightProjVarying) +\n\t\t\t// reencode RGBA\n\t\t\t\"dp4 \" + targetReg + \".z, \" + temp + \", \" + this._decReg + \"\\n\";\n\t\t// currentDistanceToLight - closestDistanceToLight\n\t\tcode += \"sub \" + targetReg + \".z, \" + this._lightProjVarying + \".z, \" + targetReg + \".z\\n\" +\n\t\t\t\n\t\t\t\"sub \" + targetReg + \".z, \" + this._propReg + \".x, \" + targetReg + \".z\\n\" +\n\t\t\t\"mul \" + targetReg + \".z, \" + this._propReg + \".y, \" + targetReg + \".z\\n\" +\n\t\t\t\"sat \" + targetReg + \".z, \" + targetReg + \".z\\n\" +\n\t\t\t\n\t\t\t// targetReg.x contains dot(lightDir, normal)\n\t\t\t// modulate according to incident light angle (scatter = scatter*(-.5*dot(light, normal) + .5)\n\t\t\t\"neg \" + targetReg + \".y, \" + targetReg + \".x\\n\" +\n\t\t\t\"mul \" + targetReg + \".y, \" + targetReg + \".y, \" + this._propReg + \".z\\n\" +\n\t\t\t\"add \" + targetReg + \".y, \" + targetReg + \".y, \" + this._propReg + \".z\\n\" +\n\t\t\t\"mul \" + this._targetReg + \".w, \" + targetReg + \".z, \" + targetReg + \".y\\n\" +\n\t\t\t\n\t\t\t// blend diffuse: d' = (1-s)*d + s*1\n\t\t\t\"sub \" + targetReg + \".y, \" + this._colorReg + \".w, \" + this._targetReg + \".w\\n\" +\n\t\t\t\"mul \" + targetReg + \".w, \" + targetReg + \".w, \" + targetReg + \".y\\n\";\n\t\t\n\t\treturn code;\n\t}\n}\n\nexport = DiffuseSubSurfaceMethod;",
    "import Stage\t\t\t\t\t\t\t= require(\"awayjs-stagegl/lib/base/Stage\");\n\nimport LightingShader\t\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/LightingShader\");\nimport ShaderRegisterCache\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterCache\");\nimport ShaderRegisterData\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterData\");\nimport ShaderRegisterElement\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterElement\");\n\nimport MethodVO\t\t\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/data/MethodVO\");\nimport DiffuseBasicMethod\t\t\t\t= require(\"awayjs-methodmaterials/lib/methods/DiffuseBasicMethod\");\n\n/**\n * DiffuseWrapMethod is an alternative to DiffuseBasicMethod in which the light is allowed to be \"wrapped around\" the normally dark area, to some extent.\n * It can be used as a crude approximation to Oren-Nayar or simple subsurface scattering.\n */\nclass DiffuseWrapMethod extends DiffuseBasicMethod\n{\n\tprivate _wrapDataRegister:ShaderRegisterElement;\n\tprivate _wrapFactor:number;\n\n\t/**\n\t * Creates a new DiffuseWrapMethod object.\n\t * @param wrapFactor A factor to indicate the amount by which the light is allowed to wrap\n\t */\n\tconstructor(wrapFactor:number = .5)\n\t{\n\t\tsuper();\n\n\t\tthis.wrapFactor = wrapFactor;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iCleanCompilationData()\n\t{\n\t\tsuper.iCleanCompilationData();\n\n\t\tthis._wrapDataRegister = null;\n\t}\n\n\t/**\n\t * A factor to indicate the amount by which the light is allowed to wrap.\n\t */\n\tpublic get wrapFactor():number\n\t{\n\t\treturn this._wrapFactor;\n\t}\n\n\tpublic set wrapFactor(value:number)\n\t{\n\t\tthis._wrapFactor = value;\n\t\tthis._wrapFactor = 1/(value + 1);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentPreLightingCode(shader:LightingShader, methodVO:MethodVO, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = super.iGetFragmentPreLightingCode(shader, methodVO, registerCache, sharedRegisters);\n\t\tthis._pIsFirstLight = true;\n\t\tthis._wrapDataRegister = registerCache.getFreeFragmentConstant();\n\t\tmethodVO.secondaryFragmentConstantsIndex = this._wrapDataRegister.index*4;\n\n\t\treturn code;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentCodePerLight(shader:LightingShader, methodVO:MethodVO, lightDirReg:ShaderRegisterElement, lightColReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = \"\";\n\t\tvar t:ShaderRegisterElement;\n\n\t\t// write in temporary if not first light, so we can add to total diffuse colour\n\t\tif (this._pIsFirstLight) {\n\t\t\tt = this._pTotalLightColorReg;\n\t\t} else {\n\t\t\tt = registerCache.getFreeFragmentVectorTemp();\n\t\t\tregisterCache.addFragmentTempUsages(t, 1);\n\t\t}\n\n\t\tcode += \"dp3 \" + t + \".x, \" + lightDirReg + \".xyz, \" + sharedRegisters.normalFragment + \".xyz\\n\" +\n\t\t\t\"add \" + t + \".y, \" + t + \".x, \" + this._wrapDataRegister + \".x\\n\" +\n\t\t\t\"mul \" + t + \".y, \" + t + \".y, \" + this._wrapDataRegister + \".y\\n\" +\n\t\t\t\"sat \" + t + \".w, \" + t + \".y\\n\" +\n\t\t\t\"mul \" + t + \".xz, \" + t + \".w, \" + lightDirReg + \".wz\\n\";\n\n\t\tif (this._iModulateMethod != null)\n\t\t\tcode += this._iModulateMethod(shader, methodVO, lightDirReg, registerCache, sharedRegisters);\n\n\t\tcode += \"mul \" + t + \", \" + t + \".x, \" + lightColReg + \"\\n\";\n\n\t\tif (!this._pIsFirstLight) {\n\t\t\tcode += \"add \" + this._pTotalLightColorReg + \".xyz, \" + this._pTotalLightColorReg + \".xyz, \" + t + \".xyz\\n\";\n\t\t\tregisterCache.removeFragmentTempUsage(t);\n\t\t}\n\n\t\tthis._pIsFirstLight = false;\n\n\t\treturn code;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iActivate(shader:LightingShader, methodVO:MethodVO, stage:Stage)\n\t{\n\t\tsuper.iActivate(shader, methodVO, stage);\n\n\t\tvar index:number /*int*/ = methodVO.secondaryFragmentConstantsIndex;\n\t\tvar data:Float32Array = shader.fragmentConstantData;\n\t\tdata[index] = this._wrapFactor;\n\t\tdata[index + 1] = 1/(this._wrapFactor + 1);\n\t}\n}\n\nexport = DiffuseWrapMethod;",
    "import Camera\t\t\t\t\t\t\t= require(\"awayjs-display/lib/entities/Camera\");\nimport TextureBase\t\t\t\t\t\t= require(\"awayjs-display/lib/textures/TextureBase\");\n\nimport Stage\t\t\t\t\t\t\t= require(\"awayjs-stagegl/lib/base/Stage\");\n\nimport RenderableBase\t\t\t\t\t= require(\"awayjs-renderergl/lib/renderables/RenderableBase\");\nimport LightingShader\t\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/LightingShader\");\nimport ShaderBase\t\t\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderBase\");\nimport ShaderRegisterCache\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterCache\");\nimport ShaderRegisterData\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterData\");\nimport ShaderRegisterElement\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterElement\");\n\nimport MethodVO\t\t\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/data/MethodVO\");\nimport EffectMethodBase\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/methods/EffectMethodBase\");\n\n/**\n * EffectAlphaMaskMethod allows the use of an additional texture to specify the alpha value of the material. When used\n * with the secondary uv set, it allows for a tiled main texture with independently varying alpha (useful for water\n * etc).\n */\nclass EffectAlphaMaskMethod extends EffectMethodBase\n{\n\tprivate _texture:TextureBase;\n\tprivate _useSecondaryUV:boolean;\n\n\t/**\n\t * Creates a new EffectAlphaMaskMethod object.\n\t *\n\t * @param texture The texture to use as the alpha mask.\n\t * @param useSecondaryUV Indicated whether or not the secondary uv set for the mask. This allows mapping alpha independently.\n\t */\n\tconstructor(texture:TextureBase, useSecondaryUV:boolean = false)\n\t{\n\t\tsuper();\n\n\t\tthis._texture = texture;\n\t\tthis._useSecondaryUV = useSecondaryUV;\n\n\t\tif (this._texture)\n\t\t\tthis.iAddTexture(this._texture);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitVO(shader:ShaderBase, methodVO:MethodVO)\n\t{\n\t\tmethodVO.textureVO = shader.getTextureVO(this._texture);\n\n\t\tif (this._useSecondaryUV)\n\t\t\tshader.secondaryUVDependencies++;\n\t\telse\n\t\t\tshader.uvDependencies++;\n\t}\n\n\t/**\n\t * Indicated whether or not the secondary uv set for the mask. This allows mapping alpha independently, for\n\t * instance to tile the main texture and normal map while providing untiled alpha, for example to define the\n\t * transparency over a tiled water surface.\n\t */\n\tpublic get useSecondaryUV():boolean\n\t{\n\t\treturn this._useSecondaryUV;\n\t}\n\n\tpublic set useSecondaryUV(value:boolean)\n\t{\n\t\tif (this._useSecondaryUV == value)\n\t\t\treturn;\n\n\t\tthis._useSecondaryUV = value;\n\n\t\tthis.iInvalidateShaderProgram();\n\t}\n\n\t/**\n\t * The texture to use as the alpha mask.\n\t */\n\tpublic get texture():TextureBase\n\t{\n\t\treturn this._texture;\n\t}\n\n\tpublic set texture(value:TextureBase)\n\t{\n\t\tif (this._texture == value)\n\t\t\treturn;\n\n\t\tif (this._texture)\n\t\t\tthis.iRemoveTexture(this._texture);\n\n\t\tthis._texture = value;\n\n\t\tif (this._texture)\n\t\t\tthis.iAddTexture(this._texture);\n\n\t\tthis.iInvalidateShaderProgram();\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentCode(shader:ShaderBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar temp:ShaderRegisterElement = registerCache.getFreeFragmentVectorTemp();\n\n\t\treturn methodVO.textureVO._iGetFragmentCode(shader, temp, registerCache, sharedRegisters, this._useSecondaryUV? sharedRegisters.secondaryUVVarying : sharedRegisters.uvVarying) +\n\t\t\t\"mul \" + targetReg + \", \" + targetReg + \", \" + temp + \".x\\n\";\n\t}\n\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iActivate(shader:LightingShader, methodVO:MethodVO, stage:Stage)\n\t{\n\t\tsuper.iActivate(shader, methodVO, stage);\n\n\t\tmethodVO.textureVO.activate(shader);\n\t}\n\n\n\tpublic iSetRenderState(shader:ShaderBase, methodVO:MethodVO, renderable:RenderableBase, stage:Stage, camera:Camera)\n\t{\n\t\tmethodVO.textureVO._setRenderState(renderable, shader);\n\t}\n}\n\nexport = EffectAlphaMaskMethod;",
    "import Stage\t\t\t\t\t\t\t= require(\"awayjs-stagegl/lib/base/Stage\");\n\nimport ShaderBase\t\t\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderBase\");\nimport ShaderRegisterCache\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterCache\");\nimport ShaderRegisterData\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterData\");\nimport ShaderRegisterElement\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterElement\");\n\nimport MethodVO\t\t\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/data/MethodVO\");\nimport EffectMethodBase\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/methods/EffectMethodBase\");\n\n/**\n * EffectColorMatrixMethod provides a shading method that changes the colour of a material analogous to a ColorMatrixFilter.\n */\nclass EffectColorMatrixMethod extends EffectMethodBase\n{\n\tprivate _matrix:Array<number>;\n\n\t/**\n\t * Creates a new EffectColorTransformMethod.\n\t *\n\t * @param matrix An array of 20 items for 4 x 5 color transform.\n\t */\n\tconstructor(matrix:Array<number>)\n\t{\n\t\tsuper();\n\n\t\tif (matrix.length != 20)\n\t\t\tthrow new Error(\"Matrix length must be 20!\");\n\n\t\tthis._matrix = matrix;\n\t}\n\n\t/**\n\t * The 4 x 5 matrix to transform the color of the material.\n\t */\n\tpublic get colorMatrix():Array<number>\n\t{\n\t\treturn this._matrix;\n\t}\n\n\tpublic set colorMatrix(value:Array<number>)\n\t{\n\t\tthis._matrix = value;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentCode(shader:ShaderBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = \"\";\n\t\tvar colorMultReg:ShaderRegisterElement = registerCache.getFreeFragmentConstant();\n\t\tregisterCache.getFreeFragmentConstant();\n\t\tregisterCache.getFreeFragmentConstant();\n\t\tregisterCache.getFreeFragmentConstant();\n\n\t\tvar colorOffsetReg:ShaderRegisterElement = registerCache.getFreeFragmentConstant();\n\n\t\tmethodVO.fragmentConstantsIndex = colorMultReg.index*4;\n\n\t\tvar temp:ShaderRegisterElement = registerCache.getFreeFragmentVectorTemp();\n\n\t\tcode += \"m44 \" + temp + \", \" + targetReg + \", \" + colorMultReg + \"\\n\" +\n\t\t\t\t\"add \" + targetReg + \", \" + temp + \", \" + colorOffsetReg + \"\\n\";\n\n\t\treturn code;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iActivate(shader:ShaderBase, methodVO:MethodVO, stage:Stage)\n\t{\n\t\tvar matrix:Array<number> = this._matrix;\n\t\tvar index:number /*int*/ = methodVO.fragmentConstantsIndex;\n\t\tvar data:Float32Array = shader.fragmentConstantData;\n\n\t\t// r\n\t\tdata[index] = matrix[0];\n\t\tdata[index + 1] = matrix[1];\n\t\tdata[index + 2] = matrix[2];\n\t\tdata[index + 3] = matrix[3];\n\n\t\t// g\n\t\tdata[index + 4] = matrix[5];\n\t\tdata[index + 5] = matrix[6];\n\t\tdata[index + 6] = matrix[7];\n\t\tdata[index + 7] = matrix[8];\n\n\t\t// b\n\t\tdata[index + 8] = matrix[10];\n\t\tdata[index + 9] = matrix[11];\n\t\tdata[index + 10] = matrix[12];\n\t\tdata[index + 11] = matrix[13];\n\n\t\t// a\n\t\tdata[index + 12] = matrix[15];\n\t\tdata[index + 13] = matrix[16];\n\t\tdata[index + 14] = matrix[17];\n\t\tdata[index + 15] = matrix[18];\n\n\t\t// rgba offset\n\t\tdata[index + 16] = matrix[4];\n\t\tdata[index + 17] = matrix[9];\n\t\tdata[index + 18] = matrix[14];\n\t\tdata[index + 19] = matrix[19];\n\t}\n}\n\nexport = EffectColorMatrixMethod;",
    "import ColorTransform\t\t\t\t= require(\"awayjs-core/lib/geom/ColorTransform\");\n\nimport Stage\t\t\t\t\t\t= require(\"awayjs-stagegl/lib/base/Stage\");\n\nimport ShaderBase\t\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderBase\");\nimport ShaderRegisterCache\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterCache\");\nimport ShaderRegisterData\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterData\");\nimport ShaderRegisterElement\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterElement\");\n\nimport MethodVO\t\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/data/MethodVO\");\nimport EffectMethodBase\t\t\t\t= require(\"awayjs-methodmaterials/lib/methods/EffectMethodBase\");\n\n/**\n * EffectColorTransformMethod provides a shading method that changes the colour of a material analogous to a\n * ColorTransform object.\n */\nclass EffectColorTransformMethod extends EffectMethodBase\n{\n\tprivate _colorTransform:ColorTransform;\n\n\t/**\n\t * Creates a new EffectColorTransformMethod.\n\t */\n\tconstructor()\n\t{\n\t\tsuper();\n\t}\n\n\t/**\n\t * The ColorTransform object to transform the colour of the material with.\n\t */\n\tpublic get colorTransform():ColorTransform\n\t{\n\t\treturn this._colorTransform;\n\t}\n\n\tpublic set colorTransform(value:ColorTransform)\n\t{\n\t\tthis._colorTransform = value;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentCode(shader:ShaderBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = \"\";\n\t\tvar colorMultReg:ShaderRegisterElement = registerCache.getFreeFragmentConstant();\n\t\tvar colorOffsReg:ShaderRegisterElement = registerCache.getFreeFragmentConstant();\n\n\t\tmethodVO.fragmentConstantsIndex = colorMultReg.index*4;\n\n\t\t//TODO: AGAL <> GLSL\n\n\t\tcode += \"mul \" + targetReg + \", \" + targetReg + \", \" + colorMultReg + \"\\n\" + \"add \" + targetReg + \", \" + targetReg + \", \" + colorOffsReg + \"\\n\";\n\n\t\treturn code;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iActivate(shader:ShaderBase, methodVO:MethodVO, stage:Stage)\n\t{\n\t\tvar inv:number = 1/0xff;\n\t\tvar index:number = methodVO.fragmentConstantsIndex;\n\t\tvar data:Float32Array = shader.fragmentConstantData;\n\n\t\tdata[index] = this._colorTransform.redMultiplier;\n\t\tdata[index + 1] = this._colorTransform.greenMultiplier;\n\t\tdata[index + 2] = this._colorTransform.blueMultiplier;\n\t\tdata[index + 3] = this._colorTransform.alphaMultiplier;\n\t\tdata[index + 4] = this._colorTransform.redOffset*inv;\n\t\tdata[index + 5] = this._colorTransform.greenOffset*inv;\n\t\tdata[index + 6] = this._colorTransform.blueOffset*inv;\n\t\tdata[index + 7] = this._colorTransform.alphaOffset*inv;\n\n\t}\n}\n\nexport = EffectColorTransformMethod;",
    "import Camera\t\t\t\t\t\t\t= require(\"awayjs-display/lib/entities/Camera\");\nimport TextureBase\t\t\t\t\t\t= require(\"awayjs-display/lib/textures/TextureBase\");\n\nimport Stage\t\t\t\t\t\t\t= require(\"awayjs-stagegl/lib/base/Stage\");\n\nimport RenderableBase\t\t\t\t\t= require(\"awayjs-renderergl/lib/renderables/RenderableBase\");\nimport ShaderBase\t\t\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderBase\");\nimport ShaderRegisterCache\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterCache\");\nimport ShaderRegisterData\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterData\");\nimport ShaderRegisterElement\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterElement\");\n\nimport MethodVO\t\t\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/data/MethodVO\");\nimport EffectMethodBase\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/methods/EffectMethodBase\");\n\n/**\n * EffectEnvMapMethod provides a material method to perform reflection mapping using cube maps.\n */\nclass EffectEnvMapMethod extends EffectMethodBase\n{\n\tprivate _envMap:TextureBase;\n\tprivate _alpha:number;\n\tprivate _mask:TextureBase;\n\n\t/**\n\t * Creates an EffectEnvMapMethod object.\n\t * @param envMap The environment map containing the reflected scene.\n\t * @param alpha The reflectivity of the surface.\n\t */\n\tconstructor(envMap:TextureBase, alpha:number = 1)\n\t{\n\t\tsuper();\n\t\tthis._envMap = envMap;\n\t\tthis._alpha = alpha;\n\n\t\tif (this._envMap)\n\t\t\tthis.iAddTexture(this._envMap);\n\t}\n\n\t/**\n\t * An optional texture to modulate the reflectivity of the surface.\n\t */\n\tpublic get mask():TextureBase\n\t{\n\t\treturn this._mask;\n\t}\n\n\tpublic set mask(value:TextureBase)\n\t{\n\t\tif (value == this._mask)\n\t\t\treturn;\n\n\t\tif (this._mask)\n\t\t\tthis.iRemoveTexture(this._mask);\n\n\t\tthis._mask = value;\n\n\t\tif (this._mask)\n\t\t\tthis.iAddTexture(this._mask);\n\n\t\tthis.iInvalidateShaderProgram();\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitVO(shader:ShaderBase, methodVO:MethodVO)\n\t{\n\t\tmethodVO.needsNormals = true;\n\t\tmethodVO.needsView = true;\n\n\t\tmethodVO.textureVO = shader.getTextureVO(this._envMap);\n\n\t\tif (this._mask != null) {\n\t\t\tmethodVO.secondaryTextureVO = shader.getTextureVO(this._mask);\n\t\t\tshader.uvDependencies++;\n\t\t}\n\t}\n\n\t/**\n\t * The cubic environment map containing the reflected scene.\n\t */\n\tpublic get envMap():TextureBase\n\t{\n\t\treturn this._envMap;\n\t}\n\n\tpublic set envMap(value:TextureBase)\n\t{\n\t\tif (this._envMap == value)\n\t\t\treturn;\n\n\t\tif (this._envMap)\n\t\t\tthis.iRemoveTexture(this._envMap);\n\n\t\tthis._envMap = value;\n\n\t\tif (this._envMap)\n\t\t\tthis.iAddTexture(this._envMap);\n\n\t\tthis.iInvalidateShaderProgram();\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic dispose()\n\t{\n\t}\n\n\t/**\n\t * The reflectivity of the surface.\n\t */\n\tpublic get alpha():number\n\t{\n\t\treturn this._alpha;\n\t}\n\n\tpublic set alpha(value:number)\n\t{\n\t\tthis._alpha = value;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iActivate(shader:ShaderBase, methodVO:MethodVO, stage:Stage)\n\t{\n\t\tshader.fragmentConstantData[methodVO.fragmentConstantsIndex] = this._alpha;\n\n\t\tmethodVO.textureVO.activate(shader);\n\n\t\tif (this._mask)\n\t\t\tmethodVO.secondaryTextureVO.activate(shader);\n\t}\n\n\tpublic iSetRenderState(shader:ShaderBase, methodVO:MethodVO, renderable:RenderableBase, stage:Stage, camera:Camera)\n\t{\n\t\tmethodVO.textureVO._setRenderState(renderable, shader);\n\n\t\tif (this._mask)\n\t\t\tmethodVO.secondaryTextureVO._setRenderState(renderable, shader);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentCode(shader:ShaderBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar dataRegister:ShaderRegisterElement = registerCache.getFreeFragmentConstant();\n\t\tvar code:string = \"\";\n\n\t\tmethodVO.fragmentConstantsIndex = dataRegister.index*4;\n\n\t\tvar temp:ShaderRegisterElement = registerCache.getFreeFragmentVectorTemp();\n\t\tregisterCache.addFragmentTempUsages(temp, 1);\n\t\tvar temp2:ShaderRegisterElement = registerCache.getFreeFragmentVectorTemp();\n\t\tregisterCache.addFragmentTempUsages(temp2, 1);\n\n\t\t// r = I - 2(I.N)*N\n\t\tcode += \"dp3 \" + temp + \".w, \" + sharedRegisters.viewDirFragment + \".xyz, \" + sharedRegisters.normalFragment + \".xyz\\n\" +\n\t\t\t\"add \" + temp + \".w, \" + temp + \".w, \" + temp + \".w\\n\" +\n\t\t\t\"mul \" + temp + \".xyz, \" + sharedRegisters.normalFragment + \".xyz, \" + temp + \".w\\n\" +\n\t\t\t\"sub \" + temp + \".xyz, \" + temp + \".xyz, \" + sharedRegisters.viewDirFragment + \".xyz\\n\" +\n\t\t\tmethodVO.textureVO._iGetFragmentCode(shader, temp, registerCache, sharedRegisters, temp) +\n\t\t\t\"sub \" + temp2 + \".w, \" + temp + \".w, fc0.x\\n\" + // -.5\n\t\t\t\"kil \" + temp2 + \".w\\n\" +\t// used for real time reflection mapping - if alpha is not 1 (mock texture) kil output\n\t\t\t\"sub \" + temp + \", \" + temp + \", \" + targetReg + \"\\n\";\n\n\t\tif (this._mask) {\n\t\t\tcode += methodVO.secondaryTextureVO._iGetFragmentCode(shader, temp2, registerCache, sharedRegisters, sharedRegisters.uvVarying) +\n\t\t\t\t\"mul \" + temp + \", \" + temp2 + \", \" + temp + \"\\n\";\n\t\t}\n\n\t\tcode += \"mul \" + temp + \", \" + temp + \", \" + dataRegister + \".x\\n\" +\n\t\t\t\t\"add \" + targetReg + \", \" + targetReg + \", \" + temp + \"\\n\";\n\n\t\tregisterCache.removeFragmentTempUsage(temp);\n\t\tregisterCache.removeFragmentTempUsage(temp2);\n\n\t\treturn code;\n\t}\n}\n\nexport = EffectEnvMapMethod;",
    "import Stage\t\t\t\t\t\t\t= require(\"awayjs-stagegl/lib/base/Stage\");\n\nimport LightingShader\t\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/LightingShader\");\nimport ShaderBase\t\t\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderBase\");\nimport ShaderRegisterCache\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterCache\");\nimport ShaderRegisterData\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterData\");\nimport ShaderRegisterElement\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterElement\");\n\nimport MethodVO\t\t\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/data/MethodVO\");\nimport EffectMethodBase\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/methods/EffectMethodBase\");\n\n/**\n * EffectFogMethod provides a method to add distance-based fog to a material.\n */\nclass EffectFogMethod extends EffectMethodBase\n{\n\tprivate _minDistance:number = 0;\n\tprivate _maxDistance:number = 1000;\n\tprivate _fogColor:number /*uint*/;\n\tprivate _fogR:number;\n\tprivate _fogG:number;\n\tprivate _fogB:number;\n\n\t/**\n\t * Creates a new EffectFogMethod object.\n\t * @param minDistance The distance from which the fog starts appearing.\n\t * @param maxDistance The distance at which the fog is densest.\n\t * @param fogColor The colour of the fog.\n\t */\n\tconstructor(minDistance:number, maxDistance:number, fogColor:number /*uint*/ = 0x808080)\n\t{\n\t\tsuper();\n\t\tthis.minDistance = minDistance;\n\t\tthis.maxDistance = maxDistance;\n\t\tthis.fogColor = fogColor;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitVO(shader:LightingShader, methodVO:MethodVO)\n\t{\n\t\tmethodVO.needsProjection = true;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitConstants(shader:ShaderBase, methodVO:MethodVO)\n\t{\n\t\tvar data:Float32Array = shader.fragmentConstantData;\n\t\tvar index:number /*int*/ = methodVO.fragmentConstantsIndex;\n\t\tdata[index + 3] = 1;\n\t\tdata[index + 6] = 0;\n\t\tdata[index + 7] = 0;\n\t}\n\n\t/**\n\t * The distance from which the fog starts appearing.\n\t */\n\tpublic get minDistance():number\n\t{\n\t\treturn this._minDistance;\n\t}\n\n\tpublic set minDistance(value:number)\n\t{\n\t\tthis._minDistance = value;\n\t}\n\n\t/**\n\t * The distance at which the fog is densest.\n\t */\n\tpublic get maxDistance():number\n\t{\n\t\treturn this._maxDistance;\n\t}\n\n\tpublic set maxDistance(value:number)\n\t{\n\t\tthis._maxDistance = value;\n\t}\n\n\t/**\n\t * The colour of the fog.\n\t */\n\tpublic get fogColor():number /*uint*/\n\t{\n\t\treturn this._fogColor;\n\t}\n\n\tpublic set fogColor(value:number/*uint*/)\n\t{\n\t\tthis._fogColor = value;\n\t\tthis._fogR = ((value >> 16) & 0xff)/0xff;\n\t\tthis._fogG = ((value >> 8) & 0xff)/0xff;\n\t\tthis._fogB = (value & 0xff)/0xff;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iActivate(shader:ShaderBase, methodVO:MethodVO, stage:Stage)\n\t{\n\t\tvar data:Float32Array = shader.fragmentConstantData;\n\t\tvar index:number /*int*/ = methodVO.fragmentConstantsIndex;\n\t\tdata[index] = this._fogR;\n\t\tdata[index + 1] = this._fogG;\n\t\tdata[index + 2] = this._fogB;\n\t\tdata[index + 4] = this._minDistance;\n\t\tdata[index + 5] = 1/(this._maxDistance - this._minDistance);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentCode(shader:ShaderBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar fogColor:ShaderRegisterElement = registerCache.getFreeFragmentConstant();\n\t\tvar fogData:ShaderRegisterElement = registerCache.getFreeFragmentConstant();\n\t\tvar temp:ShaderRegisterElement = registerCache.getFreeFragmentVectorTemp();\n\t\tregisterCache.addFragmentTempUsages(temp, 1);\n\t\tvar temp2:ShaderRegisterElement = registerCache.getFreeFragmentVectorTemp();\n\t\tvar code:string = \"\";\n\t\tmethodVO.fragmentConstantsIndex = fogColor.index*4;\n\n\t\tcode += \"sub \" + temp2 + \".w, \" + sharedRegisters.projectionFragment + \".z, \" + fogData + \".x\\n\" +\n\t\t\t\t\"mul \" + temp2 + \".w, \" + temp2 + \".w, \" + fogData + \".y\\n\" +\n\t\t\t\t\"sat \" + temp2 + \".w, \" + temp2 + \".w\\n\" +\n\t\t\t\t\"sub \" + temp + \", \" + fogColor + \", \" + targetReg + \"\\n\" + // (fogColor- col)\n\t\t\t\t\"mul \" + temp + \", \" + temp + \", \" + temp2 + \".w\\n\" + // (fogColor- col)*fogRatio\n\t\t\t\t\"add \" + targetReg + \", \" + targetReg + \", \" + temp + \"\\n\"; // fogRatio*(fogColor- col) + col\n\n\t\tregisterCache.removeFragmentTempUsage(temp);\n\n\t\treturn code;\n\t}\n}\n\nexport = EffectFogMethod;",
    "import Camera\t\t\t\t\t\t\t= require(\"awayjs-display/lib/entities/Camera\");\nimport TextureBase\t\t\t\t\t\t= require(\"awayjs-display/lib/textures/TextureBase\");\n\nimport Stage\t\t\t\t\t\t\t= require(\"awayjs-stagegl/lib/base/Stage\");\n\nimport RenderableBase\t\t\t\t\t= require(\"awayjs-renderergl/lib/renderables/RenderableBase\");\nimport ShaderBase\t\t\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderBase\");\nimport ShaderRegisterCache\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterCache\");\nimport ShaderRegisterData\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterData\");\nimport ShaderRegisterElement\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterElement\");\n\nimport MethodVO\t\t\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/data/MethodVO\");\nimport EffectMethodBase\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/methods/EffectMethodBase\");\n\n/**\n * EffectFresnelEnvMapMethod provides a method to add fresnel-based reflectivity to an object using cube maps, which gets\n * stronger as the viewing angle becomes more grazing.\n */\nclass EffectFresnelEnvMapMethod extends EffectMethodBase\n{\n\tprivate _envMap:TextureBase;\n\tprivate _fresnelPower:number = 5;\n\tprivate _normalReflectance:number = 0;\n\tprivate _alpha:number;\n\tprivate _mask:TextureBase;\n\n\t/**\n\t * Creates a new <code>EffectFresnelEnvMapMethod</code> object.\n\t *\n\t * @param envMap The environment map containing the reflected scene.\n\t * @param alpha The reflectivity of the material.\n\t */\n\tconstructor(envMap:TextureBase, alpha:number = 1)\n\t{\n\t\tsuper();\n\n\t\tthis._envMap = envMap;\n\t\tthis._alpha = alpha;\n\n\t\tif (this._envMap)\n\t\t\tthis.iAddTexture(this._envMap);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitVO(shader:ShaderBase, methodVO:MethodVO)\n\t{\n\t\tmethodVO.needsNormals = true;\n\t\tmethodVO.needsView = true;\n\n\t\tmethodVO.textureVO = shader.getTextureVO(this._envMap);\n\n\t\tif (this._mask != null) {\n\t\t\tmethodVO.secondaryTextureVO = shader.getTextureVO(this._mask);\n\t\t\tshader.uvDependencies++;\n\t\t}\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitConstants(shader:ShaderBase, methodVO:MethodVO)\n\t{\n\t\tshader.fragmentConstantData[methodVO.fragmentConstantsIndex + 3] = 1;\n\t}\n\n\t/**\n\t * An optional texture to modulate the reflectivity of the surface.\n\t */\n\tpublic get mask():TextureBase\n\t{\n\t\treturn this._mask;\n\t}\n\n\tpublic set mask(value:TextureBase)\n\t{\n\t\tif (this._mask == value)\n\t\t\treturn;\n\n\t\tif (this._mask)\n\t\t\tthis.iRemoveTexture(this._mask);\n\n\t\tthis._mask = value;\n\n\t\tif (this._mask)\n\t\t\tthis.iAddTexture(this._mask);\n\n\t\tthis.iInvalidateShaderProgram();\n\t}\n\n\t/**\n\t * The power used in the Fresnel equation. Higher values make the fresnel effect more pronounced. Defaults to 5.\n\t */\n\tpublic get fresnelPower():number\n\t{\n\t\treturn this._fresnelPower;\n\t}\n\n\tpublic set fresnelPower(value:number)\n\t{\n\t\tthis._fresnelPower = value;\n\t}\n\n\t/**\n\t * The cubic environment map containing the reflected scene.\n\t */\n\tpublic get envMap():TextureBase\n\t{\n\t\treturn this._envMap;\n\t}\n\n\tpublic set envMap(value:TextureBase)\n\t{\n\t\tif (this._envMap == value)\n\t\t\treturn;\n\n\t\tif (this._envMap)\n\t\t\tthis.iRemoveTexture(this._envMap);\n\n\t\tthis._envMap = value;\n\n\t\tif (this._envMap)\n\t\t\tthis.iAddTexture(this._envMap);\n\t}\n\n\t/**\n\t * The reflectivity of the surface.\n\t */\n\tpublic get alpha():number\n\t{\n\t\treturn this._alpha;\n\t}\n\n\tpublic set alpha(value:number)\n\t{\n\t\tthis._alpha = value;\n\t}\n\n\t/**\n\t * The minimum amount of reflectance, ie the reflectance when the view direction is normal to the surface or light direction.\n\t */\n\tpublic get normalReflectance():number\n\t{\n\t\treturn this._normalReflectance;\n\t}\n\n\tpublic set normalReflectance(value:number)\n\t{\n\t\tthis._normalReflectance = value;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iActivate(shader:ShaderBase, methodVO:MethodVO, stage:Stage)\n\t{\n\t\tvar data:Float32Array = shader.fragmentConstantData;\n\t\tvar index:number /*int*/ = methodVO.fragmentConstantsIndex;\n\t\tdata[index] = this._alpha;\n\t\tdata[index + 1] = this._normalReflectance;\n\t\tdata[index + 2] = this._fresnelPower;\n\n\t\tmethodVO.textureVO.activate(shader);\n\n\t\tif (this._mask)\n\t\t\tmethodVO.secondaryTextureVO.activate(shader);\n\t}\n\n\tpublic iSetRenderState(shader:ShaderBase, methodVO:MethodVO, renderable:RenderableBase, stage:Stage, camera:Camera)\n\t{\n\t\tmethodVO.textureVO._setRenderState(renderable, shader);\n\n\t\tif (this._mask)\n\t\t\tmethodVO.secondaryTextureVO._setRenderState(renderable, shader);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentCode(shader:ShaderBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar dataRegister:ShaderRegisterElement = registerCache.getFreeFragmentConstant();\n\t\tvar code:string = \"\";\n\t\tvar viewDirReg:ShaderRegisterElement = sharedRegisters.viewDirFragment;\n\t\tvar normalReg:ShaderRegisterElement = sharedRegisters.normalFragment;\n\n\t\tmethodVO.fragmentConstantsIndex = dataRegister.index*4;\n\n\t\tvar temp:ShaderRegisterElement = registerCache.getFreeFragmentVectorTemp();\n\t\tregisterCache.addFragmentTempUsages(temp, 1);\n\t\tvar temp2:ShaderRegisterElement = registerCache.getFreeFragmentVectorTemp();\n\t\tregisterCache.addFragmentTempUsages(temp2, 1);\n\n\t\t// r = V - 2(V.N)*N\n\t\tcode += \"dp3 \" + temp + \".w, \" + viewDirReg + \".xyz, \" + normalReg + \".xyz\\n\" +\n\t\t\t\t\"add \" + temp + \".w, \" + temp + \".w, \" + temp + \".w\\n\" +\n\t\t\t\t\"mul \" + temp + \".xyz, \" + normalReg + \".xyz, \" + temp + \".w\\n\" +\n\t\t\t\t\"sub \" + temp + \".xyz, \" + temp + \".xyz, \" + viewDirReg + \".xyz\\n\" +\n\t\t\tmethodVO.textureVO._iGetFragmentCode(shader, temp, registerCache, sharedRegisters, temp) +\n\t\t\t\t\"sub \" + temp2 + \".w, \" + temp + \".w, fc0.x\\n\" +               \t// -.5\n\t\t\t\t\"kil \" + temp2 + \".w\\n\" +\t// used for real time reflection mapping - if alpha is not 1 (mock texture) kil output\n\t\t\t\t\"sub \" + temp + \", \" + temp + \", \" + targetReg + \"\\n\";\n\n\t\t// calculate fresnel term\n\t\tcode += \"dp3 \" + viewDirReg + \".w, \" + viewDirReg + \".xyz, \" + normalReg + \".xyz\\n\" +  // dot(V, H)\n\t\t\t\t\"sub \" + viewDirReg + \".w, \" + dataRegister + \".w, \" + viewDirReg + \".w\\n\" +       // base = 1-dot(V, H)\n\t\t\t\t\"pow \" + viewDirReg + \".w, \" + viewDirReg + \".w, \" + dataRegister + \".z\\n\" +       // exp = pow(base, 5)\n\t\t\t\t\"sub \" + normalReg + \".w, \" + dataRegister + \".w, \" + viewDirReg + \".w\\n\" +        // 1 - exp\n\t\t\t\t\"mul \" + normalReg + \".w, \" + dataRegister + \".y, \" + normalReg + \".w\\n\" +         // f0*(1 - exp)\n\t\t\t\t\"add \" + viewDirReg + \".w, \" + viewDirReg + \".w, \" + normalReg + \".w\\n\" +          // exp + f0*(1 - exp)\n\n\t\t\t\t// total alpha\n\t\t\t\t\"mul \" + viewDirReg + \".w, \" + dataRegister + \".x, \" + viewDirReg + \".w\\n\";\n\n\t\tif (this._mask) {\n\t\t\tcode += methodVO.secondaryTextureVO._iGetFragmentCode(shader, temp2, registerCache, sharedRegisters, sharedRegisters.uvVarying) +\n\t\t\t\t\"mul \" + viewDirReg + \".w, \" + temp2 + \".x, \" + viewDirReg + \".w\\n\";\n\t\t}\n\n\t\t// blend\n\t\tcode += \"mul \" + temp + \", \" + temp + \", \" + viewDirReg + \".w\\n\" +\n\t\t\t\t\"add \" + targetReg + \", \" + targetReg + \", \" + temp + \"\\n\";\n\n\t\tregisterCache.removeFragmentTempUsage(temp);\n\t\tregisterCache.removeFragmentTempUsage(temp2);\n\n\t\treturn code;\n\t}\n}\n\nexport = EffectFresnelEnvMapMethod;",
    "import Camera\t\t\t\t\t\t\t= require(\"awayjs-display/lib/entities/Camera\");\nimport TextureBase\t\t\t\t\t\t= require(\"awayjs-display/lib/textures/TextureBase\");\n\nimport Stage\t\t\t\t\t\t\t= require(\"awayjs-stagegl/lib/base/Stage\");\n\nimport RenderableBase\t\t\t\t\t= require(\"awayjs-renderergl/lib/renderables/RenderableBase\");\nimport ShaderBase\t\t\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderBase\");\nimport ShaderRegisterCache\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterCache\");\nimport ShaderRegisterData\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterData\");\nimport ShaderRegisterElement\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterElement\");\n\nimport MethodVO\t\t\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/data/MethodVO\");\nimport EffectMethodBase\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/methods/EffectMethodBase\");\n\n/**\n * EffectLightMapMethod provides a method that allows applying a light map texture to the calculated pixel colour.\n * It is different from DiffuseLightMapMethod in that the latter only modulates the diffuse shading value rather\n * than the whole pixel colour.\n */\nclass EffectLightMapMethod extends EffectMethodBase\n{\n\t/**\n\t * Indicates the light map should be multiplied with the calculated shading result.\n\t */\n\tpublic static MULTIPLY:string = \"multiply\";\n\n\t/**\n\t * Indicates the light map should be added into the calculated shading result.\n\t */\n\tpublic static ADD:string = \"add\";\n\n\tprivate _lightMap:TextureBase;\n\n\tprivate _blendMode:string;\n\tprivate _useSecondaryUV:boolean;\n\n\t/**\n\t * Creates a new EffectLightMapMethod object.\n\t *\n\t * @param lightMap The texture containing the light map.\n\t * @param blendMode The blend mode with which the light map should be applied to the lighting result.\n\t * @param useSecondaryUV Indicates whether the secondary UV set should be used to map the light map.\n\t */\n\tconstructor(lightMap:TextureBase, blendMode:string = \"multiply\", useSecondaryUV:boolean = false)\n\t{\n\t\tsuper();\n\n\t\tif (blendMode != EffectLightMapMethod.ADD && blendMode != EffectLightMapMethod.MULTIPLY)\n\t\t\tthrow new Error(\"Unknown blendmode!\");\n\n\t\tthis._lightMap = lightMap;\n\t\tthis._blendMode = blendMode;\n\t\tthis._useSecondaryUV = useSecondaryUV;\n\n\t\tif (this._lightMap)\n\t\t\tthis.iAddTexture(this._lightMap);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitVO(shader:ShaderBase, methodVO:MethodVO)\n\t{\n\t\tmethodVO.textureVO = shader.getTextureVO(this._lightMap);\n\n\t\tif (this._useSecondaryUV)\n\t\t\tshader.secondaryUVDependencies++;\n\t\telse\n\t\t\tshader.uvDependencies++;\n\t}\n\n\t/**\n\t * The blend mode with which the light map should be applied to the lighting result.\n\t *\n\t * @see EffectLightMapMethod.ADD\n\t * @see EffectLightMapMethod.MULTIPLY\n\t */\n\tpublic get blendMode():string\n\t{\n\t\treturn this._blendMode;\n\t}\n\n\tpublic set blendMode(value:string)\n\t{\n\t\tif (this._blendMode == value)\n\t\t\treturn;\n\n\t\tif (value != EffectLightMapMethod.ADD && value != EffectLightMapMethod.MULTIPLY)\n\t\t\tthrow new Error(\"Unknown blendmode!\");\n\n\t\tthis._blendMode = value;\n\n\t\tthis.iInvalidateShaderProgram();\n\t}\n\n\t/**\n\t * The lightMap containing the light map.\n\t */\n\tpublic get lightMap():TextureBase\n\t{\n\t\treturn this._lightMap;\n\t}\n\n\tpublic set lightMap(value:TextureBase)\n\t{\n\t\tif (this._lightMap == value)\n\t\t\treturn;\n\n\t\tif (this._lightMap)\n\t\t\tthis.iRemoveTexture(this._lightMap);\n\n\t\tthis._lightMap = value;\n\n\t\tif (this._lightMap)\n\t\t\tthis.iAddTexture(this._lightMap);\n\n\t\tthis.iInvalidateShaderProgram();\n\t}\n\n\t/**\n\t * Indicates whether the secondary UV set should be used to map the light map.\n\t */\n\tpublic get useSecondaryUV():boolean\n\t{\n\t\treturn this._useSecondaryUV;\n\t}\n\n\tpublic set useSecondaryUV(value:boolean)\n\t{\n\t\tif (this._useSecondaryUV == value)\n\t\t\treturn;\n\n\t\tthis._useSecondaryUV = value;\n\n\t\tthis.iInvalidateShaderProgram();\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentCode(shader:ShaderBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string;\n\t\tvar temp:ShaderRegisterElement = registerCache.getFreeFragmentVectorTemp();\n\n\t\tcode = methodVO.secondaryTextureVO._iGetFragmentCode(shader, temp, registerCache, sharedRegisters, this._useSecondaryUV? sharedRegisters.secondaryUVVarying : sharedRegisters.uvVarying);\n\n\t\tswitch (this._blendMode) {\n\t\t\tcase EffectLightMapMethod.MULTIPLY:\n\t\t\t\tcode += \"mul \" + targetReg + \", \" + targetReg + \", \" + temp + \"\\n\";\n\t\t\t\tbreak;\n\t\t\tcase EffectLightMapMethod.ADD:\n\t\t\t\tcode += \"add \" + targetReg + \", \" + targetReg + \", \" + temp + \"\\n\";\n\t\t\t\tbreak;\n\t\t}\n\n\t\treturn code;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iActivate(shader:ShaderBase, methodVO:MethodVO, stage:Stage)\n\t{\n\t\tmethodVO.textureVO.activate(shader);\n\t}\n\n\n\tpublic iSetRenderState(shader:ShaderBase, methodVO:MethodVO, renderable:RenderableBase, stage:Stage, camera:Camera)\n\t{\n\t\tmethodVO.textureVO._setRenderState(renderable, shader);\n\t}\n}\n\nexport = EffectLightMapMethod;",
    "import IAsset\t\t\t\t\t\t= require(\"awayjs-core/lib/library/IAsset\");\nimport AbstractMethodError\t\t\t= require(\"awayjs-core/lib/errors/AbstractMethodError\");\n\nimport ShaderBase\t\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderBase\");\nimport ShaderRegisterCache\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterCache\");\nimport ShaderRegisterData\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterData\");\nimport ShaderRegisterElement\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterElement\");\n\nimport MethodVO\t\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/data/MethodVO\");\nimport ShadingMethodBase\t\t\t= require(\"awayjs-methodmaterials/lib/methods/ShadingMethodBase\");\n\n/**\n * EffectMethodBase forms an abstract base class for shader methods that are not dependent on light sources,\n * and are in essence post-process effects on the materials.\n */\nclass EffectMethodBase extends ShadingMethodBase implements IAsset\n{\n\tpublic static assetType:string = \"[asset EffectMethod]\";\n\n\tconstructor()\n\t{\n\t\tsuper();\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic get assetType():string\n\t{\n\t\treturn EffectMethodBase.assetType;\n\t}\n\n\t/**\n\t * Get the fragment shader code that should be added after all per-light code. Usually composits everything to the target register.\n\t * @param methodVO The MethodVO object containing the method data for the currently compiled material pass.\n\t * @param regCache The register cache used during the compilation.\n\t * @param targetReg The register that will be containing the method's output.\n\t * @private\n\t */\n\tpublic iGetFragmentCode(shader:ShaderBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tthrow new AbstractMethodError();\n\t\treturn \"\";\n\t}\n}\n\nexport = EffectMethodBase;",
    "import Camera\t\t\t\t\t\t\t= require(\"awayjs-display/lib/entities/Camera\");\nimport TextureBase\t\t\t\t\t\t= require(\"awayjs-display/lib/textures/TextureBase\");\n\nimport Stage\t\t\t\t\t\t\t= require(\"awayjs-stagegl/lib/base/Stage\");\n\nimport RenderableBase\t\t\t\t\t= require(\"awayjs-renderergl/lib/renderables/RenderableBase\");\nimport ShaderBase\t\t\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderBase\");\nimport ShaderRegisterCache\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterCache\");\nimport ShaderRegisterData\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterData\");\nimport ShaderRegisterElement\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterElement\");\n\nimport MethodVO\t\t\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/data/MethodVO\");\nimport EffectMethodBase\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/methods/EffectMethodBase\");\n\n/**\n * EffectRefractionEnvMapMethod provides a method to add refracted transparency based on cube maps.\n */\nclass EffectRefractionEnvMapMethod extends EffectMethodBase\n{\n\tprivate _envMap:TextureBase;\n\n\tprivate _dispersionR:number = 0;\n\tprivate _dispersionG:number = 0;\n\tprivate _dispersionB:number = 0;\n\tprivate _useDispersion:boolean;\n\tprivate _refractionIndex:number;\n\tprivate _alpha:number = 1;\n\n\t/**\n\t * Creates a new EffectRefractionEnvMapMethod object. Example values for dispersion are: dispersionR: -0.03, dispersionG: -0.01, dispersionB: = .0015\n\t *\n\t * @param envMap The environment map containing the refracted scene.\n\t * @param refractionIndex The refractive index of the material.\n\t * @param dispersionR The amount of chromatic dispersion of the red channel. Defaults to 0 (none).\n\t * @param dispersionG The amount of chromatic dispersion of the green channel. Defaults to 0 (none).\n\t * @param dispersionB The amount of chromatic dispersion of the blue channel. Defaults to 0 (none).\n\t */\n\tconstructor(envMap:TextureBase, refractionIndex:number = .1, dispersionR:number = 0, dispersionG:number = 0, dispersionB:number = 0)\n\t{\n\t\tsuper();\n\t\tthis._envMap = envMap;\n\t\tthis._dispersionR = dispersionR;\n\t\tthis._dispersionG = dispersionG;\n\t\tthis._dispersionB = dispersionB;\n\t\tthis._useDispersion = !(this._dispersionR == this._dispersionB && this._dispersionR == this._dispersionG);\n\t\tthis._refractionIndex = refractionIndex;\n\n\t\tif (this._envMap)\n\t\t\tthis.iAddTexture(this._envMap);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitConstants(shader:ShaderBase, methodVO:MethodVO)\n\t{\n\t\tvar index:number /*int*/ = methodVO.fragmentConstantsIndex;\n\t\tvar data:Float32Array = shader.fragmentConstantData;\n\t\tdata[index + 4] = 1;\n\t\tdata[index + 5] = 0;\n\t\tdata[index + 7] = 1;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitVO(shader:ShaderBase, methodVO:MethodVO)\n\t{\n\t\tmethodVO.needsNormals = true;\n\t\tmethodVO.needsView = true;\n\n\t\tmethodVO.textureVO = shader.getTextureVO(this._envMap);\n\t}\n\n\t/**\n\t * The cube environment map to use for the refraction.\n\t */\n\tpublic get envMap():TextureBase\n\t{\n\t\treturn this._envMap;\n\t}\n\n\tpublic set envMap(value:TextureBase)\n\t{\n\t\tif (this._envMap == value)\n\t\t\treturn;\n\n\t\tif (this._envMap)\n\t\t\tthis.iRemoveTexture(this._envMap);\n\n\t\tthis._envMap = value;\n\n\t\tif (this._envMap)\n\t\t\tthis.iAddTexture(this._envMap);\n\t}\n\n\t/**\n\t * The refractive index of the material.\n\t */\n\tpublic get refractionIndex():number\n\t{\n\t\treturn this._refractionIndex;\n\t}\n\n\tpublic set refractionIndex(value:number)\n\t{\n\t\tthis._refractionIndex = value;\n\t}\n\n\t/**\n\t * The amount of chromatic dispersion of the red channel. Defaults to 0 (none).\n\t */\n\tpublic get dispersionR():number\n\t{\n\t\treturn this._dispersionR;\n\t}\n\n\tpublic set dispersionR(value:number)\n\t{\n\t\tthis._dispersionR = value;\n\n\t\tvar useDispersion:boolean = !(this._dispersionR == this._dispersionB && this._dispersionR == this._dispersionG);\n\t\tif (this._useDispersion != useDispersion) {\n\t\t\tthis.iInvalidateShaderProgram();\n\t\t\tthis._useDispersion = useDispersion;\n\t\t}\n\t}\n\n\t/**\n\t * The amount of chromatic dispersion of the green channel. Defaults to 0 (none).\n\t */\n\tpublic get dispersionG():number\n\t{\n\t\treturn this._dispersionG;\n\t}\n\n\tpublic set dispersionG(value:number)\n\t{\n\t\tthis._dispersionG = value;\n\n\t\tvar useDispersion:boolean = !(this._dispersionR == this._dispersionB && this._dispersionR == this._dispersionG);\n\t\tif (this._useDispersion != useDispersion) {\n\t\t\tthis.iInvalidateShaderProgram();\n\t\t\tthis._useDispersion = useDispersion;\n\t\t}\n\t}\n\n\t/**\n\t * The amount of chromatic dispersion of the blue channel. Defaults to 0 (none).\n\t */\n\tpublic get dispersionB():number\n\t{\n\t\treturn this._dispersionB;\n\t}\n\n\tpublic set dispersionB(value:number)\n\t{\n\t\tthis._dispersionB = value;\n\n\t\tvar useDispersion:boolean = !(this._dispersionR == this._dispersionB && this._dispersionR == this._dispersionG);\n\t\tif (this._useDispersion != useDispersion) {\n\t\t\tthis.iInvalidateShaderProgram();\n\t\t\tthis._useDispersion = useDispersion;\n\t\t}\n\t}\n\n\t/**\n\t * The amount of transparency of the object. Warning: the alpha applies to the refracted color, not the actual\n\t * material. A value of 1 will make it appear fully transparent.\n\t */\n\tpublic get alpha():number\n\t{\n\t\treturn this._alpha;\n\t}\n\n\tpublic set alpha(value:number)\n\t{\n\t\tthis._alpha = value;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iActivate(shader:ShaderBase, methodVO:MethodVO, stage:Stage)\n\t{\n\t\tvar index:number /*int*/ = methodVO.fragmentConstantsIndex;\n\t\tvar data:Float32Array = shader.fragmentConstantData;\n\n\t\tdata[index] = this._dispersionR + this._refractionIndex;\n\n\t\tif (this._useDispersion) {\n\t\t\tdata[index + 1] = this._dispersionG + this._refractionIndex;\n\t\t\tdata[index + 2] = this._dispersionB + this._refractionIndex;\n\t\t}\n\t\tdata[index + 3] = this._alpha;\n\n\t\tmethodVO.textureVO.activate(shader);\n\t}\n\n\tpublic iSetRenderState(shader:ShaderBase, methodVO:MethodVO, renderable:RenderableBase, stage:Stage, camera:Camera)\n\t{\n\t\tmethodVO.textureVO._setRenderState(renderable, shader);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentCode(shader:ShaderBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\t// todo: data2.x could use common reg, so only 1 reg is used\n\t\tvar data:ShaderRegisterElement = registerCache.getFreeFragmentConstant();\n\t\tvar data2:ShaderRegisterElement = registerCache.getFreeFragmentConstant();\n\t\tvar code:string = \"\";\n\t\tvar refractionDir:ShaderRegisterElement;\n\t\tvar refractionColor:ShaderRegisterElement;\n\t\tvar temp:ShaderRegisterElement;\n\n\t\tmethodVO.fragmentConstantsIndex = data.index*4;\n\n\t\trefractionDir = registerCache.getFreeFragmentVectorTemp();\n\t\tregisterCache.addFragmentTempUsages(refractionDir, 1);\n\t\trefractionColor = registerCache.getFreeFragmentVectorTemp();\n\t\tregisterCache.addFragmentTempUsages(refractionColor, 1);\n\t\ttemp = registerCache.getFreeFragmentVectorTemp();\n\t\tregisterCache.addFragmentTempUsages(temp, 1);\n\n\t\tvar viewDirReg:ShaderRegisterElement = sharedRegisters.viewDirFragment;\n\t\tvar normalReg:ShaderRegisterElement = sharedRegisters.normalFragment;\n\n\t\tcode += \"neg \" + viewDirReg + \".xyz, \" + viewDirReg + \".xyz\\n\";\n\n\t\tcode += \"dp3 \" + temp + \".x, \" + viewDirReg + \".xyz, \" + normalReg + \".xyz\\n\" +\n\t\t\t\"mul \" + temp + \".w, \" + temp + \".x, \" + temp + \".x\\n\" +\n\t\t\t\"sub \" + temp + \".w, \" + data2 + \".x, \" + temp + \".w\\n\" +\n\t\t\t\"mul \" + temp + \".w, \" + data + \".x, \" + temp + \".w\\n\" +\n\t\t\t\"mul \" + temp + \".w, \" + data + \".x, \" + temp + \".w\\n\" +\n\t\t\t\"sub \" + temp + \".w, \" + data2 + \".x, \" + temp + \".w\\n\" +\n\t\t\t\"sqt \" + temp + \".y, \" + temp + \".w\\n\" +\n\n\t\t\t\"mul \" + temp + \".x, \" + data + \".x, \" + temp + \".x\\n\" +\n\t\t\t\"add \" + temp + \".x, \" + temp + \".x, \" + temp + \".y\\n\" +\n\t\t\t\"mul \" + temp + \".xyz, \" + temp + \".x, \" + normalReg + \".xyz\\n\" +\n\n\t\t\t\"mul \" + refractionDir + \", \" + data + \".x, \" + viewDirReg + \"\\n\" +\n\t\t\t\"sub \" + refractionDir + \".xyz, \" + refractionDir + \".xyz, \" + temp + \".xyz\\n\" +\n\t\t\t\"nrm \" + refractionDir + \".xyz, \" + refractionDir + \".xyz\\n\" +\n\t\tmethodVO.textureVO._iGetFragmentCode(shader, refractionColor, registerCache, sharedRegisters, refractionDir) +\n\t\t\t\"sub \" + refractionColor + \".w, \" + refractionColor + \".w, fc0.x\t\\n\" +\n\t\t\t\"kil \" + refractionColor + \".w\\n\";\n\n\t\tif (this._useDispersion) {\n\t\t\t// GREEN\n\t\t\tcode += \"dp3 \" + temp + \".x, \" + viewDirReg + \".xyz, \" + normalReg + \".xyz\\n\" +\n\t\t\t\t\"mul \" + temp + \".w, \" + temp + \".x, \" + temp + \".x\\n\" +\n\t\t\t\t\"sub \" + temp + \".w, \" + data2 + \".x, \" + temp + \".w\\n\" +\n\t\t\t\t\"mul \" + temp + \".w, \" + data + \".y, \" + temp + \".w\\n\" +\n\t\t\t\t\"mul \" + temp + \".w, \" + data + \".y, \" + temp + \".w\\n\" +\n\t\t\t\t\"sub \" + temp + \".w, \" + data2 + \".x, \" + temp + \".w\\n\" +\n\t\t\t\t\"sqt \" + temp + \".y, \" + temp + \".w\\n\" +\n\n\t\t\t\t\"mul \" + temp + \".x, \" + data + \".y, \" + temp + \".x\\n\" +\n\t\t\t\t\"add \" + temp + \".x, \" + temp + \".x, \" + temp + \".y\\n\" +\n\t\t\t\t\"mul \" + temp + \".xyz, \" + temp + \".x, \" + normalReg + \".xyz\\n\" +\n\n\t\t\t\t\"mul \" + refractionDir + \", \" + data + \".y, \" + viewDirReg + \"\\n\" +\n\t\t\t\t\"sub \" + refractionDir + \".xyz, \" + refractionDir + \".xyz, \" + temp + \".xyz\\n\" +\n\t\t\t\t\"nrm \" + refractionDir + \".xyz, \" + refractionDir + \".xyz\\n\" +\n\t\t\tmethodVO.textureVO._iGetFragmentCode(shader, temp, registerCache, sharedRegisters, refractionDir) +\n\t\t\t\t\"mov \" + refractionColor + \".y, \" + temp + \".y\\n\";\n\n\t\t\t// BLUE\n\t\t\tcode += \"dp3 \" + temp + \".x, \" + viewDirReg + \".xyz, \" + normalReg + \".xyz\\n\" +\n\t\t\t\t\"mul \" + temp + \".w, \" + temp + \".x, \" + temp + \".x\\n\" +\n\t\t\t\t\"sub \" + temp + \".w, \" + data2 + \".x, \" + temp + \".w\\n\" +\n\t\t\t\t\"mul \" + temp + \".w, \" + data + \".z, \" + temp + \".w\\n\" +\n\t\t\t\t\"mul \" + temp + \".w, \" + data + \".z, \" + temp + \".w\\n\" +\n\t\t\t\t\"sub \" + temp + \".w, \" + data2 + \".x, \" + temp + \".w\\n\" +\n\t\t\t\t\"sqt \" + temp + \".y, \" + temp + \".w\\n\" +\n\n\t\t\t\t\"mul \" + temp + \".x, \" + data + \".z, \" + temp + \".x\\n\" +\n\t\t\t\t\"add \" + temp + \".x, \" + temp + \".x, \" + temp + \".y\\n\" +\n\t\t\t\t\"mul \" + temp + \".xyz, \" + temp + \".x, \" + normalReg + \".xyz\\n\" +\n\n\t\t\t\t\"mul \" + refractionDir + \", \" + data + \".z, \" + viewDirReg + \"\\n\" +\n\t\t\t\t\"sub \" + refractionDir + \".xyz, \" + refractionDir + \".xyz, \" + temp + \".xyz\\n\" +\n\t\t\t\t\"nrm \" + refractionDir + \".xyz, \" + refractionDir + \".xyz\\n\" +\n\t\t\tmethodVO.textureVO._iGetFragmentCode(shader, temp, registerCache, sharedRegisters, refractionDir) +\n\t\t\t\t\"mov \" + refractionColor + \".z, \" + temp + \".z\\n\";\n\t\t}\n\n\t\tcode += \"sub \" + refractionColor + \".xyz, \" + refractionColor + \".xyz, \" + targetReg + \".xyz\\n\" +\n\t\t\t\"mul \" + refractionColor + \".xyz, \" + refractionColor + \".xyz, \" + data + \".w\\n\" +\n\t\t\t\"add \" + targetReg + \".xyz, \" + targetReg + \".xyz, \" + refractionColor + \".xyz\\n\";\n\n\t\tregisterCache.removeFragmentTempUsage(temp);\n\t\tregisterCache.removeFragmentTempUsage(refractionDir);\n\t\tregisterCache.removeFragmentTempUsage(refractionColor);\n\n\t\t// restore\n\t\tcode += \"neg \" + viewDirReg + \".xyz, \" + viewDirReg + \".xyz\\n\";\n\n\t\treturn code;\n\t}\n}\n\nexport = EffectRefractionEnvMapMethod;",
    "import Stage\t\t\t\t\t\t\t= require(\"awayjs-stagegl/lib/base/Stage\");\n\nimport ShaderBase\t\t\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderBase\");\nimport ShaderRegisterCache\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterCache\");\nimport ShaderRegisterData\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterData\");\nimport ShaderRegisterElement\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterElement\");\n\nimport MethodVO\t\t\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/data/MethodVO\");\nimport EffectMethodBase\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/methods/EffectMethodBase\");\n\n/**\n * EffectRimLightMethod provides a method to add rim lighting to a material. This adds a glow-like effect to edges of objects.\n */\nclass EffectRimLightMethod extends EffectMethodBase\n{\n\tpublic static ADD:string = \"add\";\n\tpublic static MULTIPLY:string = \"multiply\";\n\tpublic static MIX:string = \"mix\";\n\n\tprivate _color:number /*uint*/;\n\tprivate _blendMode:string;\n\tprivate _colorR:number;\n\tprivate _colorG:number;\n\tprivate _colorB:number;\n\tprivate _strength:number;\n\tprivate _power:number;\n\n\t/**\n\t * Creates a new <code>EffectRimLightMethod</code> object.\n\t *\n\t * @param color The colour of the rim light.\n\t * @param strength The strength of the rim light.\n\t * @param power The power of the rim light. Higher values will result in a higher edge fall-off.\n\t * @param blend The blend mode with which to add the light to the object.\n\t */\n\tconstructor(color:number /*uint*/ = 0xffffff, strength:number = .4, power:number = 2, blend:string = \"mix\")\n\t{\n\t\tsuper();\n\n\t\tthis._blendMode = blend;\n\t\tthis._strength = strength;\n\t\tthis._power = power;\n\n\t\tthis.color = color;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitConstants(shader:ShaderBase, methodVO:MethodVO)\n\t{\n\t\tshader.fragmentConstantData[methodVO.fragmentConstantsIndex + 3] = 1;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitVO(shader:ShaderBase, methodVO:MethodVO)\n\t{\n\t\tmethodVO.needsNormals = true;\n\t\tmethodVO.needsView = true;\n\t}\n\n\n\t/**\n\t * The blend mode with which to add the light to the object.\n\t *\n\t * EffectRimLightMethod.MULTIPLY multiplies the rim light with the material's colour.\n\t * EffectRimLightMethod.ADD adds the rim light with the material's colour.\n\t * EffectRimLightMethod.MIX provides normal alpha blending.\n\t */\n\tpublic get blendMode():string\n\t{\n\t\treturn this._blendMode;\n\t}\n\n\tpublic set blendMode(value:string)\n\t{\n\t\tif (this._blendMode == value)\n\t\t\treturn;\n\n\t\tthis._blendMode = value;\n\n\t\tthis.iInvalidateShaderProgram();\n\t}\n\n\t/**\n\t * The color of the rim light.\n\t */\n\tpublic get color():number /*uint*/\n\t{\n\t\treturn this._color;\n\t}\n\n\tpublic set color(value:number /*uint*/)\n\t{\n\t\tthis._color = value;\n\t\tthis._colorR = ((value >> 16) & 0xff)/0xff;\n\t\tthis._colorG = ((value >> 8) & 0xff)/0xff;\n\t\tthis._colorB = (value & 0xff)/0xff;\n\t}\n\n\t/**\n\t * The strength of the rim light.\n\t */\n\tpublic get strength():number\n\t{\n\t\treturn this._strength;\n\t}\n\n\tpublic set strength(value:number)\n\t{\n\t\tthis._strength = value;\n\t}\n\n\t/**\n\t * The power of the rim light. Higher values will result in a higher edge fall-off.\n\t */\n\tpublic get power():number\n\t{\n\t\treturn this._power;\n\t}\n\n\tpublic set power(value:number)\n\t{\n\t\tthis._power = value;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iActivate(shader:ShaderBase, methodVO:MethodVO, stage:Stage)\n\t{\n\t\tvar index:number /*int*/ = methodVO.fragmentConstantsIndex;\n\t\tvar data:Float32Array = shader.fragmentConstantData;\n\t\tdata[index] = this._colorR;\n\t\tdata[index + 1] = this._colorG;\n\t\tdata[index + 2] = this._colorB;\n\t\tdata[index + 4] = this._strength;\n\t\tdata[index + 5] = this._power;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentCode(shader:ShaderBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar dataRegister:ShaderRegisterElement = registerCache.getFreeFragmentConstant();\n\t\tvar dataRegister2:ShaderRegisterElement = registerCache.getFreeFragmentConstant();\n\t\tvar temp:ShaderRegisterElement = registerCache.getFreeFragmentVectorTemp();\n\t\tvar code:string = \"\";\n\n\t\tmethodVO.fragmentConstantsIndex = dataRegister.index*4;\n\n\t\tcode += \"dp3 \" + temp + \".x, \" + sharedRegisters.viewDirFragment + \".xyz, \" + sharedRegisters.normalFragment + \".xyz\\n\" +\n\t\t\t\"sat \" + temp + \".x, \" + temp + \".x\\n\" +\n\t\t\t\"sub \" + temp + \".x, \" + dataRegister + \".w, \" + temp + \".x\\n\" +\n\t\t\t\"pow \" + temp + \".x, \" + temp + \".x, \" + dataRegister2 + \".y\\n\" +\n\t\t\t\"mul \" + temp + \".x, \" + temp + \".x, \" + dataRegister2 + \".x\\n\" +\n\t\t\t\"sub \" + temp + \".x, \" + dataRegister + \".w, \" + temp + \".x\\n\" +\n\t\t\t\"mul \" + targetReg + \".xyz, \" + targetReg + \".xyz, \" + temp + \".x\\n\" +\n\t\t\t\"sub \" + temp + \".w, \" + dataRegister + \".w, \" + temp + \".x\\n\";\n\n\t\tif (this._blendMode == EffectRimLightMethod.ADD) {\n\t\t\tcode += \"mul \" + temp + \".xyz, \" + temp + \".w, \" + dataRegister + \".xyz\\n\" +\n\t\t\t\t\"add \" + targetReg + \".xyz, \" + targetReg + \".xyz, \" + temp + \".xyz\\n\";\n\t\t} else if (this._blendMode == EffectRimLightMethod.MULTIPLY) {\n\t\t\tcode += \"mul \" + temp + \".xyz, \" + temp + \".w, \" + dataRegister + \".xyz\\n\" +\n\t\t\t\t\"mul \" + targetReg + \".xyz, \" + targetReg + \".xyz, \" + temp + \".xyz\\n\";\n\t\t} else {\n\t\t\tcode += \"sub \" + temp + \".xyz, \" + dataRegister + \".xyz, \" + targetReg + \".xyz\\n\" +\n\t\t\t\t\"mul \" + temp + \".xyz, \" + temp + \".xyz, \" + temp + \".w\\n\" +\n\t\t\t\t\"add \" + targetReg + \".xyz, \" + targetReg + \".xyz, \" + temp + \".xyz\\n\";\n\t\t}\n\n\t\treturn code;\n\t}\n}\n\nexport = EffectRimLightMethod;",
    "import ShaderBase\t\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderBase\");\nimport LightingShader\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/LightingShader\");\nimport ShaderRegisterCache\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterCache\");\nimport ShaderRegisterData\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterData\");\nimport ShaderRegisterElement\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterElement\");\n\nimport MethodVO\t\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/data/MethodVO\");\nimport ShadingMethodBase\t\t\t= require(\"awayjs-methodmaterials/lib/methods/ShadingMethodBase\");\n\n/**\n * LightingMethodBase provides an abstract base method for shading methods that uses lights.\n * Used for diffuse and specular shaders only.\n */\nclass LightingMethodBase extends ShadingMethodBase\n{\n\t/**\n\t * A method that is exposed to wrappers in case the strength needs to be controlled\n\t */\n\tpublic _iModulateMethod:(shader:ShaderBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData) => string;\n\n\t/**\n\t * Creates a new LightingMethodBase.\n\t */\n\tconstructor()\n\t{\n\t\tsuper();\n\t}\n\n\t/**\n\t * Get the fragment shader code that will be needed before any per-light code is added.\n\t * @param methodVO The MethodVO object containing the method data for the currently compiled material pass.\n\t * @param regCache The register cache used during the compilation.\n\t * @private\n\t */\n\tpublic iGetFragmentPreLightingCode(shader:LightingShader, methodVO:MethodVO, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\treturn \"\";\n\t}\n\n\t/**\n\t * Get the fragment shader code that will generate the code relevant to a single light.\n\t *\n\t * @param methodVO The MethodVO object containing the method data for the currently compiled material pass.\n\t * @param lightDirReg The register containing the light direction vector.\n\t * @param lightColReg The register containing the light colour.\n\t * @param regCache The register cache used during the compilation.\n\t */\n\tpublic iGetFragmentCodePerLight(shader:LightingShader, methodVO:MethodVO, lightDirReg:ShaderRegisterElement, lightColReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\treturn \"\";\n\t}\n\n\t/**\n\t * Get the fragment shader code that will generate the code relevant to a single light probe object.\n\t *\n\t * @param methodVO The MethodVO object containing the method data for the currently compiled material pass.\n\t * @param cubeMapReg The register containing the cube map for the current probe\n\t * @param weightRegister A string representation of the register + component containing the current weight\n\t * @param regCache The register cache providing any necessary registers to the shader\n\t */\n\tpublic iGetFragmentCodePerProbe(shader:LightingShader, methodVO:MethodVO, cubeMapReg:ShaderRegisterElement, weightRegister:string, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\treturn \"\";\n\t}\n\n\t/**\n\t * Get the fragment shader code that should be added after all per-light code. Usually composits everything to the target register.\n\t *\n\t * @param methodVO The MethodVO object containing the method data for the currently compiled material pass.\n\t * @param regCache The register cache used during the compilation.\n\t * @param targetReg The register containing the final shading output.\n\t * @private\n\t */\n\tpublic iGetFragmentPostLightingCode(shader:LightingShader, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\treturn \"\";\n\t}\n}\n\nexport = LightingMethodBase;",
    "import Camera\t\t\t\t\t\t\t= require(\"awayjs-display/lib/entities/Camera\");\nimport TextureBase\t\t\t\t\t\t= require(\"awayjs-display/lib/textures/TextureBase\");\n\nimport Stage\t\t\t\t\t\t\t= require(\"awayjs-stagegl/lib/base/Stage\");\n\nimport RenderableBase\t\t\t\t\t= require(\"awayjs-renderergl/lib/renderables/RenderableBase\");\nimport ShaderBase\t\t\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderBase\");\nimport ShaderRegisterCache\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterCache\");\nimport ShaderRegisterData\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterData\");\nimport ShaderRegisterElement\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterElement\");\n\nimport MethodVO\t\t\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/data/MethodVO\");\nimport ShadingMethodBase\t\t\t\t= require(\"awayjs-methodmaterials/lib/methods/ShadingMethodBase\");\n\n/**\n * NormalBasicMethod is the default method for standard tangent-space normal mapping.\n */\nclass NormalBasicMethod extends ShadingMethodBase\n{\n\tprivate _normalMap:TextureBase;\n\n\t/**\n\t * Creates a new NormalBasicMethod object.\n\t */\n\tconstructor(normalMap:TextureBase = null)\n\t{\n\t\tsuper();\n\n\t\tthis._normalMap = normalMap;\n\n\t\tif (this._normalMap)\n\t\t\tthis.iAddTexture(this._normalMap);\n\t}\n\n\tpublic iIsUsed(shader:ShaderBase):boolean\n\t{\n\t\tif (this._normalMap && shader.normalDependencies)\n\t\t\treturn true;\n\n\t\treturn false;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitVO(shader:ShaderBase, methodVO:MethodVO)\n\t{\n\t\tif (this._normalMap) {\n\t\t\tmethodVO.textureVO = shader.getTextureVO(this._normalMap);\n\t\t\tshader.uvDependencies++;\n\t\t}\n\t}\n\n\t/**\n\t * Indicates whether or not this method outputs normals in tangent space. Override for object-space normals.\n\t */\n\tpublic iOutputsTangentNormals():boolean\n\t{\n\t\treturn true;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic copyFrom(method:ShadingMethodBase)\n\t{\n\t\tvar s:any = method;\n\t\tvar bnm:NormalBasicMethod = <NormalBasicMethod> method;\n\n\t\tif (bnm.normalMap != null)\n\t\t\tthis.normalMap = bnm.normalMap;\n\t}\n\n\t/**\n\t * The texture containing the normals per pixel.\n\t */\n\tpublic get normalMap():TextureBase\n\t{\n\t\treturn this._normalMap;\n\t}\n\n\tpublic set normalMap(value:TextureBase)\n\t{\n\t\tif (this._normalMap == value)\n\t\t\treturn;\n\n\t\tif (this._normalMap)\n\t\t\tthis.iRemoveTexture(this._normalMap);\n\n\t\tthis._normalMap = value;\n\n\t\tif (this._normalMap)\n\t\t\tthis.iAddTexture(this._normalMap);\n\n\t\tthis.iInvalidateShaderProgram();\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic dispose()\n\t{\n\t\tif (this._normalMap)\n\t\t\tthis._normalMap = null;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iActivate(shader:ShaderBase, methodVO:MethodVO, stage:Stage)\n\t{\n\t\tif (this._normalMap)\n\t\t\tmethodVO.textureVO.activate(shader);\n\t}\n\n\tpublic iSetRenderState(shader:ShaderBase, methodVO:MethodVO, renderable:RenderableBase, stage:Stage, camera:Camera)\n\t{\n\t\tif (this._normalMap)\n\t\t\tmethodVO.textureVO._setRenderState(renderable, shader);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentCode(shader:ShaderBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = \"\";\n\n\t\tif (this._normalMap)\n\t\t\tcode += methodVO.textureVO._iGetFragmentCode(shader, targetReg, registerCache, sharedRegisters, sharedRegisters.uvVarying);\n\n\n\t\tcode += \"sub \" + targetReg + \".xyz, \" + targetReg + \".xyz, \" + sharedRegisters.commons + \".xxx\\n\" +\n\t\t\t\"nrm \" + targetReg + \".xyz, \" + targetReg + \"\\n\";\n\n\t\treturn code;\n\t}\n}\n\nexport = NormalBasicMethod;",
    "import Single2DTexture\t\t\t\t\t= require(\"awayjs-display/lib/textures/Single2DTexture\");\nimport TextureBase\t\t\t\t\t\t= require(\"awayjs-display/lib/textures/TextureBase\");\n\nimport ShaderBase\t\t\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderBase\");\nimport ShaderRegisterCache\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterCache\");\nimport ShaderRegisterData\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterData\");\nimport ShaderRegisterElement\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterElement\");\n\nimport MethodVO\t\t\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/data/MethodVO\");\nimport NormalBasicMethod\t\t\t\t= require(\"awayjs-methodmaterials/lib/methods/NormalBasicMethod\");\nimport ShadingMethodBase\t\t\t\t= require(\"awayjs-methodmaterials/lib/methods/ShadingMethodBase\");\n\n/**\n * NormalHeightMapMethod provides a normal map method that uses a height map to calculate the normals.\n */\nclass NormalHeightMapMethod extends NormalBasicMethod\n{\n\tprivate _worldXYRatio:number;\n\tprivate _worldXZRatio:number;\n\n\t/**\n\t * Creates a new NormalHeightMapMethod method.\n\t *\n\t * @param heightMap The texture containing the height data. 0 means low, 1 means high.\n\t * @param worldWidth The width of the 'world'. This is used to map uv coordinates' u component to scene dimensions.\n\t * @param worldHeight The height of the 'world'. This is used to map the height map values to scene dimensions.\n\t * @param worldDepth The depth of the 'world'. This is used to map uv coordinates' v component to scene dimensions.\n\t */\n\tconstructor(heightMap:TextureBase, worldWidth:number, worldHeight:number, worldDepth:number)\n\t{\n\t\tsuper();\n\n\t\tthis.normalMap = heightMap;\n\t\tthis._worldXYRatio = worldWidth/worldHeight;\n\t\tthis._worldXZRatio = worldDepth/worldHeight;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitConstants(shader:ShaderBase, methodVO:MethodVO)\n\t{\n\t\tvar index:number /*int*/ = methodVO.fragmentConstantsIndex;\n\t\tvar data:Float32Array = shader.fragmentConstantData;\n\t\tdata[index] = 1/(<Single2DTexture> this.normalMap).image2D.width;\n\t\tdata[index + 1] = 1/(<Single2DTexture> this.normalMap).image2D.height;\n\t\tdata[index + 2] = 0;\n\t\tdata[index + 3] = 1;\n\t\tdata[index + 4] = this._worldXYRatio;\n\t\tdata[index + 5] = this._worldXZRatio;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic get tangentSpace():boolean\n\t{\n\t\treturn false;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic copyFrom(method:ShadingMethodBase)\n\t{\n\t\tsuper.copyFrom(method);\n\n\t\tthis._worldXYRatio = (<NormalHeightMapMethod> method)._worldXYRatio;\n\t\tthis._worldXZRatio = (<NormalHeightMapMethod> method)._worldXZRatio;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentCode(shader:ShaderBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = \"\";\n\t\tvar temp:ShaderRegisterElement = registerCache.getFreeFragmentVectorTemp();\n\t\tregisterCache.addFragmentTempUsages(temp, 1);\n\n\t\tvar dataReg:ShaderRegisterElement = registerCache.getFreeFragmentConstant();\n\t\tvar dataReg2:ShaderRegisterElement = registerCache.getFreeFragmentConstant();\n\n\t\tmethodVO.fragmentConstantsIndex = dataReg.index*4;\n\n\t\tcode+= methodVO.textureVO._iGetFragmentCode(shader, targetReg, registerCache, sharedRegisters, sharedRegisters.uvVarying) +\n\n\t\t\t\"add \" + temp + \", \" + sharedRegisters.uvVarying + \", \" + dataReg + \".xzzz\\n\" +\n\n\t\tmethodVO.textureVO._iGetFragmentCode(shader, temp, registerCache, sharedRegisters, temp) +\n\n\t\t\t\"sub \" + targetReg + \".x, \" + targetReg + \".x, \" + temp + \".x\\n\" +\n\t\t\t\"add \" + temp + \", \" + sharedRegisters.uvVarying + \", \" + dataReg + \".zyzz\\n\" +\n\n\t\tmethodVO.textureVO._iGetFragmentCode(shader, temp, registerCache, sharedRegisters, temp) +\n\n\t\t\t\"sub \" + targetReg + \".z, \" + targetReg + \".z, \" + temp + \".x\\n\" +\n\t\t\t\"mov \" + targetReg + \".y, \" + dataReg + \".w\\n\" +\n\t\t\t\"mul \" + targetReg + \".xz, \" + targetReg + \".xz, \" + dataReg2 + \".xy\\n\" +\n\t\t\t\"nrm \" + targetReg + \".xyz, \" + targetReg + \".xyz\\n\";\n\n\t\tregisterCache.removeFragmentTempUsage(temp);\n\n\t\treturn code;\n\t}\n}\n\nexport = NormalHeightMapMethod;",
    "import Camera\t\t\t\t\t\t\t= require(\"awayjs-display/lib/entities/Camera\");\nimport TextureBase\t\t\t\t\t\t= require(\"awayjs-display/lib/textures/TextureBase\");\n\nimport Stage\t\t\t\t\t\t\t= require(\"awayjs-stagegl/lib/base/Stage\");\n\nimport RenderableBase\t\t\t\t\t= require(\"awayjs-renderergl/lib/renderables/RenderableBase\");\nimport ShaderBase\t\t\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderBase\");\nimport ShaderRegisterCache\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterCache\");\nimport ShaderRegisterData\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterData\");\nimport ShaderRegisterElement\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterElement\");\n\nimport MethodVO\t\t\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/data/MethodVO\");\nimport NormalBasicMethod\t\t\t\t= require(\"awayjs-methodmaterials/lib/methods/NormalBasicMethod\");\n\n/**\n * NormalSimpleWaterMethod provides a basic normal map method to create water ripples by translating two wave normal maps.\n */\nclass NormalSimpleWaterMethod extends NormalBasicMethod\n{\n\tprivate _secondaryNormalMap:TextureBase;\n\tprivate _water1OffsetX:number = 0;\n\tprivate _water1OffsetY:number = 0;\n\tprivate _water2OffsetX:number = 0;\n\tprivate _water2OffsetY:number = 0;\n\n\t/**\n\t * Creates a new NormalSimpleWaterMethod object.\n\t * @param waveMap1 A normal map containing one layer of a wave structure.\n\t * @param waveMap2 A normal map containing a second layer of a wave structure.\n\t */\n\tconstructor(normalMap:TextureBase = null, secondaryNormalMap:TextureBase = null)\n\t{\n\t\tsuper(normalMap);\n\n\t\tthis._secondaryNormalMap = secondaryNormalMap;\n\n\t\tif (this._secondaryNormalMap)\n\t\t\tthis.iAddTexture(this._secondaryNormalMap);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitConstants(shader:ShaderBase, methodVO:MethodVO)\n\t{\n\t\tvar index:number = methodVO.fragmentConstantsIndex;\n\t\tvar data:Float32Array = shader.fragmentConstantData;\n\t\tdata[index] = .5;\n\t\tdata[index + 1] = 0;\n\t\tdata[index + 2] = 0;\n\t\tdata[index + 3] = 1;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitVO(shader:ShaderBase, methodVO:MethodVO)\n\t{\n\t\tsuper.iInitVO(shader, methodVO);\n\t\t\n\t\tif (this._secondaryNormalMap) {\n\t\t\tmethodVO.secondaryTextureVO = shader.getTextureVO(this._secondaryNormalMap);\n\t\t\tshader.uvDependencies++;\n\t\t}\n\t}\n\n\t/**\n\t * The translation of the first wave layer along the X-axis.\n\t */\n\tpublic get water1OffsetX():number\n\t{\n\t\treturn this._water1OffsetX;\n\t}\n\n\tpublic set water1OffsetX(value:number)\n\t{\n\t\tthis._water1OffsetX = value;\n\t}\n\n\t/**\n\t * The translation of the first wave layer along the Y-axis.\n\t */\n\tpublic get water1OffsetY():number\n\t{\n\t\treturn this._water1OffsetY;\n\t}\n\n\tpublic set water1OffsetY(value:number)\n\t{\n\t\tthis._water1OffsetY = value;\n\t}\n\n\t/**\n\t * The translation of the second wave layer along the X-axis.\n\t */\n\tpublic get water2OffsetX():number\n\t{\n\t\treturn this._water2OffsetX;\n\t}\n\n\tpublic set water2OffsetX(value:number)\n\t{\n\t\tthis._water2OffsetX = value;\n\t}\n\n\t/**\n\t * The translation of the second wave layer along the Y-axis.\n\t */\n\tpublic get water2OffsetY():number\n\t{\n\t\treturn this._water2OffsetY;\n\t}\n\n\tpublic set water2OffsetY(value:number)\n\t{\n\t\tthis._water2OffsetY = value;\n\t}\n\n\t/**\n\t * A second normal map that will be combined with the first to create a wave-like animation pattern.\n\t */\n\tpublic get secondaryNormalMap():TextureBase\n\t{\n\t\treturn this._secondaryNormalMap;\n\t}\n\n\tpublic set secondaryNormalMap(value:TextureBase)\n\t{\n\t\tif (this._secondaryNormalMap == value)\n\t\t\treturn;\n\n\t\tif (this._secondaryNormalMap)\n\t\t\tthis.iRemoveTexture(this._secondaryNormalMap);\n\n\t\tthis._secondaryNormalMap = value;\n\n\t\tif (this._secondaryNormalMap)\n\t\t\tthis.iAddTexture(this._secondaryNormalMap);\n\n\t\tthis.iInvalidateShaderProgram();\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic dispose()\n\t{\n\t\tsuper.dispose();\n\n\t\tthis._secondaryNormalMap = null;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iActivate(shader:ShaderBase, methodVO:MethodVO, stage:Stage)\n\t{\n\t\tsuper.iActivate(shader, methodVO, stage);\n\n\t\tvar data:Float32Array = shader.fragmentConstantData;\n\t\tvar index:number = methodVO.fragmentConstantsIndex;\n\n\t\tdata[index + 4] = this._water1OffsetX;\n\t\tdata[index + 5] = this._water1OffsetY;\n\t\tdata[index + 6] = this._water2OffsetX;\n\t\tdata[index + 7] = this._water2OffsetY;\n\n\t\tif (this._secondaryNormalMap)\n\t\t\tmethodVO.secondaryTextureVO.activate(shader);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iSetRenderState(shader:ShaderBase, methodVO:MethodVO, renderable:RenderableBase, stage:Stage, camera:Camera)\n\t{\n\t\tsuper.iSetRenderState(shader, methodVO, renderable, stage, camera);\n\n\t\tif (this._secondaryNormalMap)\n\t\t\tmethodVO.secondaryTextureVO._setRenderState(renderable, shader);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentCode(shader:ShaderBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = \"\";\n\t\tvar temp:ShaderRegisterElement = registerCache.getFreeFragmentVectorTemp();\n\t\tregisterCache.addFragmentTempUsages(temp, 1);\n\n\t\tvar dataReg:ShaderRegisterElement = registerCache.getFreeFragmentConstant();\n\t\tvar dataReg2:ShaderRegisterElement = registerCache.getFreeFragmentConstant();\n\t\tmethodVO.fragmentConstantsIndex = dataReg.index*4;\n\n\t\tcode += \"add \" + temp + \", \" + sharedRegisters.uvVarying + \", \" + dataReg2 + \".xyxy\\n\";\n\n\t\tif (this.normalMap)\n\t\t\tcode += methodVO.textureVO._iGetFragmentCode(shader, targetReg, registerCache, sharedRegisters, temp);\n\n\t\tcode += \"add \" + temp + \", \" + sharedRegisters.uvVarying + \", \" + dataReg2 + \".zwzw\\n\";\n\n\t\tif (this._secondaryNormalMap)\n\t\t\tcode += methodVO.secondaryTextureVO._iGetFragmentCode(shader, temp, registerCache, sharedRegisters, temp);\n\n\t\tcode +=\t\"add \" + targetReg + \", \" + targetReg + \", \" + temp + \"\t\t\\n\" +\n\t\t\t\"mul \" + targetReg + \", \" + targetReg + \", \" + dataReg + \".x\t\\n\" +\n\t\t\t\"sub \" + targetReg + \".xyz, \" + targetReg + \".xyz, \" + sharedRegisters.commons + \".xxx\t\\n\" +\n\t\t\t\"nrm \" + targetReg + \".xyz, \" + targetReg + \".xyz\t\t\t\t\t\t\t\\n\";\n\n\t\treturn code;\n\t}\n}\n\nexport = NormalSimpleWaterMethod;",
    "import AssetBase\t\t\t\t\t= require(\"awayjs-core/lib/library/AssetBase\");\n\nimport Camera\t\t\t\t\t\t= require(\"awayjs-display/lib/entities/Camera\");\nimport IRenderOwner\t\t\t\t\t= require(\"awayjs-display/lib/base/IRenderOwner\");\nimport TextureBase\t\t\t\t\t= require(\"awayjs-display/lib/textures/TextureBase\");\n\nimport Stage\t\t\t\t\t\t= require(\"awayjs-stagegl/lib/base/Stage\");\n\nimport RenderableBase\t\t\t\t= require(\"awayjs-renderergl/lib/renderables/RenderableBase\");\nimport ShadingMethodEvent\t\t\t= require(\"awayjs-renderergl/lib/events/ShadingMethodEvent\");\nimport ShaderBase\t\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderBase\");\nimport ShaderRegisterCache\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterCache\");\nimport ShaderRegisterData\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterData\");\nimport ShaderRegisterElement\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterElement\");\n\nimport MethodVO\t\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/data/MethodVO\");\n\n\n/**\n * ShadingMethodBase provides an abstract base method for shading methods, used by compiled passes to compile\n * the final shading program.\n */\nclass ShadingMethodBase extends AssetBase\n{\n\tpublic _textures:Array<TextureBase> = new Array<TextureBase>();\n\n\tpublic _owners:Array<IRenderOwner> = new Array<IRenderOwner>();\n\tpublic _counts:Array<number> = new Array<number>();\n\n\tpublic static assetType:string = \"[asset ShadingMethod]\";\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic get assetType():string\n\t{\n\t\treturn ShadingMethodBase.assetType;\n\t}\n\n\t/**\n\t * Create a new ShadingMethodBase object.\n\t */\n\tconstructor()\n\t{\n\t\tsuper();\n\t}\n\n\tpublic iIsUsed(shader:ShaderBase):boolean\n\t{\n\t\treturn true;\n\t}\n\n\t/**\n\t * Initializes the properties for a MethodVO, including register and texture indices.\n\t *\n\t * @param methodVO The MethodVO object linking this method with the pass currently being compiled.\n\t *\n\t * @internal\n\t */\n\tpublic iInitVO(shader:ShaderBase, methodVO:MethodVO)\n\t{\n\n\t}\n\n\t/**\n\t * Initializes unchanging shader constants using the data from a MethodVO.\n\t *\n\t * @param methodVO The MethodVO object linking this method with the pass currently being compiled.\n\t *\n\t * @internal\n\t */\n\tpublic iInitConstants(shader:ShaderBase, methodVO:MethodVO)\n\t{\n\n\n\t}\n\n\t/**\n\t * Indicates whether or not this method expects normals in tangent space. Override for object-space normals.\n\t */\n\tpublic iUsesTangentSpace():boolean\n\t{\n\t\treturn true;\n\t}\n\n\t/**\n\t * Cleans up any resources used by the current object.\n\t */\n\tpublic dispose()\n\t{\n\n\t}\n\n\n\tpublic iAddOwner(owner:IRenderOwner)\n\t{\n\t\t//a method can be used more than once in the same material, so we check for this\n\t\tvar index:number = this._owners.indexOf(owner);\n\n\t\tif (index != -1) {\n\t\t\tthis._counts[index]++;\n\t\t} else {\n\t\t\tthis._owners.push(owner);\n\t\t\tthis._counts.push(1);\n\n\t\t\t//add textures\n\t\t\tvar len:number = this._textures.length;\n\t\t\tfor (var i:number = 0; i< len; i++)\n\t\t\t\tthis._textures[i].iAddOwner(owner);\n\t\t}\n\t}\n\n\tpublic iRemoveOwner(owner:IRenderOwner)\n\t{\n\t\tvar index:number = this._owners.indexOf(owner);\n\n\t\tif (this._counts[index] != 1) {\n\t\t\tthis._counts[index]--;\n\t\t} else {\n\t\t\tthis._owners.splice(index, 1);\n\t\t\tthis._counts.splice(index, 1);\n\n\t\t\t//remove textures\n\t\t\tvar len:number = this._textures.length;\n\t\t\tfor (var i:number = 0; i< len; i++)\n\t\t\t\tthis._textures[i].iRemoveOwner(owner);\n\t\t}\n\t}\n\n\n\t/**\n\t *\n\t */\n\tpublic iAddTexture(texture:TextureBase)\n\t{\n\t\tthis._textures.push(texture);\n\n\t\tvar len:number = this._owners.length;\n\t\tfor (var i:number = 0; i < len; i++)\n\t\t\ttexture.iAddOwner(this._owners[i]);\n\t}\n\n\t/**\n\t *\n\t */\n\tpublic iRemoveTexture(texture:TextureBase)\n\t{\n\t\tthis._textures.splice(this._textures.indexOf(texture), 1);\n\n\t\tvar len:number = this._owners.length;\n\t\tfor (var i:number = 0; i < len; i++)\n\t\t\ttexture.iRemoveOwner(this._owners[i]);\n\t}\n\n\t/**\n\t * Resets the compilation state of the method.\n\t *\n\t * @internal\n\t */\n\tpublic iReset()\n\t{\n\t\tthis.iCleanCompilationData();\n\t}\n\n\t/**\n\t * Resets the method's state for compilation.\n\t *\n\t * @internal\n\t */\n\tpublic iCleanCompilationData()\n\t{\n\t}\n\n\t/**\n\t * Get the vertex shader code for this method.\n\t * @param vo The MethodVO object linking this method with the pass currently being compiled.\n\t * @param regCache The register cache used during the compilation.\n\t *\n\t * @internal\n\t */\n\tpublic iGetVertexCode(shader:ShaderBase, methodVO:MethodVO, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\treturn \"\";\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentCode(shader:ShaderBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\treturn null;\n\t}\n\n\t/**\n\t * Sets the render state for this method.\n\t *\n\t * @param methodVO The MethodVO object linking this method with the pass currently being compiled.\n\t * @param stage The Stage object currently used for rendering.\n\t *\n\t * @internal\n\t */\n\tpublic iActivate(shader:ShaderBase, methodVO:MethodVO, stage:Stage)\n\t{\n\n\t}\n\n\t/**\n\t * Sets the render state for a single renderable.\n\t *\n\t * @param vo The MethodVO object linking this method with the pass currently being compiled.\n\t * @param renderable The renderable currently being rendered.\n\t * @param stage The Stage object currently used for rendering.\n\t * @param camera The camera from which the scene is currently rendered.\n\t *\n\t * @internal\n\t */\n\tpublic iSetRenderState(shader:ShaderBase, methodVO:MethodVO, renderable:RenderableBase, stage:Stage, camera:Camera)\n\t{\n\n\t}\n\n\t/**\n\t * Clears the render state for this method.\n\t * @param vo The MethodVO object linking this method with the pass currently being compiled.\n\t * @param stage The Stage object currently used for rendering.\n\t *\n\t * @internal\n\t */\n\tpublic iDeactivate(shader:ShaderBase, methodVO:MethodVO, stage:Stage)\n\t{\n\n\t}\n\n\t/**\n\t * Marks the shader program as invalid, so it will be recompiled before the next render.\n\t *\n\t * @internal\n\t */\n\tpublic iInvalidateShaderProgram()\n\t{\n\t\tthis.dispatchEvent(new ShadingMethodEvent(ShadingMethodEvent.SHADER_INVALIDATED));\n\t}\n\n\t/**\n\t * Copies the state from a ShadingMethodBase object into the current object.\n\t */\n\tpublic copyFrom(method:ShadingMethodBase)\n\t{\n\t}\n}\n\nexport = ShadingMethodBase;",
    "import Event\t\t\t\t\t\t\t= require(\"awayjs-core/lib/events/Event\");\n\nimport Camera\t\t\t\t\t\t\t= require(\"awayjs-display/lib/entities/Camera\");\nimport DirectionalLight\t\t\t\t\t= require(\"awayjs-display/lib/entities/DirectionalLight\");\nimport CascadeShadowMapper\t\t\t\t= require(\"awayjs-display/lib/materials/shadowmappers/CascadeShadowMapper\");\nimport TextureBase\t\t\t\t\t\t= require(\"awayjs-display/lib/textures/TextureBase\");\n\nimport Stage\t\t\t\t\t\t\t= require(\"awayjs-stagegl/lib/base/Stage\");\n\nimport RenderableBase\t\t\t\t\t= require(\"awayjs-renderergl/lib/renderables/RenderableBase\");\nimport ShadingMethodEvent\t\t\t\t= require(\"awayjs-renderergl/lib/events/ShadingMethodEvent\");\nimport LightingShader\t\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/LightingShader\");\nimport ShaderBase\t\t\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderBase\");\nimport ShaderRegisterCache\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterCache\");\nimport ShaderRegisterData\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterData\");\nimport ShaderRegisterElement\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterElement\");\n\nimport MethodVO\t\t\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/data/MethodVO\");\nimport ShadowMapMethodBase\t\t\t\t= require(\"awayjs-methodmaterials/lib/methods/ShadowMapMethodBase\");\nimport ShadowMethodBase\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/methods/ShadowMethodBase\");\n\n/**\n * ShadowCascadeMethod is a shadow map method to apply cascade shadow mapping on materials.\n * Must be used with a DirectionalLight with a CascadeShadowMapper assigned to its shadowMapper property.\n *\n * @see away.lights.CascadeShadowMapper\n */\nclass ShadowCascadeMethod extends ShadowMapMethodBase\n{\n\tprivate _baseMethod:ShadowMethodBase;\n\tprivate _cascadeShadowMapper:CascadeShadowMapper;\n\tprivate _depthMapCoordVaryings:Array<ShaderRegisterElement>;\n\tprivate _cascadeProjections:Array<ShaderRegisterElement>;\n\n\t/**\n\t * Creates a new ShadowCascadeMethod object.\n\t *\n\t * @param shadowMethodBase The shadow map sampling method used to sample individual cascades (fe: ShadowHardMethod, ShadowSoftMethod)\n\t */\n\tconstructor(shadowMethodBase:ShadowMethodBase)\n\t{\n\t\tsuper(shadowMethodBase.castingLight);\n\n\t\tthis._baseMethod = shadowMethodBase;\n\t\tif (!(this._pCastingLight instanceof DirectionalLight))\n\t\t\tthrow new Error(\"ShadowCascadeMethod is only compatible with DirectionalLight\");\n\n\t\tthis._cascadeShadowMapper = <CascadeShadowMapper> this._pCastingLight.shadowMapper;\n\n\t\tif (!this._cascadeShadowMapper)\n\t\t\tthrow new Error(\"ShadowCascadeMethod requires a light that has a CascadeShadowMapper instance assigned to shadowMapper.\");\n\n\t\tthis._cascadeShadowMapper.addEventListener(Event.CHANGE, (event:Event) => this.onCascadeChange(event));\n\t\tthis._baseMethod.addEventListener(ShadingMethodEvent.SHADER_INVALIDATED, (event:ShadingMethodEvent) => this.onShaderInvalidated(event));\n\t}\n\n\t/**\n\t * The shadow map sampling method used to sample individual cascades. These are typically those used in conjunction\n\t * with a DirectionalShadowMapper.\n\t *\n\t * @see ShadowHardMethod\n\t * @see ShadowSoftMethod\n\t */\n\tpublic get baseMethod():ShadowMethodBase\n\t{\n\t\treturn this._baseMethod;\n\t}\n\n\tpublic set baseMethod(value:ShadowMethodBase)\n\t{\n\t\tif (this._baseMethod == value)\n\t\t\treturn;\n\n\t\tthis._baseMethod.removeEventListener(ShadingMethodEvent.SHADER_INVALIDATED, (event:ShadingMethodEvent) => this.onShaderInvalidated(event));\n\n\t\tthis._baseMethod = value;\n\n\t\tthis._baseMethod.addEventListener(ShadingMethodEvent.SHADER_INVALIDATED, (event:ShadingMethodEvent) => this.onShaderInvalidated(event));\n\n\t\tthis.iInvalidateShaderProgram();\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitVO(shader:LightingShader, methodVO:MethodVO)\n\t{\n\t\tvar tempVO:MethodVO = new MethodVO(this._baseMethod);\n\t\tthis._baseMethod.iInitVO(shader, tempVO);\n\n\t\tmethodVO.needsGlobalVertexPos = true;\n\t\tmethodVO.needsProjection = true;\n\n\t\tmethodVO.textureVO = shader.getTextureVO(this._pCastingLight.shadowMapper.depthMap);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitConstants(shader:ShaderBase, methodVO:MethodVO)\n\t{\n\t\tvar fragmentData:Float32Array = shader.fragmentConstantData;\n\t\tvar vertexData:Float32Array = shader.vertexConstantData;\n\t\tvar index:number = methodVO.fragmentConstantsIndex;\n\t\tfragmentData[index] = 1.0;\n\t\tfragmentData[index + 1] = 1/255.0;\n\t\tfragmentData[index + 2] = 1/65025.0;\n\t\tfragmentData[index + 3] = 1/16581375.0;\n\n\t\tfragmentData[index + 6] = .5;\n\t\tfragmentData[index + 7] = -.5;\n\n\t\tindex = methodVO.vertexConstantsIndex;\n\t\tvertexData[index] = .5;\n\t\tvertexData[index + 1] = -.5;\n\t\tvertexData[index + 2] = 0;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iCleanCompilationData()\n\t{\n\t\tsuper.iCleanCompilationData();\n\t\tthis._cascadeProjections = null;\n\t\tthis._depthMapCoordVaryings = null;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetVertexCode(shader:ShaderBase, methodVO:MethodVO, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = \"\";\n\t\tvar dataReg:ShaderRegisterElement = registerCache.getFreeVertexConstant();\n\n\t\tthis.initProjectionsRegs(registerCache);\n\t\tmethodVO.vertexConstantsIndex = dataReg.index*4;\n\n\t\tvar temp:ShaderRegisterElement = registerCache.getFreeVertexVectorTemp();\n\n\t\tfor (var i:number = 0; i < this._cascadeShadowMapper.numCascades; ++i) {\n\t\t\tcode += \"m44 \" + temp + \", \" + sharedRegisters.globalPositionVertex + \", \" + this._cascadeProjections[i] + \"\\n\" +\n\t\t\t\t\"add \" + this._depthMapCoordVaryings[i] + \", \" + temp + \", \" + dataReg + \".zzwz\\n\";\n\t\t}\n\n\t\treturn code;\n\t}\n\n\t/**\n\t * Creates the registers for the cascades' projection coordinates.\n\t */\n\tprivate initProjectionsRegs(registerCache:ShaderRegisterCache)\n\t{\n\t\tthis._cascadeProjections = new Array<ShaderRegisterElement>(this._cascadeShadowMapper.numCascades);\n\t\tthis._depthMapCoordVaryings = new Array<ShaderRegisterElement>(this._cascadeShadowMapper.numCascades);\n\n\t\tfor (var i:number = 0; i < this._cascadeShadowMapper.numCascades; ++i) {\n\t\t\tthis._depthMapCoordVaryings[i] = registerCache.getFreeVarying();\n\t\t\tthis._cascadeProjections[i] = registerCache.getFreeVertexConstant();\n\t\t\tregisterCache.getFreeVertexConstant();\n\t\t\tregisterCache.getFreeVertexConstant();\n\t\t\tregisterCache.getFreeVertexConstant();\n\t\t}\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentCode(shader:ShaderBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar numCascades:number = this._cascadeShadowMapper.numCascades;\n\t\tvar decReg:ShaderRegisterElement = registerCache.getFreeFragmentConstant();\n\t\tvar dataReg:ShaderRegisterElement = registerCache.getFreeFragmentConstant();\n\t\tvar planeDistanceReg:ShaderRegisterElement = registerCache.getFreeFragmentConstant();\n\t\tvar planeDistances:Array<string> = Array<string>( planeDistanceReg + \".x\", planeDistanceReg + \".y\", planeDistanceReg + \".z\", planeDistanceReg + \".w\" );\n\t\tvar code:string;\n\n\t\tmethodVO.fragmentConstantsIndex = decReg.index*4;\n\n\t\tvar inQuad:ShaderRegisterElement = registerCache.getFreeFragmentVectorTemp();\n\t\tregisterCache.addFragmentTempUsages(inQuad, 1);\n\t\tvar uvCoord:ShaderRegisterElement = registerCache.getFreeFragmentVectorTemp();\n\t\tregisterCache.addFragmentTempUsages(uvCoord, 1);\n\n\t\t// assume lowest partition is selected, will be overwritten later otherwise\n\t\tcode = \"mov \" + uvCoord + \", \" + this._depthMapCoordVaryings[numCascades - 1] + \"\\n\";\n\n\t\tfor (var i:number = numCascades - 2; i >= 0; --i) {\n\t\t\tvar uvProjection:ShaderRegisterElement = this._depthMapCoordVaryings[i];\n\n\t\t\t// calculate if in texturemap (result == 0 or 1, only 1 for a single partition)\n\t\t\tcode += \"slt \" + inQuad + \".z, \" + sharedRegisters.projectionFragment + \".z, \" + planeDistances[i] + \"\\n\"; // z = x > minX, w = y > minY\n\n\t\t\tvar temp:ShaderRegisterElement = registerCache.getFreeFragmentVectorTemp();\n\n\t\t\t// linearly interpolate between old and new uv coords using predicate value == conditional toggle to new value if predicate == 1 (true)\n\t\t\tcode += \"sub \" + temp + \", \" + uvProjection + \", \" + uvCoord + \"\\n\" +\n\t\t\t\t\"mul \" + temp + \", \" + temp + \", \" + inQuad + \".z\\n\" +\n\t\t\t\t\"add \" + uvCoord + \", \" + uvCoord + \", \" + temp + \"\\n\";\n\t\t}\n\n\t\tregisterCache.removeFragmentTempUsage(inQuad);\n\n\t\tcode += \"div \" + uvCoord + \", \" + uvCoord + \", \" + uvCoord + \".w\\n\" +\n\t\t\t\"mul \" + uvCoord + \".xy, \" + uvCoord + \".xy, \" + dataReg + \".zw\\n\" +\n\t\t\t\"add \" + uvCoord + \".xy, \" + uvCoord + \".xy, \" + dataReg + \".zz\\n\";\n\n\t\tcode += this._baseMethod._iGetCascadeFragmentCode(shader, methodVO, decReg, uvCoord, targetReg, registerCache, sharedRegisters) +\n\t\t\t\"add \" + targetReg + \".w, \" + targetReg + \".w, \" + dataReg + \".y\\n\";\n\n\t\tregisterCache.removeFragmentTempUsage(uvCoord);\n\n\t\treturn code;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iActivate(shader:ShaderBase, methodVO:MethodVO, stage:Stage)\n\t{\n\t\tmethodVO.textureVO.activate(shader);\n\n\t\tvar vertexData:Float32Array = shader.vertexConstantData;\n\t\tvar vertexIndex:number = methodVO.vertexConstantsIndex;\n\n\t\tshader.vertexConstantData[methodVO.vertexConstantsIndex + 3] = -1/(this._cascadeShadowMapper.depth*this._pEpsilon);\n\n\t\tvar numCascades:number = this._cascadeShadowMapper.numCascades;\n\t\tvertexIndex += 4;\n\t\tfor (var k:number = 0; k < numCascades; ++k) {\n\t\t\tthis._cascadeShadowMapper.getDepthProjections(k).copyRawDataTo(vertexData, vertexIndex, true);\n\t\t\tvertexIndex += 16;\n\t\t}\n\n\t\tvar fragmentData:Float32Array = shader.fragmentConstantData;\n\t\tvar fragmentIndex:number = methodVO.fragmentConstantsIndex;\n\t\tfragmentData[fragmentIndex + 5] = 1 - this._pAlpha;\n\n\t\tvar nearPlaneDistances:Array<number> = this._cascadeShadowMapper._iNearPlaneDistances;\n\n\t\tfragmentIndex += 8;\n\t\tfor (var i:number = 0; i < numCascades; ++i)\n\t\t\tfragmentData[fragmentIndex + i] = nearPlaneDistances[i];\n\n\t\tthis._baseMethod.iActivateForCascade(shader, methodVO, stage);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iSetRenderState(shader:ShaderBase, methodVO:MethodVO, renderable:RenderableBase, stage:Stage, camera:Camera)\n\t{\n\t}\n\n\t/**\n\t * Called when the shadow mappers cascade configuration changes.\n\t */\n\tprivate onCascadeChange(event:Event)\n\t{\n\t\tthis.iInvalidateShaderProgram();\n\t}\n\n\t/**\n\t * Called when the base method's shader code is invalidated.\n\t */\n\tprivate onShaderInvalidated(event:ShadingMethodEvent)\n\t{\n\t\tthis.iInvalidateShaderProgram();\n\t}\n}\n\nexport = ShadowCascadeMethod;",
    "import BitmapImage2D\t\t\t\t\t= require(\"awayjs-core/lib/data/BitmapImage2D\");\n\nimport Camera\t\t\t\t\t\t\t= require(\"awayjs-display/lib/entities/Camera\");\nimport DirectionalLight\t\t\t\t\t= require(\"awayjs-display/lib/entities/DirectionalLight\");\nimport Single2DTexture\t\t\t\t\t= require(\"awayjs-display/lib/textures/Single2DTexture\");\n\nimport Stage\t\t\t\t\t\t\t= require(\"awayjs-stagegl/lib/base/Stage\");\n\nimport RenderableBase\t\t\t\t\t= require(\"awayjs-renderergl/lib/renderables/RenderableBase\");\nimport LightingShader\t\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/LightingShader\");\nimport ShaderBase\t\t\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderBase\");\nimport ShaderRegisterCache\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterCache\");\nimport ShaderRegisterData\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterData\");\nimport ShaderRegisterElement\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterElement\");\n\nimport MethodVO\t\t\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/data/MethodVO\");\nimport ShadowMethodBase\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/methods/ShadowMethodBase\");\n\n/**\n * ShadowDitheredMethod provides a soft shadowing technique by randomly distributing sample points differently for each fragment.\n */\nclass ShadowDitheredMethod extends ShadowMethodBase\n{\n\tprivate static _grainTexture:Single2DTexture;\n\tprivate static _grainUsages:number /*int*/;\n\tprivate static _grainBitmapImage2D:BitmapImage2D;\n\tprivate _depthMapSize:number /*int*/;\n\tprivate _range:number;\n\tprivate _numSamples:number /*int*/;\n\n\t/**\n\t * Creates a new ShadowDitheredMethod object.\n\t * @param castingLight The light casting the shadows\n\t * @param numSamples The amount of samples to take for dithering. Minimum 1, maximum 24.\n\t */\n\tconstructor(castingLight:DirectionalLight, numSamples:number /*int*/ = 4, range:number = 1)\n\t{\n\t\tsuper(castingLight);\n\n\t\tthis._depthMapSize = this._pCastingLight.shadowMapper.depthMapSize;\n\n\t\tthis.numSamples = numSamples;\n\t\tthis.range = range;\n\n\t\t++ShadowDitheredMethod._grainUsages;\n\n\t\tif (!ShadowDitheredMethod._grainTexture)\n\t\t\tthis.initGrainTexture();\n\t}\n\n\t/**\n\t * The amount of samples to take for dithering. Minimum 1, maximum 24. The actual maximum may depend on the\n\t * complexity of the shader.\n\t */\n\tpublic get numSamples():number /*int*/\n\t{\n\t\treturn this._numSamples;\n\t}\n\n\tpublic set numSamples(value:number /*int*/)\n\t{\n\t\tif (value < 1)\n\t\t\tvalue = 1;\n\t\telse if (value > 24)\n\t\t\tvalue = 24;\n\n\t\tif (this._numSamples == value)\n\t\t\treturn;\n\n\t\tthis._numSamples = value;\n\n\t\tthis.iInvalidateShaderProgram();\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitVO(shader:LightingShader, methodVO:MethodVO)\n\t{\n\t\tsuper.iInitVO(shader, methodVO);\n\n\t\tmethodVO.needsProjection = true;\n\n\t\tmethodVO.secondaryTextureVO = shader.getTextureVO(ShadowDitheredMethod._grainTexture);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitConstants(shader:ShaderBase, methodVO:MethodVO)\n\t{\n\t\tsuper.iInitConstants(shader, methodVO);\n\n\t\tvar fragmentData:Float32Array = shader.fragmentConstantData;\n\t\tvar index:number /*int*/ = methodVO.fragmentConstantsIndex;\n\t\tfragmentData[index + 8] = 1/this._numSamples;\n\t}\n\n\t/**\n\t * The range in the shadow map in which to distribute the samples.\n\t */\n\tpublic get range():number\n\t{\n\t\treturn this._range*2;\n\t}\n\n\tpublic set range(value:number)\n\t{\n\t\tthis._range = value/2;\n\t}\n\n\t/**\n\t * Creates a texture containing the dithering noise texture.\n\t */\n\tprivate initGrainTexture()\n\t{\n\t\tShadowDitheredMethod._grainBitmapImage2D = new BitmapImage2D(64, 64, false);\n\t\tvar vec:Array<number> /*uint*/ = new Array<number>();\n\t\tvar len:number /*uint*/ = 4096;\n\t\tvar step:number = 1/(this._depthMapSize*this._range);\n\t\tvar r:number, g:number;\n\n\t\tfor (var i:number /*uint*/ = 0; i < len; ++i) {\n\t\t\tr = 2*(Math.random() - .5);\n\t\t\tg = 2*(Math.random() - .5);\n\t\t\tif (r < 0)\n\t\t\t\tr -= step; else\n\t\t\t\tr += step;\n\t\t\tif (g < 0)\n\t\t\t\tg -= step; else\n\t\t\t\tg += step;\n\t\t\tif (r > 1)\n\t\t\t\tr = 1; else if (r < -1)\n\t\t\t\tr = -1;\n\t\t\tif (g > 1)\n\t\t\t\tg = 1; else if (g < -1)\n\t\t\t\tg = -1;\n\t\t\tvec[i] = (Math.floor((r*.5 + .5)*0xff) << 16) | (Math.floor((g*.5 + .5)*0xff) << 8);\n\t\t}\n\n\t\tShadowDitheredMethod._grainBitmapImage2D.setArray(ShadowDitheredMethod._grainBitmapImage2D.rect, vec);\n\t\tShadowDitheredMethod._grainTexture = new Single2DTexture(ShadowDitheredMethod._grainBitmapImage2D);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic dispose()\n\t{\n\t\tif (--ShadowDitheredMethod._grainUsages == 0) {\n\t\t\tShadowDitheredMethod._grainTexture.dispose();\n\t\t\tShadowDitheredMethod._grainBitmapImage2D.dispose();\n\t\t\tShadowDitheredMethod._grainTexture = null;\n\t\t}\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iActivate(shader:ShaderBase, methodVO:MethodVO, stage:Stage)\n\t{\n\t\tsuper.iActivate(shader, methodVO, stage);\n\n\t\tvar data:Float32Array = shader.fragmentConstantData;\n\t\tvar index:number /*uint*/ = methodVO.fragmentConstantsIndex;\n\t\tdata[index + 9] = (stage.width - 1)/63;\n\t\tdata[index + 10] = (stage.height - 1)/63;\n\t\tdata[index + 11] = 2*this._range/this._depthMapSize;\n\n\t\tmethodVO.secondaryTextureVO.activate(shader);\n\t}\n\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iSetRenderState(shader:ShaderBase, methodVO:MethodVO, renderable:RenderableBase, stage:Stage, camera:Camera)\n\t{\n\t\tsuper.iSetRenderState(shader, methodVO, renderable, stage, camera);\n\n\t\tmethodVO.secondaryTextureVO._setRenderState(renderable, shader);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic _pGetPlanarFragmentCode(shader:ShaderBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, regCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar decReg:ShaderRegisterElement = regCache.getFreeFragmentConstant();\n\t\tvar dataReg:ShaderRegisterElement = regCache.getFreeFragmentConstant();\n\t\tvar customDataReg:ShaderRegisterElement = regCache.getFreeFragmentConstant();\n\n\t\tmethodVO.fragmentConstantsIndex = decReg.index*4;\n\n\t\treturn this.getSampleCode(shader, methodVO, customDataReg, decReg, targetReg, regCache, sharedRegisters);\n\t}\n\n\t/**\n\t * Get the actual shader code for shadow mapping\n\t * @param regCache The register cache managing the registers.\n\t * @param depthMapRegister The texture register containing the depth map.\n\t * @param decReg The register containing the depth map decoding data.\n\t * @param targetReg The target register to add the shadow coverage.\n\t */\n\tprivate getSampleCode(shader:ShaderBase, methodVO:MethodVO, customDataReg:ShaderRegisterElement, decReg:ShaderRegisterElement, targetReg:ShaderRegisterElement, regCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = \"\";\n\t\tvar numSamples:number /*int*/ = this._numSamples;\n\t\tvar uvReg:ShaderRegisterElement = regCache.getFreeFragmentVectorTemp();\n\t\tregCache.addFragmentTempUsages(uvReg, 1);\n\t\tvar temp:ShaderRegisterElement = regCache.getFreeFragmentVectorTemp();\n\t\tregCache.addFragmentTempUsages(temp, 1);\n\n\t\tvar projectionReg:ShaderRegisterElement = sharedRegisters.projectionFragment;\n\n\t\tcode += \"div \" + uvReg + \", \" + projectionReg + \", \" + projectionReg + \".w\\n\" +\n\t\t\t\"mul \" + uvReg + \".xy, \" + uvReg + \".xy, \" + customDataReg + \".yz\\n\";\n\n\t\twhile (numSamples > 0) {\n\t\t\tif (numSamples == this._numSamples) {\n\t\t\t\tcode += methodVO.secondaryTextureVO._iGetFragmentCode(shader, uvReg, regCache, sharedRegisters, uvReg);\n\t\t\t} else {\n\t\t\t\tcode += \"mov \" + temp + \", \" + uvReg + \".zwxy \\n\" +\n\t\t\t\t\tmethodVO.secondaryTextureVO._iGetFragmentCode(shader, uvReg, regCache, sharedRegisters, temp);\n\t\t\t}\n\n\t\t\t// keep grain in uvReg.zw\n\t\t\tcode += \"sub \" + uvReg + \".zw, \" + uvReg + \".xy, fc0.xx\\n\" + // uv-.5\n\t\t\t\t\"mul \" + uvReg + \".zw, \" + uvReg + \".zw, \" + customDataReg + \".w\\n\"; // (tex unpack scale and tex scale in one)\n\n\t\t\tif (numSamples == this._numSamples) {\n\t\t\t\t// first sample\n\t\t\t\tcode += \"add \" + uvReg + \".xy, \" + uvReg + \".zw, \" + this._pDepthMapCoordReg + \".xy\\n\" +\n\t\t\t\t\tmethodVO.textureVO._iGetFragmentCode(shader, temp, regCache, sharedRegisters, uvReg) +\n\t\t\t\t\t\"dp4 \" + temp + \".z, \" + temp + \", \" + decReg + \"\\n\" +\n\t\t\t\t\t\"slt \" + targetReg + \".w, \" + this._pDepthMapCoordReg + \".z, \" + temp + \".z\\n\"; // 0 if in shadow\n\t\t\t} else {\n\t\t\t\tcode += this.addSample(shader, methodVO, uvReg, decReg, targetReg, regCache, sharedRegisters);\n\t\t\t}\n\n\t\t\tif (numSamples > 4)\n\t\t\t\tcode += \"add \" + uvReg + \".xy, \" + uvReg + \".xy, \" + uvReg + \".zw\\n\" + this.addSample(shader, methodVO, uvReg, decReg, targetReg, regCache, sharedRegisters);\n\n\t\t\tif (numSamples > 1)\n\t\t\t\tcode += \"sub \" + uvReg + \".xy, \" + this._pDepthMapCoordReg + \".xy, \" + uvReg + \".zw\\n\" + this.addSample(shader, methodVO, uvReg, decReg, targetReg, regCache, sharedRegisters);\n\n\t\t\tif (numSamples > 5)\n\t\t\t\tcode += \"sub \" + uvReg + \".xy, \" + uvReg + \".xy, \" + uvReg + \".zw\\n\" + this.addSample(shader, methodVO, uvReg, decReg, targetReg, regCache, sharedRegisters);\n\n\t\t\tif (numSamples > 2) {\n\t\t\t\tcode += \"neg \" + uvReg + \".w, \" + uvReg + \".w\\n\"; // will be rotated 90 degrees when being accessed as wz\n\t\t\t\tcode += \"add \" + uvReg + \".xy, \" + uvReg + \".wz, \" + this._pDepthMapCoordReg + \".xy\\n\" + this.addSample(shader, methodVO, uvReg, decReg, targetReg, regCache, sharedRegisters);\n\t\t\t}\n\n\t\t\tif (numSamples > 6)\n\t\t\t\tcode += \"add \" + uvReg + \".xy, \" + uvReg + \".xy, \" + uvReg + \".wz\\n\" + this.addSample(shader, methodVO, uvReg, decReg, targetReg, regCache, sharedRegisters);\n\n\t\t\tif (numSamples > 3)\n\t\t\t\tcode += \"sub \" + uvReg + \".xy, \" + this._pDepthMapCoordReg + \".xy, \" + uvReg + \".wz\\n\" + this.addSample(shader, methodVO, uvReg, decReg, targetReg, regCache, sharedRegisters);\n\n\t\t\tif (numSamples > 7)\n\t\t\t\tcode += \"sub \" + uvReg + \".xy, \" + uvReg + \".xy, \" + uvReg + \".wz\\n\" + this.addSample(shader, methodVO, uvReg, decReg, targetReg, regCache, sharedRegisters);\n\n\t\t\tnumSamples -= 8;\n\t\t}\n\n\t\tregCache.removeFragmentTempUsage(temp);\n\t\tregCache.removeFragmentTempUsage(uvReg);\n\t\tcode += \"mul \" + targetReg + \".w, \" + targetReg + \".w, \" + customDataReg + \".x\\n\"; // average\n\t\treturn code;\n\t}\n\n\t/**\n\t * Adds the code for another tap to the shader code.\n\t * @param uvReg The uv register for the tap.\n\t * @param depthMapRegister The texture register containing the depth map.\n\t * @param decReg The register containing the depth map decoding data.\n\t * @param targetReg The target register to add the tap comparison result.\n\t * @param regCache The register cache managing the registers.\n\t * @return\n\t */\n\tprivate addSample(shader:ShaderBase, methodVO:MethodVO, uvReg:ShaderRegisterElement, decReg:ShaderRegisterElement, targetReg:ShaderRegisterElement, regCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar temp:ShaderRegisterElement = regCache.getFreeFragmentVectorTemp();\n\n\t\treturn methodVO.textureVO._iGetFragmentCode(shader, temp, regCache, sharedRegisters, uvReg) +\n\t\t\t\"dp4 \" + temp + \".z, \" + temp + \", \" + decReg + \"\\n\" +\n\t\t\t\"slt \" + temp + \".z, \" + this._pDepthMapCoordReg + \".z, \" + temp + \".z\\n\" + // 0 if in shadow\n\t\t\t\"add \" + targetReg + \".w, \" + targetReg + \".w, \" + temp + \".z\\n\";\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iActivateForCascade(shader:ShaderBase, methodVO:MethodVO, stage:Stage)\n\t{\n\t\tvar data:Float32Array = shader.fragmentConstantData;\n\t\tvar index:number /*uint*/ = methodVO.secondaryFragmentConstantsIndex;\n\t\tdata[index] = 1/this._numSamples;\n\t\tdata[index + 1] = (stage.width - 1)/63;\n\t\tdata[index + 2] = (stage.height - 1)/63;\n\t\tdata[index + 3] = 2*this._range/this._depthMapSize;\n\n\t\tmethodVO.secondaryTextureVO.activate(shader);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic _iGetCascadeFragmentCode(shader:ShaderBase, methodVO:MethodVO, decodeRegister:ShaderRegisterElement, depthProjection:ShaderRegisterElement, targetRegister:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tthis._pDepthMapCoordReg = depthProjection;\n\n\t\tvar dataReg:ShaderRegisterElement = registerCache.getFreeFragmentConstant();\n\t\tmethodVO.secondaryFragmentConstantsIndex = dataReg.index*4;\n\n\t\treturn this.getSampleCode(shader, methodVO, dataReg, decodeRegister, targetRegister, registerCache, sharedRegisters);\n\t}\n}\n\nexport = ShadowDitheredMethod;",
    "import DirectionalLight\t\t\t\t\t= require(\"awayjs-display/lib/entities/DirectionalLight\");\n\nimport Stage\t\t\t\t\t\t\t= require(\"awayjs-stagegl/lib/base/Stage\");\n\nimport LightingShader\t\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/LightingShader\");\nimport ShaderBase\t\t\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderBase\");\nimport ShaderRegisterCache\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterCache\");\nimport ShaderRegisterData\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterData\");\nimport ShaderRegisterElement\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterElement\");\n\nimport MethodVO\t\t\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/data/MethodVO\");\nimport ShadowMethodBase\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/methods/ShadowMethodBase\");\n\n/**\n * ShadowFilteredMethod provides a softened shadowing technique by bilinearly interpolating shadow comparison\n * results of neighbouring pixels.\n */\nclass ShadowFilteredMethod extends ShadowMethodBase\n{\n\t/**\n\t * Creates a new DiffuseBasicMethod object.\n\t *\n\t * @param castingLight The light casting the shadow\n\t */\n\tconstructor(castingLight:DirectionalLight)\n\t{\n\t\tsuper(castingLight);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitConstants(shader:LightingShader, methodVO:MethodVO)\n\t{\n\t\tsuper.iInitConstants(shader, methodVO);\n\n\t\tvar fragmentData:Float32Array = shader.fragmentConstantData;\n\t\tvar index:number /*int*/ = methodVO.fragmentConstantsIndex;\n\t\tfragmentData[index + 8] = .5;\n\t\tvar size:number /*int*/ = this.castingLight.shadowMapper.depthMapSize;\n\t\tfragmentData[index + 9] = size;\n\t\tfragmentData[index + 10] = 1/size;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic _pGetPlanarFragmentCode(shader:ShaderBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, regCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = \"\";\n\t\tvar decReg:ShaderRegisterElement = regCache.getFreeFragmentConstant();\n\t\tregCache.getFreeFragmentConstant();\n\t\tvar customDataReg:ShaderRegisterElement = regCache.getFreeFragmentConstant();\n\n\t\tmethodVO.fragmentConstantsIndex = decReg.index*4;\n\n\t\tvar depthCol:ShaderRegisterElement = regCache.getFreeFragmentVectorTemp();\n\t\tregCache.addFragmentTempUsages(depthCol, 1);\n\t\tvar uvReg:ShaderRegisterElement = regCache.getFreeFragmentVectorTemp();\n\t\tregCache.addFragmentTempUsages(uvReg, 1);\n\n\t\tcode += \"mov \" + uvReg + \", \" + this._pDepthMapCoordReg + \"\\n\" +\n\n\t\t\tmethodVO.textureVO._iGetFragmentCode(shader, depthCol, regCache, sharedRegisters, this._pDepthMapCoordReg) +\n\t\t\t\"dp4 \" + depthCol + \".z, \" + depthCol + \", \" + decReg + \"\\n\" +\n\t\t\t\"slt \" + uvReg + \".z, \" + this._pDepthMapCoordReg + \".z, \" + depthCol + \".z\\n\" +   // 0 if in shadow\n\n\t\t\t\"add \" + uvReg + \".x, \" + this._pDepthMapCoordReg + \".x, \" + customDataReg + \".z\\n\" + \t// (1, 0)\n\t\t\tmethodVO.textureVO._iGetFragmentCode(shader, depthCol, regCache, sharedRegisters, uvReg) +\n\t\t\t\"dp4 \" + depthCol + \".z, \" + depthCol + \", \" + decReg + \"\\n\" +\n\t\t\t\"slt \" + uvReg + \".w, \" + this._pDepthMapCoordReg + \".z, \" + depthCol + \".z\\n\" +   // 0 if in shadow\n\n\t\t\t\"mul \" + depthCol + \".x, \" + this._pDepthMapCoordReg + \".x, \" + customDataReg + \".y\\n\" +\n\t\t\t\"frc \" + depthCol + \".x, \" + depthCol + \".x\\n\" +\n\t\t\t\"sub \" + uvReg + \".w, \" + uvReg + \".w, \" + uvReg + \".z\\n\" +\n\t\t\t\"mul \" + uvReg + \".w, \" + uvReg + \".w, \" + depthCol + \".x\\n\" +\n\t\t\t\"add \" + targetReg + \".w, \" + uvReg + \".z, \" + uvReg + \".w\\n\" +\n\n\t\t\t\"mov \" + uvReg + \".x, \" + this._pDepthMapCoordReg + \".x\\n\" +\n\t\t\t\"add \" + uvReg + \".y, \" + this._pDepthMapCoordReg + \".y, \" + customDataReg + \".z\\n\" +\t// (0, 1)\n\t\t\tmethodVO.textureVO._iGetFragmentCode(shader, depthCol, regCache, sharedRegisters, uvReg) +\n\t\t\t\"dp4 \" + depthCol + \".z, \" + depthCol + \", \" + decReg + \"\\n\" +\n\t\t\t\"slt \" + uvReg + \".z, \" + this._pDepthMapCoordReg + \".z, \" + depthCol + \".z\\n\" +   // 0 if in shadow\n\n\t\t\t\"add \" + uvReg + \".x, \" + this._pDepthMapCoordReg + \".x, \" + customDataReg + \".z\\n\" +\t// (1, 1)\n\t\t\tmethodVO.textureVO._iGetFragmentCode(shader, depthCol, regCache, sharedRegisters, uvReg) +\n\t\t\t\"dp4 \" + depthCol + \".z, \" + depthCol + \", \" + decReg + \"\\n\" +\n\t\t\t\"slt \" + uvReg + \".w, \" + this._pDepthMapCoordReg + \".z, \" + depthCol + \".z\\n\" +   // 0 if in shadow\n\n\t\t\t// recalculate fraction, since we ran out of registers :(\n\t\t\t\"mul \" + depthCol + \".x, \" + this._pDepthMapCoordReg + \".x, \" + customDataReg + \".y\\n\" +\n\t\t\t\"frc \" + depthCol + \".x, \" + depthCol + \".x\\n\" + \"sub \" + uvReg + \".w, \" + uvReg + \".w, \" + uvReg + \".z\\n\" +\n\t\t\t\"mul \" + uvReg + \".w, \" + uvReg + \".w, \" + depthCol + \".x\\n\" +\n\t\t\t\"add \" + uvReg + \".w, \" + uvReg + \".z, \" + uvReg + \".w\\n\" +\n\n\t\t\t\"mul \" + depthCol + \".x, \" + this._pDepthMapCoordReg + \".y, \" + customDataReg + \".y\\n\" +\n\t\t\t\"frc \" + depthCol + \".x, \" + depthCol + \".x\\n\" +\n\t\t\t\"sub \" + uvReg + \".w, \" + uvReg + \".w, \" + targetReg + \".w\\n\" +\n\t\t\t\"mul \" + uvReg + \".w, \" + uvReg + \".w, \" + depthCol + \".x\\n\" +\n\t\t\t\"add \" + targetReg + \".w, \" + targetReg + \".w, \" + uvReg + \".w\\n\";\n\n\t\tregCache.removeFragmentTempUsage(depthCol);\n\t\tregCache.removeFragmentTempUsage(uvReg);\n\n\t\treturn code;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iActivateForCascade(shader:ShaderBase, methodVO:MethodVO, stage:Stage)\n\t{\n\t\tvar size:number /*int*/ = this.castingLight.shadowMapper.depthMapSize;\n\t\tvar index:number /*int*/ = methodVO.secondaryFragmentConstantsIndex;\n\t\tvar data:Float32Array = shader.fragmentConstantData;\n\t\tdata[index] = size;\n\t\tdata[index + 1] = 1/size;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic _iGetCascadeFragmentCode(shader:ShaderBase, methodVO:MethodVO, decodeRegister:ShaderRegisterElement, depthProjection:ShaderRegisterElement, targetRegister:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string;\n\t\tvar dataReg:ShaderRegisterElement = registerCache.getFreeFragmentConstant();\n\t\tmethodVO.secondaryFragmentConstantsIndex = dataReg.index*4;\n\n\t\tvar temp:ShaderRegisterElement = registerCache.getFreeFragmentVectorTemp();\n\t\tregisterCache.addFragmentTempUsages(temp, 1);\n\t\tvar predicate:ShaderRegisterElement = registerCache.getFreeFragmentVectorTemp();\n\t\tregisterCache.addFragmentTempUsages(predicate, 1);\n\n\t\tcode = methodVO.textureVO._iGetFragmentCode(shader, temp, registerCache, sharedRegisters, depthProjection) +\n\t\t\t\"dp4 \" + temp + \".z, \" + temp + \", \" + decodeRegister + \"\\n\" +\n\t\t\t\"slt \" + predicate + \".x, \" + depthProjection + \".z, \" + temp + \".z\\n\" +\n\n\t\t\t\"add \" + depthProjection + \".x, \" + depthProjection + \".x, \" + dataReg + \".y\\n\" +\n\t\t\tmethodVO.textureVO._iGetFragmentCode(shader, temp, registerCache, sharedRegisters, depthProjection) +\n\t\t\t\"dp4 \" + temp + \".z, \" + temp + \", \" + decodeRegister + \"\\n\" +\n\t\t\t\"slt \" + predicate + \".z, \" + depthProjection + \".z, \" + temp + \".z\\n\" +\n\n\t\t\t\"add \" + depthProjection + \".y, \" + depthProjection + \".y, \" + dataReg + \".y\\n\" +\n\t\t\tmethodVO.textureVO._iGetFragmentCode(shader, temp, registerCache, sharedRegisters, depthProjection) +\n\t\t\t\"dp4 \" + temp + \".z, \" + temp + \", \" + decodeRegister + \"\\n\" +\n\t\t\t\"slt \" + predicate + \".w, \" + depthProjection + \".z, \" + temp + \".z\\n\" +\n\n\t\t\t\"sub \" + depthProjection + \".x, \" + depthProjection + \".x, \" + dataReg + \".y\\n\" +\n\t\t\tmethodVO.textureVO._iGetFragmentCode(shader, temp, registerCache, sharedRegisters, depthProjection) +\n\t\t\t\"dp4 \" + temp + \".z, \" + temp + \", \" + decodeRegister + \"\\n\" +\n\t\t\t\"slt \" + predicate + \".y, \" + depthProjection + \".z, \" + temp + \".z\\n\" +\n\n\t\t\t\"mul \" + temp + \".xy, \" + depthProjection + \".xy, \" + dataReg + \".x\\n\" +\n\t\t\t\"frc \" + temp + \".xy, \" + temp + \".xy\\n\" +\n\n\t\t\t// some strange register juggling to prevent agal bugging out\n\t\t\t\"sub \" + depthProjection + \", \" + predicate + \".xyzw, \" + predicate + \".zwxy\\n\" +\n\t\t\t\"mul \" + depthProjection + \", \" + depthProjection + \", \" + temp + \".x\\n\" +\n\n\t\t\t\"add \" + predicate + \".xy, \" + predicate + \".xy, \" + depthProjection + \".zw\\n\" +\n\n\t\t\t\"sub \" + predicate + \".y, \" + predicate + \".y, \" + predicate + \".x\\n\" +\n\t\t\t\"mul \" + predicate + \".y, \" + predicate + \".y, \" + temp + \".y\\n\" +\n\t\t\t\"add \" + targetRegister + \".w, \" + predicate + \".x, \" + predicate + \".y\\n\";\n\n\t\tregisterCache.removeFragmentTempUsage(temp);\n\t\tregisterCache.removeFragmentTempUsage(predicate);\n\t\treturn code;\n\t}\n}\n\nexport = ShadowFilteredMethod;",
    "import LightBase\t\t\t\t\t\t= require(\"awayjs-display/lib/base/LightBase\");\n\nimport Stage\t\t\t\t\t\t\t= require(\"awayjs-stagegl/lib/base/Stage\");\n\nimport ShaderBase\t\t\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderBase\");\nimport ShaderRegisterCache\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterCache\");\nimport ShaderRegisterData\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterData\");\nimport ShaderRegisterElement\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterElement\");\n\nimport MethodVO\t\t\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/data/MethodVO\");\nimport ShadowMethodBase\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/methods/ShadowMethodBase\");\n\n/**\n * ShadowHardMethod provides the cheapest shadow map method by using a single tap without any filtering.\n */\nclass ShadowHardMethod extends ShadowMethodBase\n{\n\t/**\n\t * Creates a new ShadowHardMethod object.\n\t */\n\tconstructor(castingLight:LightBase)\n\t{\n\t\tsuper(castingLight);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic _pGetPlanarFragmentCode(shader:ShaderBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, regCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = \"\";\n\t\tvar decReg:ShaderRegisterElement = regCache.getFreeFragmentConstant();\n\t\tregCache.getFreeFragmentConstant();\n\n\t\tvar depthCol:ShaderRegisterElement = regCache.getFreeFragmentVectorTemp();\n\n\t\tmethodVO.fragmentConstantsIndex = decReg.index*4;\n\n\t\tcode += methodVO.textureVO._iGetFragmentCode(shader, depthCol, regCache, sharedRegisters, this._pDepthMapCoordReg) +\n\t\t\t\"dp4 \" + depthCol + \".z, \" + depthCol + \", \" + decReg + \"\\n\" +\n\t\t\t\"slt \" + targetReg + \".w, \" + this._pDepthMapCoordReg + \".z, \" + depthCol + \".z\\n\"; // 0 if in shadow\n\n\t\treturn code;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic _pGetPointFragmentCode(shader:ShaderBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, regCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = \"\";\n\t\tvar decReg:ShaderRegisterElement = regCache.getFreeFragmentConstant();\n\t\tvar epsReg:ShaderRegisterElement = regCache.getFreeFragmentConstant();\n\t\tvar posReg:ShaderRegisterElement = regCache.getFreeFragmentConstant();\n\t\tvar depthSampleCol:ShaderRegisterElement = regCache.getFreeFragmentVectorTemp();\n\t\tregCache.addFragmentTempUsages(depthSampleCol, 1);\n\t\tvar lightDir:ShaderRegisterElement = regCache.getFreeFragmentVectorTemp();\n\t\tregCache.addFragmentTempUsages(lightDir, 1);\n\n\t\tmethodVO.fragmentConstantsIndex = decReg.index*4;\n\n\t\tcode += \"sub \" + lightDir + \", \" + sharedRegisters.globalPositionVarying + \", \" + posReg + \"\\n\" +\n\t\t\t\"dp3 \" + lightDir + \".w, \" + lightDir + \".xyz, \" + lightDir + \".xyz\\n\" +\n\t\t\t\"mul \" + lightDir + \".w, \" + lightDir + \".w, \" + posReg + \".w\\n\" +\n\t\t\t\"nrm \" + lightDir + \".xyz, \" + lightDir + \".xyz\\n\" +\n\n\t\t\tmethodVO.textureVO._iGetFragmentCode(shader, depthSampleCol, regCache, sharedRegisters, lightDir) +\n\t\t\t\"dp4 \" + depthSampleCol + \".z, \" + depthSampleCol + \", \" + decReg + \"\\n\" +\n\t\t\t\"add \" + targetReg + \".w, \" + lightDir + \".w, \" + epsReg + \".x\\n\" +    // offset by epsilon\n\n\t\t\t\"slt \" + targetReg + \".w, \" + targetReg + \".w, \" + depthSampleCol + \".z\\n\"; // 0 if in shadow\n\n\t\tregCache.removeFragmentTempUsage(lightDir);\n\t\tregCache.removeFragmentTempUsage(depthSampleCol);\n\n\t\treturn code;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic _iGetCascadeFragmentCode(shader:ShaderBase, methodVO:MethodVO, decodeRegister:ShaderRegisterElement, depthProjection:ShaderRegisterElement, targetRegister:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar temp:ShaderRegisterElement = registerCache.getFreeFragmentVectorTemp();\n\n\t\treturn methodVO.textureVO._iGetFragmentCode(shader, temp, registerCache, sharedRegisters, depthProjection) +\n\t\t\t\"dp4 \" + temp + \".z, \" + temp + \", \" + decodeRegister + \"\\n\" +\n\t\t\t\"slt \" + targetRegister + \".w, \" + depthProjection + \".z, \" + temp + \".z\\n\"; // 0 if in shadow\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iActivateForCascade(shader:ShaderBase, methodVO:MethodVO, stage:Stage)\n\t{\n\t}\n}\n\nexport = ShadowHardMethod;",
    "import IAsset\t\t\t\t\t\t\t= require(\"awayjs-core/lib/library/IAsset\");\n\nimport LightBase\t\t\t\t\t\t= require(\"awayjs-display/lib/base/LightBase\");\nimport ShadowMapperBase\t\t\t\t\t= require(\"awayjs-display/lib/materials/shadowmappers/ShadowMapperBase\");\n\nimport ShadingMethodBase\t\t\t\t= require(\"awayjs-methodmaterials/lib/methods/ShadingMethodBase\");\n\n/**\n * ShadowMapMethodBase provides an abstract base method for shadow map methods.\n */\nclass ShadowMapMethodBase extends ShadingMethodBase implements IAsset\n{\n\tpublic static assetType:string = \"[asset ShadowMapMethod]\";\n\n\tpublic _pCastingLight:LightBase;\n\tpublic _pShadowMapper:ShadowMapperBase;\n\n\tpublic _pEpsilon:number = .02;\n\tpublic _pAlpha:number = 1;\n\n\t/**\n\t * Creates a new ShadowMapMethodBase object.\n\t * @param castingLight The light used to cast shadows.\n\t */\n\tconstructor(castingLight:LightBase)\n\t{\n\t\tsuper();\n\t\tthis._pCastingLight = castingLight;\n\t\tcastingLight.castsShadows = true;\n\t\tthis._pShadowMapper = castingLight.shadowMapper;\n\n\t\tthis.iAddTexture(castingLight.shadowMapper.depthMap);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic get assetType():string\n\t{\n\t\treturn ShadowMapMethodBase.assetType;\n\t}\n\n\t/**\n\t * The \"transparency\" of the shadows. This allows making shadows less strong.\n\t */\n\tpublic get alpha():number\n\t{\n\t\treturn this._pAlpha;\n\t}\n\n\tpublic set alpha(value:number)\n\t{\n\t\tthis._pAlpha = value;\n\t}\n\n\t/**\n\t * The light casting the shadows.\n\t */\n\tpublic get castingLight():LightBase\n\t{\n\t\treturn this._pCastingLight;\n\t}\n\n\t/**\n\t * A small value to counter floating point precision errors when comparing values in the shadow map with the\n\t * calculated depth value. Increase this if shadow banding occurs, decrease it if the shadow seems to be too detached.\n\t */\n\tpublic get epsilon():number\n\t{\n\t\treturn this._pEpsilon;\n\t}\n\n\tpublic set epsilon(value:number)\n\t{\n\t\tthis._pEpsilon = value;\n\t}\n}\n\nexport = ShadowMapMethodBase;",
    "import Vector3D\t\t\t\t\t\t\t= require(\"awayjs-core/lib/geom/Vector3D\");\nimport AbstractMethodError\t\t\t\t= require(\"awayjs-core/lib/errors/AbstractMethodError\");\n\nimport LightBase\t\t\t\t\t\t= require(\"awayjs-display/lib/base/LightBase\");\nimport Camera\t\t\t\t\t\t\t= require(\"awayjs-display/lib/entities/Camera\");\nimport DirectionalLight\t\t\t\t\t= require(\"awayjs-display/lib/entities/DirectionalLight\");\nimport PointLight\t\t\t\t\t\t= require(\"awayjs-display/lib/entities/PointLight\");\nimport DirectionalShadowMapper\t\t\t= require(\"awayjs-display/lib/materials/shadowmappers/DirectionalShadowMapper\");\nimport TextureBase\t\t\t\t\t\t= require(\"awayjs-display/lib/textures/TextureBase\");\n\nimport Stage\t\t\t\t\t\t\t= require(\"awayjs-stagegl/lib/base/Stage\");\n\nimport RenderableBase\t\t\t\t\t= require(\"awayjs-renderergl/lib/renderables/RenderableBase\");\nimport LightingShader\t\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/LightingShader\");\nimport ShaderBase\t\t\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderBase\");\nimport ShaderRegisterCache\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterCache\");\nimport ShaderRegisterData\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterData\");\nimport ShaderRegisterElement\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterElement\");\n\nimport MethodVO\t\t\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/data/MethodVO\");\nimport ShadowMapMethodBase\t\t\t\t= require(\"awayjs-methodmaterials/lib/methods/ShadowMapMethodBase\");\n\n/**\n * ShadowMethodBase provides an abstract method for simple (non-wrapping) shadow map methods.\n */\nclass ShadowMethodBase extends ShadowMapMethodBase\n{\n\tpublic _pDepthMapCoordReg:ShaderRegisterElement;\n\tpublic _pUsePoint:boolean;\n\n\t/**\n\t * Creates a new ShadowMethodBase object.\n\t * @param castingLight The light used to cast shadows.\n\t */\n\tconstructor(castingLight:LightBase)\n\t{\n\t\tthis._pUsePoint = (castingLight instanceof PointLight);\n\n\t\tsuper(castingLight);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitVO(shader:LightingShader, methodVO:MethodVO)\n\t{\n\t\tmethodVO.needsView = true;\n\t\tmethodVO.needsGlobalVertexPos = true;\n\t\tmethodVO.needsGlobalFragmentPos = this._pUsePoint;\n\t\tmethodVO.needsNormals = shader.numLights > 0;\n\n\t\tmethodVO.textureVO = shader.getTextureVO(this._pCastingLight.shadowMapper.depthMap);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitConstants(shader:ShaderBase, methodVO:MethodVO)\n\t{\n\t\tvar fragmentData:Float32Array = shader.fragmentConstantData;\n\t\tvar vertexData:Float32Array = shader.vertexConstantData;\n\t\tvar index:number /*int*/ = methodVO.fragmentConstantsIndex;\n\t\tfragmentData[index] = 1.0;\n\t\tfragmentData[index + 1] = 1/255.0;\n\t\tfragmentData[index + 2] = 1/65025.0;\n\t\tfragmentData[index + 3] = 1/16581375.0;\n\n\t\tfragmentData[index + 6] = 0;\n\t\tfragmentData[index + 7] = 1;\n\n\t\tif (this._pUsePoint) {\n\t\t\tfragmentData[index + 8] = 0;\n\t\t\tfragmentData[index + 9] = 0;\n\t\t\tfragmentData[index + 10] = 0;\n\t\t\tfragmentData[index + 11] = 1;\n\t\t}\n\n\t\tindex = methodVO.vertexConstantsIndex;\n\t\tif (index != -1) {\n\t\t\tvertexData[index] = .5;\n\t\t\tvertexData[index + 1] = .5;\n\t\t\tvertexData[index + 2] = 0.0;\n\t\t\tvertexData[index + 3] = 1.0;\n\t\t}\n\t}\n\n\t/**\n\t * Wrappers that override the vertex shader need to set this explicitly\n\t */\n\tpublic get _iDepthMapCoordReg():ShaderRegisterElement\n\t{\n\t\treturn this._pDepthMapCoordReg;\n\t}\n\n\tpublic set _iDepthMapCoordReg(value:ShaderRegisterElement)\n\t{\n\t\tthis._pDepthMapCoordReg = value;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iCleanCompilationData()\n\t{\n\t\tsuper.iCleanCompilationData();\n\n\t\tthis._pDepthMapCoordReg = null;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetVertexCode(shader:ShaderBase, methodVO:MethodVO, regCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\treturn this._pUsePoint? this._pGetPointVertexCode(methodVO, regCache, sharedRegisters):this.pGetPlanarVertexCode(methodVO, regCache, sharedRegisters);\n\t}\n\n\t/**\n\t * Gets the vertex code for shadow mapping with a point light.\n\t *\n\t * @param methodVO The MethodVO object linking this method with the pass currently being compiled.\n\t * @param regCache The register cache used during the compilation.\n\t */\n\tpublic _pGetPointVertexCode(methodVO:MethodVO, regCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tmethodVO.vertexConstantsIndex = -1;\n\t\treturn \"\";\n\t}\n\n\t/**\n\t * Gets the vertex code for shadow mapping with a planar shadow map (fe: directional lights).\n\t *\n\t * @param methodVO The MethodVO object linking this method with the pass currently being compiled.\n\t * @param regCache The register cache used during the compilation.\n\t */\n\tpublic pGetPlanarVertexCode(methodVO:MethodVO, regCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = \"\";\n\t\tvar temp:ShaderRegisterElement = regCache.getFreeVertexVectorTemp();\n\t\tvar dataReg:ShaderRegisterElement = regCache.getFreeVertexConstant();\n\t\tvar depthMapProj:ShaderRegisterElement = regCache.getFreeVertexConstant();\n\t\tregCache.getFreeVertexConstant();\n\t\tregCache.getFreeVertexConstant();\n\t\tregCache.getFreeVertexConstant();\n\t\tthis._pDepthMapCoordReg = regCache.getFreeVarying();\n\t\tmethodVO.vertexConstantsIndex = dataReg.index*4;\n\n\t\t// todo: can epsilon be applied here instead of fragment shader?\n\n\t\tcode += \"m44 \" + temp + \", \" + sharedRegisters.globalPositionVertex + \", \" + depthMapProj + \"\\n\" +\n\t\t\t\"div \" + temp + \", \" + temp + \", \" + temp + \".w\\n\" +\n\t\t\t\"mul \" + temp + \".xy, \" + temp + \".xy, \" + dataReg + \".xy\\n\" +\n\t\t\t\"add \" + this._pDepthMapCoordReg + \", \" + temp + \", \" + dataReg + \".xxwz\\n\";\n\t\t//\"sub \" + this._pDepthMapCoordReg + \".z, \" + this._pDepthMapCoordReg + \".z, \" + this._pDepthMapCoordReg + \".w\\n\";\n\n\t\treturn code;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentCode(shader:ShaderBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = this._pUsePoint? this._pGetPointFragmentCode(shader, methodVO, targetReg, registerCache, sharedRegisters) : this._pGetPlanarFragmentCode(shader, methodVO, targetReg, registerCache, sharedRegisters);\n\t\tcode += \"add \" + targetReg + \".w, \" + targetReg + \".w, fc\" + (methodVO.fragmentConstantsIndex/4 + 1) + \".y\\n\" +\n\t\t\t\"sat \" + targetReg + \".w, \" + targetReg + \".w\\n\";\n\t\treturn code;\n\t}\n\n\t/**\n\t * Gets the fragment code for shadow mapping with a planar shadow map.\n\t * @param methodVO The MethodVO object linking this method with the pass currently being compiled.\n\t * @param regCache The register cache used during the compilation.\n\t * @param targetReg The register to contain the shadow coverage\n\t * @return\n\t */\n\tpublic _pGetPlanarFragmentCode(shader:ShaderBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, regCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tthrow new AbstractMethodError();\n\t\treturn \"\";\n\t}\n\n\t/**\n\t * Gets the fragment code for shadow mapping with a point light.\n\t * @param methodVO The MethodVO object linking this method with the pass currently being compiled.\n\t * @param regCache The register cache used during the compilation.\n\t * @param targetReg The register to contain the shadow coverage\n\t * @return\n\t */\n\tpublic _pGetPointFragmentCode(shader:ShaderBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, regCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tthrow new AbstractMethodError();\n\t\treturn \"\";\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iSetRenderState(shader:ShaderBase, methodVO:MethodVO, renderable:RenderableBase, stage:Stage, camera:Camera)\n\t{\n\t\tif (!this._pUsePoint)\n\t\t\t(<DirectionalShadowMapper> this._pShadowMapper).iDepthProjection.copyRawDataTo(shader.vertexConstantData, methodVO.vertexConstantsIndex + 4, true);\n\n\t\tmethodVO.textureVO._setRenderState(renderable, shader);\n\t}\n\n\t/**\n\t * Gets the fragment code for combining this method with a cascaded shadow map method.\n\t * @param methodVO The MethodVO object linking this method with the pass currently being compiled.\n\t * @param regCache The register cache used during the compilation.\n\t * @param decodeRegister The register containing the data to decode the shadow map depth value.\n\t * @param depthTexture The texture containing the shadow map.\n\t * @param depthProjection The projection of the fragment relative to the light.\n\t * @param targetRegister The register to contain the shadow coverage\n\t * @return\n\t */\n\tpublic _iGetCascadeFragmentCode(shader:ShaderBase, methodVO:MethodVO, decodeRegister:ShaderRegisterElement, depthProjection:ShaderRegisterElement, targetRegister:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tthrow new Error(\"This shadow method is incompatible with cascade shadows\");\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iActivate(shader:ShaderBase, methodVO:MethodVO, stage:Stage)\n\t{\n\t\tvar fragmentData:Float32Array = shader.fragmentConstantData;\n\t\tvar index:number /*int*/ = methodVO.fragmentConstantsIndex;\n\n\t\tif (this._pUsePoint)\n\t\t\tfragmentData[index + 4] = -Math.pow(1/((<PointLight> this._pCastingLight).fallOff*this._pEpsilon), 2);\n\t\telse\n\t\t\tshader.vertexConstantData[methodVO.vertexConstantsIndex + 3] = -1/((<DirectionalShadowMapper> this._pShadowMapper).depth*this._pEpsilon);\n\n\t\tfragmentData[index + 5] = 1 - this._pAlpha;\n\n\t\tif (this._pUsePoint) {\n\t\t\tvar pos:Vector3D = this._pCastingLight.scenePosition;\n\t\t\tfragmentData[index + 8] = pos.x;\n\t\t\tfragmentData[index + 9] = pos.y;\n\t\t\tfragmentData[index + 10] = pos.z;\n\t\t\t// used to decompress distance\n\t\t\tvar f:number = (<PointLight> this._pCastingLight).fallOff;\n\t\t\tfragmentData[index + 11] = 1/(2*f*f);\n\t\t}\n\n\t\tmethodVO.textureVO.activate(shader);\n\t}\n\n\t/**\n\t * Sets the method state for cascade shadow mapping.\n\t */\n\tpublic iActivateForCascade(shader:ShaderBase, methodVO:MethodVO, stage:Stage)\n\t{\n\t\tthrow new Error(\"This shadow method is incompatible with cascade shadows\");\n\t}\n}\n\nexport = ShadowMethodBase;",
    "import NearDirectionalShadowMapper\t\t= require(\"awayjs-display/lib/materials/shadowmappers/NearDirectionalShadowMapper\");\nimport Camera\t\t\t\t\t\t\t= require(\"awayjs-display/lib/entities/Camera\");\n\nimport Stage\t\t\t\t\t\t\t= require(\"awayjs-stagegl/lib/base/Stage\");\n\nimport RenderableBase\t\t\t\t\t= require(\"awayjs-renderergl/lib/renderables/RenderableBase\");\nimport ShadingMethodEvent\t\t\t\t= require(\"awayjs-renderergl/lib/events/ShadingMethodEvent\");\nimport LightingShader\t\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/LightingShader\");\nimport ShaderBase\t\t\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderBase\");\nimport ShaderRegisterCache\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterCache\");\nimport ShaderRegisterData\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterData\");\nimport ShaderRegisterElement\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterElement\");\n\nimport MethodVO\t\t\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/data/MethodVO\");\nimport ShadowMethodBase\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/methods/ShadowMethodBase\");\n\n// TODO: shadow mappers references in materials should be an interface so that this class should NOT extend ShadowMapMethodBase just for some delegation work\n/**\n * ShadowNearMethod provides a shadow map method that restricts the shadowed area near the camera to optimize\n * shadow map usage. This method needs to be used in conjunction with a NearDirectionalShadowMapper.\n *\n * @see away.lights.NearDirectionalShadowMapper\n */\nclass ShadowNearMethod extends ShadowMethodBase\n{\n\tprivate _baseMethod:ShadowMethodBase;\n\n\tprivate _fadeRatio:number;\n\tprivate _nearShadowMapper:NearDirectionalShadowMapper;\n\n\tprivate _onShaderInvalidatedDelegate:Function;\n\n\t/**\n\t * Creates a new ShadowNearMethod object.\n\t * @param baseMethod The shadow map sampling method used to sample individual cascades (fe: ShadowHardMethod, ShadowSoftMethod)\n\t * @param fadeRatio The amount of shadow fading to the outer shadow area. A value of 1 would mean the shadows start fading from the camera's near plane.\n\t */\n\tconstructor(baseMethod:ShadowMethodBase, fadeRatio:number = .1)\n\t{\n\t\tsuper(baseMethod.castingLight);\n\n\t\tthis._onShaderInvalidatedDelegate = (event:ShadingMethodEvent) => this.onShaderInvalidated(event);\n\n\t\tthis._baseMethod = baseMethod;\n\t\tthis._fadeRatio = fadeRatio;\n\t\tthis._nearShadowMapper = <NearDirectionalShadowMapper> this._pCastingLight.shadowMapper;\n\t\tif (!this._nearShadowMapper)\n\t\t\tthrow new Error(\"ShadowNearMethod requires a light that has a NearDirectionalShadowMapper instance assigned to shadowMapper.\");\n\t\tthis._baseMethod.addEventListener(ShadingMethodEvent.SHADER_INVALIDATED, this._onShaderInvalidatedDelegate);\n\t}\n\n\t/**\n\t * The base shadow map method on which this method's shading is based.\n\t */\n\tpublic get baseMethod():ShadowMethodBase\n\t{\n\t\treturn this._baseMethod;\n\t}\n\n\tpublic set baseMethod(value:ShadowMethodBase)\n\t{\n\t\tif (this._baseMethod == value)\n\t\t\treturn;\n\n\t\tthis._baseMethod.removeEventListener(ShadingMethodEvent.SHADER_INVALIDATED, this._onShaderInvalidatedDelegate);\n\n\t\tthis._baseMethod = value;\n\n\t\tthis._baseMethod.addEventListener(ShadingMethodEvent.SHADER_INVALIDATED, this._onShaderInvalidatedDelegate);\n\n\t\tthis.iInvalidateShaderProgram();\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitConstants(shader:ShaderBase, methodVO:MethodVO)\n\t{\n\t\tsuper.iInitConstants(shader, methodVO);\n\t\tthis._baseMethod.iInitConstants(shader, methodVO);\n\n\t\tvar fragmentData:Float32Array = shader.fragmentConstantData;\n\t\tvar index:number /*int*/ = methodVO.secondaryFragmentConstantsIndex;\n\t\tfragmentData[index + 2] = 0;\n\t\tfragmentData[index + 3] = 1;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitVO(shader:LightingShader, methodVO:MethodVO)\n\t{\n\t\tthis._baseMethod.iInitVO(shader, methodVO);\n\n\t\tmethodVO.needsProjection = true;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic dispose()\n\t{\n\t\tthis._baseMethod.removeEventListener(ShadingMethodEvent.SHADER_INVALIDATED, this._onShaderInvalidatedDelegate);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic get alpha():number\n\t{\n\t\treturn this._baseMethod.alpha;\n\t}\n\n\tpublic set alpha(value:number)\n\t{\n\t\tthis._baseMethod.alpha = value;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic get epsilon():number\n\t{\n\t\treturn this._baseMethod.epsilon;\n\t}\n\n\tpublic set epsilon(value:number)\n\t{\n\t\tthis._baseMethod.epsilon = value;\n\t}\n\n\t/**\n\t * The amount of shadow fading to the outer shadow area. A value of 1 would mean the shadows start fading from the camera's near plane.\n\t */\n\tpublic get fadeRatio():number\n\t{\n\t\treturn this._fadeRatio;\n\t}\n\n\tpublic set fadeRatio(value:number)\n\t{\n\t\tthis._fadeRatio = value;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentCode(shader:ShaderBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = this._baseMethod.iGetFragmentCode(shader, methodVO, targetReg, registerCache, sharedRegisters);\n\n\t\tvar dataReg:ShaderRegisterElement = registerCache.getFreeFragmentConstant();\n\t\tvar temp:ShaderRegisterElement = registerCache.getFreeFragmentSingleTemp();\n\t\tmethodVO.secondaryFragmentConstantsIndex = dataReg.index*4;\n\n\t\tcode += \"abs \" + temp + \", \" + sharedRegisters.projectionFragment + \".w\\n\" +\n\t\t\t\"sub \" + temp + \", \" + temp + \", \" + dataReg + \".x\\n\" +\n\t\t\t\"mul \" + temp + \", \" + temp + \", \" + dataReg + \".y\\n\" +\n\t\t\t\"sat \" + temp + \", \" + temp + \"\\n\" +\n\t\t\t\"sub \" + temp + \", \" + dataReg + \".w,\" + temp + \"\\n\" +\n\t\t\t\"sub \" + targetReg + \".w, \" + dataReg + \".w,\" + targetReg + \".w\\n\" +\n\t\t\t\"mul \" + targetReg + \".w, \" + targetReg + \".w, \" + temp + \"\\n\" +\n\t\t\t\"sub \" + targetReg + \".w, \" + dataReg + \".w,\" + targetReg + \".w\\n\";\n\n\t\treturn code;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iActivate(shader:ShaderBase, methodVO:MethodVO, stage:Stage)\n\t{\n\t\tthis._baseMethod.iActivate(shader, methodVO, stage);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iDeactivate(shader:ShaderBase, methodVO:MethodVO, stage:Stage)\n\t{\n\t\tthis._baseMethod.iDeactivate(shader, methodVO, stage);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iSetRenderState(shader:ShaderBase, methodVO:MethodVO, renderable:RenderableBase, stage:Stage, camera:Camera)\n\t{\n\t\t// todo: move this to activate (needs camera)\n\t\tvar near:number = camera.projection.near;\n\t\tvar d:number = camera.projection.far - near;\n\t\tvar maxDistance:number = this._nearShadowMapper.coverageRatio;\n\t\tvar minDistance:number = maxDistance*(1 - this._fadeRatio);\n\n\t\tmaxDistance = near + maxDistance*d;\n\t\tminDistance = near + minDistance*d;\n\n\t\tvar fragmentData:Float32Array = shader.fragmentConstantData;\n\t\tvar index:number /*int*/ = methodVO.secondaryFragmentConstantsIndex;\n\t\tfragmentData[index] = minDistance;\n\t\tfragmentData[index + 1] = 1/(maxDistance - minDistance);\n\n\t\tthis._baseMethod.iSetRenderState(shader, methodVO, renderable, stage, camera);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetVertexCode(shader:ShaderBase, methodVO:MethodVO, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\treturn this._baseMethod.iGetVertexCode(shader, methodVO, registerCache, sharedRegisters);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iReset()\n\t{\n\t\tthis._baseMethod.iReset();\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iCleanCompilationData()\n\t{\n\t\tsuper.iCleanCompilationData();\n\t\tthis._baseMethod.iCleanCompilationData();\n\t}\n\n\t/**\n\t * Called when the base method's shader code is invalidated.\n\t */\n\tprivate onShaderInvalidated(event:ShadingMethodEvent)\n\t{\n\t\tthis.iInvalidateShaderProgram();\n\t}\n}\n\nexport = ShadowNearMethod;",
    "import PoissonLookup\t\t\t\t\t= require(\"awayjs-core/lib/geom/PoissonLookup\");\n\nimport DirectionalLight\t\t\t\t\t= require(\"awayjs-display/lib/entities/DirectionalLight\");\n\nimport Stage\t\t\t\t\t\t\t= require(\"awayjs-stagegl/lib/base/Stage\");\n\nimport ShaderBase\t\t\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderBase\");\nimport ShaderRegisterCache\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterCache\");\nimport ShaderRegisterData\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterData\");\nimport ShaderRegisterElement\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterElement\");\n\nimport MethodVO\t\t\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/data/MethodVO\");\nimport ShadowMethodBase\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/methods/ShadowMethodBase\");\n\n/**\n * ShadowSoftMethod provides a soft shadowing technique by randomly distributing sample points.\n */\nclass ShadowSoftMethod extends ShadowMethodBase\n{\n\tprivate _range:number = 1;\n\tprivate _numSamples:number /*int*/;\n\tprivate _offsets:Array<number>;\n\n\t/**\n\t * Creates a new DiffuseBasicMethod object.\n\t *\n\t * @param castingLight The light casting the shadows\n\t * @param numSamples The amount of samples to take for dithering. Minimum 1, maximum 32.\n\t */\n\tconstructor(castingLight:DirectionalLight, numSamples:number /*int*/ = 5, range:number = 1)\n\t{\n\t\tsuper(castingLight);\n\n\t\tthis.numSamples = numSamples;\n\t\tthis.range = range;\n\t}\n\n\t/**\n\t * The amount of samples to take for dithering. Minimum 1, maximum 32. The actual maximum may depend on the\n\t * complexity of the shader.\n\t */\n\tpublic get numSamples():number /*int*/\n\t{\n\t\treturn this._numSamples;\n\t}\n\n\tpublic set numSamples(value:number /*int*/)\n\t{\n\t\tthis._numSamples = value;\n\t\t\n\t\tif (this._numSamples < 1)\n\t\t\tthis._numSamples = 1;\n\t\telse if (this._numSamples > 32)\n\t\t\tthis._numSamples = 32;\n\n\t\tthis._offsets = PoissonLookup.getDistribution(this._numSamples);\n\t\t\n\t\tthis.iInvalidateShaderProgram();\n\t}\n\n\t/**\n\t * The range in the shadow map in which to distribute the samples.\n\t */\n\tpublic get range():number\n\t{\n\t\treturn this._range;\n\t}\n\n\tpublic set range(value:number)\n\t{\n\t\tthis._range = value;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitConstants(shader:ShaderBase, methodVO:MethodVO)\n\t{\n\t\tsuper.iInitConstants(shader, methodVO);\n\n\t\tshader.fragmentConstantData[methodVO.fragmentConstantsIndex + 8] = 1/this._numSamples;\n\t\tshader.fragmentConstantData[methodVO.fragmentConstantsIndex + 9] = 0;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iActivate(shader:ShaderBase, methodVO:MethodVO, stage:Stage)\n\t{\n\t\tsuper.iActivate(shader, methodVO, stage);\n\n\t\tvar texRange:number = .5*this._range/this._pCastingLight.shadowMapper.depthMapSize;\n\t\tvar data:Float32Array = shader.fragmentConstantData;\n\t\tvar index:number /*uint*/ = methodVO.fragmentConstantsIndex + 10;\n\t\tvar len:number /*uint*/ = this._numSamples << 1;\n\n\t\tfor (var i:number /*int*/ = 0; i < len; ++i)\n\t\t\tdata[index + i] = this._offsets[i]*texRange;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic _pGetPlanarFragmentCode(shader:ShaderBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, regCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\t// todo: move some things to super\n\t\tvar decReg:ShaderRegisterElement = regCache.getFreeFragmentConstant();\n\t\tregCache.getFreeFragmentConstant();\n\t\tvar dataReg:ShaderRegisterElement = regCache.getFreeFragmentConstant();\n\n\t\tmethodVO.fragmentConstantsIndex = decReg.index*4;\n\n\t\treturn this.getSampleCode(shader, methodVO, decReg, targetReg, regCache, sharedRegisters, dataReg);\n\t}\n\n\t/**\n\t * Adds the code for another tap to the shader code.\n\t * @param uv The uv register for the tap.\n\t * @param texture The texture register containing the depth map.\n\t * @param decode The register containing the depth map decoding data.\n\t * @param target The target register to add the tap comparison result.\n\t * @param regCache The register cache managing the registers.\n\t * @return\n\t */\n\tprivate addSample(shader:ShaderBase, methodVO:MethodVO, decodeRegister:ShaderRegisterElement, targetRegister:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData, uvReg:ShaderRegisterElement):string\n\t{\n\t\tvar temp:ShaderRegisterElement = registerCache.getFreeFragmentVectorTemp();\n\t\treturn methodVO.textureVO._iGetFragmentCode(shader, temp, registerCache, sharedRegisters, uvReg) +\n\t\t\t\"dp4 \" + temp + \".z, \" + temp + \", \" + decodeRegister + \"\\n\" +\n\t\t\t\"slt \" + uvReg + \".w, \" + this._pDepthMapCoordReg + \".z, \" + temp + \".z\\n\" + // 0 if in shadow\n\t\t\t\"add \" + targetRegister + \".w, \" + targetRegister + \".w, \" + uvReg + \".w\\n\";\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iActivateForCascade(shader:ShaderBase, methodVO:MethodVO, stage:Stage)\n\t{\n\t\tsuper.iActivate(shader, methodVO, stage);\n\n\t\tvar texRange:number = this._range/this._pCastingLight.shadowMapper.depthMapSize;\n\t\tvar data:Float32Array = shader.fragmentConstantData;\n\t\tvar index:number /*uint*/ = methodVO.secondaryFragmentConstantsIndex;\n\t\tvar len:number /*uint*/ = this._numSamples << 1;\n\t\tdata[index] = 1/this._numSamples;\n\t\tdata[index + 1] = 0;\n\t\tindex += 2;\n\n\t\tfor (var i:number /*int*/ = 0; i < len; ++i)\n\t\t\tdata[index + i] = this._offsets[i]*texRange;\n\n\t\tif (len%4 == 0) {\n\t\t\tdata[index + len] = 0;\n\t\t\tdata[index + len + 1] = 0;\n\t\t}\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic _iGetCascadeFragmentCode(shader:ShaderBase, methodVO:MethodVO, decodeRegister:ShaderRegisterElement, depthProjection:ShaderRegisterElement, targetRegister:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tthis._pDepthMapCoordReg = depthProjection;\n\n\t\tvar dataReg:ShaderRegisterElement = registerCache.getFreeFragmentConstant();\n\t\tmethodVO.secondaryFragmentConstantsIndex = dataReg.index*4;\n\n\t\treturn this.getSampleCode(shader, methodVO, decodeRegister, targetRegister, registerCache, sharedRegisters, dataReg);\n\t}\n\n\t/**\n\t * Get the actual shader code for shadow mapping\n\t * @param regCache The register cache managing the registers.\n\t * @param depthTexture The texture register containing the depth map.\n\t * @param decodeRegister The register containing the depth map decoding data.\n\t * @param targetReg The target register to add the shadow coverage.\n\t * @param dataReg The register containing additional data.\n\t */\n\tprivate getSampleCode(shader:ShaderBase, methodVO:MethodVO, decodeRegister:ShaderRegisterElement, targetRegister:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData, dataReg:ShaderRegisterElement):string\n\t{\n\t\tvar code:string;\n\t\tvar uvReg:ShaderRegisterElement = registerCache.getFreeFragmentVectorTemp();\n\t\tregisterCache.addFragmentTempUsages(uvReg, 1);\n\n\t\tvar offsets:Array<string> = new Array<string>(dataReg + \".zw\");\n\t\tvar numRegs:number /*int*/ = this._numSamples >> 1;\n\n\t\tfor (var i:number /*int*/ = 0; i < numRegs; ++i) {\n\t\t\tvar reg:ShaderRegisterElement = registerCache.getFreeFragmentConstant();\n\t\t\toffsets.push(reg + \".xy\");\n\t\t\toffsets.push(reg + \".zw\");\n\t\t}\n\n\t\tfor (i = 0; i < this._numSamples; ++i) {\n\t\t\tif (i == 0) {\n\t\t\t\tvar temp:ShaderRegisterElement = registerCache.getFreeFragmentVectorTemp();\n\n\t\t\t\tcode = \"add \" + uvReg + \", \" + this._pDepthMapCoordReg + \", \" + dataReg + \".zwyy\\n\" +\n\t\t\t\t\tmethodVO.textureVO._iGetFragmentCode(shader, temp, registerCache, sharedRegisters, uvReg) +\n\t\t\t\t\t\"dp4 \" + temp + \".z, \" + temp + \", \" + decodeRegister + \"\\n\" +\n\t\t\t\t\t\"slt \" + targetRegister + \".w, \" + this._pDepthMapCoordReg + \".z, \" + temp + \".z\\n\"; // 0 if in shadow;\n\t\t\t} else {\n\t\t\t\tcode += \"add \" + uvReg + \".xy, \" + this._pDepthMapCoordReg + \".xy, \" + offsets[i] + \"\\n\" +\n\t\t\t\t\tthis.addSample(shader, methodVO, decodeRegister, targetRegister, registerCache, sharedRegisters, uvReg);\n\t\t\t}\n\t\t}\n\n\t\tregisterCache.removeFragmentTempUsage(uvReg);\n\n\t\tcode += \"mul \" + targetRegister + \".w, \" + targetRegister + \".w, \" + dataReg + \".x\\n\"; // average\n\n\t\treturn code;\n\t}\n}\n\nexport = ShadowSoftMethod;",
    "import LightingShader\t\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/LightingShader\");\nimport ShaderRegisterCache\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterCache\");\nimport ShaderRegisterData\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterData\");\nimport ShaderRegisterElement\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterElement\");\n\nimport MethodVO\t\t\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/data/MethodVO\");\nimport SpecularBasicMethod\t\t\t\t= require(\"awayjs-methodmaterials/lib/methods/SpecularBasicMethod\");\n\n/**\n * SpecularAnisotropicMethod provides a specular method resulting in anisotropic highlights. These are typical for\n * surfaces with microfacet details such as tiny grooves. In particular, this uses the Heidrich-Seidel distrubution.\n * The tangent vectors are used as the surface groove directions.\n */\nclass SpecularAnisotropicMethod extends SpecularBasicMethod\n{\n\t/**\n\t * Creates a new SpecularAnisotropicMethod object.\n\t */\n\tconstructor()\n\t{\n\t\tsuper();\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitVO(shader:LightingShader, methodVO:MethodVO)\n\t{\n\t\tmethodVO.needsTangents = true;\n\t\tmethodVO.needsView = true;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentCodePerLight(shader:LightingShader, methodVO:MethodVO, lightDirReg:ShaderRegisterElement, lightColReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = \"\";\n\t\tvar t:ShaderRegisterElement;\n\n\t\tif (this._pIsFirstLight)\n\t\t\tt = this._pTotalLightColorReg;\n\t\telse {\n\t\t\tt = registerCache.getFreeFragmentVectorTemp();\n\t\t\tregisterCache.addFragmentTempUsages(t, 1);\n\t\t}\n\n\t\t// (sin(l,t) * sin(v,t) - cos(l,t)*cos(v,t)) ^ k\n\n\t\tcode += \"nrm \" + t + \".xyz, \" + sharedRegisters.tangentVarying + \".xyz\\n\" +\n\t\t\t\"dp3 \" + t + \".w, \" + t + \".xyz, \" + lightDirReg + \".xyz\\n\" +\n\t\t\t\"dp3 \" + t + \".z, \" + t + \".xyz, \" + sharedRegisters.viewDirFragment + \".xyz\\n\";\n\n\t\t// (sin(t.w) * sin(t.z) - cos(t.w)*cos(t.z)) ^ k\n\t\tcode += \"sin \" + t + \".x, \" + t + \".w\\n\" +\n\t\t\t\"sin \" + t + \".y, \" + t + \".z\\n\" +\n\t\t\t// (t.x * t.y - cos(t.w)*cos(t.z)) ^ k\n\t\t\t\"mul \" + t + \".x, \" + t + \".x, \" + t + \".y\\n\" +\n\t\t\t// (t.x - cos(t.w)*cos(t.z)) ^ k\n\t\t\t\"cos \" + t + \".z, \" + t + \".z\\n\" +\n\t\t\t\"cos \" + t + \".w, \" + t + \".w\\n\" +\n\t\t\t// (t.x - t.w*t.z) ^ k\n\t\t\t\"mul \" + t + \".w, \" + t + \".w, \" + t + \".z\\n\" +\n\t\t\t// (t.x - t.w) ^ k\n\t\t\t\"sub \" + t + \".w, \" + t + \".x, \" + t + \".w\\n\";\n\n\t\tif (this.texture) {\n\t\t\t// apply gloss modulation from texture\n\t\t\tcode += \"mul \" + this._pSpecularTexData + \".w, \" + this._pSpecularTexData + \".y, \" + this._pSpecularDataRegister + \".w\\n\" +\n\t\t\t\t\"pow \" + t + \".w, \" + t + \".w, \" + this._pSpecularTexData + \".w\\n\";\n\t\t} else\n\t\t\tcode += \"pow \" + t + \".w, \" + t + \".w, \" + this._pSpecularDataRegister + \".w\\n\";\n\n\t\t// attenuate\n\t\tcode += \"mul \" + t + \".w, \" + t + \".w, \" + lightDirReg + \".w\\n\";\n\n\t\tif (this._iModulateMethod != null)\n\t\t\tcode += this._iModulateMethod(shader, methodVO, t, registerCache, sharedRegisters);\n\n\t\tcode += \"mul \" + t + \".xyz, \" + lightColReg + \".xyz, \" + t + \".w\\n\";\n\n\t\tif (!this._pIsFirstLight) {\n\t\t\tcode += \"add \" + this._pTotalLightColorReg + \".xyz, \" + this._pTotalLightColorReg + \".xyz, \" + t + \".xyz\\n\";\n\t\t\tregisterCache.removeFragmentTempUsage(t);\n\t\t}\n\n\t\tthis._pIsFirstLight = false;\n\n\t\treturn code;\n\t}\n}\n\nexport = SpecularAnisotropicMethod;",
    "import Camera\t\t\t\t\t\t\t= require(\"awayjs-display/lib/entities/Camera\");\nimport TextureBase\t\t\t\t\t\t= require(\"awayjs-display/lib/textures/TextureBase\");\n\nimport Stage\t\t\t\t\t\t\t= require(\"awayjs-stagegl/lib/base/Stage\");\n\nimport RenderableBase\t\t\t\t\t= require(\"awayjs-renderergl/lib/renderables/RenderableBase\");\nimport LightingShader\t\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/LightingShader\");\nimport ShaderRegisterCache\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterCache\");\nimport ShaderRegisterData\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterData\");\nimport ShaderRegisterElement\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterElement\");\n\nimport MethodVO\t\t\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/data/MethodVO\");\nimport LightingMethodBase\t\t\t\t= require(\"awayjs-methodmaterials/lib/methods/LightingMethodBase\");\nimport ShadingMethodBase\t\t\t\t= require(\"awayjs-methodmaterials/lib/methods/ShadingMethodBase\");\n\n/**\n * SpecularBasicMethod provides the default shading method for Blinn-Phong specular highlights (an optimized but approximated\n * version of Phong specularity).\n */\nclass SpecularBasicMethod extends LightingMethodBase\n{\n\tpublic _pTotalLightColorReg:ShaderRegisterElement;\n\tpublic _pSpecularTexData:ShaderRegisterElement;\n\tpublic _pSpecularDataRegister:ShaderRegisterElement;\n\n\tprivate _texture:TextureBase;\n\n\tprivate _gloss:number = 50;\n\tprivate _specular:number = 1;\n\tprivate _specularColor:number = 0xffffff;\n\tpublic _iSpecularR:number = 1;\n\tpublic _iSpecularG:number = 1;\n\tpublic _iSpecularB:number = 1;\n\tpublic _pIsFirstLight:boolean;\n\n\t/**\n\t * Creates a new SpecularBasicMethod object.\n\t */\n\tconstructor()\n\t{\n\t\tsuper();\n\t}\n\n\tpublic iIsUsed(shader:LightingShader):boolean\n\t{\n\t\tif (!shader.numLights)\n\t\t\treturn false;\n\n\t\treturn true;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitVO(shader:LightingShader, methodVO:MethodVO)\n\t{\n\t\tmethodVO.needsNormals = shader.numLights > 0;\n\t\tmethodVO.needsView = shader.numLights > 0;\n\n\t\tif (this._texture) {\n\t\t\tmethodVO.textureVO = shader.getTextureVO(this._texture);\n\t\t\tshader.uvDependencies++;\n\t\t} else if (methodVO.textureVO) {\n\t\t\tmethodVO.textureVO.dispose();\n\t\t\tmethodVO.textureVO = null;\n\t\t}\n\t}\n\n\t/**\n\t * The sharpness of the specular highlight.\n\t */\n\tpublic get gloss():number\n\t{\n\t\treturn this._gloss;\n\t}\n\n\tpublic set gloss(value:number)\n\t{\n\t\tthis._gloss = value;\n\t}\n\n\t/**\n\t * The overall strength of the specular highlights.\n\t */\n\tpublic get specular():number\n\t{\n\t\treturn this._specular;\n\t}\n\n\tpublic set specular(value:number)\n\t{\n\t\tif (value == this._specular)\n\t\t\treturn;\n\n\t\tthis._specular = value;\n\t\tthis.updateSpecular();\n\t}\n\n\t/**\n\t * The colour of the specular reflection of the surface.\n\t */\n\tpublic get specularColor():number\n\t{\n\t\treturn this._specularColor;\n\t}\n\n\tpublic set specularColor(value:number)\n\t{\n\t\tif (this._specularColor == value)\n\t\t\treturn;\n\n\t\t// specular is now either enabled or disabled\n\t\tif (this._specularColor == 0 || value == 0)\n\t\t\tthis.iInvalidateShaderProgram();\n\n\t\tthis._specularColor = value;\n\t\tthis.updateSpecular();\n\t}\n\n\t/**\n\t * The bitmapData that encodes the specular highlight strength per texel in the red channel, and the sharpness\n\t * in the green channel. You can use SpecularTextureBase if you want to easily set specular and gloss maps\n\t * from grayscale images, but prepared images are preferred.\n\t */\n\tpublic get texture():TextureBase\n\t{\n\t\treturn this._texture;\n\t}\n\n\tpublic set texture(value:TextureBase)\n\t{\n\t\tif (this._texture == value)\n\t\t\treturn;\n\n\t\tif (this._texture)\n\t\t\tthis.iRemoveTexture(this._texture);\n\n\t\tthis._texture = value;\n\n\t\tif (this._texture)\n\t\t\tthis.iAddTexture(this._texture);\n\n\t\tthis.iInvalidateShaderProgram();\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic copyFrom(method:ShadingMethodBase)\n\t{\n\n\t\tvar m:any = method;\n\t\tvar bsm:SpecularBasicMethod = <SpecularBasicMethod> method;\n\n\t\tvar spec:SpecularBasicMethod = bsm;//SpecularBasicMethod(method);\n\t\tthis.texture = spec.texture;\n\t\tthis.specular = spec.specular;\n\t\tthis.specularColor = spec.specularColor;\n\t\tthis.gloss = spec.gloss;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iCleanCompilationData()\n\t{\n\t\tsuper.iCleanCompilationData();\n\t\tthis._pTotalLightColorReg = null;\n\t\tthis._pSpecularTexData = null;\n\t\tthis._pSpecularDataRegister = null;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentPreLightingCode(shader:LightingShader, methodVO:MethodVO, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = \"\";\n\n\t\tthis._pIsFirstLight = true;\n\n\t\tthis._pSpecularDataRegister = registerCache.getFreeFragmentConstant();\n\t\tmethodVO.fragmentConstantsIndex = this._pSpecularDataRegister.index*4;\n\n\t\tif (this._texture) {\n\n\t\t\tthis._pSpecularTexData = registerCache.getFreeFragmentVectorTemp();\n\t\t\tregisterCache.addFragmentTempUsages(this._pSpecularTexData, 1);\n\n\t\t\tcode += methodVO.textureVO._iGetFragmentCode(shader, this._pSpecularTexData, registerCache, sharedRegisters, sharedRegisters.uvVarying);\n\t\t}\n\n\t\tthis._pTotalLightColorReg = registerCache.getFreeFragmentVectorTemp();\n\t\tregisterCache.addFragmentTempUsages(this._pTotalLightColorReg, 1);\n\n\t\treturn code;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentCodePerLight(shader:LightingShader, methodVO:MethodVO, lightDirReg:ShaderRegisterElement, lightColReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = \"\";\n\t\tvar t:ShaderRegisterElement;\n\n\t\tif (this._pIsFirstLight) {\n\t\t\tt = this._pTotalLightColorReg;\n\t\t} else {\n\t\t\tt = registerCache.getFreeFragmentVectorTemp();\n\t\t\tregisterCache.addFragmentTempUsages(t, 1);\n\t\t}\n\n\t\tvar viewDirReg:ShaderRegisterElement = sharedRegisters.viewDirFragment;\n\t\tvar normalReg:ShaderRegisterElement = sharedRegisters.normalFragment;\n\n\t\t// blinn-phong half vector model\n\t\tcode += \"add \" + t + \", \" + lightDirReg + \", \" + viewDirReg + \"\\n\" +\n\t\t\t\t\"nrm \" + t + \".xyz, \" + t + \"\\n\" +\n\t\t\t\t\"dp3 \" + t + \".w, \" + normalReg + \", \" + t + \"\\n\" +\n\t\t\t\t\"sat \" + t + \".w, \" + t + \".w\\n\";\n\n\t\tif (this._texture) {\n\t\t\t// apply gloss modulation from texture\n\t\t\tcode += \"mul \" + this._pSpecularTexData + \".w, \" + this._pSpecularTexData + \".y, \" + this._pSpecularDataRegister + \".w\\n\" +\n\t\t\t\t\t\"pow \" + t + \".w, \" + t + \".w, \" + this._pSpecularTexData + \".w\\n\";\n\t\t} else {\n\t\t\tcode += \"pow \" + t + \".w, \" + t + \".w, \" + this._pSpecularDataRegister + \".w\\n\";\n\t\t}\n\n\t\t// attenuate\n\t\tif (shader.usesLightFallOff)\n\t\t\tcode += \"mul \" + t + \".w, \" + t + \".w, \" + lightDirReg + \".w\\n\";\n\n\t\tif (this._iModulateMethod != null)\n\t\t\tcode += this._iModulateMethod(shader, methodVO, t, registerCache, sharedRegisters);\n\n\t\tcode += \"mul \" + t + \".xyz, \" + lightColReg + \", \" + t + \".w\\n\";\n\n\t\tif (!this._pIsFirstLight) {\n\t\t\tcode += \"add \" + this._pTotalLightColorReg + \".xyz, \" + this._pTotalLightColorReg + \", \" + t + \"\\n\";\n\t\t\tregisterCache.removeFragmentTempUsage(t);\n\t\t}\n\n\t\tthis._pIsFirstLight = false;\n\n\t\treturn code;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentCodePerProbe(shader:LightingShader, methodVO:MethodVO, cubeMapReg:ShaderRegisterElement, weightRegister:string, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = \"\";\n\t\tvar t:ShaderRegisterElement;\n\n\t\t// write in temporary if not first light, so we can add to total diffuse colour\n\t\tif (this._pIsFirstLight) {\n\t\t\tt = this._pTotalLightColorReg;\n\t\t} else {\n\t\t\tt = registerCache.getFreeFragmentVectorTemp();\n\t\t\tregisterCache.addFragmentTempUsages(t, 1);\n\t\t}\n\n\t\tvar normalReg:ShaderRegisterElement = sharedRegisters.normalFragment;\n\t\tvar viewDirReg:ShaderRegisterElement = sharedRegisters.viewDirFragment;\n\n\t\tcode += \"dp3 \" + t + \".w, \" + normalReg + \", \" + viewDirReg + \"\\n\" +\n\t\t\t\t\"add \" + t + \".w, \" + t + \".w, \" + t + \".w\\n\" +\n\t\t\t\t\"mul \" + t + \", \" + t + \".w, \" + normalReg + \"\\n\" +\n\t\t\t\t\"sub \" + t + \", \" + t + \", \" + viewDirReg + \"\\n\" +\n\t\t\t\t\"tex \" + t + \", \" + t + \", \" + cubeMapReg + \" <cube,\" + (shader.useSmoothTextures? \"linear\":\"nearest\") + \",miplinear>\\n\" +\n\t\t\t\t\"mul \" + t + \".xyz, \" + t + \", \" + weightRegister + \"\\n\";\n\n\t\tif (this._iModulateMethod != null)\n\t\t\tcode += this._iModulateMethod(shader, methodVO, t, registerCache, sharedRegisters);\n\n\t\tif (!this._pIsFirstLight) {\n\t\t\tcode += \"add \" + this._pTotalLightColorReg + \".xyz, \" + this._pTotalLightColorReg + \", \" + t + \"\\n\";\n\t\t\tregisterCache.removeFragmentTempUsage(t);\n\t\t}\n\n\t\tthis._pIsFirstLight = false;\n\n\t\treturn code;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentPostLightingCode(shader:LightingShader, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = \"\";\n\n\t\tif (sharedRegisters.shadowTarget)\n\t\t\tcode += \"mul \" + this._pTotalLightColorReg + \".xyz, \" + this._pTotalLightColorReg + \", \" + sharedRegisters.shadowTarget + \".w\\n\";\n\n\t\tif (this._texture) {\n\t\t\t// apply strength modulation from texture\n\t\t\tcode += \"mul \" + this._pTotalLightColorReg + \".xyz, \" + this._pTotalLightColorReg + \", \" + this._pSpecularTexData + \".x\\n\";\n\t\t\tregisterCache.removeFragmentTempUsage(this._pSpecularTexData);\n\t\t}\n\n\t\t// apply material's specular reflection\n\t\tcode += \"mul \" + this._pTotalLightColorReg + \".xyz, \" + this._pTotalLightColorReg + \", \" + this._pSpecularDataRegister + \"\\n\" +\n\t\t\t\"add \" + targetReg + \".xyz, \" + targetReg + \", \" + this._pTotalLightColorReg + \"\\n\";\n\t\tregisterCache.removeFragmentTempUsage(this._pTotalLightColorReg);\n\n\t\treturn code;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iActivate(shader:LightingShader, methodVO:MethodVO, stage:Stage)\n\t{\n\t\tif (this._texture)\n\t\t\tmethodVO.textureVO.activate(shader);\n\n\t\tvar index:number = methodVO.fragmentConstantsIndex;\n\t\tvar data:Float32Array = shader.fragmentConstantData;\n\t\tdata[index] = this._iSpecularR;\n\t\tdata[index + 1] = this._iSpecularG;\n\t\tdata[index + 2] = this._iSpecularB;\n\t\tdata[index + 3] = this._gloss;\n\t}\n\n\tpublic iSetRenderState(shader:LightingShader, methodVO:MethodVO, renderable:RenderableBase, stage:Stage, camera:Camera)\n\t{\n\t\tif (this._texture)\n\t\t\tmethodVO.textureVO._setRenderState(renderable, shader);\n\t}\n\n\t/**\n\t * Updates the specular color data used by the render state.\n\t */\n\tprivate updateSpecular()\n\t{\n\t\tthis._iSpecularR = (( this._specularColor >> 16) & 0xff)/0xff*this._specular;\n\t\tthis._iSpecularG = (( this._specularColor >> 8) & 0xff)/0xff*this._specular;\n\t\tthis._iSpecularB = ( this._specularColor & 0xff)/0xff*this._specular;\n\t}\n}\n\nexport = SpecularBasicMethod;",
    "import Stage\t\t\t\t\t\t\t= require(\"awayjs-stagegl/lib/base/Stage\");\n\nimport LightingShader\t\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/LightingShader\");\nimport ShaderBase\t\t\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderBase\");\nimport ShaderRegisterCache\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterCache\");\nimport ShaderRegisterData\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterData\");\nimport ShaderRegisterElement\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterElement\");\n\nimport MethodVO\t\t\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/data/MethodVO\");\nimport SpecularBasicMethod\t\t\t\t= require(\"awayjs-methodmaterials/lib/methods/SpecularBasicMethod\");\nimport SpecularCompositeMethod\t\t\t= require(\"awayjs-methodmaterials/lib/methods/SpecularCompositeMethod\");\n\n/**\n * SpecularCelMethod provides a shading method to add specular cel (cartoon) shading.\n */\nclass SpecularCelMethod extends SpecularCompositeMethod\n{\n\tprivate _dataReg:ShaderRegisterElement;\n\tprivate _smoothness:number = .1;\n\tprivate _specularCutOff:number = .1;\n\n\t/**\n\t * Creates a new SpecularCelMethod object.\n\t * @param specularCutOff The threshold at which the specular highlight should be shown.\n\t * @param baseMethod An optional specular method on which the cartoon shading is based. If ommitted, SpecularBasicMethod is used.\n\t */\n\tconstructor(specularCutOff:number = .5, baseMethod:SpecularBasicMethod = null)\n\t{\n\t\tsuper(null, baseMethod);\n\n\t\tthis.baseMethod._iModulateMethod = (shader:ShaderBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData) => this.clampSpecular(shader, methodVO, targetReg, registerCache, sharedRegisters);\n\n\t\tthis._specularCutOff = specularCutOff;\n\t}\n\n\t/**\n\t * The smoothness of the highlight edge.\n\t */\n\tpublic get smoothness():number\n\t{\n\t\treturn this._smoothness;\n\t}\n\n\tpublic set smoothness(value:number)\n\t{\n\t\tthis._smoothness = value;\n\t}\n\n\t/**\n\t * The threshold at which the specular highlight should be shown.\n\t */\n\tpublic get specularCutOff():number\n\t{\n\t\treturn this._specularCutOff;\n\t}\n\n\tpublic set specularCutOff(value:number)\n\t{\n\t\tthis._specularCutOff = value;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iActivate(shader:LightingShader, methodVO:MethodVO, stage:Stage)\n\t{\n\t\tsuper.iActivate(shader, methodVO, stage);\n\n\t\tvar index:number /*int*/ = methodVO.secondaryFragmentConstantsIndex;\n\t\tvar data:Float32Array = shader.fragmentConstantData;\n\t\tdata[index] = this._smoothness;\n\t\tdata[index + 1] = this._specularCutOff;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iCleanCompilationData()\n\t{\n\t\tsuper.iCleanCompilationData();\n\t\tthis._dataReg = null;\n\t}\n\n\t/**\n\t * Snaps the specular shading strength of the wrapped method to zero or one, depending on whether or not it exceeds the specularCutOff\n\t * @param vo The MethodVO used to compile the current shader.\n\t * @param t The register containing the specular strength in the \"w\" component, and either the half-vector or the reflection vector in \"xyz\".\n\t * @param regCache The register cache used for the shader compilation.\n\t * @param sharedRegisters The shared register data for this shader.\n\t * @return The AGAL fragment code for the method.\n\t */\n\tprivate clampSpecular(shader:ShaderBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\treturn \"sub \" + targetReg + \".y, \" + targetReg + \".w, \" + this._dataReg + \".y\\n\" + // x - cutoff\n\t\t\t\"div \" + targetReg + \".y, \" + targetReg + \".y, \" + this._dataReg + \".x\\n\" + // (x - cutoff)/epsilon\n\t\t\t\"sat \" + targetReg + \".y, \" + targetReg + \".y\\n\" +\n\t\t\t\"sge \" + targetReg + \".w, \" + targetReg + \".w, \" + this._dataReg + \".y\\n\" +\n\t\t\t\"mul \" + targetReg + \".w, \" + targetReg + \".w, \" + targetReg + \".y\\n\";\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentPreLightingCode(shader:LightingShader, methodVO:MethodVO, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tthis._dataReg = registerCache.getFreeFragmentConstant();\n\t\tmethodVO.secondaryFragmentConstantsIndex = this._dataReg.index*4;\n\n\t\treturn super.iGetFragmentPreLightingCode(shader, methodVO, registerCache, sharedRegisters);\n\t}\n}\n\nexport = SpecularCelMethod;",
    "import Camera\t\t\t\t\t\t\t= require(\"awayjs-display/lib/entities/Camera\");\nimport TextureBase\t\t\t\t\t\t= require(\"awayjs-display/lib/textures/TextureBase\");\nimport IRenderOwner\t\t\t\t\t\t= require(\"awayjs-display/lib/base/IRenderOwner\");\n\nimport Stage\t\t\t\t\t\t\t= require(\"awayjs-stagegl/lib/base/Stage\");\n\nimport RenderableBase\t\t\t\t\t= require(\"awayjs-renderergl/lib/renderables/RenderableBase\");\nimport ShadingMethodEvent\t\t\t\t= require(\"awayjs-renderergl/lib/events/ShadingMethodEvent\");\nimport LightingShader\t\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/LightingShader\");\nimport ShaderBase\t\t\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderBase\");\nimport ShaderRegisterCache\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterCache\");\nimport ShaderRegisterData\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterData\");\nimport ShaderRegisterElement\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterElement\");\n\nimport MethodVO\t\t\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/data/MethodVO\");\nimport SpecularBasicMethod\t\t\t\t= require(\"awayjs-methodmaterials/lib/methods/SpecularBasicMethod\");\n\n/**\n * SpecularCompositeMethod provides a base class for specular methods that wrap a specular method to alter the\n * calculated specular reflection strength.\n */\nclass SpecularCompositeMethod extends SpecularBasicMethod\n{\n\tprivate _baseMethod:SpecularBasicMethod;\n\n\tprivate _onShaderInvalidatedDelegate:Function;\n\n\t/**\n\t * Creates a new <code>SpecularCompositeMethod</code> object.\n\t *\n\t * @param modulateMethod The method which will add the code to alter the base method's strength. It needs to have the signature modSpecular(t:ShaderRegisterElement, regCache:ShaderRegisterCache):string, in which t.w will contain the specular strength and t.xyz will contain the half-vector or the reflection vector.\n\t * @param baseMethod The base specular method on which this method's shading is based.\n\t */\n\tconstructor(modulateMethod:(shader:ShaderBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData) => string, baseMethod:SpecularBasicMethod = null)\n\t{\n\t\tsuper();\n\n\t\tthis._onShaderInvalidatedDelegate = (event:ShadingMethodEvent) => this.onShaderInvalidated(event);\n\n\t\tthis._baseMethod = baseMethod || new SpecularBasicMethod();\n\t\tthis._baseMethod._iModulateMethod = modulateMethod;\n\t\tthis._baseMethod.addEventListener(ShadingMethodEvent.SHADER_INVALIDATED, this._onShaderInvalidatedDelegate);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitVO(shader:LightingShader, methodVO:MethodVO)\n\t{\n\t\tthis._baseMethod.iInitVO(shader, methodVO);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitConstants(shader:ShaderBase, methodVO:MethodVO)\n\t{\n\t\tthis._baseMethod.iInitConstants(shader, methodVO);\n\t}\n\n\n\tpublic iAddOwner(owner:IRenderOwner)\n\t{\n\t\tsuper.iAddOwner(owner);\n\n\t\tthis._baseMethod.iAddOwner(owner);\n\t}\n\n\tpublic iRemoveOwner(owner:IRenderOwner)\n\t{\n\t\tsuper.iRemoveOwner(owner);\n\n\t\tthis._baseMethod.iRemoveOwner(owner);\n\t}\n\n\t/**\n\t * The base specular method on which this method's shading is based.\n\t */\n\tpublic get baseMethod():SpecularBasicMethod\n\t{\n\t\treturn this._baseMethod;\n\t}\n\n\tpublic set baseMethod(value:SpecularBasicMethod)\n\t{\n\t\tif (this._baseMethod == value)\n\t\t\treturn;\n\n\t\tthis._baseMethod.removeEventListener(ShadingMethodEvent.SHADER_INVALIDATED, this._onShaderInvalidatedDelegate);\n\n\t\tthis._baseMethod = value;\n\n\t\tthis._baseMethod.addEventListener(ShadingMethodEvent.SHADER_INVALIDATED, this._onShaderInvalidatedDelegate);\n\n\t\tthis.iInvalidateShaderProgram();\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic get gloss():number\n\t{\n\t\treturn this._baseMethod.gloss;\n\t}\n\n\tpublic set gloss(value:number)\n\t{\n\t\tthis._baseMethod.gloss = value;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic get specular():number\n\t{\n\t\treturn this._baseMethod.specular;\n\t}\n\n\tpublic set specular(value:number)\n\t{\n\t\tthis._baseMethod.specular = value;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic dispose()\n\t{\n\t\tthis._baseMethod.removeEventListener(ShadingMethodEvent.SHADER_INVALIDATED, this._onShaderInvalidatedDelegate);\n\t\tthis._baseMethod.dispose();\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic get texture():TextureBase\n\t{\n\t\treturn this._baseMethod.texture;\n\t}\n\n\tpublic set texture(value:TextureBase)\n\t{\n\t\tthis._baseMethod.texture = value;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iActivate(shader:LightingShader, methodVO:MethodVO, stage:Stage)\n\t{\n\t\tthis._baseMethod.iActivate(shader, methodVO, stage);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iSetRenderState(shader:LightingShader, methodVO:MethodVO, renderable:RenderableBase, stage:Stage, camera:Camera)\n\t{\n\t\tthis._baseMethod.iSetRenderState(shader, methodVO, renderable, stage, camera);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iDeactivate(shader:ShaderBase, methodVO:MethodVO, stage:Stage)\n\t{\n\t\tthis._baseMethod.iDeactivate(shader, methodVO, stage);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetVertexCode(shader:ShaderBase, methodVO:MethodVO, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\treturn this._baseMethod.iGetVertexCode(shader, methodVO, registerCache, sharedRegisters);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentPreLightingCode(shader:LightingShader, methodVO:MethodVO, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\treturn this._baseMethod.iGetFragmentPreLightingCode(shader, methodVO, registerCache, sharedRegisters);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentCodePerLight(shader:LightingShader, methodVO:MethodVO, lightDirReg:ShaderRegisterElement, lightColReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\treturn this._baseMethod.iGetFragmentCodePerLight(shader, methodVO, lightDirReg, lightColReg, registerCache, sharedRegisters);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t * @return\n\t */\n\tpublic iGetFragmentCodePerProbe(shader:LightingShader, methodVO:MethodVO, cubeMapReg:ShaderRegisterElement, weightRegister:string, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\treturn this._baseMethod.iGetFragmentCodePerProbe(shader, methodVO, cubeMapReg, weightRegister, registerCache, sharedRegisters);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentPostLightingCode(shader:LightingShader, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\treturn this._baseMethod.iGetFragmentPostLightingCode(shader, methodVO, targetReg, registerCache, sharedRegisters);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iReset()\n\t{\n\t\tthis._baseMethod.iReset();\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iCleanCompilationData()\n\t{\n\t\tsuper.iCleanCompilationData();\n\t\tthis._baseMethod.iCleanCompilationData();\n\t}\n\n\t/**\n\t * Called when the base method's shader code is invalidated.\n\t */\n\tprivate onShaderInvalidated(event:ShadingMethodEvent)\n\t{\n\t\tthis.iInvalidateShaderProgram();\n\t}\n}\n\nexport = SpecularCompositeMethod;",
    "import Camera\t\t\t\t\t\t\t= require(\"awayjs-display/lib/entities/Camera\");\n\nimport Stage\t\t\t\t\t\t\t= require(\"awayjs-stagegl/lib/base/Stage\");\n\nimport LightingShader\t\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/LightingShader\");\nimport ShaderBase\t\t\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderBase\");\nimport ShaderRegisterCache\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterCache\");\nimport ShaderRegisterData\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterData\");\nimport ShaderRegisterElement\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterElement\");\n\nimport MethodVO\t\t\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/data/MethodVO\");\nimport SpecularBasicMethod\t\t\t\t= require(\"awayjs-methodmaterials/lib/methods/SpecularBasicMethod\");\nimport SpecularCompositeMethod\t\t\t= require(\"awayjs-methodmaterials/lib/methods/SpecularCompositeMethod\");\n\n/**\n * SpecularFresnelMethod provides a specular shading method that causes stronger highlights on grazing view angles.\n */\nclass SpecularFresnelMethod extends SpecularCompositeMethod\n{\n\tprivate _dataReg:ShaderRegisterElement;\n\tprivate _incidentLight:boolean;\n\tprivate _fresnelPower:number = 5;\n\tprivate _normalReflectance:number = .028; // default value for skin\n\n\t/**\n\t * Creates a new SpecularFresnelMethod object.\n\t * @param basedOnSurface Defines whether the fresnel effect should be based on the view angle on the surface (if true), or on the angle between the light and the view.\n\t * @param baseMethod The specular method to which the fresnel equation. Defaults to SpecularBasicMethod.\n\t */\n\tconstructor(basedOnSurface:boolean = true, baseMethod:SpecularBasicMethod = null)\n\t{\n\t\t// may want to offer diff speculars\n\t\tsuper(null, baseMethod);\n\n\t\tthis.baseMethod._iModulateMethod = (shader:ShaderBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData) => this.modulateSpecular(shader, methodVO, targetReg, registerCache, sharedRegisters);\n\n\t\tthis._incidentLight = !basedOnSurface;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitConstants(shader:ShaderBase, methodVO:MethodVO)\n\t{\n\n\t\tvar index:number = methodVO.secondaryFragmentConstantsIndex;\n\t\tshader.fragmentConstantData[index + 2] = 1;\n\t\tshader.fragmentConstantData[index + 3] = 0;\n\t}\n\n\t/**\n\t * Defines whether the fresnel effect should be based on the view angle on the surface (if true), or on the angle between the light and the view.\n\t */\n\tpublic get basedOnSurface():boolean\n\t{\n\t\treturn !this._incidentLight;\n\t}\n\n\tpublic set basedOnSurface(value:boolean)\n\t{\n\t\tif (this._incidentLight != value)\n\t\t\treturn;\n\n\t\tthis._incidentLight = !value;\n\n\t\tthis.iInvalidateShaderProgram();\n\t}\n\n\t/**\n\t * The power used in the Fresnel equation. Higher values make the fresnel effect more pronounced. Defaults to 5.\n\t */\n\tpublic get fresnelPower():number\n\t{\n\t\treturn this._fresnelPower;\n\t}\n\n\tpublic set fresnelPower(value:number)\n\t{\n\t\tthis._fresnelPower = value;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iCleanCompilationData()\n\t{\n\t\tsuper.iCleanCompilationData();\n\t\tthis._dataReg = null;\n\t}\n\n\t/**\n\t * The minimum amount of reflectance, ie the reflectance when the view direction is normal to the surface or light direction.\n\t */\n\tpublic get normalReflectance():number\n\t{\n\t\treturn this._normalReflectance;\n\t}\n\n\tpublic set normalReflectance(value:number)\n\t{\n\t\tthis._normalReflectance = value;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iActivate(shader:LightingShader, methodVO:MethodVO, stage:Stage)\n\t{\n\t\tsuper.iActivate(shader, methodVO, stage);\n\n\t\tvar fragmentData:Float32Array = shader.fragmentConstantData;\n\n\t\tvar index:number = methodVO.secondaryFragmentConstantsIndex;\n\t\tfragmentData[index] = this._normalReflectance;\n\t\tfragmentData[index + 1] = this._fresnelPower;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentPreLightingCode(shader:LightingShader, methodVO:MethodVO, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tthis._dataReg = registerCache.getFreeFragmentConstant();\n\n\t\tmethodVO.secondaryFragmentConstantsIndex = this._dataReg.index*4;\n\n\t\treturn super.iGetFragmentPreLightingCode(shader, methodVO, registerCache, sharedRegisters);\n\t}\n\n\t/**\n\t * Applies the fresnel effect to the specular strength.\n\t *\n\t * @param vo The MethodVO object containing the method data for the currently compiled material pass.\n\t * @param target The register containing the specular strength in the \"w\" component, and the half-vector/reflection vector in \"xyz\".\n\t * @param regCache The register cache used for the shader compilation.\n\t * @param sharedRegisters The shared registers created by the compiler.\n\t * @return The AGAL fragment code for the method.\n\t */\n\tprivate modulateSpecular(shader:ShaderBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string;\n\n\t\tcode = \"dp3 \" + targetReg + \".y, \" + sharedRegisters.viewDirFragment + \".xyz, \" + (this._incidentLight? targetReg : sharedRegisters.normalFragment) + \".xyz\\n\" +   // dot(V, H)\n\t\t\t\"sub \" + targetReg + \".y, \" + this._dataReg + \".z, \" + targetReg + \".y\\n\" +             // base = 1-dot(V, H)\n\t\t\t\"pow \" + targetReg + \".x, \" + targetReg + \".y, \" + this._dataReg + \".y\\n\" +             // exp = pow(base, 5)\n\t\t\t\"sub \" + targetReg + \".y, \" + this._dataReg + \".z, \" + targetReg + \".y\\n\" +             // 1 - exp\n\t\t\t\"mul \" + targetReg + \".y, \" + this._dataReg + \".x, \" + targetReg + \".y\\n\" +             // f0*(1 - exp)\n\t\t\t\"add \" + targetReg + \".y, \" + targetReg + \".x, \" + targetReg + \".y\\n\" +          // exp + f0*(1 - exp)\n\t\t\t\"mul \" + targetReg + \".w, \" + targetReg + \".w, \" + targetReg + \".y\\n\";\n\n\t\treturn code;\n\t}\n\n}\n\nexport = SpecularFresnelMethod;",
    "import LightingShader\t\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/LightingShader\");\nimport ShaderRegisterCache\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterCache\");\nimport ShaderRegisterData\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterData\");\nimport ShaderRegisterElement\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterElement\");\n\nimport MethodVO\t\t\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/data/MethodVO\");\nimport SpecularBasicMethod\t\t\t\t= require(\"awayjs-methodmaterials/lib/methods/SpecularBasicMethod\");\n\n/**\n * SpecularPhongMethod provides a specular method that provides Phong highlights.\n */\nclass SpecularPhongMethod extends SpecularBasicMethod\n{\n\t/**\n\t * Creates a new SpecularPhongMethod object.\n\t */\n\tconstructor()\n\t{\n\t\tsuper();\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentCodePerLight(shader:LightingShader, methodVO:MethodVO, lightDirReg:ShaderRegisterElement, lightColReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = \"\";\n\t\tvar t:ShaderRegisterElement;\n\n\t\tif (this._pIsFirstLight) {\n\t\t\tt = this._pTotalLightColorReg;\n\t\t} else {\n\t\t\tt = registerCache.getFreeFragmentVectorTemp();\n\t\t\tregisterCache.addFragmentTempUsages(t, 1);\n\t\t}\n\n\t\tvar viewDirReg:ShaderRegisterElement =sharedRegisters.viewDirFragment;\n\t\tvar normalReg:ShaderRegisterElement =sharedRegisters.normalFragment;\n\n\t\t// phong model\n\t\tcode += \"dp3 \" + t + \".w, \" + lightDirReg + \", \" + normalReg + \"\\n\" + // sca1 = light.normal\n\n\t\t\t//find the reflected light vector R\n\t\t\t\"add \" + t + \".w, \" + t + \".w, \" + t + \".w\\n\" + // sca1 = sca1*2\n\t\t\t\"mul \" + t + \".xyz, \" + normalReg + \", \" + t + \".w\\n\" + // vec1 = normal*sca1\n\t\t\t\"sub \" + t + \".xyz, \" + t + \", \" + lightDirReg + \"\\n\" + // vec1 = vec1 - light (light vector is negative)\n\n\t\t\t//smooth the edge as incidence angle approaches 90\n\t\t\t\"add \" + t + \".w, \" + t + \".w, \" +sharedRegisters.commons + \".w\\n\" + // sca1 = sca1 + smoothtep;\n\t\t\t\"sat \" + t + \".w, \" + t + \".w\\n\" + // sca1 range 0 - 1\n\t\t\t\"mul \" + t + \".xyz, \" + t + \", \" + t + \".w\\n\" + // vec1 = vec1*sca1\n\n\t\t\t//find the dot product between R and V\n\t\t\t\"dp3 \" + t + \".w, \" + t + \", \" + viewDirReg + \"\\n\" + // sca1 = vec1.view\n\t\t\t\"sat \" + t + \".w, \" + t + \".w\\n\";\n\n\t\tif (this.texture) {\n\t\t\t// apply gloss modulation from texture\n\t\t\tcode += \"mul \" + this._pSpecularTexData + \".w, \" + this._pSpecularTexData + \".y, \" + this._pSpecularDataRegister + \".w\\n\" +\n\t\t\t\t\"pow \" + t + \".w, \" + t + \".w, \" + this._pSpecularTexData + \".w\\n\";\n\t\t} else\n\t\t\tcode += \"pow \" + t + \".w, \" + t + \".w, \" + this._pSpecularDataRegister + \".w\\n\";\n\n\t\t// attenuate\n\t\tif (shader.usesLightFallOff)\n\t\t\tcode += \"mul \" + t + \".w, \" + t + \".w, \" + lightDirReg + \".w\\n\";\n\n\t\tif (this._iModulateMethod != null)\n\t\t\tcode += this._iModulateMethod(shader, methodVO, t, registerCache, sharedRegisters);\n\n\t\tcode += \"mul \" + t + \".xyz, \" + lightColReg + \".xyz, \" + t + \".w\\n\";\n\n\t\tif (!this._pIsFirstLight) {\n\t\t\tcode += \"add \" + this._pTotalLightColorReg + \".xyz, \" + this._pTotalLightColorReg + \".xyz, \" + t + \".xyz\\n\";\n\t\t\tregisterCache.removeFragmentTempUsage(t);\n\t\t}\n\n\t\tthis._pIsFirstLight = false;\n\n\t\treturn code;\n\t}\n}\n\nexport = SpecularPhongMethod;",
    "import BlendMode\t\t\t\t\t\t= require(\"awayjs-core/lib/data/BlendMode\");\nimport ColorTransform\t\t\t\t\t= require(\"awayjs-core/lib/geom/ColorTransform\");\nimport Matrix\t\t\t\t\t\t\t= require(\"awayjs-core/lib/geom/Matrix\");\nimport Matrix3D\t\t\t\t\t\t\t= require(\"awayjs-core/lib/geom/Matrix3D\");\nimport Matrix3DUtils\t\t\t\t\t= require(\"awayjs-core/lib/geom/Matrix3DUtils\");\nimport Vector3D\t\t\t\t\t\t\t= require(\"awayjs-core/lib/geom/Vector3D\");\nimport AbstractMethodError\t\t\t\t= require(\"awayjs-core/lib/errors/AbstractMethodError\");\n\nimport Camera\t\t\t\t\t\t\t= require(\"awayjs-display/lib/entities/Camera\");\nimport IRenderOwner\t\t\t\t\t\t= require(\"awayjs-display/lib/base/IRenderOwner\");\nimport StaticLightPicker\t\t\t\t= require(\"awayjs-display/lib/materials/lightpickers/StaticLightPicker\");\n\nimport Stage\t\t\t\t\t\t\t= require(\"awayjs-stagegl/lib/base/Stage\");\nimport ContextGLCompareMode\t\t\t\t= require(\"awayjs-stagegl/lib/base/ContextGLCompareMode\");\n\nimport RendererBase\t\t\t\t\t\t= require(\"awayjs-renderergl/lib/RendererBase\");\nimport ShaderBase\t\t\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderBase\");\nimport ShadingMethodEvent\t\t\t\t= require(\"awayjs-renderergl/lib/events/ShadingMethodEvent\");\nimport RenderableBase\t\t\t\t\t= require(\"awayjs-renderergl/lib/renderables/RenderableBase\");\nimport IRenderableClass\t\t\t\t\t= require(\"awayjs-renderergl/lib/renderables/IRenderableClass\");\nimport RenderBase\t\t\t\t\t\t= require(\"awayjs-renderergl/lib/render/RenderBase\");\nimport RenderPool\t\t\t\t\t\t= require(\"awayjs-renderergl/lib/render/RenderPool\");\n\nimport MethodMaterial\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/MethodMaterial\");\nimport MethodMaterialMode\t\t\t\t= require(\"awayjs-methodmaterials/lib/MethodMaterialMode\");\nimport MethodPassMode\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/render/passes/MethodPassMode\");\nimport MethodPass\t\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/render/passes/MethodPass\");\nimport AmbientBasicMethod\t\t\t\t= require(\"awayjs-methodmaterials/lib/methods/AmbientBasicMethod\");\nimport DiffuseBasicMethod\t\t\t\t= require(\"awayjs-methodmaterials/lib/methods/DiffuseBasicMethod\");\nimport EffectColorTransformMethod\t\t= require(\"awayjs-methodmaterials/lib/methods/EffectColorTransformMethod\");\nimport EffectMethodBase\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/methods/EffectMethodBase\");\nimport LightingMethodBase\t\t\t\t= require(\"awayjs-methodmaterials/lib/methods/LightingMethodBase\");\nimport NormalBasicMethod\t\t\t\t= require(\"awayjs-methodmaterials/lib/methods/NormalBasicMethod\");\nimport ShadowMapMethodBase\t\t\t\t= require(\"awayjs-methodmaterials/lib/methods/ShadowMapMethodBase\");\nimport SpecularBasicMethod\t\t\t\t= require(\"awayjs-methodmaterials/lib/methods/SpecularBasicMethod\");\n\n/**\n * CompiledPass forms an abstract base class for the default compiled pass materials provided by Away3D,\n * using material methods to define their appearance.\n */\nclass MethodMaterialRender extends RenderBase\n{\n\tprivate _material:MethodMaterial;\n\tprivate _pass:MethodPass;\n\tprivate _casterLightPass:MethodPass;\n\tprivate _nonCasterLightPasses:Array<MethodPass>;\n\t\n\t/**\n\t * The maximum total number of lights provided by the light picker.\n\t */\n\tprivate get numLights():number\n\t{\n\t\treturn this._material.lightPicker? this._material.lightPicker.numLightProbes + this._material.lightPicker.numDirectionalLights + this._material.lightPicker.numPointLights + this._material.lightPicker.numCastingDirectionalLights + this._material.lightPicker.numCastingPointLights : 0;\n\t}\n\n\t/**\n\t * The amount of lights that don't cast shadows.\n\t */\n\tprivate get numNonCasters():number\n\t{\n\t\treturn this._material.lightPicker? this._material.lightPicker.numLightProbes + this._material.lightPicker.numDirectionalLights + this._material.lightPicker.numPointLights : 0;\n\t}\n\n\t/**\n\t * Creates a new CompiledPass object.\n\t *\n\t * @param material The material to which this pass belongs.\n\t */\n\tconstructor(pool:RenderPool, material:MethodMaterial, renderableClass:IRenderableClass, stage:Stage)\n\t{\n\t\tsuper(pool, material, renderableClass, stage);\n\n\t\tthis._material = material;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic _pUpdateRender()\n\t{\n\t\tsuper._pUpdateRender();\n\n\t\tthis.initPasses();\n\n\t\tthis.setBlendAndCompareModes();\n\n\t\tthis._pClearPasses();\n\n\t\tif (this._material.mode == MethodMaterialMode.MULTI_PASS) {\n\t\t\tif (this._casterLightPass)\n\t\t\t\tthis._pAddPass(this._casterLightPass);\n\n\t\t\tif (this._nonCasterLightPasses)\n\t\t\t\tfor (var i:number = 0; i < this._nonCasterLightPasses.length; ++i)\n\t\t\t\t\tthis._pAddPass(this._nonCasterLightPasses[i]);\n\t\t}\n\n\t\tif (this._pass)\n\t\t\tthis._pAddPass(this._pass);\n\t}\n\n\t/**\n\t * Initializes all the passes and their dependent passes.\n\t */\n\tprivate initPasses()\n\t{\n\t\t// let the effects pass handle everything if there are no lights, when there are effect methods applied\n\t\t// after shading, or when the material mode is single pass.\n\t\tif (this.numLights == 0 || this._material.numEffectMethods > 0 || this._material.mode == MethodMaterialMode.SINGLE_PASS)\n\t\t\tthis.initEffectPass();\n\t\telse if (this._pass)\n\t\t\tthis.removeEffectPass();\n\n\t\t// only use a caster light pass if shadows need to be rendered\n\t\tif (this._material.shadowMethod && this._material.mode == MethodMaterialMode.MULTI_PASS)\n\t\t\tthis.initCasterLightPass();\n\t\telse if (this._casterLightPass)\n\t\t\tthis.removeCasterLightPass();\n\n\t\t// only use non caster light passes if there are lights that don't cast\n\t\tif (this.numNonCasters > 0 && this._material.mode == MethodMaterialMode.MULTI_PASS)\n\t\t\tthis.initNonCasterLightPasses();\n\t\telse if (this._nonCasterLightPasses)\n\t\t\tthis.removeNonCasterLightPasses();\n\t}\n\n\t/**\n\t * Sets up the various blending modes for all screen passes, based on whether or not there are previous passes.\n\t */\n\tprivate setBlendAndCompareModes()\n\t{\n\t\tvar forceSeparateMVP:boolean = Boolean(this._casterLightPass || this._pass);\n\n\t\t// caster light pass is always first if it exists, hence it uses normal blending\n\t\tif (this._casterLightPass) {\n\t\t\tthis._casterLightPass.forceSeparateMVP = forceSeparateMVP;\n\t\t\tthis._casterLightPass.shader.setBlendMode(BlendMode.NORMAL);\n\t\t\tthis._casterLightPass.shader.depthCompareMode = this._material.depthCompareMode;\n\t\t}\n\n\t\tif (this._nonCasterLightPasses) {\n\t\t\tvar firstAdditiveIndex:number = 0;\n\n\t\t\t// if there's no caster light pass, the first non caster light pass will be the first\n\t\t\t// and should use normal blending\n\t\t\tif (!this._casterLightPass) {\n\t\t\t\tthis._nonCasterLightPasses[0].forceSeparateMVP = forceSeparateMVP;\n\t\t\t\tthis._nonCasterLightPasses[0].shader.setBlendMode(BlendMode.NORMAL);\n\t\t\t\tthis._nonCasterLightPasses[0].shader.depthCompareMode = this._material.depthCompareMode;\n\t\t\t\tfirstAdditiveIndex = 1;\n\t\t\t}\n\n\t\t\t// all lighting passes following the first light pass should use additive blending\n\t\t\tfor (var i:number = firstAdditiveIndex; i < this._nonCasterLightPasses.length; ++i) {\n\t\t\t\tthis._nonCasterLightPasses[i].forceSeparateMVP = forceSeparateMVP;\n\t\t\t\tthis._nonCasterLightPasses[i].shader.setBlendMode(BlendMode.ADD);\n\t\t\t\tthis._nonCasterLightPasses[i].shader.depthCompareMode = ContextGLCompareMode.LESS_EQUAL;\n\t\t\t}\n\t\t}\n\n\t\tif (this._casterLightPass || this._nonCasterLightPasses) {\n\t\t\t//cannot be blended by blendmode property if multipass enabled\n\t\t\tthis._pRequiresBlending = false;\n\n\t\t\t// there are light passes, so this should be blended in\n\t\t\tif (this._pass) {\n\t\t\t\tthis._pass.mode = MethodPassMode.EFFECTS;\n\t\t\t\tthis._pass.forceSeparateMVP = forceSeparateMVP;\n\t\t\t\tthis._pass.shader.depthCompareMode = ContextGLCompareMode.LESS_EQUAL;\n\t\t\t\tthis._pass.shader.setBlendMode(BlendMode.LAYER);\n\t\t\t}\n\n\t\t} else if (this._pass) {\n\t\t\tthis._pRequiresBlending = (this._material.blendMode != BlendMode.NORMAL || this._material.alphaBlending || (this._material.colorTransform && this._material.colorTransform.alphaMultiplier < 1));\n\t\t\t// effects pass is the only pass, so it should just blend normally\n\t\t\tthis._pass.mode = MethodPassMode.SUPER_SHADER;\n\t\t\tthis._pass.preserveAlpha = this._pRequiresBlending;\n\t\t\tthis._pass.forceSeparateMVP = false;\n\t\t\tthis._pass.colorTransform = this._material.colorTransform;\n\t\t\tthis._pass.shader.setBlendMode((this._material.blendMode == BlendMode.NORMAL && this._pRequiresBlending)? BlendMode.LAYER : this._material.blendMode);\n\t\t\tthis._pass.shader.depthCompareMode = this._material.depthCompareMode;\n\t\t}\n\t}\n\n\tprivate initCasterLightPass()\n\t{\n\n\t\tif (this._casterLightPass == null)\n\t\t\tthis._casterLightPass = new MethodPass(MethodPassMode.LIGHTING, this, this._material, this._renderableClass, this._stage);\n\n\t\tthis._casterLightPass.lightPicker = new StaticLightPicker([this._material.shadowMethod.castingLight]);\n\t\tthis._casterLightPass.shadowMethod = this._material.shadowMethod;\n\t\tthis._casterLightPass.diffuseMethod = this._material.diffuseMethod;\n\t\tthis._casterLightPass.ambientMethod = this._material.ambientMethod;\n\t\tthis._casterLightPass.normalMethod = this._material.normalMethod;\n\t\tthis._casterLightPass.specularMethod = this._material.specularMethod;\n\t}\n\n\tprivate removeCasterLightPass()\n\t{\n\t\tthis._casterLightPass.dispose();\n\t\tthis._pRemovePass(this._casterLightPass);\n\t\tthis._casterLightPass = null;\n\t}\n\n\tprivate initNonCasterLightPasses()\n\t{\n\t\tthis.removeNonCasterLightPasses();\n\t\tvar pass:MethodPass;\n\t\tvar numDirLights:number = this._material.lightPicker.numDirectionalLights;\n\t\tvar numPointLights:number = this._material.lightPicker.numPointLights;\n\t\tvar numLightProbes:number = this._material.lightPicker.numLightProbes;\n\t\tvar dirLightOffset:number = 0;\n\t\tvar pointLightOffset:number = 0;\n\t\tvar probeOffset:number = 0;\n\n\t\tif (!this._casterLightPass) {\n\t\t\tnumDirLights += this._material.lightPicker.numCastingDirectionalLights;\n\t\t\tnumPointLights += this._material.lightPicker.numCastingPointLights;\n\t\t}\n\n\t\tthis._nonCasterLightPasses = new Array<MethodPass>();\n\n\t\twhile (dirLightOffset < numDirLights || pointLightOffset < numPointLights || probeOffset < numLightProbes) {\n\t\t\tpass = new MethodPass(MethodPassMode.LIGHTING, this, this._material, this._renderableClass, this._stage);\n\t\t\tpass.includeCasters = this._material.shadowMethod == null;\n\t\t\tpass.directionalLightsOffset = dirLightOffset;\n\t\t\tpass.pointLightsOffset = pointLightOffset;\n\t\t\tpass.lightProbesOffset = probeOffset;\n\t\t\tpass.lightPicker = this._material.lightPicker;\n\t\t\tpass.diffuseMethod = this._material.diffuseMethod;\n\t\t\tpass.ambientMethod = this._material.ambientMethod;\n\t\t\tpass.normalMethod = this._material.normalMethod;\n\t\t\tpass.specularMethod = this._material.specularMethod;\n\t\t\tthis._nonCasterLightPasses.push(pass);\n\n\t\t\tdirLightOffset += pass.numDirectionalLights;\n\t\t\tpointLightOffset += pass.numPointLights;\n\t\t\tprobeOffset += pass.numLightProbes;\n\t\t}\n\t}\n\n\tprivate removeNonCasterLightPasses()\n\t{\n\t\tif (!this._nonCasterLightPasses)\n\t\t\treturn;\n\n\t\tfor (var i:number = 0; i < this._nonCasterLightPasses.length; ++i)\n\t\t\tthis._pRemovePass(this._nonCasterLightPasses[i]);\n\n\t\tthis._nonCasterLightPasses = null;\n\t}\n\n\tprivate removeEffectPass()\n\t{\n\t\tif (this._pass.ambientMethod != this._material.ambientMethod)\n\t\t\tthis._pass.ambientMethod.dispose();\n\n\t\tif (this._pass.diffuseMethod != this._material.diffuseMethod)\n\t\t\tthis._pass.diffuseMethod.dispose();\n\n\t\tif (this._pass.specularMethod != this._material.specularMethod)\n\t\t\tthis._pass.specularMethod.dispose();\n\n\t\tif (this._pass.normalMethod != this._material.normalMethod)\n\t\t\tthis._pass.normalMethod.dispose();\n\n\t\tthis._pRemovePass(this._pass);\n\t\tthis._pass = null;\n\t}\n\n\tprivate initEffectPass()\n\t{\n\t\tif (this._pass == null)\n\t\t\tthis._pass = new MethodPass(MethodPassMode.SUPER_SHADER, this, this._material, this._renderableClass, this._stage);\n\n\t\tif (this._material.mode == MethodMaterialMode.SINGLE_PASS) {\n\t\t\tthis._pass.ambientMethod = this._material.ambientMethod;\n\t\t\tthis._pass.diffuseMethod = this._material.diffuseMethod;\n\t\t\tthis._pass.specularMethod = this._material.specularMethod;\n\t\t\tthis._pass.normalMethod = this._material.normalMethod;\n\t\t\tthis._pass.shadowMethod = this._material.shadowMethod;\n\t\t} else if (this._material.mode == MethodMaterialMode.MULTI_PASS) {\n\t\t\tif (this.numLights == 0) {\n\t\t\t\tthis._pass.ambientMethod = this._material.ambientMethod;\n\t\t\t} else {\n\t\t\t\tthis._pass.ambientMethod = null;\n\t\t\t}\n\n\t\t\tthis._pass.preserveAlpha = false;\n\t\t\tthis._pass.normalMethod = this._material.normalMethod;\n\t\t}\n\n\t\t//update effect methods\n\t\tvar i:number = 0;\n\t\tvar effectMethod:EffectMethodBase;\n\t\tvar len:number = Math.max(this._material.numEffectMethods, this._pass.numEffectMethods);\n\n\t\twhile (i < len) {\n\t\t\teffectMethod = this._material.getEffectMethodAt(i);\n\t\t\tif (effectMethod != this._pass.getEffectMethodAt(i)) {\n\t\t\t\tthis._pass.removeEffectMethodAt(i);\n\n\t\t\t\tif (effectMethod != null) {\n\t\t\t\t\tif (i < this._pass.numEffectMethods)\n\t\t\t\t\t\tthis._pass.addEffectMethodAt(effectMethod, i);\n\t\t\t\t\telse\n\t\t\t\t\t\tthis._pass.addEffectMethod(effectMethod);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\ti++;\n\t\t}\n\t}\n\t\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic dispose()\n\t{\n\t\tsuper.dispose();\n\n\t\t//TODO\n\t}\n}\n\nexport = MethodMaterialRender;",
    "class PassMode\n{\n\t/**\n\t *\n\t */\n\tpublic static EFFECTS:number = 0x01;\n\n\t/**\n\t *\n\t */\n\tpublic static LIGHTING:number = 0x02;\n\n\t/**\n\t *\n\t */\n\tpublic static SUPER_SHADER:number = 0x03;\n}\n\nexport = PassMode;",
    "import ColorTransform\t\t\t\t\t= require(\"awayjs-core/lib/geom/ColorTransform\");\nimport Matrix\t\t\t\t\t\t\t= require(\"awayjs-core/lib/geom/Matrix\");\nimport Matrix3D\t\t\t\t\t\t\t= require(\"awayjs-core/lib/geom/Matrix3D\");\nimport Matrix3DUtils\t\t\t\t\t= require(\"awayjs-core/lib/geom/Matrix3DUtils\");\nimport Vector3D\t\t\t\t\t\t\t= require(\"awayjs-core/lib/geom/Vector3D\");\nimport AbstractMethodError\t\t\t\t= require(\"awayjs-core/lib/errors/AbstractMethodError\");\nimport Event\t\t\t\t\t\t\t= require(\"awayjs-core/lib/events/Event\");\nimport MaterialBase\t\t\t\t\t\t= require(\"awayjs-display/lib/materials/MaterialBase\");\n\nimport Camera\t\t\t\t\t\t\t= require(\"awayjs-display/lib/entities/Camera\");\nimport IRenderOwner\t\t\t\t\t\t= require(\"awayjs-display/lib/base/IRenderOwner\");\nimport LightPickerBase\t\t\t\t\t= require(\"awayjs-display/lib/materials/lightpickers/LightPickerBase\");\nimport LightSources\t\t\t\t\t\t= require(\"awayjs-display/lib/materials/LightSources\");\n\nimport Stage\t\t\t\t\t\t\t= require(\"awayjs-stagegl/lib/base/Stage\");\n\nimport RendererBase\t\t\t\t\t\t= require(\"awayjs-renderergl/lib/RendererBase\");\nimport LightingShader\t\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/LightingShader\");\nimport ShadingMethodEvent\t\t\t\t= require(\"awayjs-renderergl/lib/events/ShadingMethodEvent\");\nimport ShaderBase\t\t\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderBase\");\nimport ShaderRegisterCache\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterCache\");\nimport ShaderRegisterData\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterData\");\nimport ShaderRegisterElement\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterElement\");\nimport RenderableBase\t\t\t\t\t= require(\"awayjs-renderergl/lib/renderables/RenderableBase\");\nimport PassBase\t\t\t\t\t\t\t= require(\"awayjs-renderergl/lib/render/passes/PassBase\");\nimport ILightingPass\t\t\t\t\t= require(\"awayjs-renderergl/lib/render/passes/ILightingPass\");\nimport IRenderableClass\t\t\t\t\t= require(\"awayjs-renderergl/lib/renderables/IRenderableClass\");\n\nimport MethodVO\t\t\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/data/MethodVO\");\nimport AmbientBasicMethod\t\t\t\t= require(\"awayjs-methodmaterials/lib/methods/AmbientBasicMethod\");\nimport DiffuseBasicMethod\t\t\t\t= require(\"awayjs-methodmaterials/lib/methods/DiffuseBasicMethod\");\nimport EffectColorTransformMethod\t\t= require(\"awayjs-methodmaterials/lib/methods/EffectColorTransformMethod\");\nimport EffectMethodBase\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/methods/EffectMethodBase\");\nimport LightingMethodBase\t\t\t\t= require(\"awayjs-methodmaterials/lib/methods/LightingMethodBase\");\nimport NormalBasicMethod\t\t\t\t= require(\"awayjs-methodmaterials/lib/methods/NormalBasicMethod\");\nimport ShadowMapMethodBase\t\t\t\t= require(\"awayjs-methodmaterials/lib/methods/ShadowMapMethodBase\");\nimport SpecularBasicMethod\t\t\t\t= require(\"awayjs-methodmaterials/lib/methods/SpecularBasicMethod\");\nimport MethodPassMode\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/render/passes/MethodPassMode\");\nimport MethodMaterialRender\t\t\t\t= require(\"awayjs-methodmaterials/lib/render/MethodMaterialRender\");\n\n/**\n * CompiledPass forms an abstract base class for the default compiled pass materials provided by Away3D,\n * using material methods to define their appearance.\n */\nclass MethodPass extends PassBase implements ILightingPass\n{\n\tprivate _maxLights:number = 3;\n\n\tprivate _mode:number = 0x03;\n\tprivate _material:MaterialBase;\n\tprivate _lightPicker:LightPickerBase;\n\n\tprivate _includeCasters:boolean = true;\n\n\tpublic _iColorTransformMethodVO:MethodVO;\n\tpublic _iNormalMethodVO:MethodVO;\n\tpublic _iAmbientMethodVO:MethodVO;\n\tpublic _iShadowMethodVO:MethodVO;\n\tpublic _iDiffuseMethodVO:MethodVO;\n\tpublic _iSpecularMethodVO:MethodVO;\n\tpublic _iMethodVOs:Array<MethodVO> = new Array<MethodVO>();\n\n\tpublic _numEffectDependencies:number = 0;\n\n\tprivate _onLightsChangeDelegate:(event:Event) => void;\n\tprivate _onMethodInvalidatedDelegate:(event:ShadingMethodEvent) => void;\n\n\tpublic numDirectionalLights:number = 0;\n\n\tpublic numPointLights:number = 0;\n\n\tpublic numLightProbes:number = 0;\n\n\tpublic pointLightsOffset:number = 0;\n\t\n\tpublic directionalLightsOffset:number= 0;\n\t\n\tpublic lightProbesOffset:number = 0;\n\t\n\t/**\n\t *\n\t */\n\tpublic get mode():number\n\t{\n\t\treturn this._mode;\n\t}\n\n\tpublic set mode(value:number)\n\t{\n\t\tif (this._mode == value)\n\t\t\treturn;\n\t\t\n\t\tthis._mode = value;\n\n\t\tthis._updateLights();\n\t}\n\n\t/**\n\t * Indicates whether or not shadow casting lights need to be included.\n\t */\n\tpublic get includeCasters():boolean\n\t{\n\t\treturn this._includeCasters;\n\t}\n\n\tpublic set includeCasters(value:boolean)\n\t{\n\t\tif (this._includeCasters == value)\n\t\t\treturn;\n\n\t\tthis._includeCasters = value;\n\n\t\tthis._updateLights();\n\t}\n\n\t/**\n\t * \n\t * @returns {LightPickerBase}\n\t */\n\tpublic get lightPicker():LightPickerBase\n\t{\n\t\treturn this._lightPicker;\n\t}\n\n\tpublic set lightPicker(value:LightPickerBase)\n\t{\n\t\t//if (this._lightPicker == value)\n\t\t//\treturn;\n\n\t\tif (this._lightPicker)\n\t\t\tthis._lightPicker.removeEventListener(Event.CHANGE, this._onLightsChangeDelegate);\n\n\t\tthis._lightPicker = value;\n\n\t\tif (this._lightPicker)\n\t\t\tthis._lightPicker.addEventListener(Event.CHANGE, this._onLightsChangeDelegate);\n\n\t\tthis._updateLights();\n\t}\n\t\n\t/**\n\t * Whether or not to use fallOff and radius properties for lights. This can be used to improve performance and\n\t * compatibility for constrained mode.\n\t */\n\tpublic get enableLightFallOff():boolean\n\t{\n\t\treturn this._material.enableLightFallOff;\n\t}\n\n\t/**\n\t * Define which light source types to use for diffuse reflections. This allows choosing between regular lights\n\t * and/or light probes for diffuse reflections.\n\t *\n\t * @see away3d.materials.LightSources\n\t */\n\tpublic get diffuseLightSources():number\n\t{\n\t\treturn this._material.diffuseLightSources;\n\t}\n\n\t/**\n\t * Define which light source types to use for specular reflections. This allows choosing between regular lights\n\t * and/or light probes for specular reflections.\n\t *\n\t * @see away3d.materials.LightSources\n\t */\n\tpublic get specularLightSources():number\n\t{\n\t\treturn this._material.specularLightSources;\n\t}\n\n\t/**\n\t * Creates a new CompiledPass object.\n\t *\n\t * @param material The material to which this pass belongs.\n\t */\n\tconstructor(mode:number, render:MethodMaterialRender, renderOwner:MaterialBase, renderableClass:IRenderableClass, stage:Stage)\n\t{\n\t\tsuper(render, renderOwner, renderableClass, stage);\n\n\t\tthis._mode = mode;\n\n\t\tthis._material = renderOwner;\n\n\t\tthis._onLightsChangeDelegate = (event:Event) => this.onLightsChange(event);\n\t\t\n\t\tthis._onMethodInvalidatedDelegate = (event:ShadingMethodEvent) => this.onMethodInvalidated(event);\n\n\t\tthis.lightPicker = renderOwner.lightPicker;\n\n\t\tif (this._shader == null)\n\t\t\tthis._updateShader();\n\t}\n\n\tprivate _updateShader()\n\t{\n\t\tif ((this.numDirectionalLights || this.numPointLights || this.numLightProbes) && !(this._shader instanceof LightingShader)) {\n\t\t\tif (this._shader != null)\n\t\t\t\tthis._shader.dispose();\n\n\t\t\tthis._shader = new LightingShader(this._renderableClass, this, this._stage);\n\t\t} else if (!(this._shader instanceof ShaderBase)) {\n\t\t\tif (this._shader != null)\n\t\t\t\tthis._shader.dispose();\n\n\t\t\tthis._shader = new ShaderBase(this._renderableClass, this, this._stage);\n\t\t}\n\t}\n\n\t/**\n\t * Initializes the unchanging constant data for this material.\n\t */\n\tpublic _iInitConstantData(shader:ShaderBase)\n\t{\n\t\tsuper._iInitConstantData(shader);\n\n\t\t//Updates method constants if they have changed.\n\t\tvar len:number = this._iMethodVOs.length;\n\t\tfor (var i:number = 0; i < len; ++i)\n\t\t\tthis._iMethodVOs[i].method.iInitConstants(shader, this._iMethodVOs[i]);\n\t}\n\n\t/**\n\t * The ColorTransform object to transform the colour of the material with. Defaults to null.\n\t */\n\tpublic get colorTransform():ColorTransform\n\t{\n\t\treturn this.colorTransformMethod? this.colorTransformMethod.colorTransform : null;\n\t}\n\n\tpublic set colorTransform(value:ColorTransform)\n\t{\n\t\tif (value) {\n\t\t\tif (this.colorTransformMethod == null)\n\t\t\t\tthis.colorTransformMethod = new EffectColorTransformMethod();\n\n\t\t\tthis.colorTransformMethod.colorTransform = value;\n\n\t\t} else if (!value) {\n\t\t\tif (this.colorTransformMethod)\n\t\t\t\tthis.colorTransformMethod = null;\n\t\t}\n\t}\n\n\t/**\n\t * The EffectColorTransformMethod object to transform the colour of the material with. Defaults to null.\n\t */\n\tpublic get colorTransformMethod():EffectColorTransformMethod\n\t{\n\t\treturn this._iColorTransformMethodVO? <EffectColorTransformMethod> this._iColorTransformMethodVO.method : null;\n\t}\n\n\tpublic set colorTransformMethod(value:EffectColorTransformMethod)\n\t{\n\t\tif (this._iColorTransformMethodVO && this._iColorTransformMethodVO.method == value)\n\t\t\treturn;\n\n\t\tif (this._iColorTransformMethodVO) {\n\t\t\tthis._removeDependency(this._iColorTransformMethodVO);\n\t\t\tthis._iColorTransformMethodVO = null;\n\t\t}\n\n\t\tif (value) {\n\t\t\tthis._iColorTransformMethodVO = new MethodVO(value);\n\t\t\tthis._addDependency(this._iColorTransformMethodVO);\n\t\t}\n\t}\n\n\tprivate _removeDependency(methodVO:MethodVO, effectsDependency:boolean = false)\n\t{\n\t\tvar index:number = this._iMethodVOs.indexOf(methodVO);\n\n\t\tif (!effectsDependency)\n\t\t\tthis._numEffectDependencies--;\n\n\t\tmethodVO.method.removeEventListener(ShadingMethodEvent.SHADER_INVALIDATED, this._onMethodInvalidatedDelegate);\n\t\tthis._iMethodVOs.splice(index, 1);\n\n\t\tthis.invalidatePass();\n\t}\n\n\tprivate _addDependency(methodVO:MethodVO, effectsDependency:boolean = false, index:number = -1)\n\t{\n\t\tmethodVO.method.addEventListener(ShadingMethodEvent.SHADER_INVALIDATED, this._onMethodInvalidatedDelegate);\n\n\t\tif (effectsDependency) {\n\t\t\tif (index != -1)\n\t\t\t\tthis._iMethodVOs.splice(index + this._iMethodVOs.length - this._numEffectDependencies, 0, methodVO);\n\t\t\telse\n\t\t\t\tthis._iMethodVOs.push(methodVO);\n\t\t\tthis._numEffectDependencies++;\n\t\t} else {\n\t\t\tthis._iMethodVOs.splice(this._iMethodVOs.length - this._numEffectDependencies, 0, methodVO);\n\t\t}\n\n\t\tthis.invalidatePass();\n\t}\n\n\t/**\n\t * Appends an \"effect\" shading method to the shader. Effect methods are those that do not influence the lighting\n\t * but modulate the shaded colour, used for fog, outlines, etc. The method will be applied to the result of the\n\t * methods added prior.\n\t */\n\tpublic addEffectMethod(method:EffectMethodBase)\n\t{\n\t\tthis._addDependency(new MethodVO(method), true);\n\t}\n\n\t/**\n\t * The number of \"effect\" methods added to the material.\n\t */\n\tpublic get numEffectMethods():number\n\t{\n\t\treturn this._numEffectDependencies;\n\t}\n\n\t/**\n\t * Queries whether a given effects method was added to the material.\n\t *\n\t * @param method The method to be queried.\n\t * @return true if the method was added to the material, false otherwise.\n\t */\n\tpublic hasEffectMethod(method:EffectMethodBase):boolean\n\t{\n\t\treturn this.getDependencyForMethod(method) != null;\n\t}\n\n\t/**\n\t * Returns the method added at the given index.\n\t * @param index The index of the method to retrieve.\n\t * @return The method at the given index.\n\t */\n\tpublic getEffectMethodAt(index:number):EffectMethodBase\n\t{\n\t\tif (index < 0 || index > this._numEffectDependencies - 1)\n\t\t\treturn null;\n\n\t\treturn <EffectMethodBase> this._iMethodVOs[index + this._iMethodVOs.length - this._numEffectDependencies].method;\n\t}\n\n\t/**\n\t * Adds an effect method at the specified index amongst the methods already added to the material. Effect\n\t * methods are those that do not influence the lighting but modulate the shaded colour, used for fog, outlines,\n\t * etc. The method will be applied to the result of the methods with a lower index.\n\t */\n\tpublic addEffectMethodAt(method:EffectMethodBase, index:number)\n\t{\n\t\tthis._addDependency(new MethodVO(method), true, index);\n\t}\n\n\t/**\n\t * Removes an effect method from the material.\n\t * @param method The method to be removed.\n\t */\n\tpublic removeEffectMethod(method:EffectMethodBase)\n\t{\n\t\tvar methodVO:MethodVO = this.getDependencyForMethod(method);\n\n\t\tif (methodVO != null)\n\t\t\tthis._removeDependency(methodVO, true);\n\t}\n\n\n\t/**\n\t * remove an effect method at the specified index from the material.\n\t */\n\tpublic removeEffectMethodAt(index:number)\n\t{\n\t\tif (index < 0 || index > this._numEffectDependencies - 1)\n\t\t\treturn;\n\n\t\tvar methodVO:MethodVO = this._iMethodVOs[index + this._iMethodVOs.length - this._numEffectDependencies];\n\n\t\tif (methodVO != null)\n\t\t\tthis._removeDependency(methodVO, true);\n\t}\n\n\n\tprivate getDependencyForMethod(method:EffectMethodBase):MethodVO\n\t{\n\t\tvar len:number = this._iMethodVOs.length;\n\t\tfor (var i:number = 0; i < len; ++i)\n\t\t\tif (this._iMethodVOs[i].method == method)\n\t\t\t\treturn this._iMethodVOs[i];\n\n\t\treturn null;\n\t}\n\n\t/**\n\t * The method used to generate the per-pixel normals. Defaults to NormalBasicMethod.\n\t */\n\tpublic get normalMethod():NormalBasicMethod\n\t{\n\t\treturn this._iNormalMethodVO? <NormalBasicMethod> this._iNormalMethodVO.method : null;\n\t}\n\n\tpublic set normalMethod(value:NormalBasicMethod)\n\t{\n\t\tif (this._iNormalMethodVO && this._iNormalMethodVO.method == value)\n\t\t\treturn;\n\n\t\tif (this._iNormalMethodVO) {\n\t\t\tthis._removeDependency(this._iNormalMethodVO);\n\t\t\tthis._iNormalMethodVO = null;\n\t\t}\n\n\t\tif (value) {\n\t\t\tthis._iNormalMethodVO = new MethodVO(value);\n\t\t\tthis._addDependency(this._iNormalMethodVO);\n\t\t}\n\t}\n\n\t/**\n\t * The method that provides the ambient lighting contribution. Defaults to AmbientBasicMethod.\n\t */\n\tpublic get ambientMethod():AmbientBasicMethod\n\t{\n\t\treturn this._iAmbientMethodVO? <AmbientBasicMethod> this._iAmbientMethodVO.method : null;\n\t}\n\n\tpublic set ambientMethod(value:AmbientBasicMethod)\n\t{\n\t\tif (this._iAmbientMethodVO && this._iAmbientMethodVO.method == value)\n\t\t\treturn;\n\n\t\tif (this._iAmbientMethodVO) {\n\t\t\tthis._removeDependency(this._iAmbientMethodVO);\n\t\t\tthis._iAmbientMethodVO = null;\n\t\t}\n\n\t\tif (value) {\n\t\t\tthis._iAmbientMethodVO = new MethodVO(value);\n\t\t\tthis._addDependency(this._iAmbientMethodVO);\n\t\t}\n\t}\n\n\t/**\n\t * The method used to render shadows cast on this surface, or null if no shadows are to be rendered. Defaults to null.\n\t */\n\tpublic get shadowMethod():ShadowMapMethodBase\n\t{\n\t\treturn this._iShadowMethodVO? <ShadowMapMethodBase> this._iShadowMethodVO.method : null;\n\t}\n\n\tpublic set shadowMethod(value:ShadowMapMethodBase)\n\t{\n\t\tif (this._iShadowMethodVO && this._iShadowMethodVO.method == value)\n\t\t\treturn;\n\n\t\tif (this._iShadowMethodVO) {\n\t\t\tthis._removeDependency(this._iShadowMethodVO);\n\t\t\tthis._iShadowMethodVO = null;\n\t\t}\n\n\t\tif (value) {\n\t\t\tthis._iShadowMethodVO = new MethodVO(value);\n\t\t\tthis._addDependency(this._iShadowMethodVO);\n\t\t}\n\t}\n\n\t/**\n\t * The method that provides the diffuse lighting contribution. Defaults to DiffuseBasicMethod.\n\t */\n\tpublic get diffuseMethod():DiffuseBasicMethod\n\t{\n\t\treturn this._iDiffuseMethodVO? <DiffuseBasicMethod> this._iDiffuseMethodVO.method : null;\n\t}\n\n\tpublic set diffuseMethod(value:DiffuseBasicMethod)\n\t{\n\t\tif (this._iDiffuseMethodVO && this._iDiffuseMethodVO.method == value)\n\t\t\treturn;\n\n\t\tif (this._iDiffuseMethodVO) {\n\t\t\tthis._removeDependency(this._iDiffuseMethodVO);\n\t\t\tthis._iDiffuseMethodVO = null;\n\t\t}\n\n\t\tif (value) {\n\t\t\tthis._iDiffuseMethodVO = new MethodVO(value);\n\t\t\tthis._addDependency(this._iDiffuseMethodVO);\n\t\t}\n\t}\n\n\t/**\n\t * The method that provides the specular lighting contribution. Defaults to SpecularBasicMethod.\n\t */\n\tpublic get specularMethod():SpecularBasicMethod\n\t{\n\t\treturn this._iSpecularMethodVO? <SpecularBasicMethod> this._iSpecularMethodVO.method : null;\n\t}\n\n\tpublic set specularMethod(value:SpecularBasicMethod)\n\t{\n\t\tif (this._iSpecularMethodVO && this._iSpecularMethodVO.method == value)\n\t\t\treturn;\n\n\t\tif (this._iSpecularMethodVO) {\n\t\t\tthis._removeDependency(this._iSpecularMethodVO);\n\t\t\tthis._iSpecularMethodVO = null;\n\t\t}\n\n\t\tif (value) {\n\t\t\tthis._iSpecularMethodVO = new MethodVO(value);\n\t\t\tthis._addDependency(this._iSpecularMethodVO);\n\t\t}\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic dispose()\n\t{\n\t\tif (this._lightPicker)\n\t\t\tthis._lightPicker.removeEventListener(Event.CHANGE, this._onLightsChangeDelegate);\n\n\t\twhile (this._iMethodVOs.length)\n\t\t\tthis._removeDependency(this._iMethodVOs[0]);\n\n\t\tsuper.dispose();\n\n\t\tthis._iMethodVOs = null;\n\t}\n\n\t/**\n\t * Called when any method's shader code is invalidated.\n\t */\n\tprivate onMethodInvalidated(event:ShadingMethodEvent)\n\t{\n\t\tthis.invalidatePass();\n\t}\n\n\t// RENDER LOOP\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic _iActivate(camera:Camera)\n\t{\n\t\tsuper._iActivate(camera);\n\n\t\tvar methodVO:MethodVO;\n\t\tvar len:number = this._iMethodVOs.length;\n\t\tfor (var i:number = 0; i < len; ++i) {\n\t\t\tmethodVO = this._iMethodVOs[i];\n\t\t\tif (methodVO.useMethod)\n\t\t\t\tmethodVO.method.iActivate(this._shader, methodVO, this._stage);\n\t\t}\n\t}\n\n\t/**\n\t *\n\t *\n\t * @param renderable\n\t * @param stage\n\t * @param camera\n\t */\n\tpublic _iRender(renderable:RenderableBase, camera:Camera, viewProjection:Matrix3D)\n\t{\n\t\tsuper._iRender(renderable, camera, viewProjection);\n\n\t\tvar methodVO:MethodVO;\n\t\tvar len:number = this._iMethodVOs.length;\n\t\tfor (var i:number = 0; i < len; ++i) {\n\t\t\tmethodVO = this._iMethodVOs[i];\n\t\t\tif (methodVO.useMethod)\n\t\t\t\tmethodVO.method.iSetRenderState(this._shader, methodVO, renderable, this._stage, camera);\n\t\t}\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic _iDeactivate()\n\t{\n\t\tsuper._iDeactivate();\n\n\t\tvar methodVO:MethodVO;\n\t\tvar len:number = this._iMethodVOs.length;\n\t\tfor (var i:number = 0; i < len; ++i) {\n\t\t\tmethodVO = this._iMethodVOs[i];\n\t\t\tif (methodVO.useMethod)\n\t\t\t\tmethodVO.method.iDeactivate(this._shader, methodVO, this._stage);\n\t\t}\n\t}\n\n\tpublic _iIncludeDependencies(shader:LightingShader)\n\t{\n\t\tsuper._iIncludeDependencies(shader);\n\n\t\t//TODO: fragment animtion should be compatible with lighting pass\n\t\tshader.usesFragmentAnimation = Boolean(this._mode == MethodPassMode.SUPER_SHADER);\n\n\t\tif (shader.useAlphaPremultiplied && shader.usesBlending)\n\t\t\tshader.usesCommonData = true;\n\n\t\tvar i:number;\n\t\tvar len:number = this._iMethodVOs.length;\n\t\tfor (i = 0; i < len; ++i)\n\t\t\tthis.setupAndCountDependencies(shader, this._iMethodVOs[i]);\n\n\t\tvar usesTangentSpace:boolean = true;\n\n\t\tvar methodVO:MethodVO;\n\t\tfor (i = 0; i < len; ++i) {\n\t\t\tmethodVO = this._iMethodVOs[i];\n\t\t\tif ((methodVO.useMethod = methodVO.method.iIsUsed(shader)) && !methodVO.method.iUsesTangentSpace())\n\t\t\t\tusesTangentSpace = false;\n\t\t}\n\n\t\tshader.outputsNormals = this._iNormalMethodVO && this._iNormalMethodVO.useMethod;\n\t\tshader.outputsTangentNormals = shader.outputsNormals && (<NormalBasicMethod> this._iNormalMethodVO.method).iOutputsTangentNormals();\n\t\tshader.usesTangentSpace = shader.outputsTangentNormals && !shader.usesProbes && usesTangentSpace;\n\n\t\tif (!shader.usesTangentSpace) {\n\t\t\tif (shader.viewDirDependencies > 0) {\n\t\t\t\tshader.globalPosDependencies++;\n\t\t\t} else if (this.numPointLights > 0 && shader.usesLights) {\n\t\t\t\tshader.globalPosDependencies++;\n\t\t\t\tif (Boolean(this._mode & MethodPassMode.EFFECTS))\n\t\t\t\t\tshader.usesGlobalPosFragment = true;\n\t\t\t}\n\t\t}\n\t}\n\n\n\t/**\n\t * Counts the dependencies for a given method.\n\t * @param method The method to count the dependencies for.\n\t * @param methodVO The method's data for this material.\n\t */\n\tprivate setupAndCountDependencies(shader:ShaderBase, methodVO:MethodVO)\n\t{\n\t\tmethodVO.reset();\n\n\t\tmethodVO.method.iInitVO(shader, methodVO);\n\n\t\tif (methodVO.needsProjection)\n\t\t\tshader.projectionDependencies++;\n\n\t\tif (methodVO.needsGlobalVertexPos || methodVO.needsGlobalFragmentPos) {\n\n\t\t\tshader.globalPosDependencies++;\n\n\t\t\tif (methodVO.needsGlobalFragmentPos)\n\t\t\t\tshader.usesGlobalPosFragment = true;\n\n\t\t}\n\n\t\tif (methodVO.needsNormals)\n\t\t\tshader.normalDependencies++;\n\n\t\tif (methodVO.needsTangents)\n\t\t\tshader.tangentDependencies++;\n\n\t\tif (methodVO.needsView)\n\t\t\tshader.viewDirDependencies++;\n\t}\n\n\tpublic _iGetPreLightingVertexCode(shader:ShaderBase, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = \"\";\n\n\t\tif (this._iAmbientMethodVO && this._iAmbientMethodVO.useMethod)\n\t\t\tcode += this._iAmbientMethodVO.method.iGetVertexCode(shader, this._iAmbientMethodVO, registerCache, sharedRegisters);\n\n\t\tif (this._iDiffuseMethodVO && this._iDiffuseMethodVO.useMethod)\n\t\t\tcode += this._iDiffuseMethodVO.method.iGetVertexCode(shader, this._iDiffuseMethodVO, registerCache, sharedRegisters);\n\n\t\tif (this._iSpecularMethodVO && this._iSpecularMethodVO.useMethod)\n\t\t\tcode += this._iSpecularMethodVO.method.iGetVertexCode(shader, this._iSpecularMethodVO, registerCache, sharedRegisters);\n\n\t\treturn code;\n\t}\n\n\tpublic _iGetPreLightingFragmentCode(shader:ShaderBase, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = \"\";\n\n\t\tif (this._iAmbientMethodVO && this._iAmbientMethodVO.useMethod) {\n\t\t\tcode += this._iAmbientMethodVO.method.iGetFragmentCode(shader, this._iAmbientMethodVO, sharedRegisters.shadedTarget, registerCache, sharedRegisters);\n\n\t\t\tif (this._iAmbientMethodVO.needsNormals)\n\t\t\t\tregisterCache.removeFragmentTempUsage(sharedRegisters.normalFragment);\n\n\t\t\tif (this._iAmbientMethodVO.needsView)\n\t\t\t\tregisterCache.removeFragmentTempUsage(sharedRegisters.viewDirFragment);\n\t\t}\n\n\t\tif (this._iDiffuseMethodVO && this._iDiffuseMethodVO.useMethod)\n\t\t\tcode += (<LightingMethodBase> this._iDiffuseMethodVO.method).iGetFragmentPreLightingCode(<LightingShader> shader, this._iDiffuseMethodVO, registerCache, sharedRegisters);\n\n\t\tif (this._iSpecularMethodVO && this._iSpecularMethodVO.useMethod)\n\t\t\tcode += (<LightingMethodBase> this._iSpecularMethodVO.method).iGetFragmentPreLightingCode(<LightingShader> shader, this._iSpecularMethodVO, registerCache, sharedRegisters);\n\n\t\treturn code;\n\t}\n\n\tpublic _iGetPerLightDiffuseFragmentCode(shader:LightingShader, lightDirReg:ShaderRegisterElement, diffuseColorReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\treturn (<LightingMethodBase> this._iDiffuseMethodVO.method).iGetFragmentCodePerLight(shader, this._iDiffuseMethodVO, lightDirReg, diffuseColorReg, registerCache, sharedRegisters);\n\t}\n\n\tpublic _iGetPerLightSpecularFragmentCode(shader:LightingShader, lightDirReg:ShaderRegisterElement, specularColorReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\treturn (<LightingMethodBase> this._iSpecularMethodVO.method).iGetFragmentCodePerLight(shader, this._iSpecularMethodVO, lightDirReg, specularColorReg, registerCache, sharedRegisters);\n\t}\n\n\tpublic _iGetPerProbeDiffuseFragmentCode(shader:LightingShader, texReg:ShaderRegisterElement, weightReg:string, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\treturn (<LightingMethodBase> this._iDiffuseMethodVO.method).iGetFragmentCodePerProbe(shader, this._iDiffuseMethodVO, texReg, weightReg, registerCache, sharedRegisters);\n\t}\n\n\tpublic _iGetPerProbeSpecularFragmentCode(shader:LightingShader, texReg:ShaderRegisterElement, weightReg:string, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\treturn (<LightingMethodBase> this._iSpecularMethodVO.method).iGetFragmentCodePerProbe(shader, this._iSpecularMethodVO, texReg, weightReg, registerCache, sharedRegisters);\n\t}\n\n\tpublic _iGetPostLightingVertexCode(shader:LightingShader, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = \"\";\n\n\t\tif (this._iShadowMethodVO)\n\t\t\tcode += this._iShadowMethodVO.method.iGetVertexCode(shader, this._iShadowMethodVO, registerCache, sharedRegisters);\n\n\t\treturn code;\n\t}\n\n\tpublic _iGetPostLightingFragmentCode(shader:LightingShader, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = \"\";\n\n\t\tif (shader.useAlphaPremultiplied && shader.usesBlending) {\n\t\t\tcode += \"add \" + sharedRegisters.shadedTarget + \".w, \" + sharedRegisters.shadedTarget + \".w, \" + sharedRegisters.commons + \".z\\n\" +\n\t\t\t\"div \" + sharedRegisters.shadedTarget + \".xyz, \" + sharedRegisters.shadedTarget + \", \" + sharedRegisters.shadedTarget + \".w\\n\" +\n\t\t\t\"sub \" + sharedRegisters.shadedTarget + \".w, \" + sharedRegisters.shadedTarget + \".w, \" + sharedRegisters.commons + \".z\\n\" +\n\t\t\t\"sat \" + sharedRegisters.shadedTarget + \".xyz, \" + sharedRegisters.shadedTarget + \"\\n\";\n\t\t}\n\n\t\tif (this._iShadowMethodVO)\n\t\t\tcode += this._iShadowMethodVO.method.iGetFragmentCode(shader, this._iShadowMethodVO, sharedRegisters.shadowTarget, registerCache, sharedRegisters);\n\n\t\tif (this._iDiffuseMethodVO && this._iDiffuseMethodVO.useMethod) {\n\t\t\tcode += (<LightingMethodBase> this._iDiffuseMethodVO.method).iGetFragmentPostLightingCode(shader, this._iDiffuseMethodVO, sharedRegisters.shadedTarget, registerCache, sharedRegisters);\n\n\t\t\t// resolve other dependencies as well?\n\t\t\tif (this._iDiffuseMethodVO.needsNormals)\n\t\t\t\tregisterCache.removeFragmentTempUsage(sharedRegisters.normalFragment);\n\n\t\t\tif (this._iDiffuseMethodVO.needsView)\n\t\t\t\tregisterCache.removeFragmentTempUsage(sharedRegisters.viewDirFragment);\n\t\t}\n\n\t\tif (this._iSpecularMethodVO && this._iSpecularMethodVO.useMethod) {\n\t\t\tcode += (<LightingMethodBase> this._iSpecularMethodVO.method).iGetFragmentPostLightingCode(shader, this._iSpecularMethodVO, sharedRegisters.shadedTarget, registerCache, sharedRegisters);\n\t\t\tif (this._iSpecularMethodVO.needsNormals)\n\t\t\t\tregisterCache.removeFragmentTempUsage(sharedRegisters.normalFragment);\n\t\t\tif (this._iSpecularMethodVO.needsView)\n\t\t\t\tregisterCache.removeFragmentTempUsage(sharedRegisters.viewDirFragment);\n\t\t}\n\n\t\tif (this._iShadowMethodVO)\n\t\t\tregisterCache.removeFragmentTempUsage(sharedRegisters.shadowTarget);\n\n\t\treturn code;\n\t}\n\n\n\tpublic _iGetNormalVertexCode(shader:ShaderBase, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\treturn this._iNormalMethodVO.method.iGetVertexCode(shader, this._iNormalMethodVO, registerCache, sharedRegisters);\n\t}\n\n\tpublic _iGetNormalFragmentCode(shader:ShaderBase, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = this._iNormalMethodVO.method.iGetFragmentCode(shader, this._iNormalMethodVO, sharedRegisters.normalFragment, registerCache, sharedRegisters);\n\n\t\tif (this._iNormalMethodVO.needsView)\n\t\t\tregisterCache.removeFragmentTempUsage(sharedRegisters.viewDirFragment);\n\n\t\tif (this._iNormalMethodVO.needsGlobalFragmentPos || this._iNormalMethodVO.needsGlobalVertexPos)\n\t\t\tregisterCache.removeVertexTempUsage(sharedRegisters.globalPositionVertex);\n\n\t\treturn code;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic _iGetVertexCode(shader:ShaderBase, regCache:ShaderRegisterCache, sharedReg:ShaderRegisterData):string\n\t{\n\t\tvar code:string = \"\";\n\t\tvar methodVO:MethodVO;\n\t\tvar len:number = this._iMethodVOs.length;\n\t\tfor (var i:number = len - this._numEffectDependencies; i < len; i++) {\n\t\t\tmethodVO = this._iMethodVOs[i];\n\t\t\tif (methodVO.useMethod) {\n\t\t\t\tcode += methodVO.method.iGetVertexCode(shader, methodVO, regCache, sharedReg);\n\n\t\t\t\tif (methodVO.needsGlobalVertexPos || methodVO.needsGlobalFragmentPos)\n\t\t\t\t\tregCache.removeVertexTempUsage(sharedReg.globalPositionVertex);\n\t\t\t}\n\t\t}\n\n\t\tif (this._iColorTransformMethodVO && this._iColorTransformMethodVO.useMethod)\n\t\t\tcode += this._iColorTransformMethodVO.method.iGetVertexCode(shader, this._iColorTransformMethodVO, regCache, sharedReg);\n\n\t\treturn code;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic _iGetFragmentCode(shader:ShaderBase, regCache:ShaderRegisterCache, sharedReg:ShaderRegisterData):string\n\t{\n\t\tvar code:string = \"\";\n\t\tvar alphaReg:ShaderRegisterElement;\n\n\t\tif (this.preserveAlpha && this._numEffectDependencies > 0) {\n\t\t\talphaReg = regCache.getFreeFragmentSingleTemp();\n\t\t\tregCache.addFragmentTempUsages(alphaReg, 1);\n\t\t\tcode += \"mov \" + alphaReg + \", \" + sharedReg.shadedTarget + \".w\\n\";\n\t\t}\n\n\t\tvar methodVO:MethodVO;\n\t\tvar len:number = this._iMethodVOs.length;\n\t\tfor (var i:number = len - this._numEffectDependencies; i < len; i++) {\n\t\t\tmethodVO = this._iMethodVOs[i];\n\t\t\tif (methodVO.useMethod) {\n\t\t\t\tcode += methodVO.method.iGetFragmentCode(shader, methodVO, sharedReg.shadedTarget, regCache, sharedReg);\n\n\t\t\t\tif (methodVO.needsNormals)\n\t\t\t\t\tregCache.removeFragmentTempUsage(sharedReg.normalFragment);\n\n\t\t\t\tif (methodVO.needsView)\n\t\t\t\t\tregCache.removeFragmentTempUsage(sharedReg.viewDirFragment);\n\n\t\t\t}\n\t\t}\n\n\t\tif (this.preserveAlpha && this._numEffectDependencies > 0) {\n\t\t\tcode += \"mov \" + sharedReg.shadedTarget + \".w, \" + alphaReg + \"\\n\";\n\t\t\tregCache.removeFragmentTempUsage(alphaReg);\n\t\t}\n\n\t\tif (this._iColorTransformMethodVO && this._iColorTransformMethodVO.useMethod)\n\t\t\tcode += this._iColorTransformMethodVO.method.iGetFragmentCode(shader, this._iColorTransformMethodVO, sharedReg.shadedTarget, regCache, sharedReg);\n\n\t\treturn code;\n\t}\n\t/**\n\t * Indicates whether the shader uses any shadows.\n\t */\n\tpublic _iUsesShadows(shader:ShaderBase):boolean\n\t{\n\t\treturn Boolean(this._iShadowMethodVO && (this._lightPicker.castingDirectionalLights.length > 0 || this._lightPicker.castingPointLights.length > 0));\n\t}\n\n\t/**\n\t * Indicates whether the shader uses any specular component.\n\t */\n\tpublic _iUsesSpecular(shader:ShaderBase):boolean\n\t{\n\t\treturn Boolean(this._iSpecularMethodVO);\n\t}\n\n\t/**\n\t * Indicates whether the shader uses any specular component.\n\t */\n\tpublic _iUsesDiffuse(shader:ShaderBase):boolean\n\t{\n\t\treturn Boolean(this._iDiffuseMethodVO);\n\t}\n\n\n\tprivate onLightsChange(event:Event)\n\t{\n\t\tthis._updateLights();\n\t}\n\n\tprivate _updateLights()\n\t{\n\t\tvar numDirectionalLightsOld:number = this.numDirectionalLights;\n\t\tvar numPointLightsOld:number = this.numPointLights;\n\t\tvar numLightProbesOld:number = this.numLightProbes;\n\n\t\tif (this._lightPicker && (this._mode & MethodPassMode.LIGHTING)) {\n\t\t\tthis.numDirectionalLights = this.calculateNumDirectionalLights(this._lightPicker.numDirectionalLights);\n\t\t\tthis.numPointLights = this.calculateNumPointLights(this._lightPicker.numPointLights);\n\t\t\tthis.numLightProbes = this.calculateNumProbes(this._lightPicker.numLightProbes);\n\n\t\t\tif (this._includeCasters) {\n\t\t\t\tthis.numDirectionalLights += this._lightPicker.numCastingDirectionalLights;\n\t\t\t\tthis.numPointLights += this._lightPicker.numCastingPointLights;\n\t\t\t}\n\n\t\t} else {\n\t\t\tthis.numDirectionalLights = 0;\n\t\t\tthis.numPointLights = 0;\n\t\t\tthis.numLightProbes = 0;\n\t\t}\n\n\t\tif (numDirectionalLightsOld != this.numDirectionalLights || numPointLightsOld != this.numPointLights || numLightProbesOld != this.numLightProbes) {\n\t\t\tthis._updateShader();\n\n\t\t\tthis.invalidatePass();\n\t\t}\n\t}\n\n\t/**\n\t * Calculates the amount of directional lights this material will support.\n\t * @param numDirectionalLights The maximum amount of directional lights to support.\n\t * @return The amount of directional lights this material will support, bounded by the amount necessary.\n\t */\n\tprivate calculateNumDirectionalLights(numDirectionalLights:number):number\n\t{\n\t\treturn Math.min(numDirectionalLights - this.directionalLightsOffset, this._maxLights);\n\t}\n\n\t/**\n\t * Calculates the amount of point lights this material will support.\n\t * @param numDirectionalLights The maximum amount of point lights to support.\n\t * @return The amount of point lights this material will support, bounded by the amount necessary.\n\t */\n\tprivate calculateNumPointLights(numPointLights:number):number\n\t{\n\t\tvar numFree:number = this._maxLights - this.numDirectionalLights;\n\t\treturn Math.min(numPointLights - this.pointLightsOffset, numFree);\n\t}\n\n\t/**\n\t * Calculates the amount of light probes this material will support.\n\t * @param numDirectionalLights The maximum amount of light probes to support.\n\t * @return The amount of light probes this material will support, bounded by the amount necessary.\n\t */\n\tprivate calculateNumProbes(numLightProbes:number):number\n\t{\n\t\tvar numChannels:number = 0;\n\n\t\tif ((this.specularLightSources & LightSources.PROBES) != 0)\n\t\t\t++numChannels;\n\n\t\tif ((this.diffuseLightSources & LightSources.PROBES) != 0)\n\t\t\t++numChannels;\n\n\t\t// 4 channels available\n\t\treturn Math.min(numLightProbes - this.lightProbesOffset, (4/numChannels) | 0);\n\t}\n}\n\nexport = MethodPass;",
    "import Image2D\t\t\t\t\t\t\t= require(\"awayjs-core/lib/data/Image2D\");\nimport Matrix3D\t\t\t\t\t\t\t= require(\"awayjs-core/lib/geom/Matrix3D\");\n\nimport LightBase\t\t\t\t\t\t= require(\"awayjs-display/lib/base/LightBase\");\nimport TriangleSubGeometry\t\t\t\t= require(\"awayjs-display/lib/base/TriangleSubGeometry\");\nimport Camera\t\t\t\t\t\t\t= require(\"awayjs-display/lib/entities/Camera\");\nimport MaterialBase\t\t\t\t\t\t= require(\"awayjs-display/lib/materials/MaterialBase\");\nimport IRenderOwner\t\t\t\t\t\t= require(\"awayjs-display/lib/base/IRenderOwner\");\nimport Single2DTexture\t\t\t\t\t= require(\"awayjs-display/lib/textures/Single2DTexture\");\nimport TextureBase\t\t\t\t\t\t= require(\"awayjs-display/lib/textures/TextureBase\");\n\nimport ContextGLDrawMode\t\t\t\t= require(\"awayjs-stagegl/lib/base/ContextGLDrawMode\");\nimport ContextGLProgramType\t\t\t\t= require(\"awayjs-stagegl/lib/base/ContextGLProgramType\");\nimport IContextGL\t\t\t\t\t\t= require(\"awayjs-stagegl/lib/base/IContextGL\");\nimport Stage\t\t\t\t\t\t\t= require(\"awayjs-stagegl/lib/base/Stage\");\n\nimport RendererBase\t\t\t\t\t\t= require(\"awayjs-renderergl/lib/RendererBase\");\nimport ShaderBase\t\t\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderBase\");\nimport ShaderRegisterCache\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterCache\");\nimport ShaderRegisterData\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterData\");\nimport PassBase\t\t\t\t\t\t\t= require(\"awayjs-renderergl/lib/render/passes/PassBase\");\nimport IRenderableClass\t\t\t\t\t= require(\"awayjs-renderergl/lib/renderables/IRenderableClass\");\nimport RenderableBase\t\t\t\t\t= require(\"awayjs-renderergl/lib/renderables/RenderableBase\");\nimport RenderBase\t\t\t\t\t\t= require(\"awayjs-renderergl/lib/render/RenderBase\");\nimport SubGeometryVOBase\t\t\t\t= require(\"awayjs-renderergl/lib/vos/SubGeometryVOBase\");\nimport SubGeometryVOPool\t\t\t\t= require(\"awayjs-renderergl/lib/vos/SubGeometryVOPool\");\n\n/**\n * The SingleObjectDepthPass provides a material pass that renders a single object to a depth map from the point\n * of view from a light.\n */\nclass SingleObjectDepthPass extends PassBase\n{\n\tprivate _subGeometryVOPool:SubGeometryVOPool;\n\tprivate _textures:Object;\n\tprivate _projections:Object;\n\tprivate _textureSize:number /*uint*/ = 512;\n\tprivate _polyOffset:Float32Array = new Float32Array([15, 0, 0, 0]);\n\tprivate _enc:Float32Array;\n\tprivate _projectionTexturesInvalid:Boolean = true;\n\n\t/**\n\t * The size of the depth map texture to render to.\n\t */\n\tpublic get textureSize():number\n\t{\n\t\treturn this._textureSize;\n\t}\n\n\tpublic set textureSize(value:number)\n\t{\n\t\tthis._textureSize = value;\n\t}\n\n\t/**\n\t * The amount by which the rendered object will be inflated, to prevent depth map rounding errors.\n\t */\n\tpublic get polyOffset():number\n\t{\n\t\treturn this._polyOffset[0];\n\t}\n\n\tpublic set polyOffset(value:number)\n\t{\n\t\tthis._polyOffset[0] = value;\n\t}\n\n\t/**\n\t * Creates a new SingleObjectDepthPass object.\n\t */\n\tconstructor(render:RenderBase, renderOwner:IRenderOwner, renderableClass:IRenderableClass, stage:Stage)\n\t{\n\t\tsuper(render, renderOwner, renderableClass, stage);\n\n\t\t//this._pNumUsedStreams = 2;\n\t\t//this._pNumUsedVertexConstants = 7;\n\t\t//this._enc = Array<number>(1.0, 255.0, 65025.0, 16581375.0, 1.0/255.0, 1.0/255.0, 1.0/255.0, 0.0);\n\t\t//\n\t\t//this._pAnimatableAttributes = Array<string>(\"va0\", \"va1\");\n\t\t//this._pAnimationTargetRegisters = Array<string>(\"vt0\", \"vt1\");\n\t\tthis._subGeometryVOPool = SubGeometryVOPool.getPool();\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic dispose()\n\t{\n\t\tif (this._textures) {\n\t\t\tfor (var key in this._textures) {\n\t\t\t\tvar texture:TextureBase = this._textures[key];\n\t\t\t\ttexture.dispose();\n\t\t\t}\n\t\t\tthis._textures = null;\n\t\t}\n\t}\n\n\t/**\n\t * Updates the projection textures used to contain the depth renders.\n\t */\n\tprivate updateProjectionTextures()\n\t{\n\t\tif (this._textures) {\n\t\t\tfor (var key in this._textures) {\n\t\t\t\tvar texture:TextureBase = this._textures[key];\n\t\t\t\ttexture.dispose();\n\t\t\t}\n\t\t}\n\n\t\tthis._textures = new Object();\n\t\tthis._projections = new Object();\n\t\tthis._projectionTexturesInvalid = false;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic _iGetVertexCode():string\n\t{\n\t\tvar code:string;\n\t\t// offset\n\t\tcode = \"mul vt7, vt1, vc4.x\t\\n\" +\n\t\t\t\t\"add vt7, vt7, vt0\\n\" +\n\t\t\t\t\"mov vt7.w, vt0.w\\n\";\n\t\t// project\n\t\tcode += \"m44 vt2, vt7, vc0\\n\" +\n\t\t\t\t\"mov op, vt2\\n\";\n\n\t\t// perspective divide\n\t\tcode += \"div v0, vt2, vt2.w\\n\";\n\n\t\treturn code;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic _iGetFragmentCode(shader:ShaderBase, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = \"\";\n\n\t\t// encode float -> rgba\n\t\tcode += \"mul ft0, fc0, v0.z\\n\" +\n\t\t\t\t\"frc ft0, ft0\\n\" +\n\t\t\t\t\"mul ft1, ft0.yzww, fc1\\n\" +\n\t\t\t\t\"sub ft0, ft0, ft1\\n\" +\n\t\t\t\t\"mov oc, ft0\\n\";\n\n\t\treturn code;\n\t}\n\n\t/**\n\t * Gets the depth maps rendered for this object from all lights.\n\t * @param renderable The renderable for which to retrieve the depth maps.\n\t * @param stage3DProxy The Stage3DProxy object currently used for rendering.\n\t * @return A list of depth map textures for all supported lights.\n\t */\n\tpublic _iGetDepthMap(renderable:RenderableBase):TextureBase\n\t{\n\t\treturn this._textures[renderable.renderableOwner.id];\n\t}\n\n\t/**\n\t * Retrieves the depth map projection maps for all lights.\n\t * @param renderable The renderable for which to retrieve the projection maps.\n\t * @return A list of projection maps for all supported lights.\n\t */\n\tpublic _iGetProjection(renderable:RenderableBase):Matrix3D\n\t{\n\t\treturn this._projections[renderable.renderableOwner.id];\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic _iRender(renderable:RenderableBase, camera:Camera, viewProjection:Matrix3D)\n\t{\n\t\tvar matrix:Matrix3D;\n\t\tvar context:IContextGL = this._stage.context;\n\t\tvar len:number /*uint*/;\n\t\tvar light:LightBase;\n\t\tvar lights:Array<LightBase> = this._renderOwner.lightPicker.allPickedLights;\n\t\tvar rId:number = renderable.renderableOwner.id;\n\n\t\tif (!this._textures[rId])\n\t\t\tthis._textures[rId] = new Single2DTexture(new Image2D(this._textureSize, this._textureSize));\n\n\t\tif (!this._projections[rId])\n\t\t\tthis._projections[rId] = new Matrix3D();\n\n\t\tlen = lights.length;\n\n\t\t// local position = enough\n\t\tlight = lights[0];\n\n\t\tmatrix = light.iGetObjectProjectionMatrix(renderable.sourceEntity, camera, this._projections[rId]);\n\n\t\tthis._stage.setRenderTarget(this._textures[rId], true);\n\t\tcontext.clear(1.0, 1.0, 1.0);\n\t\tcontext.setProgramConstantsFromMatrix(ContextGLProgramType.VERTEX, 0, matrix, true);\n\t\tcontext.setProgramConstantsFromArray(ContextGLProgramType.FRAGMENT, 0, this._enc, 2);\n\n\t\tvar subGeometryVO:SubGeometryVOBase = renderable.subGeometryVO;\n\t\tvar subGeom:TriangleSubGeometry = <TriangleSubGeometry> subGeometryVO.subGeometry;\n\n\t\tsubGeometryVO.activateVertexBufferVO(0, subGeom.positions, this._stage);\n\t\tsubGeometryVO.activateVertexBufferVO(1, subGeom.normals, this._stage);\n\t\tsubGeometryVO.getIndexBufferVO(this._stage).draw(ContextGLDrawMode.TRIANGLES, 0, subGeometryVO.subGeometry.numElements);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic _iActivate(camera:Camera)\n\t{\n\t\tif (this._projectionTexturesInvalid)\n\t\t\tthis.updateProjectionTextures();\n\n\t\t// never scale\n\t\tsuper._iActivate(camera);\n\n\t\tthis._stage.context.setProgramConstantsFromArray(ContextGLProgramType.VERTEX, 4, this._polyOffset, 1);\n\t}\n}\n\nexport = SingleObjectDepthPass;"
  ],
  "sourceRoot": ""
}